// Code generated by protoc-gen-go.
// source: keys.proto
// DO NOT EDIT!

package tao

import proto "github.com/golang/protobuf/proto"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = math.Inf

type CryptoVersion int32

const (
	CryptoVersion_CRYPTO_VERSION_1 CryptoVersion = 1
)

var CryptoVersion_name = map[int32]string{
	1: "CRYPTO_VERSION_1",
}
var CryptoVersion_value = map[string]int32{
	"CRYPTO_VERSION_1": 1,
}

func (x CryptoVersion) Enum() *CryptoVersion {
	p := new(CryptoVersion)
	*p = x
	return p
}
func (x CryptoVersion) String() string {
	return proto.EnumName(CryptoVersion_name, int32(x))
}
func (x *CryptoVersion) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CryptoVersion_value, data, "CryptoVersion")
	if err != nil {
		return err
	}
	*x = CryptoVersion(value)
	return nil
}

type NamedEllipticCurve int32

const (
	NamedEllipticCurve_PRIME256_V1 NamedEllipticCurve = 1
)

var NamedEllipticCurve_name = map[int32]string{
	1: "PRIME256_V1",
}
var NamedEllipticCurve_value = map[string]int32{
	"PRIME256_V1": 1,
}

func (x NamedEllipticCurve) Enum() *NamedEllipticCurve {
	p := new(NamedEllipticCurve)
	*p = x
	return p
}
func (x NamedEllipticCurve) String() string {
	return proto.EnumName(NamedEllipticCurve_name, int32(x))
}
func (x *NamedEllipticCurve) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(NamedEllipticCurve_value, data, "NamedEllipticCurve")
	if err != nil {
		return err
	}
	*x = NamedEllipticCurve(value)
	return nil
}

type CryptoCipherMode int32

const (
	CryptoCipherMode_CIPHER_MODE_CTR CryptoCipherMode = 1
)

var CryptoCipherMode_name = map[int32]string{
	1: "CIPHER_MODE_CTR",
}
var CryptoCipherMode_value = map[string]int32{
	"CIPHER_MODE_CTR": 1,
}

func (x CryptoCipherMode) Enum() *CryptoCipherMode {
	p := new(CryptoCipherMode)
	*p = x
	return p
}
func (x CryptoCipherMode) String() string {
	return proto.EnumName(CryptoCipherMode_name, int32(x))
}
func (x *CryptoCipherMode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CryptoCipherMode_value, data, "CryptoCipherMode")
	if err != nil {
		return err
	}
	*x = CryptoCipherMode(value)
	return nil
}

type CryptoDerivingMode int32

const (
	CryptoDerivingMode_DERIVING_MODE_HKDF CryptoDerivingMode = 1
)

var CryptoDerivingMode_name = map[int32]string{
	1: "DERIVING_MODE_HKDF",
}
var CryptoDerivingMode_value = map[string]int32{
	"DERIVING_MODE_HKDF": 1,
}

func (x CryptoDerivingMode) Enum() *CryptoDerivingMode {
	p := new(CryptoDerivingMode)
	*p = x
	return p
}
func (x CryptoDerivingMode) String() string {
	return proto.EnumName(CryptoDerivingMode_name, int32(x))
}
func (x *CryptoDerivingMode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CryptoDerivingMode_value, data, "CryptoDerivingMode")
	if err != nil {
		return err
	}
	*x = CryptoDerivingMode(value)
	return nil
}

type CryptoKey_CryptoPurpose int32

const (
	CryptoKey_VERIFYING CryptoKey_CryptoPurpose = 1
	CryptoKey_SIGNING   CryptoKey_CryptoPurpose = 2
	CryptoKey_CRYPTING  CryptoKey_CryptoPurpose = 3
	CryptoKey_DERIVING  CryptoKey_CryptoPurpose = 4
)

var CryptoKey_CryptoPurpose_name = map[int32]string{
	1: "VERIFYING",
	2: "SIGNING",
	3: "CRYPTING",
	4: "DERIVING",
}
var CryptoKey_CryptoPurpose_value = map[string]int32{
	"VERIFYING": 1,
	"SIGNING":   2,
	"CRYPTING":  3,
	"DERIVING":  4,
}

func (x CryptoKey_CryptoPurpose) Enum() *CryptoKey_CryptoPurpose {
	p := new(CryptoKey_CryptoPurpose)
	*p = x
	return p
}
func (x CryptoKey_CryptoPurpose) String() string {
	return proto.EnumName(CryptoKey_CryptoPurpose_name, int32(x))
}
func (x *CryptoKey_CryptoPurpose) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CryptoKey_CryptoPurpose_value, data, "CryptoKey_CryptoPurpose")
	if err != nil {
		return err
	}
	*x = CryptoKey_CryptoPurpose(value)
	return nil
}

type CryptoKey_CryptoAlgorithm int32

const (
	CryptoKey_ECDSA_SHA        CryptoKey_CryptoAlgorithm = 1
	CryptoKey_AES_CTR_HMAC_SHA CryptoKey_CryptoAlgorithm = 2
	CryptoKey_HMAC_SHA         CryptoKey_CryptoAlgorithm = 3
)

var CryptoKey_CryptoAlgorithm_name = map[int32]string{
	1: "ECDSA_SHA",
	2: "AES_CTR_HMAC_SHA",
	3: "HMAC_SHA",
}
var CryptoKey_CryptoAlgorithm_value = map[string]int32{
	"ECDSA_SHA":        1,
	"AES_CTR_HMAC_SHA": 2,
	"HMAC_SHA":         3,
}

func (x CryptoKey_CryptoAlgorithm) Enum() *CryptoKey_CryptoAlgorithm {
	p := new(CryptoKey_CryptoAlgorithm)
	*p = x
	return p
}
func (x CryptoKey_CryptoAlgorithm) String() string {
	return proto.EnumName(CryptoKey_CryptoAlgorithm_name, int32(x))
}
func (x *CryptoKey_CryptoAlgorithm) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CryptoKey_CryptoAlgorithm_value, data, "CryptoKey_CryptoAlgorithm")
	if err != nil {
		return err
	}
	*x = CryptoKey_CryptoAlgorithm(value)
	return nil
}

type CryptoKey struct {
	Version          *CryptoVersion             `protobuf:"varint,1,req,name=version,enum=tao.CryptoVersion" json:"version,omitempty"`
	Purpose          *CryptoKey_CryptoPurpose   `protobuf:"varint,2,req,name=purpose,enum=tao.CryptoKey_CryptoPurpose" json:"purpose,omitempty"`
	Algorithm        *CryptoKey_CryptoAlgorithm `protobuf:"varint,3,req,name=algorithm,enum=tao.CryptoKey_CryptoAlgorithm" json:"algorithm,omitempty"`
	Key              []byte                     `protobuf:"bytes,4,req,name=key" json:"key,omitempty"`
	XXX_unrecognized []byte                     `json:"-"`
}

func (m *CryptoKey) Reset()         { *m = CryptoKey{} }
func (m *CryptoKey) String() string { return proto.CompactTextString(m) }
func (*CryptoKey) ProtoMessage()    {}

func (m *CryptoKey) GetVersion() CryptoVersion {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return CryptoVersion_CRYPTO_VERSION_1
}

func (m *CryptoKey) GetPurpose() CryptoKey_CryptoPurpose {
	if m != nil && m.Purpose != nil {
		return *m.Purpose
	}
	return CryptoKey_VERIFYING
}

func (m *CryptoKey) GetAlgorithm() CryptoKey_CryptoAlgorithm {
	if m != nil && m.Algorithm != nil {
		return *m.Algorithm
	}
	return CryptoKey_ECDSA_SHA
}

func (m *CryptoKey) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

type CryptoKeyset struct {
	Keys             []*CryptoKey `protobuf:"bytes,1,rep,name=keys" json:"keys,omitempty"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *CryptoKeyset) Reset()         { *m = CryptoKeyset{} }
func (m *CryptoKeyset) String() string { return proto.CompactTextString(m) }
func (*CryptoKeyset) ProtoMessage()    {}

func (m *CryptoKeyset) GetKeys() []*CryptoKey {
	if m != nil {
		return m.Keys
	}
	return nil
}

type PBEData struct {
	Version    *CryptoVersion `protobuf:"varint,1,req,name=version,enum=tao.CryptoVersion" json:"version,omitempty"`
	Cipher     *string        `protobuf:"bytes,2,req,name=cipher" json:"cipher,omitempty"`
	Hmac       *string        `protobuf:"bytes,3,req,name=hmac" json:"hmac,omitempty"`
	Iterations *int32         `protobuf:"varint,4,req,name=iterations" json:"iterations,omitempty"`
	Iv         []byte         `protobuf:"bytes,5,req,name=iv" json:"iv,omitempty"`
	Ciphertext []byte         `protobuf:"bytes,6,req,name=ciphertext" json:"ciphertext,omitempty"`
	// TODO(kwalsh) Should this not use a mac as well for integrity protection?
	Salt             []byte `protobuf:"bytes,7,req,name=salt" json:"salt,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *PBEData) Reset()         { *m = PBEData{} }
func (m *PBEData) String() string { return proto.CompactTextString(m) }
func (*PBEData) ProtoMessage()    {}

func (m *PBEData) GetVersion() CryptoVersion {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return CryptoVersion_CRYPTO_VERSION_1
}

func (m *PBEData) GetCipher() string {
	if m != nil && m.Cipher != nil {
		return *m.Cipher
	}
	return ""
}

func (m *PBEData) GetHmac() string {
	if m != nil && m.Hmac != nil {
		return *m.Hmac
	}
	return ""
}

func (m *PBEData) GetIterations() int32 {
	if m != nil && m.Iterations != nil {
		return *m.Iterations
	}
	return 0
}

func (m *PBEData) GetIv() []byte {
	if m != nil {
		return m.Iv
	}
	return nil
}

func (m *PBEData) GetCiphertext() []byte {
	if m != nil {
		return m.Ciphertext
	}
	return nil
}

func (m *PBEData) GetSalt() []byte {
	if m != nil {
		return m.Salt
	}
	return nil
}

type ECDSA_SHA_VerifyingKeyV1 struct {
	Curve            *NamedEllipticCurve `protobuf:"varint,1,req,name=curve,enum=tao.NamedEllipticCurve" json:"curve,omitempty"`
	EcPublic         []byte              `protobuf:"bytes,2,req,name=ec_public" json:"ec_public,omitempty"`
	XXX_unrecognized []byte              `json:"-"`
}

func (m *ECDSA_SHA_VerifyingKeyV1) Reset()         { *m = ECDSA_SHA_VerifyingKeyV1{} }
func (m *ECDSA_SHA_VerifyingKeyV1) String() string { return proto.CompactTextString(m) }
func (*ECDSA_SHA_VerifyingKeyV1) ProtoMessage()    {}

func (m *ECDSA_SHA_VerifyingKeyV1) GetCurve() NamedEllipticCurve {
	if m != nil && m.Curve != nil {
		return *m.Curve
	}
	return NamedEllipticCurve_PRIME256_V1
}

func (m *ECDSA_SHA_VerifyingKeyV1) GetEcPublic() []byte {
	if m != nil {
		return m.EcPublic
	}
	return nil
}

type ECDSA_SHA_SigningKeyV1 struct {
	Curve            *NamedEllipticCurve `protobuf:"varint,1,req,name=curve,enum=tao.NamedEllipticCurve" json:"curve,omitempty"`
	EcPrivate        []byte              `protobuf:"bytes,2,req,name=ec_private" json:"ec_private,omitempty"`
	EcPublic         []byte              `protobuf:"bytes,3,req,name=ec_public" json:"ec_public,omitempty"`
	XXX_unrecognized []byte              `json:"-"`
}

func (m *ECDSA_SHA_SigningKeyV1) Reset()         { *m = ECDSA_SHA_SigningKeyV1{} }
func (m *ECDSA_SHA_SigningKeyV1) String() string { return proto.CompactTextString(m) }
func (*ECDSA_SHA_SigningKeyV1) ProtoMessage()    {}

func (m *ECDSA_SHA_SigningKeyV1) GetCurve() NamedEllipticCurve {
	if m != nil && m.Curve != nil {
		return *m.Curve
	}
	return NamedEllipticCurve_PRIME256_V1
}

func (m *ECDSA_SHA_SigningKeyV1) GetEcPrivate() []byte {
	if m != nil {
		return m.EcPrivate
	}
	return nil
}

func (m *ECDSA_SHA_SigningKeyV1) GetEcPublic() []byte {
	if m != nil {
		return m.EcPublic
	}
	return nil
}

type AES_CTR_HMAC_SHA_CryptingKeyV1 struct {
	Mode             *CryptoCipherMode `protobuf:"varint,1,req,name=mode,enum=tao.CryptoCipherMode" json:"mode,omitempty"`
	AesPrivate       []byte            `protobuf:"bytes,2,req,name=aes_private" json:"aes_private,omitempty"`
	HmacPrivate      []byte            `protobuf:"bytes,3,req,name=hmac_private" json:"hmac_private,omitempty"`
	XXX_unrecognized []byte            `json:"-"`
}

func (m *AES_CTR_HMAC_SHA_CryptingKeyV1) Reset()         { *m = AES_CTR_HMAC_SHA_CryptingKeyV1{} }
func (m *AES_CTR_HMAC_SHA_CryptingKeyV1) String() string { return proto.CompactTextString(m) }
func (*AES_CTR_HMAC_SHA_CryptingKeyV1) ProtoMessage()    {}

func (m *AES_CTR_HMAC_SHA_CryptingKeyV1) GetMode() CryptoCipherMode {
	if m != nil && m.Mode != nil {
		return *m.Mode
	}
	return CryptoCipherMode_CIPHER_MODE_CTR
}

func (m *AES_CTR_HMAC_SHA_CryptingKeyV1) GetAesPrivate() []byte {
	if m != nil {
		return m.AesPrivate
	}
	return nil
}

func (m *AES_CTR_HMAC_SHA_CryptingKeyV1) GetHmacPrivate() []byte {
	if m != nil {
		return m.HmacPrivate
	}
	return nil
}

type HMAC_SHA_DerivingKeyV1 struct {
	Mode             *CryptoDerivingMode `protobuf:"varint,1,req,name=mode,enum=tao.CryptoDerivingMode" json:"mode,omitempty"`
	HmacPrivate      []byte              `protobuf:"bytes,2,req,name=hmac_private" json:"hmac_private,omitempty"`
	XXX_unrecognized []byte              `json:"-"`
}

func (m *HMAC_SHA_DerivingKeyV1) Reset()         { *m = HMAC_SHA_DerivingKeyV1{} }
func (m *HMAC_SHA_DerivingKeyV1) String() string { return proto.CompactTextString(m) }
func (*HMAC_SHA_DerivingKeyV1) ProtoMessage()    {}

func (m *HMAC_SHA_DerivingKeyV1) GetMode() CryptoDerivingMode {
	if m != nil && m.Mode != nil {
		return *m.Mode
	}
	return CryptoDerivingMode_DERIVING_MODE_HKDF
}

func (m *HMAC_SHA_DerivingKeyV1) GetHmacPrivate() []byte {
	if m != nil {
		return m.HmacPrivate
	}
	return nil
}

type CryptoHeader struct {
	Version          *CryptoVersion `protobuf:"varint,1,req,name=version,enum=tao.CryptoVersion" json:"version,omitempty"`
	KeyHint          []byte         `protobuf:"bytes,2,req,name=key_hint" json:"key_hint,omitempty"`
	XXX_unrecognized []byte         `json:"-"`
}

func (m *CryptoHeader) Reset()         { *m = CryptoHeader{} }
func (m *CryptoHeader) String() string { return proto.CompactTextString(m) }
func (*CryptoHeader) ProtoMessage()    {}

func (m *CryptoHeader) GetVersion() CryptoVersion {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return CryptoVersion_CRYPTO_VERSION_1
}

func (m *CryptoHeader) GetKeyHint() []byte {
	if m != nil {
		return m.KeyHint
	}
	return nil
}

// A PDU to be serialized and signed, including a required context to ensure
// unique deserialization.
type SignaturePDU struct {
	Header *CryptoHeader `protobuf:"bytes,1,req,name=header" json:"header,omitempty"`
	// SECURITY WARNING: Always choose a unique context for each unique type of
	// message. One easy way to do this is to number the messages in a protocol
	// and make the context "ProtocolName Message Y: ProtobufName Version X"
	Context *string `protobuf:"bytes,2,req,name=context" json:"context,omitempty"`
	// The serialized protobuf representing this message.
	Data             []byte `protobuf:"bytes,3,req,name=data" json:"data,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *SignaturePDU) Reset()         { *m = SignaturePDU{} }
func (m *SignaturePDU) String() string { return proto.CompactTextString(m) }
func (*SignaturePDU) ProtoMessage()    {}

func (m *SignaturePDU) GetHeader() *CryptoHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *SignaturePDU) GetContext() string {
	if m != nil && m.Context != nil {
		return *m.Context
	}
	return ""
}

func (m *SignaturePDU) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// The result of signing.
type SignedData struct {
	Header           *CryptoHeader `protobuf:"bytes,1,req,name=header" json:"header,omitempty"`
	Signature        []byte        `protobuf:"bytes,2,req,name=signature" json:"signature,omitempty"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *SignedData) Reset()         { *m = SignedData{} }
func (m *SignedData) String() string { return proto.CompactTextString(m) }
func (*SignedData) ProtoMessage()    {}

func (m *SignedData) GetHeader() *CryptoHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *SignedData) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

// The result of encrypting.
type EncryptedData struct {
	Header           *CryptoHeader `protobuf:"bytes,1,req,name=header" json:"header,omitempty"`
	Iv               []byte        `protobuf:"bytes,2,req,name=iv" json:"iv,omitempty"`
	Ciphertext       []byte        `protobuf:"bytes,3,req,name=ciphertext" json:"ciphertext,omitempty"`
	Mac              []byte        `protobuf:"bytes,4,opt,name=mac" json:"mac,omitempty"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *EncryptedData) Reset()         { *m = EncryptedData{} }
func (m *EncryptedData) String() string { return proto.CompactTextString(m) }
func (*EncryptedData) ProtoMessage()    {}

func (m *EncryptedData) GetHeader() *CryptoHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *EncryptedData) GetIv() []byte {
	if m != nil {
		return m.Iv
	}
	return nil
}

func (m *EncryptedData) GetCiphertext() []byte {
	if m != nil {
		return m.Ciphertext
	}
	return nil
}

func (m *EncryptedData) GetMac() []byte {
	if m != nil {
		return m.Mac
	}
	return nil
}

// A PDU to be serialized and fed to HKDF for derivation.
type KeyDerivationPDU struct {
	PreviousHash     []byte  `protobuf:"bytes,1,req,name=previous_hash" json:"previous_hash,omitempty"`
	Size             *uint32 `protobuf:"fixed32,2,req,name=size" json:"size,omitempty"`
	Context          *string `protobuf:"bytes,3,req,name=context" json:"context,omitempty"`
	Index            *uint32 `protobuf:"fixed32,4,req,name=index" json:"index,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *KeyDerivationPDU) Reset()         { *m = KeyDerivationPDU{} }
func (m *KeyDerivationPDU) String() string { return proto.CompactTextString(m) }
func (*KeyDerivationPDU) ProtoMessage()    {}

func (m *KeyDerivationPDU) GetPreviousHash() []byte {
	if m != nil {
		return m.PreviousHash
	}
	return nil
}

func (m *KeyDerivationPDU) GetSize() uint32 {
	if m != nil && m.Size != nil {
		return *m.Size
	}
	return 0
}

func (m *KeyDerivationPDU) GetContext() string {
	if m != nil && m.Context != nil {
		return *m.Context
	}
	return ""
}

func (m *KeyDerivationPDU) GetIndex() uint32 {
	if m != nil && m.Index != nil {
		return *m.Index
	}
	return 0
}

func init() {
	proto.RegisterEnum("tao.CryptoVersion", CryptoVersion_name, CryptoVersion_value)
	proto.RegisterEnum("tao.NamedEllipticCurve", NamedEllipticCurve_name, NamedEllipticCurve_value)
	proto.RegisterEnum("tao.CryptoCipherMode", CryptoCipherMode_name, CryptoCipherMode_value)
	proto.RegisterEnum("tao.CryptoDerivingMode", CryptoDerivingMode_name, CryptoDerivingMode_value)
	proto.RegisterEnum("tao.CryptoKey_CryptoPurpose", CryptoKey_CryptoPurpose_name, CryptoKey_CryptoPurpose_value)
	proto.RegisterEnum("tao.CryptoKey_CryptoAlgorithm", CryptoKey_CryptoAlgorithm_name, CryptoKey_CryptoAlgorithm_value)
}
