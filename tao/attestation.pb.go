// Code generated by protoc-gen-go.
// source: attestation.proto
// DO NOT EDIT!

package tao

import proto "github.com/golang/protobuf/proto"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = math.Inf

// An Attestation is a signature and a statement together, and it conveys:
//   signer says statement
// i.e.
//   signer says (issuer from time until exp says message)
// A valid Attestation encodes a public key within the signer name, and it
// carries a signature that anyone can verify to (eventually) conclude:
//   issuer from time' until exp' says message
// Note: Because of time restrictions within attached delegations, restrictions
// time' and exp' here do not necessarily exactly match the restrictions time
// and exp on the original serialized statement.
// If the modified time restriction is met, then we can derive the same
// conclusion as we would for the included statement, e.g.:
//   delegate speaksfor issuer               (for a delegation statement)
// or:
//   issuer says Pred(arg_1, ..., arg_n)     (for a predicate statement)
// That is to say, a valid Attestation that meets its time restriction conveys
// exactly the same meaning as conveyed by the included statement.
//
// There are two categories of valid Attestations:
//
// (1) In cases where issuer is a subprincipal of (or identical to) signer, no
// delegation will be present. In these cases, signer speaksfor issuer, so from
// the attestation:
//   signer says (issuer says ...)
// we can derive:
//   issuer says (issuer says ...)
// and further:
//   issuer says ...
//
// Example of a category (1) attestation:
//   Attestation = {
//     statement = "K_aik.PCRs(...) says (K_os speaksfor K_aik.PCRs(...))"
//     signer = K_aik
//     signature = ...
//     delegation = nil
//   }
// Here, an OS has published a delegation statement establishing that key K_os
// speaks for the OS, and this statement was signed by the TPM K_aik on behalf
// of the OS. Note that the OS is a subprincipal of the TPM, so the TPM speaks
// for the OS.
//
// (2) In all other cases, a delegation will be present that, if valid, conveys:
//   issuer0 from time0 until exp0 says (delegate speaksfor issuer0)
// where issuer is a subprincipal of (or identical to) issuer0 and delegate is a
// subprincipal of (or identical to) signer. Such a valid
// delegation can be combined with:
//   signer says (issuer from time until exp says ...)
// to derive:
//   issuer0 from time0 until exp0 says (issuer from time until exp says ...)
// And because issuer0 speaks for issuer, we can further derive:
//   issuer from time' until exp' says ...
// where time' = max(time, time0) and exp = min(exp, exp0).
//
// Example of a category (2) attestation:
//   Attestation = {
//     statement = "K_aik.PCRs(...).Prog(...) says K_app speaksfor K_aik.PCRs(...).Prog(...)"
//     signer = K_os
//     signature = ...
//     delegation = {
//       statement = K_aik.PCRs(...) says K_os speaksfor K_aik.PCRs(...)
//       signer = K_aik
//       signature = ...
//       delegation = nil
//     }
//   }
// Here, the OS identified by K_aik.PCRs(...) has signed, using a
// seemingly unrelated key K_os, a statement on behalf of one of its hosted
// programs, K_aik.PCRs(...).Prog(...). The embedded delegation statement,
// signed by K_aik, binds that seemingly unrelated key K_os to the OS's actual
// identity, K_aik.PCRs(...).
//
// Verifying an attestation signature requires knowing how the signature was
// produced. We currently define two signature schemes:
//
// (a) Some signatures are produced by the TPM, so here we are bound by the
// mechanisms implemented by the TPM. In this case, we encode the signer name as
//   tpm("..K..") where "..K.." is the serialized, base64w-encoded public half
// of the TPM's RSA key K. The TPM only ever signs things on behalf of its
// hosted programs, so the issuer used in the serialized statement will always
// have the form:
//   tpm("..K..").PCRs("..i..", "..h..")...
// where "..i.." is a sorted, comma-separated list of PCR numbers, and "..h.."
// is the corresponding, comma-separated list of hex-encoded PCR values. The
// signature is computed roughly as:
//   sig = rsa_sign(K, H( H(message) | pcrbuf(i, h) ))
// Here, we first hash the statement in a tpm-specific way, then sign the
// hash with RSA key K. To obtain the statement hash, first hash the serialized
// statement, including issuer, time, expiration and other information. This
// intermediate hash is then re-hashed with a tpm-specific encoding of the PCR
// numbers ("..i..") and values ("..h..") extracted from issuer.
//
// Note: The PCR values are effectively hashed twice, once as part of statement,
// and separately as part of the pcrbuf datastructure. See optimization note
// below.
//
// (b) Other signatures are produced in software, and here we have flexibility
// to use simpler signature schemes. In this case, we encode the signer name as
//   key("..K..") where "..K.." is the serialized, base64w-encoded public half
// of a DSA key K. The issuer used in the serialized statement can have any
// form. The signature is roughly:
//   sig = dsa_sign(K, H(context|message))
// Here, we simply hash the serialized statement, along with some context, then
// sign it with the private DSA key K. The context used for attestations is
// defined in Tao.AttestationSigningContext.
//
// Together, this results in four possible combinations:
//
// (1a) No delegation, Tao signature.
//      Historical note: This is the old "ROOT" attestation type.
//      Typically (or maybe always?), signer is the policy key.
//      The signer is always key("..K..").
// (1b) No delegation, TPM signature.
//      This is produced by TPMTaoChildChannel.
//      The signer is always tpm("..K..") and the statement issuer is
//      always a tpm("..K..").PCRs("..i..", "..h..")...
// (2a) Delegation, Tao signature.
//      Historical note: This is the old "INTERMEDIATE" attestation type.
//      The signer is always key("..K..").
//      The delegation is the head of a chain that eventually terminates in a
//      type (1a) or (1b) attestation.
// (2b) Delegation, TPM signature.
//      Historical note: This is the old "TPM_1_2_QUOTE" attestation type.
//      This combination is no longer used. If it were, the signer would be
//      tpm("..K..") and the statement issuer would be something like
//      K_policy.TrustedPlatform. The delegation would be the head of a chain
//      that eventually terminates in a type (1a) or (1b) attestation. The
//      issuer at the head of the chain would always be
//      tpm("..K..").PCRs("..i..", "..h..")
type Attestation struct {
	// A serialized statement. This is serialized to avoid canonicalization issues
	// when signing and verifying signatures. In Go, this is obtained using
	// cloudproxy/tao/auth.Marshal().
	SerializedStatement []byte `protobuf:"bytes,1,req,name=serialized_statement" json:"serialized_statement,omitempty"`
	// The signer's public key, encoded using clouddproxy/tao/auth.Marshal()
	Signer []byte `protobuf:"bytes,2,req,name=signer" json:"signer,omitempty"`
	// Signature over the serialized statement using TPM or Tao signing.
	Signature []byte `protobuf:"bytes,3,req,name=signature" json:"signature,omitempty"`
	// A delegation attestation that conveys (eventually) that signer speaks for
	// the issuer in the serialized statement. If this is empty, then it must be
	// self evident that signer speaks for the issuer in the serialized statement.
	// This can be added, removed, or replaced without changing the attestation
	// signature, but verification may fail if a required delegation is missing.
	SerializedDelegation []byte `protobuf:"bytes,4,opt,name=serialized_delegation" json:"serialized_delegation,omitempty"`
	// An optional set of further attestations that may pertain, in some way, to
	// the the issuer or signer of this attestation. These can be added or removed
	// without changing the attestation signature. This allows attestations to be
	// piggy-backed, e.g. when an authorization guard requires multiple
	// attestations to check a policy.
	SerializedEndorsements [][]byte `protobuf:"bytes,5,rep,name=serialized_endorsements" json:"serialized_endorsements,omitempty"`
	XXX_unrecognized       []byte   `json:"-"`
}

func (m *Attestation) Reset()         { *m = Attestation{} }
func (m *Attestation) String() string { return proto.CompactTextString(m) }
func (*Attestation) ProtoMessage()    {}

func (m *Attestation) GetSerializedStatement() []byte {
	if m != nil {
		return m.SerializedStatement
	}
	return nil
}

func (m *Attestation) GetSigner() []byte {
	if m != nil {
		return m.Signer
	}
	return nil
}

func (m *Attestation) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *Attestation) GetSerializedDelegation() []byte {
	if m != nil {
		return m.SerializedDelegation
	}
	return nil
}

func (m *Attestation) GetSerializedEndorsements() [][]byte {
	if m != nil {
		return m.SerializedEndorsements
	}
	return nil
}

func init() {
}
