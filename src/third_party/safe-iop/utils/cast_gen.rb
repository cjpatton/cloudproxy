#!/usr/bin/ruby -w
# License:: BSD (see LICENSE)
# Author:: Will Drewry <redpig@dataspill.org>
#

require 'supported_types'

printf(<<-EOF)
/* sop_safe_cast helpers
 *
 * NOTE: The baseline are automatically generated by 'cast_gen.rb'.
 *
 * sop_safe_cast helpers rely on the C preprocessor to expand out to the
 * specific test required to perform a safe cast from one type to another.
 * These functions, in particular, follow the guidelines recommended by CERT:
 * Data truncation is avoided even at the cost of being overly safe.
 *
 * What does this mean?  It means that an operation that might result in a value
 * that can be represented by the destination type may fail if the act of
 * processing that value may over the final destination type.  For example,
 *
 *  sop_addx(sop_s8(&a),  sop_u8(10), sop_s8(-1));
 *
 * Adding 10 + (-1) logically results in 9 and fits in an unsigned 8-bit
 * integer, but since -1 cannot be represented as an unsigned value, the safe
 * cast will fail and sop_addx will return false.
 *
 * Why are there so many macros?  While safe_iop's first goal is providing
 * safe integer operations, the secondary goal is to push off as much of the
 * workload as possible to the preprocessor.  This done here by expanding
 * each and every type combination to a final macro with the implementation.
 * A single macro would expand each and every test on sop_* call and rely on
 * the compiler to handle optimizing out unreachable code.
 */
EOF

# NULLs first
printf("#define sop_safe_cast_NULL(_ptr, _a, _b) sop_safe_cast_NULL_##_a(_ptr, _a, _b)\n")
SupportedTypes::TYPES.each do |a|
  printf("#define sop_safe_cast_NULL_#{a}(_X) sop_safe_cast_NULL_#{a}_interim\n")
  printf("#define sop_safe_cast_NULL_#{a}_interim(_ptr, _a, _b) sop_safe_cast_NULL_#{a}_##_b(_ptr, _a, _b)\n")
  SupportedTypes::TYPES.each do |b|
    # The actual implementation for a<-b
    if a.bits == 0 or b.bits == 0
      # TODO: Add platform tests here for aliases -- long -> int, int64
      printf("#define sop_safe_cast_NULL_#{a}_#{b}_final(_ptr, _a, _b) /* TODO */ 0\n")
    elsif a.bits == b.bits
      if a.signed == b.signed
        printf("#define sop_safe_cast_NULL_#{a}_#{b}_final(_ptr, _a, _b)  1\n")
      elsif not a.signed and b.signed
        printf(<<-EOS)
#define sop_safe_cast_NULL_#{a}_#{b}_final(_ptr, _a, _b)  \\
  (sop_valueof_##_b >= 0)
        EOS
      elsif a.signed and not b.signed
        printf(<<-EOS)
#define sop_safe_cast_NULL_#{a}_#{b}_final(_ptr, _a, _b)  \\
  (sop_valueof_##_b <= __sop(m)(smax)(sop_typeof_##_a))
        EOS
      end
    elsif a.bits > b.bits
      if a.signed == b.signed
        printf("#define sop_safe_cast_NULL_#{a}_#{b}_final(_ptr, _a, _b)  1\n")
      elsif not a.signed and b.signed
        printf(<<-EOS)
#define sop_safe_cast_NULL_#{a}_#{b}_final(_ptr, _a, _b)  \\
  (sop_valueof_##_b >= 0)
        EOS
      elsif a.signed and not b.signed
        printf(<<-EOS)
#define sop_safe_cast_NULL_#{a}_#{b}_final(_ptr, _a, _b)  \\
  /* this is usually true, but maybe not guaranteed? */ \\
  (__sop(m)(smax)(sop_typeof_##_a) >= __sop(m)(umax)(sop_typeof_##_b) \\
   ? 1 \\
   : /* This will safely truncate given that smax(a) <= umax(b) */ \\
     ((sop_valueof_##_b) <= (sop_typeof_##_b)__sop(m)(smax)(sop_typeof_##_a) \\
      ? 1 : 0 ))
        EOS
      end
    elsif a.bits < b.bits
      if not a.signed and not b.signed
        printf(<<-EOS)
#define sop_safe_cast_NULL_#{a}_#{b}_final(_ptr, _a, _b)  \\
  (sop_valueof_##_b <= (sop_typeof_##_b)__sop(m)(umax)(sop_typeof_##_a))
        EOS
      elsif a.signed and b.signed
        printf(<<-EOS)
#define sop_safe_cast_NULL_#{a}_#{b}_final(_ptr, _a, _b)  \\
  (sop_valueof_##_b >= (sop_typeof_##_b)__sop(m)(smin)(sop_typeof_##_a) && \\
   sop_valueof_##_b <= (sop_typeof_##_b)__sop(m)(smax)(sop_typeof_##_a))
        EOS
      elsif not a.signed and b.signed
        printf(<<-EOS)
#define sop_safe_cast_NULL_#{a}_#{b}_final(_ptr, _a, _b)  \\
  (sop_valueof_##_b >= 0 && \\
   sop_valueof_##_b <= (sop_typeof_##_b)__sop(m)(umax)(sop_typeof_##_a))
        EOS
      elsif a.signed and not b.signed
        printf(<<-EOS)
#define sop_safe_cast_NULL_#{a}_#{b}_final(_ptr, _a, _b)  \\
  (sop_valueof_##_b <= (sop_typeof_##_b)__sop(m)(smax)(sop_typeof_##_a))
        EOS
      end
    end  # size tests
    printf("#define sop_safe_cast_NULL_#{a}_#{b}(_X) sop_safe_cast_NULL_#{a}_#{b}_final\n")
  end
end

# All other types
SupportedTypes::TYPES.each do |ptr|
  SupportedTypes::TYPES.each do |a|
    SupportedTypes::TYPES.each do |b|
      if a == b  # cast to self is okay
        printf("#define sop_safe_cast_#{ptr}_#{a}_#{b}_final(_ptr, _a, _b)  1\n")
      else
        # Note, it's okay to use the _ptr for _a since valueof_a is never
        # used in cast tests.
        printf(<<-EOS)
#define sop_safe_cast_#{ptr}_#{a}_#{b}_final(_ptr, _a, _b) \\
  (sop_safe_cast_NULL_#{ptr}_#{a}_final(_ptr, _ptr, _a) && \\
   sop_safe_cast_NULL_#{ptr}_#{b}_final(_ptr, _ptr, _b))
        EOS
      end
      printf("#define sop_safe_cast_#{ptr}_#{a}_#{b}(_X) sop_safe_cast_#{ptr}_#{a}_#{b}_final\n")
    end
    printf("#define sop_safe_cast_#{ptr}_#{a}_interim(_ptr, _a, _b) sop_safe_cast_#{ptr}_#{a}_##_b(_ptr, _a, _b)\n")
    printf("#define sop_safe_cast_#{ptr}_#{a}(_X) sop_safe_cast_#{ptr}_#{a}_interim\n")
  end
  printf("#define sop_safe_cast_#{ptr}_interim(_ptr, _a, _b) sop_safe_cast_#{ptr}_##_a(_ptr, _a, _b)\n")
  printf("#define sop_safe_cast_#{ptr}(_X) sop_safe_cast_#{ptr}_interim\n")
end


#printf("#define sop_safe_cast(_ptr, _a, _b) sop_safe_cast_ ## _ptr (_ptr, _a, _b)\n")
