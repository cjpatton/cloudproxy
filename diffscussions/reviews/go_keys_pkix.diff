#* 
#* author: Kevin Walsh
#* email: kwalsh@holycross.edu
#* date: 2014-07-18T23:23:16-0400
#* 
#- go: use pkix.Name for x509 subject name
#- 
#- Go has nice structures like pkix.Name for holding subject names, and
#- these are easy to construct in code, so use them directly instead of
#- text-encoded protobufs. Add a ParseX509SubjectName() to convert the
#- old style style text encoding, just in case there are callers that
#- really would describe the subject name in a string.
#- 
#- 
diff --git a/go/src/cloudproxy/tao/keys.go b/go/src/cloudproxy/tao/keys.go
index c4aaa08..cd95a51 100644
--- a/go/src/cloudproxy/tao/keys.go
+++ b/go/src/cloudproxy/tao/keys.go
@@ -102,97 +102,90 @@ func (s *Signer) ToPrincipalName() (string, error) {
 
 	return "Key(\"" + base64.URLEncoding.EncodeToString(data) + "\")", nil
 }
 
 // MarshalSigner serializes the signer to DER.
 func MarshalSignerDER(s *Signer) ([]byte, error) {
 	return x509.MarshalECPrivateKey(s.ec)
 }
 
 // UnmarshalSigner deserializes a Signer from DER.
 func UnmarshalSignerDER(signer []byte) (*Signer, error) {
 	k := new(Signer)
 	var err error
 	if k.ec, err = x509.ParseECPrivateKey(signer); err != nil {
 		return nil, err
 	}
 
 	return k, nil
 }
 
-// prepareX509Template parses the protobuf containing subject-name details and
-// fills out an X.509 template for use in x509.CreateCertificate.
-func prepareX509Template(detailsText string) (*x509.Certificate, error) {
-	details := new(X509Details)
-	if err := proto.UnmarshalText(detailsText, details); err != nil {
+func ParseX509SubjectName(name string) (*pkix.Name, error) {
+	p := new(X509Details)
+	if err := proto.UnmarshalText(name, p); err != nil {
 		return nil, err
 	}
+	return &pkix.Name{
+		Country:      []string{string(p.Country)},
+		Organization: []string{string(p.Organization)},
+		Province:     []string{string(p.State)},
+		CommonName:   string(p.Commonname),
+	}, nil
+}
 
-	template := &x509.Certificate{
+// prepareX509Template fills out an X.509 template for use in x509.CreateCertificate.
+func prepareX509Template(subjectName *pkix.Name) *x509.Certificate {
+	return &x509.Certificate{
 		SignatureAlgorithm: x509.ECDSAWithSHA256,
 		PublicKeyAlgorithm: x509.ECDSA,
 		Version:            2, // x509v3
 		// It's always allowed for self-signed certs to have serial 1.
 		SerialNumber: new(big.Int).SetInt64(1),
-		Subject: pkix.Name{
-			Country:      []string{string(details.Country)},
-			Organization: []string{string(details.Organization)},
-			Province:     []string{string(details.State)},
-			CommonName:   string(details.Commonname),
-		},
+		Subject: *subjectName,
 		NotBefore: time.Now(),
 		NotAfter:  time.Now().AddDate(1 /* years */, 0 /* months */, 0 /* days */),
 		// TODO(tmroeder): I'm not sure which of these I need to make
 		// OpenSSL happy.
 		KeyUsage:    x509.KeyUsageKeyAgreement | x509.KeyUsageCertSign,
 		ExtKeyUsage: []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth, x509.ExtKeyUsageClientAuth},
 	}
-
-	return template, nil
 }
 
 // CreateSelfSignedX509 creates a self-signed X.509 certificate for the public
 // key of this Signer.
-func (s *Signer) CreateSelfSignedX509(detailsText string) ([]byte, error) {
-	template, err := prepareX509Template(detailsText)
-	if err != nil {
-		return nil, err
-	}
-
+func (s *Signer) CreateSelfSignedX509(name *pkix.Name) ([]byte, error) {
+	template := prepareX509Template(name)
 	template.IsCA = true
 	template.Issuer = template.Subject
 
 	return x509.CreateCertificate(rand.Reader, template, template, &s.ec.PublicKey, s.ec)
 }
 
 // CreateSignedX509 creates a signed X.509 certificate for some other subject's
 // key.
-func (s *Signer) CreateSignedX509(CAPEMCert []byte, certSerial int, subjectKey *Verifier, subjectDetails string) ([]byte, error) {
+func (s *Signer) CreateSignedX509(CAPEMCert []byte, certSerial int, subjectKey *Verifier, subjectName *pkix.Name) ([]byte, error) {
 	signerCert, err := x509.ParseCertificate(CAPEMCert)
 	if err != nil {
 		return nil, err
 	}
 
-	template, err := prepareX509Template(subjectDetails)
-	if err != nil {
-		return nil, err
-	}
+	template := prepareX509Template(subjectName)
 
 	return x509.CreateCertificate(rand.Reader, template, signerCert, subjectKey.ec, s.ec)
 }
 
 // marshalECDSA_SHA_SigningKeyV1 encodes a private key as a protobuf message.
 func marshalECDSA_SHA_SigningKeyV1(k *ecdsa.PrivateKey) *ECDSA_SHA_SigningKeyV1 {
 	return &ECDSA_SHA_SigningKeyV1{
 		Curve:     NamedEllipticCurve_PRIME256_V1.Enum(),
 		EcPrivate: k.D.Bytes(),
 		EcPublic:  elliptic.Marshal(k.Curve, k.X, k.Y),
 	}
 
 }
 
 // MarshalSignerProto encodes a signing key as a CryptoKey protobuf message.
 func MarshalSignerProto(s *Signer) (*CryptoKey, error) {
 	m := marshalECDSA_SHA_SigningKeyV1(s.ec)
 	defer zeroBytes(m.EcPrivate)
 
 	b, err := proto.Marshal(m)
diff --git a/go/src/cloudproxy/tao/keys_test.go b/go/src/cloudproxy/tao/keys_test.go
index 1c4b442..d84dde9 100644
--- a/go/src/cloudproxy/tao/keys_test.go
+++ b/go/src/cloudproxy/tao/keys_test.go
@@ -32,46 +32,49 @@ func TestSignerDERSerialization(t *testing.T) {
 	if err != nil {
 		t.Fatal(err.Error())
 	}
 
 	b, err := MarshalSignerDER(s)
 	if err != nil {
 		t.Fatal(err.Error())
 	}
 
 	if _, err := UnmarshalSignerDER(b); err != nil {
 		t.Fatal(err.Error())
 	}
 }
 
 func TestSelfSignedX509(t *testing.T) {
 	s, err := GenerateSigner()
 	if err != nil {
 		t.Fatal(err.Error())
 	}
 
-	d := `
+	d, err := ParseX509SubjectName(`
 		commonname: "test",
 		country: "US",
 		state: "WA",
 		organization: "Google",
-	`
+	`)
+	if err != nil {
+		t.Fatal(err.Error())
+	}
 
 	_, err = s.CreateSelfSignedX509(d)
 	if err != nil {
 		t.Fatal(err.Error())
 	}
 }
 
 func TestSignerMarshalProto(t *testing.T) {
 	s, err := GenerateSigner()
 	if err != nil {
 		t.Fatal(err.Error())
 	}
 
 	c, err := MarshalSignerProto(s)
 	if err != nil {
 		t.Fatal(err.Error())
 	}
 
 	if _, err := UnmarshalSignerProto(c); err != nil {
 		t.Fatal(err.Error())
@@ -94,46 +97,49 @@ func TestPublicSignerMarshalProto(t *testing.T) {
 	if err != nil {
 		t.Fatal(err.Error())
 	}
 
 	ck, err := MarshalPublicSignerProto(s)
 	if err != nil {
 		t.Fatal(err.Error())
 	}
 
 	if _, err := UnmarshalVerifierProto(ck); err != nil {
 		t.Fatal(err.Error())
 	}
 }
 
 func TestVerifierFromX509(t *testing.T) {
 	s, err := GenerateSigner()
 	if err != nil {
 		t.Fatal(err.Error())
 	}
 
-	d := `
+	d, err := ParseX509SubjectName(`
 		commonname: "test",
 		country: "US",
 		state: "WA",
 		organization: "Google",
-	`
+	`)
+	if err != nil {
+		t.Fatal(err.Error())
+	}
 
 	x, err := s.CreateSelfSignedX509(d)
 	if err != nil {
 		t.Fatal(err.Error())
 	}
 
 	if _, err := FromX509(x); err != nil {
 		t.Fatal(err.Error())
 	}
 }
 
 func TestFromPrincipalName(t *testing.T) {
 	s, err := GenerateSigner()
 	if err != nil {
 		t.Fatal(err.Error())
 	}
 
 	name, err := s.ToPrincipalName()
 	if err != nil {
 		t.Fatal(err.Error())
