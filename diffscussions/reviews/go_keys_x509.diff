#* 
#* author: Kevin Walsh
#* email: kwalsh@holycross.edu
#* date: 2014-07-19T09:51:51-0400
#* 
#- go: use x509.Certificate, not []byte, where appropriate
#- 
#- 
diff --git a/go/src/cloudproxy/demo/demo.go b/go/src/cloudproxy/demo/demo.go
index 39ca6c6..36aed73 100644
--- a/go/src/cloudproxy/demo/demo.go
+++ b/go/src/cloudproxy/demo/demo.go
@@ -55,60 +55,60 @@ func setupTCPClient() (net.Conn, error) {
 
 const (
 	x509duration = 24 * time.Hour
 	x509keySize  = 2048
 )
 
 func GenerateX509() (*tls.Certificate, error) {
 	keys, err := tao.NewTemporaryTaoDelegatedKeys(tao.Signing, tao.Host())
 	if err != nil {
 		return nil, err
 	}
 
 	/*
 		if ip := net.ParseIP(*serverHost); ip != nil {
 			template.IPAddresses = append(template.IPAddresses, ip)
 		} else {
 			template.DNSNames = append(template.DNSNames, *serverHost)
 		}
 	*/
 
-	derBytes, err := keys.SigningKey.CreateSelfSignedX509(&pkix.Name{
+	cert, err := keys.SigningKey.CreateSelfSignedX509(&pkix.Name{
 		Organization: []string{"Google Tao Demo"}})
 	if err != nil {
 		return nil, err
 	}
 
-	certPem := pem.EncodeToMemory(&pem.Block{Type: "CERTIFICATE", Bytes: derBytes})
+	certPem := pem.EncodeToMemory(&pem.Block{Type: "CERTIFICATE", Bytes: cert.Raw})
 	keyBytes, err := tao.MarshalSignerDER(keys.SigningKey)
 	if err != nil {
 		return nil, err
 	}
 	keyPem := pem.EncodeToMemory(&pem.Block{Type: "ECDSA PRIVATE KEY", Bytes: keyBytes})
 
-	cert, err := tls.X509KeyPair(certPem, keyPem)
+	tlsCert, err := tls.X509KeyPair(certPem, keyPem)
 	if err != nil {
 		fmt.Printf("can't parse my cert\n")
 		return nil, err
 	}
 
-	return &cert, nil
+	return &tlsCert, nil
 }
 
 func setupTLSServer() (net.Listener, error) {
 	cert, err := GenerateX509()
 	if err != nil {
 		fmt.Printf("server: can't create key and cert: %s\n", err.Error())
 		return nil, err
 	}
 	return tls.Listen("tcp", serverAddr, &tls.Config{
 		RootCAs:            x509.NewCertPool(),
 		Certificates:       []tls.Certificate{*cert},
 		InsecureSkipVerify: true,
 	})
 }
 
 func setupTLSClient() (net.Conn, *tls.Certificate, error) {
 	cert, err := GenerateX509()
 	if err != nil {
 		fmt.Printf("client: can't create key and cert: %s\n", err.Error())
 		return nil, nil, err
diff --git a/go/src/cloudproxy/tao/keys.go b/go/src/cloudproxy/tao/keys.go
index cc66156..2d0abf4 100644
--- a/go/src/cloudproxy/tao/keys.go
+++ b/go/src/cloudproxy/tao/keys.go
@@ -135,59 +135,63 @@ func ParseX509SubjectName(name string) (*pkix.Name, error) {
 // prepareX509Template fills out an X.509 template for use in x509.CreateCertificate.
 func prepareX509Template(subjectName *pkix.Name) *x509.Certificate {
 	return &x509.Certificate{
 		SignatureAlgorithm: x509.ECDSAWithSHA256,
 		PublicKeyAlgorithm: x509.ECDSA,
 		Version:            2, // x509v3
 		// It's always allowed for self-signed certs to have serial 1.
 		SerialNumber: new(big.Int).SetInt64(1),
 		Subject:      *subjectName,
 		NotBefore:    time.Now(),
 		NotAfter:     time.Now().AddDate(1 /* years */, 0 /* months */, 0 /* days */),
 		// TODO(tmroeder): I'm not sure which of these I need to make
 		// OpenSSL happy.
 		KeyUsage:    x509.KeyUsageKeyAgreement | x509.KeyUsageCertSign,
 		ExtKeyUsage: []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth, x509.ExtKeyUsageClientAuth},
 	}
 }
 
 // CreateSelfSignedX509 creates a self-signed X.509 certificate for the public
 // key of this Signer.
-func (s *Signer) CreateSelfSignedX509(name *pkix.Name) ([]byte, error) {
+func (s *Signer) CreateSelfSignedX509(name *pkix.Name) (*x509.Certificate, error) {
 	template := prepareX509Template(name)
 	template.IsCA = true
 	template.Issuer = template.Subject
 
-	return x509.CreateCertificate(rand.Reader, template, template, &s.ec.PublicKey, s.ec)
+	der, err := x509.CreateCertificate(rand.Reader, template, template, &s.ec.PublicKey, s.ec)
+	if err != nil {
+		return nil, err
+	}
+
+	return x509.ParseCertificate(der)
 }
 
 // CreateSignedX509 creates a signed X.509 certificate for some other subject's
 // key.
-func (s *Signer) CreateSignedX509(CAPEMCert []byte, certSerial int, subjectKey *Verifier, subjectName *pkix.Name) ([]byte, error) {
-	signerCert, err := x509.ParseCertificate(CAPEMCert)
+func (s *Signer) CreateSignedX509(caCert *x509.Certificate, certSerial int, subjectKey *Verifier, subjectName *pkix.Name) (*x509.Certificate, error) {
+	template := prepareX509Template(subjectName)
+
+	der, err := x509.CreateCertificate(rand.Reader, template, caCert, subjectKey.ec, s.ec)
 	if err != nil {
 		return nil, err
 	}
-
-	template := prepareX509Template(subjectName)
-
-	return x509.CreateCertificate(rand.Reader, template, signerCert, subjectKey.ec, s.ec)
+	return x509.ParseCertificate(der)
 }
 
 // marshalECDSA_SHA_SigningKeyV1 encodes a private key as a protobuf message.
 func marshalECDSA_SHA_SigningKeyV1(k *ecdsa.PrivateKey) *ECDSA_SHA_SigningKeyV1 {
 	return &ECDSA_SHA_SigningKeyV1{
 		Curve:     NamedEllipticCurve_PRIME256_V1.Enum(),
 		EcPrivate: k.D.Bytes(),
 		EcPublic:  elliptic.Marshal(k.Curve, k.X, k.Y),
 	}
 
 }
 
 // MarshalSignerProto encodes a signing key as a CryptoKey protobuf message.
 func MarshalSignerProto(s *Signer) (*CryptoKey, error) {
 	m := marshalECDSA_SHA_SigningKeyV1(s.ec)
 	defer zeroBytes(m.EcPrivate)
 
 	b, err := proto.Marshal(m)
 	if err != nil {
 		return nil, err
@@ -418,47 +422,42 @@ func FromPrincipalName(name string) (*Verifier, error) {
 	}
 
 	if *ck.Algorithm != CryptoKey_ECDSA_SHA {
 		return nil, errors.New("bad algorithm")
 	}
 
 	var ecvk ECDSA_SHA_VerifyingKeyV1
 	if err := proto.Unmarshal(ck.Key, &ecvk); err != nil {
 		return nil, err
 	}
 
 	ec, err := unmarshalECDSA_SHA_VerifyingKeyV1(&ecvk)
 	if err != nil {
 		return nil, err
 	}
 
 	return &Verifier{ec}, nil
 }
 
 // FromX509 creates a Verifier from an X509 certificate.
-func FromX509(cert []byte) (*Verifier, error) {
-	c, err := x509.ParseCertificate(cert)
-	if err != nil {
-		return nil, err
-	}
-
-	ecpk, ok := c.PublicKey.(*ecdsa.PublicKey)
+func FromX509(cert *x509.Certificate) (*Verifier, error) {
+	ecpk, ok := cert.PublicKey.(*ecdsa.PublicKey)
 	if !ok {
 		return nil, errors.New("invalid key type in certificate: must be ECDSA")
 	}
 
 	return &Verifier{ecpk}, nil
 }
 
 // UnmarshalVerifierProto decodes a verifying key from a CryptoKey protobuf
 // message.
 func UnmarshalVerifierProto(ck *CryptoKey) (*Verifier, error) {
 	if *ck.Version != CryptoVersion_CRYPTO_VERSION_1 {
 		return nil, errors.New("bad version")
 	}
 
 	if *ck.Purpose != CryptoKey_VERIFYING {
 		return nil, errors.New("bad purpose")
 	}
 
 	if *ck.Algorithm != CryptoKey_ECDSA_SHA {
 		return nil, errors.New("bad algorithm")
@@ -885,46 +884,51 @@ func NewOnDiskPBEKeys(keyTypes KeyType, password []byte, path string) (*Keys, er
 		return nil, errors.New("bad init call: no path for keys")
 	}
 
 	k := &Keys{
 		keyTypes: keyTypes,
 		dir:      path,
 	}
 
 	if len(password) == 0 {
 		// This means there's no secret information: just load a public
 		// verifying key.
 		if k.keyTypes & ^Signing != 0 {
 			return nil, errors.New("without a password, only a verifying key can be loaded")
 		}
 
 		f, err := os.Open(k.X509Path())
 		if err != nil {
 			return nil, err
 		}
 
-		xb, err := ioutil.ReadAll(f)
+		der, err := ioutil.ReadAll(f)
+		if err != nil {
+			return nil, err
+		}
+
+		cert, err := x509.ParseCertificate(der)
 		if err != nil {
 			return nil, err
 		}
 
-		if k.VerifyingKey, err = FromX509(xb); err != nil {
+		if k.VerifyingKey, err = FromX509(cert); err != nil {
 			return nil, err
 		}
 	} else {
 		// There are two different types of keysets: in one there's
 		// just a Signer, so we use an encrypted PEM format. In the
 		// other, there are multiple keys, so we use a custom protobuf
 		// format.
 		if k.keyTypes & ^Signing != 0 {
 			// Check to see if there are already keys.
 			f, err := os.Open(k.PBEKeysetPath())
 			if err == nil {
 				ks, err := ioutil.ReadAll(f)
 				if err != nil {
 					return nil, err
 				}
 
 				data, err := PBEDecrypt(ks, password)
 				if err != nil {
 					return nil, err
 				}
