#* 
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-07-19T22:34:54-0700
#* 
#-
#- This code adds initial support for the TPM, at first with just a
#- couple of simple message types (like GetRandom). This is a port
#- from the C source code in Code/TPMDirect/vTCIDirect.{cpp,h}, which
#- in turn seems to be a direct port of Code/TPMDirect/tpm.{c,h}.
#- 
#- This version uses encoding/binary to abstract the marshalling and
#- unmarshalling of data structures that makes up most of the work of
#- communicating with the TPM and tries to turn it into a simple
#- RPC-like interface as much as possible.
#- 
#- Note that the current version of GetRandom doesn't work when it's
#- run with the other tests, though it does work when run alone under
#- -test.run=TestGetRandom. The reason seems to be that the testing
#- framework runs this command too soon after another TPM command has
#- completed.
#- 
#- The following are the commit text from the commits so far:
#- 
#- A version of the TPM port that can read PCRs from /dev/tpm0
#- 
#- 
#- Wrote GetRandom and figured out how to handle response headers
#- 
#- 
#- Generalized the hybrid response handling
#- 
#- 
#- Changed encoding to Pack/Unpack with explicit headers and mixed struct/slice support
#- 
#- 
diff --git a/.gitignore b/.gitignore
index cb9555f..2ff8115 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,2 +1,2 @@
 *.swp
-tpm
+/tpm
diff --git a/go/src/tpm/tpm.go b/go/src/tpm/tpm.go
new file mode 100644
index 0000000..14e31b3
--- /dev/null
+++ b/go/src/tpm/tpm.go
@@ -0,0 +1,261 @@
+// Package tpm supports direct communication with a tpm device under Linux.
+package tpm
+
+import (
+	"bytes"
+	"encoding/binary"
+	"errors"
+	"os"
+	"strconv"
+)
+
+// TPM constants for messages.
+const (
+	TagRQUCommand uint16 = 0x00C1
+	OrdPCRExtend  uint32 = 0x00000014
+	OrdPCRRead    uint32 = 0x00000015
+	OrdOSAP       uint32 = 0x0000000B
+	OrdOIAP       uint32 = 0x0000000A
+	OrdGetRandom  uint32 = 0x00000046
+	PCRSize       int    = 20
#*
#* author: Kevin Walsh
#* email: kwalsh@holycross.edu
#* date: 2014-07-20T09:34:54-0400
#*
#- Style: I'd put PCRSize in a separate block of code. Its different from the
#- rest.
#-
#- Also: Is it necessary to have most of these exported? Except for (perhaps) PCRSize,
#- these could be unexported. AFAIK, unexported symbols can still be used by
#- other files in the tpm package.
#-
#**
#** author: Tom Roeder
#** email: tmroeder@google.com
#** date: 2014-07-20T10:45:48-0700
#**
#-- Fixed
#-- 
+)
+
+// A Result is a return value from the TPM.
+type Result uint32
+
+const (
+	Success Result = iota
+	BuffTooSmallError
+	UnauthorizedError
+	FunctionFailedError
+)
+
+// resultErrors maps Results to their associated error strings.
+var resultErrors = map[Result]string{
+	Success:             "success",
+	BuffTooSmallError:   "buffer too small",
+	UnauthorizedError:   "unauthorized",
+	FunctionFailedError: "function failed",
+}
+
+// Error produces a string for the given TPM Error code
+func (r Result) Error() string {
+	if s, ok := resultErrors[r]; ok {
+		return s
+	}
+
+	return "Unknown error code " + strconv.Itoa(int(r))
+}
#*
#* author: Kevin Walsh
#* email: kwalsh@holycross.edu
#* date: 2014-07-20T09:42:36-0400
#*
#- I get that tpm commands don't really have results, they just have status
#- returns. And the use of type Result uint32, iota, and the Error function for
#- Result receiver is clever. But Success implements error? And wouldn't it be
#- easy to accidentally return an integer (e.g. return 5) from some function by
#- mistake instead of a real Result. I'm also not keen on the need for a map
#- from Result values to error strings. Finally, putting "Error" at the end of a
#- name is what is expected for an error type (say, TPMError), not a specific
#- error. See https://code.google.com/p/go-wiki/wiki/Errors
#-
#- I think the style seen in package io (http://golang.org/src/pkg/io/io.go)
#- might be more idiomatic and avoid the issues above. That is:
#- * Make functions return type error instead of Result. Or use:
#-    type Result error
#- * Functions can return nil for success.
#- * Use a series of vars for the errors, with prefix Err, like so:
#- var ErrBuffTooSmall = errors.New("tpm: buffer too small")
#- var ErrUnauthorized = errors.New("tpm: unauthorized")
#- var ErrFunctionFailed = errors.New("tpm: function failed")
#- * Put "tpm:" at the start of the error messages. This doesn't seem to be
#- consistently used in go packages, but I've seen it here and there and it has
#- been helpful in my own debugging.
#-
#- If these error codes (FunctionFailed = 3) are defined by the tpm/tcg spec or
#- are returned by the underlying dev driver, then we could have map[int] error
#- for them somewhere like your code above. But I don't these are those
#- errors... I think jlm invented these. The TPM_* error codes (TPM_SUCCESS,
#- TPM_AUTHFAIL, etc.) later are from the tpm/tcg spec though, so having some
#- kind of map makes sense for those.
#**
#** author: Tom Roeder
#** email: tmroeder@google.com
#** date: 2014-07-20T15:27:22-0700
#**
#-- Fixed. See tpm_errors.go and the code there for opError. I also
#-- don't export that error type now, since all the caller needs to
#-- know is that it implements error.
#-- 
+
+// A CommandHeader is the header for a TPM command.
+type CommandHeader struct {
+	Tag  uint16
+	Size uint32
+	Cmd  uint32
+}
+
+// PackedSize computes the size of a sequence of types that can be passed to
+// binary.Read or binary.Write.
+func PackedSize(elts []interface{}) int {
+	// Add the total size to the header.
+	var size int
+	for i := range elts {
+		s := binary.Size(elts[i])
#*
#* author: Kevin Walsh
#* email: kwalsh@holycross.edu
#* date: 2014-07-20T10:44:50-0400
#*
#- I think go's 2-value range loop works here:
#-   for i, e := range elts {
#-     s := binary.Size(e)
#-
#**
#** author: Tom Roeder
#** email: tmroeder@google.com
#** date: 2014-07-20T15:28:02-0700
#**
#-- Fixed. In fact, I can use _, e := range elts, since I don't need the index.
#-- 
+		if s == -1 {
+			return -1
+		}
+
+		size += s
+	}
+
+	return size
+}
+
+// Pack takes a sequence of elements that are either of fixed length or slices
+// of fixed-length types and packs them into a single byte array using
+// binary.Write. The first element of the sequence must be a *CommandHeader.
+func Pack(cmd []interface{}) ([]byte, error) {
+	hdr, ok := cmd[0].(*CommandHeader)
+	if !ok {
+		return nil, errors.New("first packed element must be a CommandHeader")
+	}
+
+	size := PackedSize(cmd)
+	if size <= 0 {
+		return nil, errors.New("can't compute the size of the command")
+	}
#*
#* author: Kevin Walsh
#* email: kwalsh@holycross.edu
#* date: 2014-07-20T10:47:02-0400
#*
#- Nit: Check size before checking for CommandHeader to avoid out-of-bounds
#- error if cmd is zero length?
#-
#**
#** author: Tom Roeder
#** email: tmroeder@google.com
#** date: 2014-07-20T15:28:25-0700
#**
#-- No longer a problem now that I pass the CommandHeader directly.
#-- 
+
+	hdr.Size = uint32(size)
+	buf := bytes.NewBuffer(make([]byte, 0, size))
+	for i := range cmd {
+		if err := binary.Write(buf, binary.BigEndian, cmd[i]); err != nil {
+			return nil, err
+		}
+	}
+
+	return buf.Bytes(), nil
+}
+
+// A header for TPM responses.
+type ResponseHeader struct {
+	Tag  uint16
+	Size uint32
+	Res  Result
#*
#* author: Kevin Walsh
#* email: kwalsh@holycross.edu
#* date: 2014-07-20T11:04:10-0400
#*
#- I think this should be Res uint32. See next comment for why.
#-
#**
#** author: Tom Roeder
#** email: tmroeder@google.com
#** date: 2014-07-20T15:28:42-0700
#**
#-- Fixed in tpm_errors.go
#-- 
+}
+
+// Unpack decodes from a byte array a sequence of elements that either either
+// pointers to fixed length types or slices of fixed-length types. It uses
+// binary.Read to do the decoding. If the first element of the resp sequence is
+// a *ResponseHeader, then the Result field will be checked for success.
+func Unpack(b []byte, resp []interface{}) error {
+	hdr, ok := resp[0].(*ResponseHeader)
#*
#* author: Kevin Walsh
#* email: kwalsh@holycross.edu
#* date: 2014-07-20T10:55:25-0400
#*
#- style: move above line down 2 lines, just before if, and maybe even combine
#- into a compound-if: if hdr, ok := ...; ok {
#-
#**
#** author: Tom Roeder
#** email: tmroeder@google.com
#** date: 2014-07-20T15:28:51-0700
#**
#-- This code now passes the ResponseHeader directly, so this is handled differently.
#-- 
+	buf := bytes.NewBuffer(b)
+	var start int
+	if ok {
+		if err := binary.Read(buf, binary.BigEndian, hdr); err != nil {
+			return err
+		}
+
+		if hdr.Res != Success {
+			return hdr.Res
+		}
#*
#* author: Kevin Walsh
#* email: kwalsh@holycross.edu
#* date: 2014-07-20T10:56:57-0400
#*
#- Errors again. Here, I'm not positive but I am pretty sure the error codes
#- that will appear inside the tpm response headers are not the same as the 
#- error codes you defined above. It happens that 0 is success for both.
#- But 1 does not mean BuffTooSmallError, it means TPM_AUTHFAIL.  And the values
#- go up to something like 39 (TPM_INAPPROPRIATE_SIG). This is where I think you
#- should use a map to get from uint32 tcg error codes to error values. Or do
#- your clever trick with 'type TPMError uint32', a map, and an Error()
#- function. And if Res is a uint32, then line here would then be:
#-   return TPMError(hdr.Res)
#- which makes the conversion from tpm codes to go errors very clear, I think.
#-
#**
#** author: Tom Roeder
#** email: tmroeder@google.com
#** date: 2014-07-20T15:29:15-0700
#**
#-- Fixed in this style in tpm_errors.go
#-- 
+		start = 1
+	}
+
+	for i := start; i < len(resp); i++ {
+		if err := binary.Read(buf, binary.BigEndian, resp[i]); err != nil {
+			return err
+		}
+	}
+
+	return nil
+}
+
+// submitTPMRequest sends a structure to the TPM device file and gets results
+// back, interpreting them as a new provided structure.
+func submitTPMRequest(f *os.File, in []interface{}, out []interface{}) error {
+	inb, err := Pack(in)
+	if err != nil {
+		return err
+	}
+
+	if _, err := f.Write(inb); err != nil {
+		return err
+	}
+
+	outSize := PackedSize(out)
+	if outSize <= 0 {
+		return errors.New("can't compute the size of the response")
+	}
+
+	// TODO(tmroeder): this assumes (probably incorrectly) that the TPM will
+	// write the same number of bytes whether the command succeeds or not. It's
+	// more likely that the TPM will return only a response header if the
+	// command fails. In that case, I need to read the response header first,
+	// then decide what action to take. And I should probably separate out the
+	// header from the rest of the output interface.
#*
#* author: Kevin Walsh
#* email: kwalsh@holycross.edu
#* date: 2014-07-20T11:12:37-0400
#*
#- tpmwg-mainrev62_Part2_TPM_Structures.pdf, page 113: 
#-   1. When a command fails for ANY reason, the TPM MUST return only the
#-      following three items:
#-     a. TPM_TAG_RQU_COMMAND (2 bytes)
#-     b. ParamLength(4 bytes, fixed at 10)
#-     c. Return Code (4 bytes, never TPM_SUCCESS)
#- I also agree about separating the response header from the output slice --
#- the caller won't need it for anything since you check the error code in
#- Unpack.
#**
#** author: Tom Roeder
#** email: tmroeder@google.com
#** date: 2014-07-20T15:29:25-0700
#**
#-- Thanks. This is now handled specially in submitTPMCommand
#-- 
+	outb := make([]byte, outSize)
+	if _, err := f.Read(outb); err != nil {
+		return err
+	}
+
+	if err := Unpack(outb, out); err != nil {
+		return err
+	}
+
#*
#* author: Kevin Walsh
#* email: kwalsh@holycross.edu
#* date: 2014-07-20T11:32:28-0400
#*
#- In all cases other than the error case discussed in the above comment, you
#- might want to sanity check the response. The tag in the response header
#- should correspond to the request tag, e.g. TagRQUCommand in the request becomes
#- TagRSPCommand in the response. Also, for every case except the error case
#- handled above, there should be an ordinal uint32 that follows the response
#- header and preceeds any command-specific data. That response ordinal should
#- match the request header Ord. I'm pretty these things are true for every TPM
#- command and response, so they should be handled here.
#-
#**
#** author: Tom Roeder
#** email: tmroeder@google.com
#** date: 2014-07-20T15:29:46-0700
#**
#-- Fixed, at least for the commands I currently support (which are all tagRQUCommand).
#-- 
+	return nil
+}
+
+// ReadPCR reads a PCR value from the TPM.
+func ReadPCR(f *os.File, pcr uint32) ([]byte, error) {
+	in := []interface{}{
+		&CommandHeader{TagRQUCommand, 0, OrdPCRRead},
+		pcr,
+	}
+
+	// The TPM is supposed to return the 20-byte PCR value
+	v := make([]byte, PCRSize)
+	if err := submitTPMRequest(f, in, []interface{}{v}); err != nil {
+		return nil, err
+	}
#*
#* author: Kevin Walsh
#* email: kwalsh@holycross.edu
#* date: 2014-07-20T11:20:13-0400
#*
#- See TPM_Main-Part_3_Commands_v1.2_rev116_01032011.pdf, page 173.
#- I'm pretty sure the TPM_PCRRead command also echos back the OrdPCRRead as
#- part of the response before the 20 byte pcr value. So your []interface needs
#- another element. Better yet, I'm pretty sure that every tpm command includes
#- the command ordinal as part of the response header, so ResponseHeader should
#- probably include Ord uint32 and submitTPMRequest should check that the
#- request.Ord == response.Ord.
#-
#**
#** author: Tom Roeder
#** email: tmroeder@google.com
#** date: 2014-07-20T15:30:12-0700
#**
#-- As discussed by email, while that Ord is logically part of the
#-- return value, it's not actually included in the bytes returned by the TPM.
#-- 
+
+	return v, nil
+}
+
+// The response to an OIAPCommand.
+type OIAPResponse struct {
+	Auth      uint32
+	NonceEven [20]byte
+}
+
+// OIAP sends an OIAP command to the TPM and gets back an auth value and a
+// nonce.
+func OIAP(f *os.File) (*OIAPResponse, error) {
+	in := []interface{}{&CommandHeader{TagRQUCommand, 0, OrdOIAP}}
+
+	var rh ResponseHeader
+	var resp OIAPResponse
+	out := []interface{}{&rh, &resp}
+
+	if err := submitTPMRequest(f, in, out); err != nil {
+		return nil, err
+	}
+
+	return &resp, nil
+}
+
+// GetRandom gets random bytes from the TPM.
+func GetRandom(f *os.File, size uint32) ([]byte, error) {
+	in := []interface{}{
+		&CommandHeader{TagRQUCommand, 0, OrdGetRandom},
+		size,
+	}
+
+	var rh ResponseHeader
+	var outSize uint32
+	b := make([]byte, int(size))
+	out := []interface{}{&rh, &outSize, b}
+
+	if err := submitTPMRequest(f, in, out); err != nil {
+		return nil, err
+	}
+
+	if outSize != size {
+		return nil, errors.New("wrong size from GetRandom")
#*
#* author: Kevin Walsh
#* email: kwalsh@holycross.edu
#* date: 2014-07-20T11:39:33-0400
#*
#- Is 0 < outSize < size an error? Or is it legal, more like Read().
#-
#**
#** author: Tom Roeder
#** email: tmroeder@google.com
#** date: 2014-07-20T15:30:39-0700
#**
#-- This is the one case I'm not yet satisfied with, though I did fix
#-- this particular instance of the problem. I need to change my
#-- Unpack method so that it decodes dynamically into []byte based on
#-- seeing a special type of integer before it; I'll probably define
#-- "type SliceLen uint32" then typecheck the []interface{} elements
#-- for that as I see them and use that information to decide how many
#-- bytes to decode if the next element is a []byte. This is only
#-- necessary if a variable-length array occurs in the middle of
#-- decoding. If it always occurs only at the end, then my current
#-- scheme will work, I think.
#--
+	}
+
+	return b, nil
+}
+
+// An OSAPCommand is a command sent for OSAP authentication.
+type OSAPCommand struct {
+	EntryType  uint16
+	EntryValue uint32
#*
#* author: Kevin Walsh
#* email: kwalsh@holycross.edu
#* date: 2014-07-20T11:41:18-0400
#*
#- I think it should be 'Entity' here and below, not 'Entry'. See spec part 3.
#-
#**
#** author: Tom Roeder
#** email: tmroeder@google.com
#** date: 2014-07-20T15:31:32-0700
#**
#-- Fixed.
#-- 
+	OddOSAP    [20]byte
+}
+
+// An OSAPResponse is a TPM reply to an OSAPCommand.
+type OSAPResponse struct {
+	Auth      uint32
+	NonceEven [20]byte
+	EvenOSAP  [20]byte
+}
+
+// OSAP sends an OSAPCommand to the TPM and gets back authentication
+// information in an OSAPResponse.
+func OSAP(f *os.File, entryType uint16, entryValue uint32, oddOSAP [20]byte) (*OSAPResponse, error) {
+	in := []interface{}{
+		&CommandHeader{TagRQUCommand, 0, OrdOSAP},
+		OSAPCommand{entryType, entryValue, oddOSAP},
+	}
+
+	var rh ResponseHeader
+	var resp OSAPResponse
+	out := []interface{}{&rh, &resp}
+
+	if err := submitTPMRequest(f, in, out); err != nil {
+		return nil, err
+	}
+
+	return &resp, nil
+}
diff --git a/go/src/tpm/tpm_test.go b/go/src/tpm/tpm_test.go
new file mode 100644
index 0000000..bd03b7d
--- /dev/null
+++ b/go/src/tpm/tpm_test.go
@@ -0,0 +1,55 @@
+package tpm
#*
#* author: Kevin Walsh
#* email: kwalsh@holycross.edu
#* date: 2014-07-20T11:43:35-0400
#*
#- Didn't look at this file. But did it work?
#-
#**
#** author: Tom Roeder
#** email: tmroeder@google.com
#** date: 2014-07-20T15:31:36-0700
#**
#-- As discussed by email, yes, this works, though there are still
#-- some problems with the TPM not always being ready when I send it a
#-- message too soon after trying another command. I need to figure
#-- out how to handle that in the future.
#-- 
+
+import (
+	"encoding/base64"
+	"os"
+	"testing"
+)
+
+func TestEncoding(t *testing.T) {
+	in := []interface{}{&CommandHeader{TagRQUCommand, 0, OrdOIAP}}
+
+	b, err := Pack(in)
+	if err != nil {
+		t.Fatal("Couldn't pack the bytes:", err)
+	}
+
+	var hdr CommandHeader
+	out := []interface{}{&hdr}
+	if err := Unpack(b, out); err != nil {
+		t.Fatal("Couldn't unpack the packed bytes")
+	}
+}
+
+func TestReadPCR(t *testing.T) {
+	// Try to read PCR 18. For this to work, you have to have access to
+	// /dev/tpm0, and there has to be a TPM driver to answer requests.
+	f, err := os.OpenFile("/dev/tpm0", os.O_RDWR, 0600)
+	if err != nil {
+		t.Fatal("Can't open /dev/tpm0 for read/write:", err)
+	}
+
+	res, err := ReadPCR(f, 18)
+	if err != nil {
+		t.Fatal("Couldn't read PCR 18 from the TPM:", err)
+	}
+
+	resStr := base64.StdEncoding.EncodeToString(res)
+	t.Logf("Got PCR 18 value %s\n", resStr)
+}
+
+func TestGetRandom(t *testing.T) {
+	// Try to get 16 bytes of randomness from the TPM.
+	f, err := os.OpenFile("/dev/tpm0", os.O_RDWR, 0600)
+	if err != nil {
+		t.Fatal("Can't open /dev/tpm0 for read/write:", err)
+	}
+
+	b, err := GetRandom(f, 16)
+	if err != nil {
+		t.Fatal("Couldn't get 16 bytes of randomness from the TPM:", err)
+	}
+
+	s := base64.StdEncoding.EncodeToString(b)
+	t.Logf("Got random bytes %s\n", s)
+}
