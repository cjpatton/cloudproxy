#* 
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-08-17T13:27:50-0700
#* 
#- A mostly empty version of the TPMTao that implements the Tao
#- 
#- 
#- Add support for TPM Tao implementation and Quote verification.
#- 
#- This commit adds implementations of the Tao interface over the TPM, using
#- github.com/google/go-tpm/tpm. It also uses that package to add support for
#- verifying TPM Quote values in attestations using the cloudproxy/tao/auth
#- framework.
#- 
#- This commit also adds some basic tests that use TPMTao as a Tao object to do
#- Seal, Unseal, Attest, and verification of a simple auth.Says.
#- 
#- 
diff --git a/go/src/cloudproxy/tao/attestation.go b/go/src/cloudproxy/tao/attestation.go
index 6e4c93d..4c2e9a2 100644
--- a/go/src/cloudproxy/tao/attestation.go
+++ b/go/src/cloudproxy/tao/attestation.go
@@ -1,58 +1,87 @@
 // Copyright (c) 2014, Kevin Walsh.  All rights reserved.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
 // You may obtain a copy of the License at
 //
 //     http://www.apache.org/licenses/LICENSE-2.0
 //
 // Unless required by applicable law or agreed to in writing, software
 // distributed under the License is distributed on an "AS IS" BASIS,
 // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
 package tao
 
 import (
 	"time"
 
+	"cloudproxy/tao/auth"
+
 	"code.google.com/p/goprotobuf/proto"
 
-	"cloudproxy/tao/auth"
+	"github.com/google/go-tpm/tpm"
 )
 
 // ValidSigner checks the signature on an attestation and, if so, returns the signer.
 func (a *Attestation) ValidSigner() (auth.Prin, error) {
 	signer, err := auth.UnmarshalPrin(a.Signer)
 	if err != nil {
 		return auth.Prin{}, err
 	}
 	if len(signer.Ext) != 0 {
 		return auth.Prin{}, newError("tao: attestation signer principal malformed: %s", signer)
 	}
 	switch signer.Type {
 	case "tpm":
-		// Signer is tpm, use tpm-specific signature verification.
-		// TODO(kwalsh) call tpm-specific verification code
-		return auth.Prin{}, newError("tao: tpm signature verification not yet implemented")
+		// The PCRs are contained in the Speaker of an auth.Says statement that
+		// makes up the a.SerializedStatement.
+		f, err := auth.UnmarshalForm(a.SerializedStatement)
+		if err != nil {
+			return auth.Prin{}, newError("tao: couldn't unmarshal the statement:", err.Error())
#*
#* author: Kevin Walsh
#* email: kwalsh@holycross.edu
#* date: 2014-08-18T15:27:17-0400
#*
#- newError should have been named newErrorf, since it uses fmt.Errorf
#- internally and expects a format string + args. You are missing "%s" here and
#- below. Also: the ".Error()" is not necessary since fmt will do the right
#- thing with an error value.
#-
+		}
+
+		// A TPM attestation must be an auth.Says.
+		says, ok := f.(auth.Says)
+		if !ok {
+			return auth.Prin{}, newError("tao: the attestation statement was not an auth.Says statement")
+		}
+
+		// Signer is tpm; use tpm-specific signature verification. Extract the
+		// PCRs from the issuer name, unmarshal the key as an RSA key, and call
+		// tpm.VerifyQuote().
+		pcrNums, pcrVals, err := extractPCRs(says.Speaker)
+		if err != nil {
+			return auth.Prin{}, newError("tao: couldn't extract PCRs from the signer:", err.Error())
+		}
+
+		pk, err := extractAIK(says.Speaker)
+		if err != nil {
+			return auth.Prin{}, newError("tao: couldn't extract the AIK from the signer:", err.Error())
+		}
+		if err := tpm.VerifyQuote(pk, a.SerializedStatement, a.Signature, pcrNums, pcrVals); err != nil {
+			return auth.Prin{}, newError("tao: TPM quote failed verification:", err)
+		}
+
+		return signer, nil
 	case "key":
 		// Signer is ECDSA key, use Tao signature verification.
 		v, err := FromPrincipal(signer)
 		if err != nil {
 			return auth.Prin{}, err
 		}
 		ok, err := v.Verify(a.SerializedStatement, AttestationSigningContext, a.Signature)
 		if err != nil {
 			return auth.Prin{}, err
 		}
 		if !ok {
 			return auth.Prin{}, newError("tao: attestation signature invalid")
 		}
#*
#* author: Kevin Walsh
#* email: kwalsh@holycross.edu
#* date: 2014-08-18T15:29:47-0400
#*
#- I was wondering earlier why key.Verify() returns a bool and an error, since
#- we can just use err=nil in place of the bool. You take that approach for
#- tpm.VerifyQuote, so maybe we should change key.Verify() to match. Sometime.
#-
 		return signer, nil
 	default:
 		return auth.Prin{}, newError("tao: attestation signer principal unrecognized: %s", signer.String())
 	}
 }
 
 // Validate checks whether an attestation is valid and, if so, it returns the
diff --git a/go/src/cloudproxy/tao/tpm_tao.go b/go/src/cloudproxy/tao/tpm_tao.go
new file mode 100644
index 0000000..dd3ddac
--- /dev/null
+++ b/go/src/cloudproxy/tao/tpm_tao.go
@@ -0,0 +1,331 @@
+// Copyright (c) 2014, Google Inc. All rights reserved.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package tao
+
+import (
+	"crypto/rsa"
+	"crypto/x509"
+	"encoding/hex"
+	"errors"
+	"io"
+	"io/ioutil"
+	"os"
+	"strconv"
+	"strings"
+	"time"
+
+	"cloudproxy/tao/auth"
+
+	"github.com/google/go-tpm/tpm"
+)
+
+// A TPMTao implements the Tao using a hardware TPM device.
+type TPMTao struct {
+	// tpmfile is the file through which TPMTao communicates with the TPM. E.g.,
+	// on Linux, this is usually /dev/tpm0.
+	tpmfile *os.File
+
+	// srkAuth is the authenticator for the SRK. In most simple cases, it's 20
+	// bytes of zeros. That value is called the "well-known authentictor"
+	srkAuth [20]byte
+
+	// aikHandle is an integer handle for an AIK held by the TPM. This key is
+	// used for creating Quote values from the TPM.
+	aikHandle tpm.Handle
+
+	// verifier is a representation of the AIK that can be used to verify Quote
+	// and Quote2 attestations.
+	verifier *rsa.PublicKey
+
+	// pcrCount is the number of PCRs in the TPM. The current go-tpm
+	// implementation fixes this at 24.
+	pcrCount uint32
+	pcrNums  []int
+	pcrVals  [][]byte
+
+	// The name of the TPMTao is tpm(...K...), and its extensions are added by
+	// calls to ExtendTaoName. When the TPMTao creates an attestation, however,
+	// it prepends the PCRs as part of its name by making an auth.SubPrin for
+	// the PCRs that is preprended to exts.
+	name auth.Prin
+	exts auth.SubPrin
#*
#* author: Kevin Walsh
#* email: kwalsh@holycross.edu
#* date: 2014-08-18T15:38:01-0400
#*
#- This comment doesn't quite parse for me: extensions aren't added to name,
#- they are added to exts in the code blow, and the PCRs aren't prepended, they
#- are part of it. So: name is tpm(...K...). The caller's name is
#- tpm(...K...).exts, where exts includes at least the PCRs, exts maybe also
#- eventually will include the locality, and exts can be (sort of) extended
#- further by calls to ExtendTaoName. More on this below.
#-
+
+	// The current TPMTao code uses only locality 0, so this value is never set.
+	locality byte
+}
+
+// NewTPMTao creates a new TPMTao and returns it under the Tao interface.
+func NewTPMTao(tpmPath, aikblobPath string, pcrNums []int) (Tao, error) {
#*
#* author: Kevin Walsh
#* email: kwalsh@holycross.edu
#* date: 2014-08-18T15:45:06-0400
#*
#- Maybe aikblobPath should just be aikblob []byte instead?
#-
+	var err error
+	tt := &TPMTao{pcrCount: 24}
+	tt.tpmfile, err = os.OpenFile(tpmPath, os.O_RDWR, 0600)
#*
#* author: Kevin Walsh
#* email: kwalsh@holycross.edu
#* date: 2014-08-18T15:43:01-0400
#*
#- What is the 0600 here? Can it just use 0 since no O_CREATE?
#-
+	if err != nil {
+		return nil, err
+	}
+
+	// For now, the SRK Auth value is all zero, which is the well-known value.
+	// So, we don't set it here.
+	// TODO(tmroeder): add support for general SRK auth values.
+
+	// TODO(tmroeder): the current tpm implementation in go-tpm assumes 24 PCRs.
+	// This is not true in general, and it should be generalized there then
+	// changed here.
+	blob, err := ioutil.ReadFile(aikblobPath)
+	if err != nil {
+		return nil, err
+	}
+
+	tt.aikHandle, err = tpm.LoadKey2(tt.tpmfile, blob, tt.srkAuth[:])
+	if err != nil {
+		return nil, err
+	}
+
+	tt.verifier, err = tpm.UnmarshalRSAPublicKey(blob)
+	if err != nil {
+		return nil, err
#*
#* author: Kevin Walsh
#* email: kwalsh@holycross.edu
#* date: 2014-08-18T15:51:45-0400
#*
#- I think this error path (and those below in this function) are going to leak
#- the tpm key since the caller gets nil and can never call tt.Close(). To be
#- super pedantic, perhaps put tt.Close() in every exit path except the success
#- one? Or figure out a way to do it with defer? Or use runtime.SetFinalizer()?
#-
+	}
+
+	// Get the pcr values for the PCR nums.
+	tt.pcrNums = make([]int, len(pcrNums))
+	tt.pcrVals = make([][]byte, len(pcrNums))
+	for i, v := range pcrNums {
+		tt.pcrNums[i] = v
+		pv, err := tpm.ReadPCR(tt.tpmfile, uint32(v))
+		if err != nil {
+			return nil, err
+		}
+		tt.pcrVals[i] = pv
+	}
+
+	aik, err := x509.MarshalPKIXPublicKey(tt.verifier)
+	if err != nil {
+		return nil, err
+	}
+	tt.name = auth.Prin{
+		Type: "tpm",
+		Key:  aik,
+	}
+
+	return tt, nil
+}
+
+func (tt *TPMTao) Close() {
+	// Flush the AIK.
+	tt.aikHandle.CloseKey(tt.tpmfile)
+
+	// Release the file handle.
+	tt.tpmfile.Close()
#*
#* author: Kevin Walsh
#* email: kwalsh@holycross.edu
#* date: 2014-08-18T15:50:42-0400
#*
#- Since tpm resources are so precious, it might be worth using
#- runtime.SetFinalizer() for TPMTao.
#-
+}
+
+// GetTaoName returns the Tao principal name assigned to the caller.
+func (tt *TPMTao) GetTaoName() (name auth.Prin, err error) {
+	return tt.name.MakeSubprincipal(tt.exts), nil
+}
+
+// ExtendTaoName irreversibly extends the Tao principal name of the caller.
+func (tt *TPMTao) ExtendTaoName(subprin auth.SubPrin) error {
+	tt.exts = append(tt.exts, subprin...)
+	return nil
#*
#* author: Kevin Walsh
#* email: kwalsh@holycross.edu
#* date: 2014-08-18T15:54:55-0400
#*
#- This is not irreversable. Caller can do any number of things to reverse it,
#- including unsafe, making a new TPMTao object, etc. This should either fail
#- until we properly implement PCR extensions, or have a nice big TODO. I have
#- ideas on how to do PCR extension + subprins, but never had the code to do it.
#-
+}
+
+// GetRandomBytes returns a slice of n random bytes.
+func (tt *TPMTao) GetRandomBytes(n int) ([]byte, error) {
+	if n < 0 {
+		return nil, errors.New("invalid number of requested random bytes")
+	}
+	return tpm.GetRandom(tt.tpmfile, uint32(n))
+}
+
+// Read implements io.Reader to read random bytes from the TPMTao.
+func (tt *TPMTao) Read(p []byte) (int, error) {
+	bytes, err := tt.GetRandomBytes(len(p))
+	if err != nil {
+		return 0, err
+	}
+
+	copy(p, bytes)
+	return len(p), nil
+}
+
+// Rand produces an io.Reader for random bytes from this Tao.
+func (tt *TPMTao) Rand() io.Reader {
+	return tt
+}
+
+// GetSharedSecret returns a slice of n secret bytes.
+func (tt *TPMTao) GetSharedSecret(n int, policy string) (bytes []byte, err error) {
+	return nil, errors.New("the TPMTao does not implement GetSharedSecret")
+}
+
+// Attest requests the Tao host sign a statement on behalf of the caller. The
+// optional issuer, time and expiration will be given default values if nil.
+func (tt *TPMTao) Attest(issuer *auth.Prin, start, expiration *int64, message auth.Form) (*Attestation, error) {
+	if issuer == nil {
+		issuer = &tt.name
+	} else if !issuer.Identical(tt.name) {
+		return nil, errors.New("invalid issuer in statement")
+	}
+
+	// TODO(tmroeder): we assume here that the PCRs haven't changed (e.g., been
+	// extended) since this TPMTao was created. If they have, then the PCRs will
+	// be wrong when we extend the principal here with them as the first
+	// component. This doesn't matter at the moment, since we don't currently
+	// support extending the PCRs or clearing them, but it will need to be
+	// changed when we do.
+	asp := auth.PrinExt{
+		Name: "PCRs",
+		Arg:  make([]auth.Term, 2),
+	}
+	var pcrNums []string
+	for _, v := range tt.pcrNums {
+		pcrNums = append(pcrNums, strconv.Itoa(v))
+	}
+	asp.Arg[0] = auth.Str(strings.Join(pcrNums, ","))
+
+	var pcrVals []string
+	for _, p := range tt.pcrVals {
+		pcrVals = append(pcrVals, hex.EncodeToString(p))
+	}
+	asp.Arg[1] = auth.Str(strings.Join(pcrVals, ","))
+
+	// Prepend the PCRs to the issuer subprincipal extensions.
+	stmt := auth.Says{
+		Speaker:    *issuer,
+		Time:       start,
+		Expiration: expiration,
+		Message:    message,
+	}
+	// Prepend the PCRs after doing a shallow copy of the issuer so that this
+	// operation doesn't change the issuer at all.
+	stmt.Speaker.Ext = append([]auth.PrinExt{asp}, issuer.Ext...)
#*
#* author: Kevin Walsh
#* email: kwalsh@holycross.edu
#* date: 2014-08-18T16:01:48-0400
#*
#- Elsewhere, the issuer param is either nil or expected to be the *child's*
#- name. You seem to be expecting either nil or the *tpm's* name. Also, you
#- write but never use tt.exts. Instead, I think you should:
#-    1. Check against name.exts at the top of this func
#-    2. Elsewhere you should have already put the PCRs into exts, e.g. in New.
#-    3. Don't prepend anything here, since PCRs are already in exts and issuer
#-       is either assigned or identical to name.exts.
+
+	// This is done in GenerateAttestation, but the TPM attestation is signed
+	// differently, so we do the time calculations here.
+	t := time.Now()
+	if stmt.Time == nil {
+		i := t.UnixNano()
+		stmt.Time = &i
+	}
+
+	if stmt.Expiration == nil {
+		i := t.Add(365 * 24 * time.Hour).UnixNano()
+		stmt.Expiration = &i
+	}
+
+	ser := auth.Marshal(stmt)
+	// TODO(tmroeder): check the pcrVals for sanity.
+	sig, _, err := tpm.Quote(tt.tpmfile, tt.aikHandle, ser, tt.pcrNums, tt.srkAuth[:])
+	if err != nil {
+		return nil, err
+	}
+
+	a := &Attestation{
+		SerializedStatement: ser,
+		Signature:           sig,
+		Signer:              auth.Marshal(tt.name),
+	}
+	return a, nil
+}
+
+// Seal encrypts data so only certain hosted programs can unseal it.
+func (tt *TPMTao) Seal(data []byte, policy string) (sealed []byte, err error) {
+	if policy != SealPolicyDefault {
+		return nil, errors.New("tpm-specific policies are not yet implemented")
+	}
+
+	return tpm.Seal(tt.tpmfile, tt.locality, tt.pcrNums, data, tt.srkAuth[:])
+}
+
+// Unseal decrypts data that has been sealed by the Seal() operation, but only
+// if the policy specified during the Seal() operation is satisfied.
+func (tt *TPMTao) Unseal(sealed []byte) (data []byte, policy string, err error) {
+	unsealed, err := tpm.Unseal(tt.tpmfile, sealed, tt.srkAuth[:])
+	if err != nil {
+		return nil, "", err
+	}
+
+	return unsealed, SealPolicyDefault, nil
+}
+
+// extractPCRs gets the PCRs from a tpm principal.
+func extractPCRs(p auth.Prin) ([]int, []byte, error) {
+	if p.Type != "tpm" {
+		return nil, nil, errors.New("can only extract PCRs from a TPM principal")
+	}
+
+	// The PCRs are stored as the first subprincipal value, with name "PCRs".
+	if len(p.Ext) == 0 {
+		return nil, nil, errors.New("no subprincipals available for PCR extraction")
+	}
+
+	if p.Ext[0].Name != "PCRs" {
+		return nil, nil, errors.New("the first subprincipal must have Name 'PCRs' for PCR extraction to work")
+	}
+
+	sp := p.Ext[0]
+	if len(sp.Arg) != 2 {
+		return nil, nil, errors.New("the PCRs subprincipal must have exactly two arguments")
+	}
+
+	// auth.Str is exactly a string.
+	arg0, ok0 := sp.Arg[0].(auth.Str)
+	arg1, ok1 := sp.Arg[1].(auth.Str)
+	if !ok0 || !ok1 {
+		return nil, nil, errors.New("both Terms in the PCRs subprincipal must be strings")
+	}
+
+	nums := strings.Split(string(arg0), ",")
+	vals := strings.Split(string(arg1), ",")
+	if len(nums) != len(vals) {
+		return nil, nil, errors.New("mismatched count between PCR nums and vals")
+	}
+
+	pcrNums := make([]int, len(nums))
+	var pcrVals []byte
+	for i, v := range nums {
+		n, err := strconv.ParseInt(v, 10, 16)
+		if err != nil {
+			return nil, nil, err
+		}
+		pcrNums[i] = int(n)
+
+		b, err := hex.DecodeString(vals[i])
+		if err != nil {
+			return nil, nil, err
+		}
+		pcrVals = append(pcrVals, b...)
+	}
+	return pcrNums, pcrVals, nil
+}
+
+// extractAIK gets an RSA public key from the TPM principal name.
+func extractAIK(p auth.Prin) (*rsa.PublicKey, error) {
+	// The principal's Key should be a binary SubjectPublicKeyInfo.
+	if p.Type != "tpm" {
+		return nil, errors.New("wrong type of principal: should be 'tpm'")
+	}
+
+	pk, err := x509.ParsePKIXPublicKey(p.Key)
+	if err != nil {
+		return nil, err
+	}
+
+	aik, ok := pk.(*rsa.PublicKey)
+	if !ok {
+		return nil, errors.New("wrong type of public key: only RSA is supported for AIKs")
+	}
+
+	return aik, nil
+}
diff --git a/go/src/cloudproxy/tao/tpm_tao_test.go b/go/src/cloudproxy/tao/tpm_tao_test.go
new file mode 100644
index 0000000..c726c23
--- /dev/null
+++ b/go/src/cloudproxy/tao/tpm_tao_test.go
@@ -0,0 +1,101 @@
+// Copyright (c) 2014, Google Inc. All rights reserved.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package tao
+
+import (
+	"bytes"
+	"testing"
+
+	"cloudproxy/tao/auth"
+)
+
+func TestTPMTao(t *testing.T) {
+	// Set up a TPM Tao that seals and attests against PCRs 17 and 18 and uses
+	// the AIK stored in aikblob. It communicates with the TPM directly through
+	// /dev/tpm0.
+	tpmtao, err := NewTPMTao("/dev/tpm0", "./aikblob", []int{17, 18})
+	if err != nil {
+		t.Fatal("Couldn't create a new TPM Tao:", err)
+	}
+
+	tt, ok := tpmtao.(*TPMTao)
+	if !ok {
+		t.Fatal("Wrong type of tao returnd from NewTPMTao")
+	}
+
+	tt.Close()
+}
+
+func TestTPMTaoSeal(t *testing.T) {
+	tpmtao, err := NewTPMTao("/dev/tpm0", "./aikblob", []int{17, 18})
+	if err != nil {
+		t.Fatal("Couldn't create a new TPM Tao:", err)
+	}
+	tt, ok := tpmtao.(*TPMTao)
+	if !ok {
+		t.Fatal("Wrong type of tao returnd from NewTPMTao")
+	}
+	defer tt.Close()
+
+	data := []byte(`test data to seal`)
+	sealed, err := tpmtao.Seal(data, SealPolicyDefault)
+	if err != nil {
+		t.Fatal("Couldn't seal data in the TPM Tao:", err)
+	}
+
+	unsealed, policy, err := tpmtao.Unseal(sealed)
+	if err != nil {
+		t.Fatal("Couldn't unseal data sealed by the TPM Tao:", err)
+	}
+
+	if policy != SealPolicyDefault {
+		t.Fatal("Got the wrong policy back from TPMTao.Unseal")
+	}
+
+	if !bytes.Equal(unsealed, data) {
+		t.Fatal("The data returned from TPMTao.Unseal didn't match the original data")
+	}
+
+}
+
+func TestTPMTaoAttest(t *testing.T) {
+	tpmtao, err := NewTPMTao("/dev/tpm0", "./aikblob", []int{17, 18})
+	if err != nil {
+		t.Fatal("Couldn't create a new TPM Tao:", err)
+	}
+	tt, ok := tpmtao.(*TPMTao)
+	if !ok {
+		t.Fatal("Wrong type of tao returnd from NewTPMTao")
+	}
+	defer tt.Close()
+
+	// Set up a fake key delegation.
+	stmt := auth.Speaksfor{
+		Delegate: auth.Prin{Type: "key", Key: []byte(`FakeKeyBytes`)},
+	}
+
+	// Let the TPMTao set up the issuer and time and expiration.
+	a, err := tpmtao.Attest(nil, nil, nil, stmt)
+	if err != nil {
+		t.Fatal("Couldn't attest to a key delegation:", err)
+	}
+
+	says, err := a.Validate()
+	if err != nil {
+		t.Fatal("The attestation didn't pass validation:", err)
+	}
+
+	t.Logf("Got valid statement %s\n", says)
+}
