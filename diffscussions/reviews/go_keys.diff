#* 
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-07-15T16:12:29-0700
#* 
#- Ported keys to use native crypto for the signer and deleted the dependency on dkeyczar
#- 
#- 
#- Added some basic tests to the new Signer functionality
#- 
#- 
#- Fixed PrincipalName to match the C++ Tao
#- 
#- 
#- Fixed the remaining problems from the code review
#- 
#- 
#- Added Verifier, Crypter, and Deriver, along with tests for each
#- 
#- 
#**
#** author: Kevin Walsh
#** email: kwalsh@holycross.edu
#** date: 2014-07-16T14:19:13-0400
#**
#-- I'm only going to look at keys.go. The other files look fine on cursory
#-- glance.
#--
diff --git a/go/dkeyczar.patch b/go/dkeyczar.patch
deleted file mode 100644
index 088f560..0000000
--- a/go/dkeyczar.patch
+++ /dev/null
@@ -1,56 +0,0 @@
-diff --git a/keyman.go b/keyman.go
-index 2ce5535..406c435 100644
---- a/keyman.go
-+++ b/keyman.go
-@@ -36,6 +36,10 @@ func (m *keyManager) Create(name string, purpose keyPurpose, ktype keyType) erro
- 
- 	m.kz = &keyCzar{keyMeta{name, ktype, purpose, false, nil}, nil, nil, -1}
- 
-+	m.kz.keys = make(map[int]keydata)
-+	m.kz.idkeys = make(map[uint32][]keydata)
-+	m.kz.keymeta.Versions = make([]keyVersion, 0)
-+
- 	// check purpose vs ktype
- 	// complain if location/meta exists
- 	// write serialized km to location/meta
-diff --git a/readers.go b/readers.go
-index b7f7531..e3b2ed1 100644
---- a/readers.go
-+++ b/readers.go
-@@ -14,6 +14,7 @@ import (
- 	"io/ioutil"
- 	"os"
- 	"strconv"
-+
- 	"code.google.com/p/go.crypto/pbkdf2"
- )
- 
-@@ -482,3 +483,28 @@ func (r *importedDSAPrivateKeyReader) GetKey(version int) (string, error) {
- 	b, err := json.Marshal(r.dsajson)
- 	return string(b), err
- }
-+
-+func NewJSONKeyReader(JSON []string) KeyReader {
-+	return &JSONKeyReader{JSON[0], JSON[1:]}
-+}
-+
-+type JSONKeyReader struct {
-+	metaJSON string
-+	keysJSON []string
-+}
-+
-+func (j *JSONKeyReader) GetMetadata() (string, error) {
-+	return j.metaJSON, nil
-+}
-+
-+func (j *JSONKeyReader) GetKey(version int) (string, error) {
-+	if version <= 0 {
-+		return "", ErrNoSuchKeyVersion
-+	}
-+
-+	if version > len(j.keysJSON) {
-+		return "", ErrNoSuchKeyVersion
-+	}
-+
-+	return j.keysJSON[version-1], nil
-+}
diff --git a/go/src/cloudproxy/tao/attestation.pb.go b/go/src/cloudproxy/tao/attestation.pb.go
index 0e0eb7b..1381ebe 100644
--- a/go/src/cloudproxy/tao/attestation.pb.go
+++ b/go/src/cloudproxy/tao/attestation.pb.go
@@ -128,116 +128,116 @@ func (m *Statement) GetPredicateName() string {
 
 func (m *Statement) GetPredicateArgs() []string {
 	if m != nil {
 		return m.PredicateArgs
 	}
 	return nil
 }
 
 // An Attestation conveys:
 //   signer says statement
 // i.e.
 //   signer says (issuer says ((time <= now < exp) implies ...))
 // A valid Attestation encodes a public key within the signer name, and it
 // carries a signature that anyone can verify to (eventually) conclude:
 //   issuer says ((time' <= now < exp') implies ...)
 // Note: Because of time restrictions within attached delegations, the time
 // restriction (time' <= now < exp') here does not necessarily exactly
 // match the restriction (time <= now < exp) on the serialized statement.
 // If the modified time restriction is met, then we can derive the same
 // conclusion as we would for the included statement, i.e.:
-//   delgate speaksfor issuer               (for a delegation statement)
+//   delegate speaksfor issuer               (for a delegation statement)
 // or:
 //   issuer says pred(arg_1, ..., arg_n)    (for a predicate statement)
 // That is to say, a valid Attestation that meets its time restriction conveys
 // exactly the same meaning as the included statement conveys.
 //
 // There are two categories of Attestations:
 //
 // (1) In cases where issuer is a subprincipal of (or identical to) signer, no
 // delegation will be present. In these cases, signer speaksfor issuer, so from
 // the attestation:
 //   signer says (issuer says ...)
 // we can derive:
 //   issuer says (issuer says ...)
 // and further:
 //   issuer says ...
 //
 // Example of a category (1) attestation:
 //   Attestation = {
 //     statement = {
 //       issuer = K_aik::PCRs(...)
 //       ...
 //       delegate = K_os
 //     }
 //     signer = K_aik
 //     signature = ...
-//     delgation = null
+//     delegation = null
 //   }
 // Here, an OS has published a delegation statement establishing that key K_os
 // speaks for the OS, and this statement was signed by the TPM K_aik on behalf
 // of the OS. Note that the OS is a subprincipal of the TPM, so the TPM speaks
 // for the OS.
 //
 // (2) In all other cases, a delegation will be present that, if valid, conveys:
 //   issuer0 says ((time0 <= now < exp0) implies (delegate speaksfor issuer0))
 // where issuer is a subprincipal of (or identical to) issuer0 and delegate is a
 // subprincipal of (or identical to) signer. Such a valid
 // delegation can be combined with:
 //   signer says (
 //      issuer says (
 //         (time <= now < exp) implies ...))
 // to derive:
 //   issuer0 says (
 //     (time0 <= now < exp0) implies (issuer says (
 //        (time <= now < exp) implies ...)))
 // And because issuer0 speaks for issuer, we can further derive:
 //   issuer says ((time' <= now < exp') implies ...)
 // where time' = max(time, time0) and exp = min(exp, exp0).
 //
 // Example of a category (2) attestation:
 //   Attestation = {
 //     statement = {
 //       issuer = K_aik::PCRs(...)::Prog(...)
 //       ...
 //       delegate = K_app
 //     }
 //     signer = K_os
 //     signature = ...
-//     delgation = {
+//     delegation = {
 //       statement = {
 //         issuer = K_aik::PCRs(...)
 //         ...
 //         delegate = K_os
 //       }
 //       signer = K_aik
 //       signature = ...
-//       delgation = null
+//       delegation = null
 //     }
 //   }
 // Here, the OS identified by K_aik::PCRs(...) has signed, using a
 // seemingly unrelated key K_os, a statement on behalf of one of its hosted
-// programs, K_aik::PCRs(...)::Prog(...). The embeded delegation statement,
+// programs, K_aik::PCRs(...)::Prog(...). The embedded delegation statement,
 // signed by K_aik, binds that seemingly unrelated key K_os to the OS's actual
 // identity, K_aik::PCRs(...).
 //
-// Verifiying an attestion signature requires knowing how the signature was
+// Verifying an attestation signature requires knowing how the signature was
 // produced. We currently define two signature schemes:
 //
 // (a) Some signatures are produced by the TPM, so here we are bound by the
 // mechanisms implemented by the TPM. In this case, we encode the signer name as
 //   TPM("..K..") where "..K.." is the serialized, base64w-encoded public half
 // of the TPM's RSA key K. The TPM only ever signs things on behalf of its
 // hosted programs, so the issuer used in the serialized statement will always
 // have the form:
 //   TPM("..K..")::PCRs("..i..", "..h..")...
 // where "..i.." is a sorted, comma-separated list of PCR numbers, and "..h.."
 // is the corresponding, comma-separated list of hex-encoded PCR values. The
 // signature is computed roughly as:
 //   sig = rsa_sign(K, H( H(issuer|time|expiration|...) | pcrbuf(i, h) ))
 // Here, we first hash the statement in a tpm-specific way, then signing the
 // hash with RSA key K. To obtain the statement hash, first hash the serialized
 // statement, including  issuer, time, expiration and other information. This
 // intermediate hash is then re-hashed with a tpm-specific encoding of the PCR
 // numbers ("..i..") and values ("..h..") extracted from issuer.
 //
 // Note: The PCR values are effectively hashed twice, once as part of issuer, and
diff --git a/go/src/cloudproxy/tao/keys.go b/go/src/cloudproxy/tao/keys.go
index 2151a20..78eecf0 100644
--- a/go/src/cloudproxy/tao/keys.go
+++ b/go/src/cloudproxy/tao/keys.go
@@ -1,391 +1,803 @@
 //  Copyright (c) 2014, Google Inc.  All rights reserved.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
 // You may obtain a copy of the License at
 //
 //     http://www.apache.org/licenses/LICENSE-2.0
 //
 // Unless required by applicable law or agreed to in writing, software
 // distributed under the License is distributed on an "AS IS" BASIS,
 // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
 package tao
 
 import (
+	"crypto/aes"
+	"crypto/cipher"
+	"crypto/ecdsa"
+	"crypto/elliptic"
+	"crypto/hmac"
+	"crypto/rand"
+	"crypto/sha1"
+	"crypto/sha256"
 	"crypto/x509"
+	"crypto/x509/pkix"
+	"encoding/asn1"
+	"encoding/base64"
 	"errors"
-	"io/ioutil"
-	"os"
+	"math/big"
 	"path"
-	"strconv"
+	"strings"
+	"time"
 
+	"code.google.com/p/go.crypto/hkdf"
 	"code.google.com/p/goprotobuf/proto"
-	key "github.com/dgryski/dkeyczar"
 )
 
-var _ = key.NewKeyManager
-
 // A KeyType represent the type(s) of keys held by a Keys struct.
 type KeyType int
 
 const (
-	Signing     KeyType = 1 << iota
-	Crypting    KeyType = 1 << iota
-	KeyDeriving KeyType = 1 << iota
-	X509	    KeyType = 1 << iota
+	Signing KeyType = 1 << iota
+	Crypting
+	Deriving
 )
 
-// A Keys holds a set of Keyczar keys and provides an interface to perform
-// actions with these keys.
-type Keys struct {
-	nickname string
-	dir string
-	policy string
+const aesKeySize = 32 // 256-bit AES
+const deriverSecretSize = 32
+const hmacKeySize = 32 // SHA-256
 
-	signer key.Signer
-	crypter key.Crypter
-	verifer key.Verifier
-	keyDeriver key.Signer
-	delegation *Attestation
-	cert *x509.Certificate
+// A Signer is used to sign and verify signatures
+type Signer struct {
+	ec *ecdsa.PrivateKey
+}
+
+// A Verifier is used to verify signatures.
+type Verifier struct {
+	ec *ecdsa.PublicKey
 }
 
-// writeKeys writes the keys from a KeyManager to disk at kp (the key path). It
-// optionally uses an Encrypter to encrypt the keys on disk if enc is non-nil.
-func writeKeys(km key.KeyManager, enc key.Encrypter, kp string) error {
-	d := km.ToJSONs(enc)
+// A Crypter is used to encrypt and decrypt data.
+type Crypter struct {
+	aesKey  []byte
+	hmacKey []byte
+}
+
+// A Deriver is used to derive key material from a context using HKDF.
+type Deriver struct {
+	secret []byte
+}
+
+// GenerateSigner creates a new Signer with a fresh key.
+func GenerateSigner() (*Signer, error) {
+	ec, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)
+	if err != nil {
+		return nil, err
+	}
+
+	return &Signer{ec}, nil
+}
 
+// ToPrincipalName produces a plain-text Tao principal name. This is a
+// base64w-encoded version of a serialized CryptoKey for the public half of
+// this signing key.
+func (s *Signer) ToPrincipalName() (string, error) {
+	var ck *CryptoKey
 	var err error
-	if err = os.MkdirAll(kp, 0700); err != nil {
-		return err
+	if ck, err = MarshalPublicSignerProto(s); err != nil {
+		return "", nil
 	}
 
-	for i, s := range d {
-		// The first JSON string is the meta file, and the rest are
-		// keys.
-		if i == 0 {
-			if err = ioutil.WriteFile(path.Join(kp, "meta"), []byte(s), 0600); err != nil {
-				return err
-			}
-		} else {
-			keyNum := strconv.FormatInt(int64(i), 10)
-			if err = ioutil.WriteFile(path.Join(kp, keyNum), []byte(s), 0600); err != nil {
-				return err
-			}
-		}
+	data, err := proto.Marshal(ck)
+	if err != nil {
+		return "", err
 	}
 
-	return nil
+	return "Key(" + base64.URLEncoding.EncodeToString(data) + ")", nil
 }
 
-// instantiateKey creates a Keyczar key of a given type, with an optional path,
-// a name, and an optional crypter for encrypting or decrypting the key. It
-// would be better to take the keyPurpose and keyType directly, but those types
-// aren't exported from dkeyczar.
-func (k *Keys) instantiateKey(keyType KeyType, keyPath, name string, crypter key.Crypter) error {
-	var r key.KeyReader
+// MarshalSigner serializes the signer to PEM.
+func MarshalSignerPEM(s *Signer) ([]byte, error) {
+	return x509.MarshalECPrivateKey(s.ec)
+}
+
+// ParseSigner deserializes a Signer from PEM.
+func ParseSignerPEM(signer []byte) (*Signer, error) {
+	k := new(Signer)
 	var err error
-	if _, err = os.Stat(keyPath); !os.IsNotExist(err) {
-		if crypter != nil {
-			fr := key.NewFileReader(keyPath)
-			r = key.NewEncryptedReader(fr, crypter)
-		} else {
-			r = key.NewFileReader(keyPath)
-		}
-	} else {
-		km := key.NewKeyManager()
-		var size uint
-		if keyType == Signing {
-			err = km.Create(name, key.P_SIGN_AND_VERIFY, key.T_RSA_PRIV)
-			size = 2048
-		} else if keyType == Crypting {
-			err = km.Create(name, key.P_DECRYPT_AND_ENCRYPT, key.T_AES)
-			size = 256
-		} else if keyType == KeyDeriving {
-			err = km.Create(name, key.P_SIGN_AND_VERIFY, key.T_HMAC_SHA1)
-			size = 256
-		} else {
-			return errors.New("Invalid Tao Keys type")
-		}
-
-		if err != nil {
-			return err
-		}
-
-		if err = km.AddKey(size, key.S_PRIMARY); err != nil {
-			return err
-		}
-
-		r = key.NewJSONKeyReader(km.ToJSONs(nil))
-		if keyPath != "" {
-			if err = writeKeys(km, crypter, keyPath); err != nil {
-				return err
-			}
-		}
-	}
-
-	if keyType == Signing {
-		k.signer, err = key.NewSigner(r)
-	} else if keyType == Crypting {
-		k.crypter, err = key.NewCrypter(r)
-	} else if keyType == KeyDeriving {
-		k.keyDeriver, err = key.NewSigner(r)
-	} else {
-		err = errors.New("Invalid Tao Key type")
+	if k.ec, err = x509.ParseECPrivateKey(signer); err != nil {
+		return nil, err
 	}
 
-	return err
+	return k, nil
 }
 
-// SignerPath returns the path to the signing keys, if any.
-func (k *Keys) SignerPath() string {
-	if k.dir == "" {
-		return ""
-	} else {
-		return path.Join(k.dir, "signer")
+// prepareX509Template parses the protobuf containing subject-name details and
+// fills out an X.509 template for use in x509.CreateCertificate.
+func prepareX509Template(detailsText string) (*x509.Certificate, error) {
+	details := new(X509Details)
+	if err := proto.UnmarshalText(detailsText, details); err != nil {
+		return nil, err
+	}
+
+	template := &x509.Certificate{
+		SignatureAlgorithm: x509.ECDSAWithSHA256,
+		PublicKeyAlgorithm: x509.ECDSA,
+		Version:            2, // x509v3
+		// It's always allowed for self-signed certs to have serial 1.
+		SerialNumber: new(big.Int).SetInt64(1),
+		Subject: pkix.Name{
+			Country:      []string{string(details.Country)},
+			Organization: []string{string(details.Organization)},
+			Province:     []string{string(details.State)},
+			CommonName:   string(details.Commonname),
+		},
+		NotBefore: time.Now(),
+		NotAfter:  time.Now().AddDate(1 /* years */, 0 /* months */, 0 /* days */),
+		// TODO(tmroeder): I'm not sure which of these I need to make
+		// OpenSSL happy.
+		KeyUsage:    x509.KeyUsageKeyAgreement | x509.KeyUsageCertSign,
+		ExtKeyUsage: []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth, x509.ExtKeyUsageClientAuth},
+	}
+
+	return template, nil
+}
+
+// CreateSelfSignedX509 creates a self-signed X.509 certificate for the public
+// key of this Signer.
+func (s *Signer) CreateSelfSignedX509(detailsText string) ([]byte, error) {
+	template, err := prepareX509Template(detailsText)
+	if err != nil {
+		return nil, err
 	}
+
+	template.IsCA = true
+	template.Issuer = template.Subject
+
+	return x509.CreateCertificate(rand.Reader, template, template, &s.ec.PublicKey, s.ec)
 }
 
-// SignerName returns a user-readable name of the signing key.
-func (k *Keys) SignerName() string {
-	return k.nickname + "_signer"
+// CreateSignedX509 creates a signed X.509 certificate for some other subject's
+// key.
+func (s *Signer) CreateSignedX509(CAPEMCert []byte, certSerial int, subjectKey *Verifier, subjectDetails string) ([]byte, error) {
+	signerCert, err := x509.ParseCertificate(CAPEMCert)
+	if err != nil {
+		return nil, err
+	}
+
+	template, err := prepareX509Template(subjectDetails)
+	if err != nil {
+		return nil, err
+	}
+
+	return x509.CreateCertificate(rand.Reader, template, signerCert, subjectKey.ec, s.ec)
 }
 
-// CrypterPath returns the path to the encryption key, if any.
-func (k *Keys) CrypterPath() string {
-	if k.dir == "" {
-		return ""
-	} else {
-		return path.Join(k.dir, "crypter")
+// marshalECDSA_SHA_SigningKeyV1 encodes a private key as a protobuf message.
+func marshalECDSA_SHA_SigningKeyV1(k *ecdsa.PrivateKey) *ECDSA_SHA_SigningKeyV1 {
+	return &ECDSA_SHA_SigningKeyV1{
+		Curve:     NamedEllipticCurve_PRIME256_V1.Enum(),
+		EcPrivate: k.D.Bytes(),
+		EcPublic:  elliptic.Marshal(k.Curve, k.X, k.Y),
 	}
+
 }
 
-// CrypterName returns a user-readable name for the encryption key.
-func (k *Keys) CrypterName() string {
-	return k.nickname + "_crypter"
+// MarshalSignerProto encodes a signing key as a CryptoKey protobuf message.
+func MarshalSignerProto(s *Signer) (*CryptoKey, error) {
+	m := marshalECDSA_SHA_SigningKeyV1(s.ec)
+	defer zeroBytes(m.EcPrivate)
+
+	b, err := proto.Marshal(m)
+	if err != nil {
+		return nil, err
+	}
+
+	ck := &CryptoKey{
+		Version:   CryptoVersion_CRYPTO_VERSION_1.Enum(),
+		Purpose:   CryptoKey_SIGNING.Enum(),
+		Algorithm: CryptoKey_ECDSA_SHA.Enum(),
+		Key:       b}
+	return ck, nil
 }
 
-// KeyDeriverPath returns the path to the key-deriving key, if any.
-func (k *Keys) KeyDeriverPath() string {
-	if k.dir == "" {
-		return ""
-	} else {
-		return path.Join(k.dir, "key_deriver")
+// marshalECDSA_SHA_VerifyingKeyV1 encodes a public key as a protobuf message.
+func marshalECDSA_SHA_VerifyingKeyV1(k *ecdsa.PublicKey) *ECDSA_SHA_VerifyingKeyV1 {
+	return &ECDSA_SHA_VerifyingKeyV1{
+		Curve:    NamedEllipticCurve_PRIME256_V1.Enum(),
+		EcPublic: elliptic.Marshal(k.Curve, k.X, k.Y),
 	}
+
 }
 
-// KeyDeriverName returns a user-readable name for the key-deriving key.
-func (k *Keys) KeyDeriverName() string {
-	return k.nickname + "_key_deriver"
+func unmarshalECDSA_SHA_VerifyingKeyV1(v *ECDSA_SHA_VerifyingKeyV1) (*ecdsa.PublicKey, error) {
+	if *v.Curve != NamedEllipticCurve_PRIME256_V1 {
+		return nil, errors.New("Bad Curve")
+	}
+
+	x, y := elliptic.Unmarshal(elliptic.P256(), v.EcPublic)
+	return &ecdsa.PublicKey{elliptic.P256(), x, y}, nil
 }
 
-// TaoSecretPath returns the path to a Tao-sealed secret, if any. This secret
-// is used to create a PBEEncrypter to encrypt generated keys.
-func (k *Keys) TaoSecretPath() string {
-	if k.dir == "" {
-		return ""
-	} else {
-		return path.Join(k.dir, "secret")
+func marshalPublicKeyProto(k *ecdsa.PublicKey) (*CryptoKey, error) {
+	m := marshalECDSA_SHA_VerifyingKeyV1(k)
+
+	b, err := proto.Marshal(m)
+	if err != nil {
+		return nil, err
+	}
+
+	ck := &CryptoKey{
+		Version:   CryptoVersion_CRYPTO_VERSION_1.Enum(),
+		Purpose:   CryptoKey_VERIFYING.Enum(),
+		Algorithm: CryptoKey_ECDSA_SHA.Enum(),
+		Key:       b,
 	}
+
+	return ck, nil
+}
+
+// MarshalPublicSignerProto encodes the public half of a signing key as a
+// CryptoKey protobuf message.
+func MarshalPublicSignerProto(s *Signer) (*CryptoKey, error) {
+	return marshalPublicKeyProto(&s.ec.PublicKey)
 }
#*
#* author: Kevin Walsh
#* email: kwalsh@holycross.edu
#* date: 2014-07-16T14:25:39-0400
#*
#- Curious: Why isn't the above a member, like this...
#- func (s *Signer) MarshalPublicProto() (*CryptoKey, error) { ... }
#-
#- I could ask the same of many of the single-argument functions here, e.g.
#- func (k *ecdsa.PublicKey) marshalProto() (*CryptoKey, error) { ... }
#- (where this takes advantage of go's ability to add methods to existing types)
#- 
#- In C++, those things are non-member functions because I didn't want them in
#- the #- header files.
 
-// instantiate creates multiple keys as specified by the bits of keyTypes. It
-// encrypts them with the crypter, if it's non-nil.
-func (k *Keys) instantiate(keyTypes KeyType, crypter key.Crypter) error {
-	if keyTypes & Signing == Signing {
-		if err := k.instantiateKey(Signing, k.SignerPath(), k.SignerName(), crypter); err != nil {
-			return err
-		}
+// MarshalVerifierProto encodes the public verifier key as a CryptoKey protobuf
+// message.
+func MarshalVerifierProto(v *Verifier) (*CryptoKey, error) {
+	return marshalPublicKeyProto(v.ec)
+}
+
+// UnmarshalSignerProto decodes a signing key from a CryptoKey protobuf
+// message.
+func UnmarshalSignerProto(ck *CryptoKey) (*Signer, error) {
+	if *ck.Version != CryptoVersion_CRYPTO_VERSION_1 {
+		return nil, errors.New("Bad version")
 	}
 
-	if keyTypes & Crypting == Crypting {
-		if err := k.instantiateKey(Crypting, k.CrypterPath(), k.CrypterName(), crypter); err != nil {
-			return err
-		}
+	if *ck.Purpose != CryptoKey_SIGNING {
+		return nil, errors.New("Bad purpose")
 	}
 
-	if keyTypes & KeyDeriving == KeyDeriving {
-		if err := k.instantiateKey(KeyDeriving, k.KeyDeriverPath(), k.KeyDeriverName(), crypter); err != nil {
-			return err
-		}
+	if *ck.Algorithm != CryptoKey_ECDSA_SHA {
+		return nil, errors.New("Bad algorithm")
 	}
 
-	return nil
+	k := new(ECDSA_SHA_SigningKeyV1)
+	defer zeroBytes(k.EcPrivate)
+	if err := proto.Unmarshal(ck.Key, k); err != nil {
+		return nil, err
+	}
+
+	if *k.Curve != NamedEllipticCurve_PRIME256_V1 {
+		return nil, errors.New("Bad Curve")
+	}
+
+	s := new(Signer)
+	s.ec = new(ecdsa.PrivateKey)
+	s.ec.D = new(big.Int).SetBytes(k.EcPrivate)
+	s.ec.Curve = elliptic.P256()
+	s.ec.X, s.ec.Y = elliptic.Unmarshal(elliptic.P256(), k.EcPublic)
+	return s, nil
 }
 
-// NewTempKeys creates a new set of temporary keys with a given type. These
-// keys are not written to disk.
-func NewTempKeys(nickname string, keyTypes KeyType) *Keys {
-	// For temp keys, there aren't any paths, so the keys aren't written to disk.
-	k := &Keys{
-		nickname: nickname,
+// FillHeader encodes the version and a key hint into a CryptoHeader.
+func (s *Signer) CreateHeader() (*CryptoHeader, error) {
+	k := marshalECDSA_SHA_VerifyingKeyV1(&s.ec.PublicKey)
+	b, err := proto.Marshal(k)
+	if err != nil {
+		return nil, err
 	}
 
-	if err := k.instantiate(keyTypes, nil); err != nil {
-		return nil
+	h := sha1.Sum(b)
+	ch := &CryptoHeader{
+		Version: CryptoVersion_CRYPTO_VERSION_1.Enum(),
+		KeyHint: h[:4],
 	}
 
-	return k
+	return ch, nil
+}
+
+// GetECDSAKey returns the private ECDSA key for this signer.
+func (s *Signer) getECDSAKey() *ecdsa.PrivateKey {
+	return s.ec
+}
#*
#* author: Kevin Walsh
#* email: kwalsh@holycross.edu
#* date: 2014-07-16T14:36:55-0400
#*
#- Is getECDSAKey() used anywhere? I don't see where...
#-
+
+// This is copied from the Go crypto/x509 source: it just uses a simple
+// two-element structure to marshal a DSA signature as ASN.1 in an X.509
+// certificate.
+type ecdsaSignature struct {
+	R, S *big.Int
 }
 
-// NewTempHostedKeys creates a new set of temporary keys hosted by a given Tao,
-// often the SoftTao in a test case. These keys are encrypted by the Tao-sealed
-// secret but are not written to disk.
-func NewTempHostedKeys(nickname string, keyTypes KeyType, tao Tao) *Keys {
-	// For temp keys, there aren't any paths, so the keys aren't written to disk.
-	k := &Keys{
-		nickname: nickname,
+// Sign computes an ECDSA sigature over the contextualized data, using the
+// private key of the signer.
+func (s *Signer) Sign(data []byte, context string) ([]byte, error) {
+	ch, err := s.CreateHeader()
+	if err != nil {
+		return nil, err
 	}
 
-	var err error
-	if err = k.instantiate(keyTypes, nil); err != nil {
-		return nil
+	// TODO(tmroeder): for compatibility with the C++ version, we should
+	// compute ECDSA signatures over hashes truncated to fit in the ECDSA
+	// signature.
+	b, err := contextualizedSHA256(ch, data, context, sha256.Size)
+	if err != nil {
+		return nil, err
+	}
+
+	R, S, err := ecdsa.Sign(rand.Reader, s.ec, b)
+	if err != nil {
+		return nil, err
 	}
 
-	s := &Statement{
-		Issuer: proto.String("soft_tao"),
+	m, err := asn1.Marshal(ecdsaSignature{R, S})
+	if err != nil {
+		return nil, err
#*
#* author: Kevin Walsh
#* email: kwalsh@holycross.edu
#* date: 2014-07-16T14:37:34-0400
#*
#- This asn1 code is pretty amazing. Does it work? Is it compatible with
#- openssl? From what I recall, marshalling asn.1 correctly requires a lot of
#- fussing with asn.1 templates because there are so many variations of how
#- things can get encoded.
#-
 	}
 
-	if k.delegation, err = tao.Attest(s); err != nil {
-		return nil
+	sd := &SignedData{
+		Header:    ch,
+		Signature: m,
 	}
 
-	return k
+	return proto.Marshal(sd)
 }
 
-// NewNonHostedKeys creates or restores a set of keys encrypted by PBE under a
-// password and stored under a directory dir.
-func NewNonHostedKeys(dir, password, nickname string, keyTypes KeyType) *Keys {
-	k := &Keys{
-		nickname: nickname,
-		dir: dir,
+// Verify checks an ECDSA signature over the contextualized data, using the
+// public key of the verifier.
+func (v *Verifier) Verify(data []byte, context string, sig []byte) (bool, error) {
+	// Deserialize the data and extract the CryptoHeader.
+	var sd SignedData
+	if err := proto.Unmarshal(sig, &sd); err != nil {
+		return false, err
+	}
+
+	var ecSig ecdsaSignature
+	// TODO(tmroeder): in what contexts can asn1.Unmarshal return data in
+	// its first parameter?
+	if _, err := asn1.Unmarshal(sd.Signature, &ecSig); err != nil {
+		return false, err
+	}
+
+	b, err := contextualizedSHA256(sd.Header, data, context, sha256.Size)
+	if err != nil {
+		return false, err
 	}
 
-	pbe := key.NewPBECrypter([]byte(password))
+	return ecdsa.Verify(v.ec, b, ecSig.R, ecSig.S), nil
+}
+
+// ToPrincipalName produces a plain-text Tao principal name. This is a
+// base64w-encoded version of a serialized CryptoKey for the public half of
+// this verifying key.
+func (v *Verifier) ToPrincipalName() (string, error) {
+	var ck *CryptoKey
 	var err error
-	if err = k.instantiate(keyTypes, pbe); err != nil {
-		return nil
+	if ck, err = MarshalVerifierProto(v); err != nil {
+		return "", nil
+	}
+
+	data, err := proto.Marshal(ck)
+	if err != nil {
+		return "", err
 	}
 
-	return k
+	return "Key(" + base64.URLEncoding.EncodeToString(data) + ")", nil
 }
 
-// zeroBytes clears the bytes in a slice.
-func zeroBytes(b []byte) {
-	for i := range b {
-		b[i] = 0
+// FromPrincipalName deserializes a Verifier from a plaintext Tao principal
+// name.
+func FromPrincipalName(name string) (*Verifier, error) {
+	// Check to make sure the key starts with "Key(" and ends with ")".
+	if !strings.HasPrefix(name, "Key(") || !strings.HasSuffix(name, ")") {
+		return nil, errors.New("Invalid prefix or suffix")
+	}
+
+	ks := strings.TrimPrefix(strings.TrimSuffix(name, ")"), "Key(")
+
#*
#* author: Kevin Walsh
#* email: kwalsh@holycross.edu
#* date: 2014-07-16T14:39:45-0400
#*
#- Do you need to get rid of the doublquotes too? We add 6+2 chars when
#- encoding, but you only drop 4+1 chars here.
#-
+	b, err := base64.URLEncoding.DecodeString(ks)
+	if err != nil {
+		return nil, err
+	}
+
+	var ck CryptoKey
+	if err := proto.Unmarshal(b, &ck); err != nil {
+		return nil, err
+	}
+
+	if *ck.Version != CryptoVersion_CRYPTO_VERSION_1 {
+		return nil, errors.New("Bad version")
+	}
+
+	if *ck.Purpose != CryptoKey_VERIFYING {
+		return nil, errors.New("Bad Purpose")
+	}
+
+	if *ck.Algorithm != CryptoKey_ECDSA_SHA {
+		return nil, errors.New("Bad Algorithm")
+	}
+
+	var ecvk ECDSA_SHA_VerifyingKeyV1
+	if err := proto.Unmarshal(ck.Key, &ecvk); err != nil {
+		return nil, err
+	}
+
+	ec, err := unmarshalECDSA_SHA_VerifyingKeyV1(&ecvk)
+	if err != nil {
+		return nil, err
+	}
+
+	return &Verifier{ec}, nil
+}
+
+// FromX509 creates a Verifier from an X509 certificate.
+func FromX509(cert []byte) (*Verifier, error) {
+	c, err := x509.ParseCertificate(cert)
+	if err != nil {
+		return nil, err
 	}
+
+	return &Verifier{c.PublicKey.(*ecdsa.PublicKey)}, nil
#*
#* author: Kevin Walsh
#* email: kwalsh@holycross.edu
#* date: 2014-07-16T14:41:05-0400
#*
#- Does this need error checking? What if the x509 has an rsa key... will it
#- panic?
#-
 }
 
-// secretLength is the length of any Tao-sealed secret.
-var secretLength int = 128
+// UnmarshalVerifierProto decodes a verifying key from a CryptoKey protobuf
+// message.
+func UnmarshalVerifierProto(ck *CryptoKey) (*Verifier, error) {
+	if *ck.Version != CryptoVersion_CRYPTO_VERSION_1 {
+		return nil, errors.New("Bad version")
+	}
 
-// newTaoPBECrypter uses the Tao to unseal or to generate and seal a new
-// secret; it then uses this secret to create a PBEEncrypter.
-func (k *Keys) newTaoPBECrypter(tao Tao) (key.Crypter, error) {
-	// Create or read the secret, using the Tao.
-	secretPath := k.TaoSecretPath()
-	var err error
-	var sec []byte
-	if _, err = os.Stat(secretPath); !os.IsNotExist(err) {
-		sec = make([]byte, secretLength)
-		if err = tao.GetRandomBytes(sec); err != nil {
-			return nil, err
-		}
-		defer zeroBytes(sec)
-
-		sealed, err := tao.Seal(sec, []byte(k.policy))
-		if err != nil {
-			return nil, err
-		}
-
-		// Only write to a path if there is a path to write at all.
-		if secretPath != "" {
-			if err = ioutil.WriteFile(secretPath, sealed, 0600); err != nil {
-				return nil, err
-			}
-		}
+	if *ck.Purpose != CryptoKey_VERIFYING {
+		return nil, errors.New("Bad purpose")
+	}
 
-	} else {
-		sealed, err := ioutil.ReadFile(secretPath)
-		if err != nil {
-			return nil, err
-		}
+	if *ck.Algorithm != CryptoKey_ECDSA_SHA {
+		return nil, errors.New("Bad algorithm")
+	}
 
-		if sec, _, err = tao.Unseal(sealed); err != nil {
-			return nil, err
-		}
-		defer zeroBytes(sec)
+	k := new(ECDSA_SHA_VerifyingKeyV1)
+	if err := proto.Unmarshal(ck.Key, k); err != nil {
+		return nil, err
 	}
 
-	return key.NewPBECrypter(sec), nil
+	if *k.Curve != NamedEllipticCurve_PRIME256_V1 {
+		return nil, errors.New("Bad curve")
+	}
+
+	s := new(Verifier)
+	s.ec = new(ecdsa.PublicKey)
+	s.ec.Curve = elliptic.P256()
+	s.ec.X, s.ec.Y = elliptic.Unmarshal(elliptic.P256(), k.EcPublic)
+	return s, nil
 }
 
-// NewHostedKeys creates or restores a set of keys encrypted using PBE from a
-// Tao-sealed secret. The sealing operation uses the given policy.
-func NewHostedKeys(dir, policy, nickname string, keyTypes KeyType, tao Tao) *Keys {
-	k := &Keys{
-		nickname: nickname,
-		dir: dir,
+// CreateHeader instantiates and fills in a header for this verifying key.
+func (v *Verifier) CreateHeader() (*CryptoHeader, error) {
+	k := marshalECDSA_SHA_VerifyingKeyV1(v.ec)
+	b, err := proto.Marshal(k)
+	if err != nil {
+		return nil, err
+	}
+
+	h := sha1.Sum(b)
+	ch := &CryptoHeader{
+		Version: CryptoVersion_CRYPTO_VERSION_1.Enum(),
+		KeyHint: h[:4],
 	}
 
-	pbe, err := k.newTaoPBECrypter(tao)
+	return ch, nil
+}
+
+// contextualizeData produces a single string from a header, data, and a context.
+func contextualizeData(h *CryptoHeader, data []byte, context string) ([]byte, error) {
+	s := &SignaturePDU{
+		Header:  h,
+		Context: proto.String(context),
+		Data:    data,
+	}
+
+	return proto.Marshal(s)
+}
+
+// contextualizedSHA256 performs a SHA-256 sum over contextualized data.
+func contextualizedSHA256(h *CryptoHeader, data []byte, context string, digestLen int) ([]byte, error) {
+	b, err := contextualizeData(h, data, context)
 	if err != nil {
-		return nil
+		return nil, err
 	}
 
-	if err = k.instantiate(keyTypes, pbe); err != nil {
-		return nil
+	hash := sha256.Sum256(b)
+	return hash[:digestLen], nil
+}
+
+// GetECDSAKey returns the public ECDSA key for this verifier.
+func (v *Verifier) getECDSAKey() *ecdsa.PublicKey {
+	return v.ec
+}
+
+// GenerateCrypter instantiates a new Crypter with fresh keys.
+func GenerateCrypter() (*Crypter, error) {
+	c := &Crypter{
+		aesKey:  make([]byte, aesKeySize),
+		hmacKey: make([]byte, hmacKeySize),
 	}
 
-	s := &Statement{
-		Issuer: proto.String("soft_tao"),
+	if _, err := rand.Read(c.aesKey); err != nil {
+		return nil, err
 	}
 
-	if k.delegation, err = tao.Attest(s); err != nil {
-		return nil
+	if _, err := rand.Read(c.hmacKey); err != nil {
+		return nil, err
 	}
 
-	return k
+	return c, nil
 }
 
-// Sign signs a message with a given context and returns the signature.
-func (k *Keys) Sign(msg, context []byte) (string, error) {
-	if k.signer == nil {
-		return "", errors.New("No signer available")
+// Encrypt encrypts plaintext into ciphertext and protects ciphertext integrity
+// with a MAC.
+func (c *Crypter) Encrypt(data []byte) ([]byte, error) {
+	block, err := aes.NewCipher(c.aesKey)
+	if err != nil {
+		return nil, err
 	}
 
-	sd := &SignedData{
-		Context: proto.String(string(context)),
-		Data: msg,
+	ch, err := c.CreateHeader()
+	if err != nil {
+		return nil, err
+	}
+
+	// A ciphertext consists of an IV, encrypted bytes, and the output of
+	// HMAC-SHA256.
+	ciphertext := make([]byte, aes.BlockSize+len(data))
+	iv := ciphertext[:aes.BlockSize]
+	if _, err := rand.Read(iv); err != nil {
+		return nil, err
+	}
+
+	s := cipher.NewCTR(block, iv)
+	s.XORKeyStream(ciphertext[aes.BlockSize:], data)
+
+	mac := hmac.New(sha256.New, c.hmacKey)
+	m := mac.Sum(ciphertext)
+
+	ed := &EncryptedData{
+		Header:     ch,
+		Iv:         iv,
+		Ciphertext: ciphertext[aes.BlockSize:],
+		Mac:        m,
+	}
+
+	return proto.Marshal(ed)
+}
+
+// Decrypt checks the MAC then decrypts ciphertext into plaintext.
+func (c *Crypter) Decrypt(ciphertext []byte) ([]byte, error) {
+	var ed EncryptedData
+	if err := proto.Unmarshal(ciphertext, &ed); err != nil {
+		return nil, err
+	}
+
+	// TODO(tmroeder): we're currently mostly ignoring the CryptoHeader,
+	// since we only have one key.
+	if *ed.Header.Version != CryptoVersion_CRYPTO_VERSION_1 {
+		return nil, errors.New("Bad version")
+	}
+
+	// Check the HMAC before touching the ciphertext.
+	fullCiphertext := make([]byte, len(ed.Iv)+len(ed.Ciphertext))
+	copy(fullCiphertext, ed.Iv)
+	copy(fullCiphertext[len(ed.Iv):], ed.Ciphertext)
+
+	mac := hmac.New(sha256.New, c.hmacKey)
+	m := mac.Sum(fullCiphertext)
+	if !hmac.Equal(m, ed.Mac) {
+		return nil, errors.New("Bad HMAC")
 	}
 
-	s, err := proto.Marshal(sd)
+	block, err := aes.NewCipher(c.aesKey)
 	if err != nil {
-		return "", err
+		return nil, err
 	}
 
-	return k.signer.Sign(s)
+	s := cipher.NewCTR(block, ed.Iv)
+	data := make([]byte, len(ed.Ciphertext))
+	s.XORKeyStream(data, ed.Ciphertext)
+	return data, nil
 }
 
-// Verify verifies a signature for a message with a given context.
-func (k *Keys) Verify(msg, context, signature []byte) (bool, error) {
-	if k.signer == nil {
-		return false, errors.New("No signer available")
+// marshalAES_CTR_HMAC_SHA_CryptingKeyV1 encodes a private AES/HMAC key pair
+// into a protobuf message.
+func marshalAES_CTR_HMAC_SHA_CryptingKeyV1(c *Crypter) *AES_CTR_HMAC_SHA_CryptingKeyV1 {
+	return &AES_CTR_HMAC_SHA_CryptingKeyV1{
+		Mode:        CryptoCipherMode_CIPHER_MODE_CTR.Enum(),
+		AesPrivate:  c.aesKey,
+		HmacPrivate: c.hmacKey,
 	}
+}
 
-	sd := &SignedData{
-		Context: proto.String(string(context)),
-		Data: msg,
+// MarshalCrypterProto encodes a Crypter as a CryptoKey protobuf message.
+func MarshalCrypterProto(c *Crypter) (*CryptoKey, error) {
+	k := marshalAES_CTR_HMAC_SHA_CryptingKeyV1(c)
+
+	// Note that we don't need to call zeroBytes on k.AesPrivate or
+	// k.HmacPrivate, since they're just slice references to the underlying
+	// keys.
+	m, err := proto.Marshal(k)
+	if err != nil {
+		return nil, err
+	}
+
+	ck := &CryptoKey{
+		Version:   CryptoVersion_CRYPTO_VERSION_1.Enum(),
+		Purpose:   CryptoKey_CRYPTING.Enum(),
+		Algorithm: CryptoKey_AES_CTR_HMAC_SHA.Enum(),
+		Key:       m,
+	}
+
+	return ck, nil
+}
+
+// UnmarshalCrypterProto decodes a crypting key from a CryptoKey protobuf
+// message.
+func UnmarshalCrypterProto(ck *CryptoKey) (*Crypter, error) {
+	if *ck.Version != CryptoVersion_CRYPTO_VERSION_1 {
+		return nil, errors.New("Bad version")
+	}
+
+	if *ck.Purpose != CryptoKey_CRYPTING {
+		return nil, errors.New("Bad purpose")
+	}
+
+	if *ck.Algorithm != CryptoKey_AES_CTR_HMAC_SHA {
+		return nil, errors.New("Bad algorithm")
+	}
+
+	var k AES_CTR_HMAC_SHA_CryptingKeyV1
+	if err := proto.Unmarshal(ck.Key, &k); err != nil {
+		return nil, err
+	}
+
+	if *k.Mode != CryptoCipherMode_CIPHER_MODE_CTR {
+		return nil, errors.New("Bad cipher mode")
+	}
+
+	c := new(Crypter)
+	c.aesKey = k.AesPrivate
+	c.hmacKey = k.HmacPrivate
+	return c, nil
+}
+
+// CreateHeader instantiates and fills in a header for this crypting key.
+func (c *Crypter) CreateHeader() (*CryptoHeader, error) {
+	k := marshalAES_CTR_HMAC_SHA_CryptingKeyV1(c)
+	b, err := proto.Marshal(k)
+	if err != nil {
+		return nil, err
+	}
+	defer zeroBytes(b)
+
+	h := sha1.Sum(b)
+	ch := &CryptoHeader{
+		Version: CryptoVersion_CRYPTO_VERSION_1.Enum(),
+		KeyHint: h[:4],
+	}
+
+	return ch, nil
+
+}
+
+// GenerateDeriver generates a deriver with a fresh secret.
+func GenerateDeriver() (*Deriver, error) {
+	d := new(Deriver)
+	d.secret = make([]byte, deriverSecretSize)
+	if _, err := rand.Read(d.secret); err != nil {
+		return nil, err
+	}
+
+	return d, nil
+}
+
+// Derive uses HKDF with HMAC-SHA256 to derive key bytes in its material
+// parameter.
+func (d *Deriver) Derive(salt, context, material []byte) error {
+	f := hkdf.New(sha256.New, d.secret, salt, context)
+	if _, err := f.Read(material); err != nil {
+		return err
 	}
 
-	s, err := proto.Marshal(sd)
+	return nil
+}
#*
#* author: Kevin Walsh
#* email: kwalsh@holycross.edu
#* date: 2014-07-16T14:47:06-0400
#*
#- Some potential issues with Derive() above. 
#- (1) go hkdf.New uses 2-stage extract-then-expand. C++ uses only expand since
#- input secret is already strong random (not a passwd) and of correct size.
#- (2) The C++ API does not include salt as a parameter. Salt is used only for
#- the extract stage, so it wasn't needed. Where will go salt come from?
#- (3) go hkdf uses sweet array packing code to create the buffers that are
#- signed when generating bytes. My C++ used protobuf for the array packing.
#- Here, the go code is more conformant with the RFCs.
#-
#- All this means is that go code will generate different secrets than C++ code.
#- However, I think in this case it is probably fine. The one place this is
#- being used right now is for children to call their host tao to get
#- deterministic but random bytes. In that case, the host tao will never change
#- from C++ to go, and no two host Taos will ever have the same key material.
#- OTOH, if two communicating apps (one in C++, one in go) establish a shared
#- secret, they might want to be able to use the Deriver interface
#- to generate secrets.
+
+// marshalHMAC_SHA_DerivingKeyV1 encodes a deriving key as a protobuf message.
+func marshalHMAC_SHA_DerivingKeyV1(d *Deriver) *HMAC_SHA_DerivingKeyV1 {
+	return &HMAC_SHA_DerivingKeyV1{
+		Mode:        CryptoDerivingMode_DERIVING_MODE_HKDF.Enum(),
+		HmacPrivate: d.secret,
+	}
+}
+
+// MarshalDeriverProto encodes a Deriver as a CryptoKey protobuf message.
+func MarshalDeriverProto(d *Deriver) (*CryptoKey, error) {
+	k := marshalHMAC_SHA_DerivingKeyV1(d)
+
+	// Note that we don't need to call zeroBytes on k.HmacPrivate since
+	// it's just a slice reference to the underlying keys.
+	m, err := proto.Marshal(k)
 	if err != nil {
-		return false, err
+		return nil, err
+	}
+
+	ck := &CryptoKey{
+		Version:   CryptoVersion_CRYPTO_VERSION_1.Enum(),
+		Purpose:   CryptoKey_DERIVING.Enum(),
+		Algorithm: CryptoKey_HMAC_SHA.Enum(),
+		Key:       m,
+	}
+
+	return ck, nil
+}
+
+// UnmarshalDeriverProto decodes a deriving key from a CryptoKey protobuf
+// message.
+func UnmarshalDeriverProto(ck *CryptoKey) (*Deriver, error) {
+	if *ck.Version != CryptoVersion_CRYPTO_VERSION_1 {
+		return nil, errors.New("Bad version")
+	}
+
+	if *ck.Purpose != CryptoKey_DERIVING {
+		return nil, errors.New("Bad purpose")
 	}
 
-	return k.signer.Verify(s, string(signature))
+	if *ck.Algorithm != CryptoKey_HMAC_SHA {
+		return nil, errors.New("Bad algorithm")
+	}
+
+	var k HMAC_SHA_DerivingKeyV1
+	if err := proto.Unmarshal(ck.Key, &k); err != nil {
+		return nil, err
+	}
+
+	if *k.Mode != CryptoDerivingMode_DERIVING_MODE_HKDF {
+		return nil, errors.New("Bad deriving mode")
+	}
+
+	d := new(Deriver)
+	d.secret = k.HmacPrivate
+	return d, nil
+}
+
+// A Keys holds a set of Keyczar keys and provides an interface to perform
+// actions with these keys.
#*
#* author: Kevin Walsh
#* email: kwalsh@holycross.edu
#* date: 2014-07-16T14:59:01-0400
#*
#- "... and provides an interface to perform actions with these keys."
#- Well, not really, at least not in C++. It is just a container.
#- If you make the Signer, Crypter, Verifier, and Deriver members of keys be
#- anonymous, you get free pass-through in go, though, whic might be nice.
#-
+type Keys struct {
+	dir    string
+	policy string
+
+	signer     *Signer
+	crypter    *Crypter
+	verifer    *Verifier
+	deriver    *Deriver
+	delegation *Attestation
+	cert       *x509.Certificate
+}
+
+// TaoSecretPath returns the path to a Tao-sealed secret, if any. This secret
+// is used to create a PBEEncrypter to encrypt generated keys.
+func (k *Keys) TaoSecretPath() string {
+	if k.dir == "" {
+		return ""
+	} else {
+		return path.Join(k.dir, "secret")
+	}
+}
+
+// zeroBytes clears the bytes in a slice.
+func zeroBytes(b []byte) {
+	for i := range b {
+		b[i] = 0
+	}
 }
diff --git a/go/src/cloudproxy/tao/keys.pb.go b/go/src/cloudproxy/tao/keys.pb.go
index c750ca8..9cfef8d 100644
--- a/go/src/cloudproxy/tao/keys.pb.go
+++ b/go/src/cloudproxy/tao/keys.pb.go
@@ -1,81 +1,630 @@
 // Code generated by protoc-gen-go.
 // source: keys.proto
 // DO NOT EDIT!
 
 package tao
 
 import proto "code.google.com/p/goprotobuf/proto"
 import math "math"
 
 // Reference imports to suppress errors if they are not otherwise used.
 var _ = proto.Marshal
 var _ = math.Inf
 
-type KeyczarPublicKey struct {
-	Metadata         *string                     `protobuf:"bytes,1,req,name=metadata" json:"metadata,omitempty"`
-	Files            []*KeyczarPublicKey_KeyFile `protobuf:"bytes,2,rep,name=files" json:"files,omitempty"`
-	XXX_unrecognized []byte                      `json:"-"`
+type CryptoVersion int32
+
+const (
+	CryptoVersion_CRYPTO_VERSION_1 CryptoVersion = 1
+)
+
+var CryptoVersion_name = map[int32]string{
+	1: "CRYPTO_VERSION_1",
+}
+var CryptoVersion_value = map[string]int32{
+	"CRYPTO_VERSION_1": 1,
+}
+
+func (x CryptoVersion) Enum() *CryptoVersion {
+	p := new(CryptoVersion)
+	*p = x
+	return p
+}
+func (x CryptoVersion) String() string {
+	return proto.EnumName(CryptoVersion_name, int32(x))
+}
+func (x *CryptoVersion) UnmarshalJSON(data []byte) error {
+	value, err := proto.UnmarshalJSONEnum(CryptoVersion_value, data, "CryptoVersion")
+	if err != nil {
+		return err
+	}
+	*x = CryptoVersion(value)
+	return nil
+}
+
+type NamedEllipticCurve int32
+
+const (
+	NamedEllipticCurve_PRIME256_V1 NamedEllipticCurve = 1
+)
+
+var NamedEllipticCurve_name = map[int32]string{
+	1: "PRIME256_V1",
+}
+var NamedEllipticCurve_value = map[string]int32{
+	"PRIME256_V1": 1,
+}
+
+func (x NamedEllipticCurve) Enum() *NamedEllipticCurve {
+	p := new(NamedEllipticCurve)
+	*p = x
+	return p
+}
+func (x NamedEllipticCurve) String() string {
+	return proto.EnumName(NamedEllipticCurve_name, int32(x))
+}
+func (x *NamedEllipticCurve) UnmarshalJSON(data []byte) error {
+	value, err := proto.UnmarshalJSONEnum(NamedEllipticCurve_value, data, "NamedEllipticCurve")
+	if err != nil {
+		return err
+	}
+	*x = NamedEllipticCurve(value)
+	return nil
+}
+
+type CryptoCipherMode int32
+
+const (
+	CryptoCipherMode_CIPHER_MODE_CTR CryptoCipherMode = 1
+)
+
+var CryptoCipherMode_name = map[int32]string{
+	1: "CIPHER_MODE_CTR",
+}
+var CryptoCipherMode_value = map[string]int32{
+	"CIPHER_MODE_CTR": 1,
+}
+
+func (x CryptoCipherMode) Enum() *CryptoCipherMode {
+	p := new(CryptoCipherMode)
+	*p = x
+	return p
+}
+func (x CryptoCipherMode) String() string {
+	return proto.EnumName(CryptoCipherMode_name, int32(x))
+}
+func (x *CryptoCipherMode) UnmarshalJSON(data []byte) error {
+	value, err := proto.UnmarshalJSONEnum(CryptoCipherMode_value, data, "CryptoCipherMode")
+	if err != nil {
+		return err
+	}
+	*x = CryptoCipherMode(value)
+	return nil
+}
+
+type CryptoDerivingMode int32
+
+const (
+	CryptoDerivingMode_DERIVING_MODE_HKDF CryptoDerivingMode = 1
+)
+
+var CryptoDerivingMode_name = map[int32]string{
+	1: "DERIVING_MODE_HKDF",
+}
+var CryptoDerivingMode_value = map[string]int32{
+	"DERIVING_MODE_HKDF": 1,
+}
+
+func (x CryptoDerivingMode) Enum() *CryptoDerivingMode {
+	p := new(CryptoDerivingMode)
+	*p = x
+	return p
+}
+func (x CryptoDerivingMode) String() string {
+	return proto.EnumName(CryptoDerivingMode_name, int32(x))
+}
+func (x *CryptoDerivingMode) UnmarshalJSON(data []byte) error {
+	value, err := proto.UnmarshalJSONEnum(CryptoDerivingMode_value, data, "CryptoDerivingMode")
+	if err != nil {
+		return err
+	}
+	*x = CryptoDerivingMode(value)
+	return nil
+}
+
+type CryptoKey_CryptoPurpose int32
+
+const (
+	CryptoKey_VERIFYING CryptoKey_CryptoPurpose = 1
+	CryptoKey_SIGNING   CryptoKey_CryptoPurpose = 2
+	CryptoKey_CRYPTING  CryptoKey_CryptoPurpose = 3
+	CryptoKey_DERIVING  CryptoKey_CryptoPurpose = 4
+)
+
+var CryptoKey_CryptoPurpose_name = map[int32]string{
+	1: "VERIFYING",
+	2: "SIGNING",
+	3: "CRYPTING",
+	4: "DERIVING",
+}
+var CryptoKey_CryptoPurpose_value = map[string]int32{
+	"VERIFYING": 1,
+	"SIGNING":   2,
+	"CRYPTING":  3,
+	"DERIVING":  4,
+}
+
+func (x CryptoKey_CryptoPurpose) Enum() *CryptoKey_CryptoPurpose {
+	p := new(CryptoKey_CryptoPurpose)
+	*p = x
+	return p
+}
+func (x CryptoKey_CryptoPurpose) String() string {
+	return proto.EnumName(CryptoKey_CryptoPurpose_name, int32(x))
+}
+func (x *CryptoKey_CryptoPurpose) UnmarshalJSON(data []byte) error {
+	value, err := proto.UnmarshalJSONEnum(CryptoKey_CryptoPurpose_value, data, "CryptoKey_CryptoPurpose")
+	if err != nil {
+		return err
+	}
+	*x = CryptoKey_CryptoPurpose(value)
+	return nil
+}
+
+type CryptoKey_CryptoAlgorithm int32
+
+const (
+	CryptoKey_ECDSA_SHA        CryptoKey_CryptoAlgorithm = 1
+	CryptoKey_AES_CTR_HMAC_SHA CryptoKey_CryptoAlgorithm = 2
+	CryptoKey_HMAC_SHA         CryptoKey_CryptoAlgorithm = 3
+)
+
+var CryptoKey_CryptoAlgorithm_name = map[int32]string{
+	1: "ECDSA_SHA",
+	2: "AES_CTR_HMAC_SHA",
+	3: "HMAC_SHA",
+}
+var CryptoKey_CryptoAlgorithm_value = map[string]int32{
+	"ECDSA_SHA":        1,
+	"AES_CTR_HMAC_SHA": 2,
+	"HMAC_SHA":         3,
+}
+
+func (x CryptoKey_CryptoAlgorithm) Enum() *CryptoKey_CryptoAlgorithm {
+	p := new(CryptoKey_CryptoAlgorithm)
+	*p = x
+	return p
+}
+func (x CryptoKey_CryptoAlgorithm) String() string {
+	return proto.EnumName(CryptoKey_CryptoAlgorithm_name, int32(x))
+}
+func (x *CryptoKey_CryptoAlgorithm) UnmarshalJSON(data []byte) error {
+	value, err := proto.UnmarshalJSONEnum(CryptoKey_CryptoAlgorithm_value, data, "CryptoKey_CryptoAlgorithm")
+	if err != nil {
+		return err
+	}
+	*x = CryptoKey_CryptoAlgorithm(value)
+	return nil
+}
+
+type CryptoKey struct {
+	Version          *CryptoVersion             `protobuf:"varint,1,req,name=version,enum=tao.CryptoVersion" json:"version,omitempty"`
+	Purpose          *CryptoKey_CryptoPurpose   `protobuf:"varint,2,req,name=purpose,enum=tao.CryptoKey_CryptoPurpose" json:"purpose,omitempty"`
+	Algorithm        *CryptoKey_CryptoAlgorithm `protobuf:"varint,3,req,name=algorithm,enum=tao.CryptoKey_CryptoAlgorithm" json:"algorithm,omitempty"`
+	Key              []byte                     `protobuf:"bytes,4,req,name=key" json:"key,omitempty"`
+	XXX_unrecognized []byte                     `json:"-"`
+}
+
+func (m *CryptoKey) Reset()         { *m = CryptoKey{} }
+func (m *CryptoKey) String() string { return proto.CompactTextString(m) }
+func (*CryptoKey) ProtoMessage()    {}
+
+func (m *CryptoKey) GetVersion() CryptoVersion {
+	if m != nil && m.Version != nil {
+		return *m.Version
+	}
+	return CryptoVersion_CRYPTO_VERSION_1
+}
+
+func (m *CryptoKey) GetPurpose() CryptoKey_CryptoPurpose {
+	if m != nil && m.Purpose != nil {
+		return *m.Purpose
+	}
+	return CryptoKey_VERIFYING
+}
+
+func (m *CryptoKey) GetAlgorithm() CryptoKey_CryptoAlgorithm {
+	if m != nil && m.Algorithm != nil {
+		return *m.Algorithm
+	}
+	return CryptoKey_ECDSA_SHA
+}
+
+func (m *CryptoKey) GetKey() []byte {
+	if m != nil {
+		return m.Key
+	}
+	return nil
+}
+
+type CryptoKeyset struct {
+	Keys             []*CryptoKey `protobuf:"bytes,1,rep,name=keys" json:"keys,omitempty"`
+	XXX_unrecognized []byte       `json:"-"`
+}
+
+func (m *CryptoKeyset) Reset()         { *m = CryptoKeyset{} }
+func (m *CryptoKeyset) String() string { return proto.CompactTextString(m) }
+func (*CryptoKeyset) ProtoMessage()    {}
+
+func (m *CryptoKeyset) GetKeys() []*CryptoKey {
+	if m != nil {
+		return m.Keys
+	}
+	return nil
+}
+
+type PBEData struct {
+	Version    *CryptoVersion `protobuf:"varint,1,req,name=version,enum=tao.CryptoVersion" json:"version,omitempty"`
+	Cipher     *string        `protobuf:"bytes,2,req,name=cipher" json:"cipher,omitempty"`
+	Hmac       *string        `protobuf:"bytes,3,req,name=hmac" json:"hmac,omitempty"`
+	Iterations *int32         `protobuf:"varint,4,req,name=iterations" json:"iterations,omitempty"`
+	Iv         []byte         `protobuf:"bytes,5,req,name=iv" json:"iv,omitempty"`
+	Ciphertext []byte         `protobuf:"bytes,6,req,name=ciphertext" json:"ciphertext,omitempty"`
+	// TODO(kwalsh) Should this not use a mac as well for integrity protection?
+	Salt             []byte `protobuf:"bytes,7,req,name=salt" json:"salt,omitempty"`
+	XXX_unrecognized []byte `json:"-"`
+}
+
+func (m *PBEData) Reset()         { *m = PBEData{} }
+func (m *PBEData) String() string { return proto.CompactTextString(m) }
+func (*PBEData) ProtoMessage()    {}
+
+func (m *PBEData) GetVersion() CryptoVersion {
+	if m != nil && m.Version != nil {
+		return *m.Version
+	}
+	return CryptoVersion_CRYPTO_VERSION_1
+}
+
+func (m *PBEData) GetCipher() string {
+	if m != nil && m.Cipher != nil {
+		return *m.Cipher
+	}
+	return ""
+}
+
+func (m *PBEData) GetHmac() string {
+	if m != nil && m.Hmac != nil {
+		return *m.Hmac
+	}
+	return ""
+}
+
+func (m *PBEData) GetIterations() int32 {
+	if m != nil && m.Iterations != nil {
+		return *m.Iterations
+	}
+	return 0
+}
+
+func (m *PBEData) GetIv() []byte {
+	if m != nil {
+		return m.Iv
+	}
+	return nil
+}
+
+func (m *PBEData) GetCiphertext() []byte {
+	if m != nil {
+		return m.Ciphertext
+	}
+	return nil
+}
+
+func (m *PBEData) GetSalt() []byte {
+	if m != nil {
+		return m.Salt
+	}
+	return nil
+}
+
+type ECDSA_SHA_VerifyingKeyV1 struct {
+	Curve            *NamedEllipticCurve `protobuf:"varint,1,req,name=curve,enum=tao.NamedEllipticCurve" json:"curve,omitempty"`
+	EcPublic         []byte              `protobuf:"bytes,2,req,name=ec_public" json:"ec_public,omitempty"`
+	XXX_unrecognized []byte              `json:"-"`
+}
+
+func (m *ECDSA_SHA_VerifyingKeyV1) Reset()         { *m = ECDSA_SHA_VerifyingKeyV1{} }
+func (m *ECDSA_SHA_VerifyingKeyV1) String() string { return proto.CompactTextString(m) }
+func (*ECDSA_SHA_VerifyingKeyV1) ProtoMessage()    {}
+
+func (m *ECDSA_SHA_VerifyingKeyV1) GetCurve() NamedEllipticCurve {
+	if m != nil && m.Curve != nil {
+		return *m.Curve
+	}
+	return NamedEllipticCurve_PRIME256_V1
+}
+
+func (m *ECDSA_SHA_VerifyingKeyV1) GetEcPublic() []byte {
+	if m != nil {
+		return m.EcPublic
+	}
+	return nil
+}
+
+type ECDSA_SHA_SigningKeyV1 struct {
+	Curve            *NamedEllipticCurve `protobuf:"varint,1,req,name=curve,enum=tao.NamedEllipticCurve" json:"curve,omitempty"`
+	EcPrivate        []byte              `protobuf:"bytes,2,req,name=ec_private" json:"ec_private,omitempty"`
+	EcPublic         []byte              `protobuf:"bytes,3,req,name=ec_public" json:"ec_public,omitempty"`
+	XXX_unrecognized []byte              `json:"-"`
+}
+
+func (m *ECDSA_SHA_SigningKeyV1) Reset()         { *m = ECDSA_SHA_SigningKeyV1{} }
+func (m *ECDSA_SHA_SigningKeyV1) String() string { return proto.CompactTextString(m) }
+func (*ECDSA_SHA_SigningKeyV1) ProtoMessage()    {}
+
+func (m *ECDSA_SHA_SigningKeyV1) GetCurve() NamedEllipticCurve {
+	if m != nil && m.Curve != nil {
+		return *m.Curve
+	}
+	return NamedEllipticCurve_PRIME256_V1
 }
 
-func (m *KeyczarPublicKey) Reset()         { *m = KeyczarPublicKey{} }
-func (m *KeyczarPublicKey) String() string { return proto.CompactTextString(m) }
-func (*KeyczarPublicKey) ProtoMessage()    {}
+func (m *ECDSA_SHA_SigningKeyV1) GetEcPrivate() []byte {
+	if m != nil {
+		return m.EcPrivate
+	}
+	return nil
+}
+
+func (m *ECDSA_SHA_SigningKeyV1) GetEcPublic() []byte {
+	if m != nil {
+		return m.EcPublic
+	}
+	return nil
+}
+
+type AES_CTR_HMAC_SHA_CryptingKeyV1 struct {
+	Mode             *CryptoCipherMode `protobuf:"varint,1,req,name=mode,enum=tao.CryptoCipherMode" json:"mode,omitempty"`
+	AesPrivate       []byte            `protobuf:"bytes,2,req,name=aes_private" json:"aes_private,omitempty"`
+	HmacPrivate      []byte            `protobuf:"bytes,3,req,name=hmac_private" json:"hmac_private,omitempty"`
+	XXX_unrecognized []byte            `json:"-"`
+}
+
+func (m *AES_CTR_HMAC_SHA_CryptingKeyV1) Reset()         { *m = AES_CTR_HMAC_SHA_CryptingKeyV1{} }
+func (m *AES_CTR_HMAC_SHA_CryptingKeyV1) String() string { return proto.CompactTextString(m) }
+func (*AES_CTR_HMAC_SHA_CryptingKeyV1) ProtoMessage()    {}
+
+func (m *AES_CTR_HMAC_SHA_CryptingKeyV1) GetMode() CryptoCipherMode {
+	if m != nil && m.Mode != nil {
+		return *m.Mode
+	}
+	return CryptoCipherMode_CIPHER_MODE_CTR
+}
+
+func (m *AES_CTR_HMAC_SHA_CryptingKeyV1) GetAesPrivate() []byte {
+	if m != nil {
+		return m.AesPrivate
+	}
+	return nil
+}
+
+func (m *AES_CTR_HMAC_SHA_CryptingKeyV1) GetHmacPrivate() []byte {
+	if m != nil {
+		return m.HmacPrivate
+	}
+	return nil
+}
+
+type HMAC_SHA_DerivingKeyV1 struct {
+	Mode             *CryptoDerivingMode `protobuf:"varint,1,req,name=mode,enum=tao.CryptoDerivingMode" json:"mode,omitempty"`
+	HmacPrivate      []byte              `protobuf:"bytes,2,req,name=hmac_private" json:"hmac_private,omitempty"`
+	XXX_unrecognized []byte              `json:"-"`
+}
+
+func (m *HMAC_SHA_DerivingKeyV1) Reset()         { *m = HMAC_SHA_DerivingKeyV1{} }
+func (m *HMAC_SHA_DerivingKeyV1) String() string { return proto.CompactTextString(m) }
+func (*HMAC_SHA_DerivingKeyV1) ProtoMessage()    {}
+
+func (m *HMAC_SHA_DerivingKeyV1) GetMode() CryptoDerivingMode {
+	if m != nil && m.Mode != nil {
+		return *m.Mode
+	}
+	return CryptoDerivingMode_DERIVING_MODE_HKDF
+}
+
+func (m *HMAC_SHA_DerivingKeyV1) GetHmacPrivate() []byte {
+	if m != nil {
+		return m.HmacPrivate
+	}
+	return nil
+}
+
+type CryptoHeader struct {
+	Version          *CryptoVersion `protobuf:"varint,1,req,name=version,enum=tao.CryptoVersion" json:"version,omitempty"`
+	KeyHint          []byte         `protobuf:"bytes,2,req,name=key_hint" json:"key_hint,omitempty"`
+	XXX_unrecognized []byte         `json:"-"`
+}
 
-func (m *KeyczarPublicKey) GetMetadata() string {
-	if m != nil && m.Metadata != nil {
-		return *m.Metadata
+func (m *CryptoHeader) Reset()         { *m = CryptoHeader{} }
+func (m *CryptoHeader) String() string { return proto.CompactTextString(m) }
+func (*CryptoHeader) ProtoMessage()    {}
+
+func (m *CryptoHeader) GetVersion() CryptoVersion {
+	if m != nil && m.Version != nil {
+		return *m.Version
+	}
+	return CryptoVersion_CRYPTO_VERSION_1
+}
+
+func (m *CryptoHeader) GetKeyHint() []byte {
+	if m != nil {
+		return m.KeyHint
+	}
+	return nil
+}
+
+// A PDU to be serialized and signed, including a required context to ensure
+// unique deserialization.
+type SignaturePDU struct {
+	Header *CryptoHeader `protobuf:"bytes,1,req,name=header" json:"header,omitempty"`
+	// SECURITY WARNING: Always choose a unique context for each unique type of
+	// message. One easy way to do this is to number the messages in a protocol
+	// and make the context "ProtocolName Message Y: ProtobufName Version X"
+	Context *string `protobuf:"bytes,2,req,name=context" json:"context,omitempty"`
+	// The serialized protobuf representing this message.
+	Data             []byte `protobuf:"bytes,3,req,name=data" json:"data,omitempty"`
+	XXX_unrecognized []byte `json:"-"`
+}
+
+func (m *SignaturePDU) Reset()         { *m = SignaturePDU{} }
+func (m *SignaturePDU) String() string { return proto.CompactTextString(m) }
+func (*SignaturePDU) ProtoMessage()    {}
+
+func (m *SignaturePDU) GetHeader() *CryptoHeader {
+	if m != nil {
+		return m.Header
+	}
+	return nil
+}
+
+func (m *SignaturePDU) GetContext() string {
+	if m != nil && m.Context != nil {
+		return *m.Context
 	}
 	return ""
 }
 
-func (m *KeyczarPublicKey) GetFiles() []*KeyczarPublicKey_KeyFile {
+func (m *SignaturePDU) GetData() []byte {
+	if m != nil {
+		return m.Data
+	}
+	return nil
+}
+
+// The result of signing.
+type SignedData struct {
+	Header           *CryptoHeader `protobuf:"bytes,1,req,name=header" json:"header,omitempty"`
+	Signature        []byte        `protobuf:"bytes,2,req,name=signature" json:"signature,omitempty"`
+	XXX_unrecognized []byte        `json:"-"`
+}
+
+func (m *SignedData) Reset()         { *m = SignedData{} }
+func (m *SignedData) String() string { return proto.CompactTextString(m) }
+func (*SignedData) ProtoMessage()    {}
+
+func (m *SignedData) GetHeader() *CryptoHeader {
+	if m != nil {
+		return m.Header
+	}
+	return nil
+}
+
+func (m *SignedData) GetSignature() []byte {
 	if m != nil {
-		return m.Files
+		return m.Signature
 	}
 	return nil
 }
 
-type KeyczarPublicKey_KeyFile struct {
-	Name             *int32  `protobuf:"varint,1,req,name=name" json:"name,omitempty"`
-	Data             *string `protobuf:"bytes,2,req,name=data" json:"data,omitempty"`
+// The result of encrypting.
+type EncryptedData struct {
+	Header           *CryptoHeader `protobuf:"bytes,1,req,name=header" json:"header,omitempty"`
+	Iv               []byte        `protobuf:"bytes,2,req,name=iv" json:"iv,omitempty"`
+	Ciphertext       []byte        `protobuf:"bytes,3,req,name=ciphertext" json:"ciphertext,omitempty"`
+	Mac              []byte        `protobuf:"bytes,4,opt,name=mac" json:"mac,omitempty"`
+	XXX_unrecognized []byte        `json:"-"`
+}
+
+func (m *EncryptedData) Reset()         { *m = EncryptedData{} }
+func (m *EncryptedData) String() string { return proto.CompactTextString(m) }
+func (*EncryptedData) ProtoMessage()    {}
+
+func (m *EncryptedData) GetHeader() *CryptoHeader {
+	if m != nil {
+		return m.Header
+	}
+	return nil
+}
+
+func (m *EncryptedData) GetIv() []byte {
+	if m != nil {
+		return m.Iv
+	}
+	return nil
+}
+
+func (m *EncryptedData) GetCiphertext() []byte {
+	if m != nil {
+		return m.Ciphertext
+	}
+	return nil
+}
+
+func (m *EncryptedData) GetMac() []byte {
+	if m != nil {
+		return m.Mac
+	}
+	return nil
+}
+
+// A PDU to be serialized and fed to HKDF for derivation.
+type KeyDerivationPDU struct {
+	PreviousHash     []byte  `protobuf:"bytes,1,req,name=previous_hash" json:"previous_hash,omitempty"`
+	Size             *uint32 `protobuf:"fixed32,2,req,name=size" json:"size,omitempty"`
+	Context          *string `protobuf:"bytes,3,req,name=context" json:"context,omitempty"`
+	Index            *uint32 `protobuf:"fixed32,4,req,name=index" json:"index,omitempty"`
 	XXX_unrecognized []byte  `json:"-"`
 }
 
-func (m *KeyczarPublicKey_KeyFile) Reset()         { *m = KeyczarPublicKey_KeyFile{} }
-func (m *KeyczarPublicKey_KeyFile) String() string { return proto.CompactTextString(m) }
-func (*KeyczarPublicKey_KeyFile) ProtoMessage()    {}
+func (m *KeyDerivationPDU) Reset()         { *m = KeyDerivationPDU{} }
+func (m *KeyDerivationPDU) String() string { return proto.CompactTextString(m) }
+func (*KeyDerivationPDU) ProtoMessage()    {}
+
+func (m *KeyDerivationPDU) GetPreviousHash() []byte {
+	if m != nil {
+		return m.PreviousHash
+	}
+	return nil
+}
 
-func (m *KeyczarPublicKey_KeyFile) GetName() int32 {
-	if m != nil && m.Name != nil {
-		return *m.Name
+func (m *KeyDerivationPDU) GetSize() uint32 {
+	if m != nil && m.Size != nil {
+		return *m.Size
 	}
 	return 0
 }
 
-func (m *KeyczarPublicKey_KeyFile) GetData() string {
-	if m != nil && m.Data != nil {
-		return *m.Data
+func (m *KeyDerivationPDU) GetContext() string {
+	if m != nil && m.Context != nil {
+		return *m.Context
 	}
 	return ""
 }
 
+func (m *KeyDerivationPDU) GetIndex() uint32 {
+	if m != nil && m.Index != nil {
+		return *m.Index
+	}
+	return 0
+}
+
 type X509Details struct {
 	// Requested x509 CommonName detail
 	Commonname []byte `protobuf:"bytes,3,opt,name=commonname" json:"commonname,omitempty"`
 	// Requested x509 Country detail
 	Country []byte `protobuf:"bytes,4,opt,name=country" json:"country,omitempty"`
 	// Requested x509 State detail
 	State []byte `protobuf:"bytes,5,opt,name=state" json:"state,omitempty"`
 	// Requested x509 Organization detail
 	Organization     []byte `protobuf:"bytes,6,opt,name=organization" json:"organization,omitempty"`
 	XXX_unrecognized []byte `json:"-"`
 }
 
 func (m *X509Details) Reset()         { *m = X509Details{} }
 func (m *X509Details) String() string { return proto.CompactTextString(m) }
 func (*X509Details) ProtoMessage()    {}
 
 func (m *X509Details) GetCommonname() []byte {
 	if m != nil {
 		return m.Commonname
 	}
@@ -86,52 +635,28 @@ func (m *X509Details) GetCountry() []byte {
 	if m != nil {
 		return m.Country
 	}
 	return nil
 }
 
 func (m *X509Details) GetState() []byte {
 	if m != nil {
 		return m.State
 	}
 	return nil
 }
 
 func (m *X509Details) GetOrganization() []byte {
 	if m != nil {
 		return m.Organization
 	}
 	return nil
 }
 
-// A signed serialized protobuf message, including a require context to ensure
-// unique deserialization.
-type SignedData struct {
-	// SECURITY WARNING: Always choose a unique context for each unique type of
-	// message. One easy way to do this is to number the messages in a protocol
-	// and make the context "ProtocolName Message Y: ProtobufName Version X"
-	Context *string `protobuf:"bytes,1,req,name=context" json:"context,omitempty"`
-	// The serialized protobuf representing this message.
-	Data             []byte `protobuf:"bytes,2,req,name=data" json:"data,omitempty"`
-	XXX_unrecognized []byte `json:"-"`
-}
-
-func (m *SignedData) Reset()         { *m = SignedData{} }
-func (m *SignedData) String() string { return proto.CompactTextString(m) }
-func (*SignedData) ProtoMessage()    {}
-
-func (m *SignedData) GetContext() string {
-	if m != nil && m.Context != nil {
-		return *m.Context
-	}
-	return ""
-}
-
-func (m *SignedData) GetData() []byte {
-	if m != nil {
-		return m.Data
-	}
-	return nil
-}
-
 func init() {
+	proto.RegisterEnum("tao.CryptoVersion", CryptoVersion_name, CryptoVersion_value)
+	proto.RegisterEnum("tao.NamedEllipticCurve", NamedEllipticCurve_name, NamedEllipticCurve_value)
+	proto.RegisterEnum("tao.CryptoCipherMode", CryptoCipherMode_name, CryptoCipherMode_value)
+	proto.RegisterEnum("tao.CryptoDerivingMode", CryptoDerivingMode_name, CryptoDerivingMode_value)
+	proto.RegisterEnum("tao.CryptoKey_CryptoPurpose", CryptoKey_CryptoPurpose_name, CryptoKey_CryptoPurpose_value)
+	proto.RegisterEnum("tao.CryptoKey_CryptoAlgorithm", CryptoKey_CryptoAlgorithm_name, CryptoKey_CryptoAlgorithm_value)
 }
diff --git a/go/src/cloudproxy/tao/keys_test.go b/go/src/cloudproxy/tao/keys_test.go
index 2df741c..fd5b275 100644
--- a/go/src/cloudproxy/tao/keys_test.go
+++ b/go/src/cloudproxy/tao/keys_test.go
@@ -1,33 +1,345 @@
 //  Copyright (c) 2014, Google Inc.  All rights reserved.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
 // You may obtain a copy of the License at
 //
 //     http://www.apache.org/licenses/LICENSE-2.0
 //
 // Unless required by applicable law or agreed to in writing, software
 // distributed under the License is distributed on an "AS IS" BASIS,
 // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
 package tao
 
 import (
+	"crypto/rand"
 	"testing"
 )
 
-func TestTempKeys(t *testing.T) {
-	msg := []byte("test msg")
-	ctxt := []byte("test context")
-	k := NewTempKeys("test", Signing | Crypting | KeyDeriving)
-	sig, err := k.Sign(msg, ctxt)
+func TestGenerateKeys(t *testing.T) {
+	if _, err := GenerateSigner(); err != nil {
+		t.Fatal(err.Error())
+	}
+}
+
+func TestSignerPEMSerialization(t *testing.T) {
+	s, err := GenerateSigner()
+	if err != nil {
+		t.Fatal(err.Error())
+	}
+
+	b, err := MarshalSignerPEM(s)
+	if err != nil {
+		t.Fatal(err.Error())
+	}
+
+	if _, err := ParseSignerPEM(b); err != nil {
+		t.Fatal(err.Error())
+	}
+}
+
+func TestSelfSignedX509(t *testing.T) {
+	s, err := GenerateSigner()
+	if err != nil {
+		t.Fatal(err.Error())
+	}
+
+	d := `
+		commonname: "test",
+		country: "US",
+		state: "WA",
+		organization: "Google",
+	`
+
+	_, err = s.CreateSelfSignedX509(d)
+	if err != nil {
+		t.Fatal(err.Error())
+	}
+}
+
+func TestSignerMarshalProto(t *testing.T) {
+	s, err := GenerateSigner()
+	if err != nil {
+		t.Fatal(err.Error())
+	}
+
+	c, err := MarshalSignerProto(s)
+	if err != nil {
+		t.Fatal(err.Error())
+	}
+
+	if _, err := UnmarshalSignerProto(c); err != nil {
+		t.Fatal(err.Error())
+	}
+}
+
+func TestCreateHeader(t *testing.T) {
+	s, err := GenerateSigner()
+	if err != nil {
+		t.Fatal(err.Error())
+	}
+
+	if _, err := s.CreateHeader(); err != nil {
+		t.Fatal(err.Error())
+	}
+}
+
+func TestPublicSignerMarshalProto(t *testing.T) {
+	s, err := GenerateSigner()
+	if err != nil {
+		t.Fatal(err.Error())
+	}
+
+	ck, err := MarshalPublicSignerProto(s)
+	if err != nil {
+		t.Fatal(err.Error())
+	}
+
+	if _, err := UnmarshalVerifierProto(ck); err != nil {
+		t.Fatal(err.Error())
+	}
+}
+
+func TestVerifierFromX509(t *testing.T) {
+	s, err := GenerateSigner()
+	if err != nil {
+		t.Fatal(err.Error())
+	}
+
+	d := `
+		commonname: "test",
+		country: "US",
+		state: "WA",
+		organization: "Google",
+	`
+
+	x, err := s.CreateSelfSignedX509(d)
+	if err != nil {
+		t.Fatal(err.Error())
+	}
+
+	if _, err := FromX509(x); err != nil {
+		t.Fatal(err.Error())
+	}
+}
+
+func TestFromPrincipalName(t *testing.T) {
+	s, err := GenerateSigner()
+	if err != nil {
+		t.Fatal(err.Error())
+	}
+
+	name, err := s.ToPrincipalName()
+	if err != nil {
+		t.Fatal(err.Error())
+	}
+
+	v, err := FromPrincipalName(name)
+	if err != nil {
+		t.Fatal(err.Error())
+	}
+
+	name2, err := v.ToPrincipalName()
+	if err != nil {
+		t.Fatal(err.Error())
+	}
+
+	if name != name2 {
+		t.Fatal("Verifier Principal name doesn't match the Signer name it was derived from")
+	}
+}
+
+func TestSignAndVerify(t *testing.T) {
+	s, err := GenerateSigner()
+	if err != nil {
+		t.Fatal(err.Error())
+	}
+
+	name, err := s.ToPrincipalName()
+	if err != nil {
+		t.Fatal(err.Error())
+	}
+
+	v, err := FromPrincipalName(name)
+	if err != nil {
+		t.Fatal(err.Error())
+	}
+
+	data := []byte(`Test data to sign`)
+	context := "Context string"
+	sig, err := s.Sign(data, context)
+	if err != nil {
+		t.Fatal(err.Error())
+	}
+
+	if verifies, err := v.Verify(data, context, sig); err != nil || !verifies {
+		if err != nil {
+			t.Fatal(err.Error())
+		} else {
+			t.Fatal("The signature failed verification")
+		}
+	}
+}
+
+func TestNewCrypter(t *testing.T) {
+	if _, err := GenerateCrypter(); err != nil {
+		t.Fatal(err.Error())
+	}
+}
+
+func TestEncryptAndDecrypt(t *testing.T) {
+	c, err := GenerateCrypter()
 	if err != nil {
-		t.Error(err.Error())
+		t.Fatal(err.Error())
+	}
+
+	data := []byte("Test data to encrypt")
+	crypted, err := c.Encrypt(data)
+	if err != nil {
+		t.Fatal(err.Error())
+	}
+
+	data2, err := c.Decrypt(crypted)
+	if err != nil {
+		t.Fatal(err.Error())
+	}
+
+	if len(data) != len(data2) {
+		t.Fatal("The decrypted data was not the same length as the original data")
+	}
+
+	for i := range data {
+		if data[i] != data2[i] {
+			t.Fatal("The decrypted data was not the same as the original data")
+		}
+	}
+}
+
+func TestMarshalCrypterProto(t *testing.T) {
+	c, err := GenerateCrypter()
+	if err != nil {
+		t.Fatal(err.Error())
+	}
+
+	ck, err := MarshalCrypterProto(c)
+	if err != nil {
+		t.Fatal(err.Error())
+	}
+
+	c2, err := UnmarshalCrypterProto(ck)
+	if err != nil {
+		t.Fatal(err.Error())
+	}
+
+	// Try encrypting with one and decrypting with the other.
+	data := []byte("Test data to encrypt")
+	crypted, err := c.Encrypt(data)
+	if err != nil {
+		t.Fatal(err.Error())
+	}
+
+	data2, err := c2.Decrypt(crypted)
+	if err != nil {
+		t.Fatal(err.Error())
+	}
+
+	if len(data) != len(data2) {
+		t.Fatal("The decrypted data was not the same length as the original data")
+	}
+
+	for i := range data {
+		if data[i] != data2[i] {
+			t.Fatal("The decrypted data was not the same as the original data")
+		}
+	}
+}
+
+func TestNewDeriver(t *testing.T) {
+	if _, err := GenerateDeriver(); err != nil {
+		t.Fatal(err.Error())
+	}
+}
+
+func TestDeriveSecret(t *testing.T) {
+	d, err := GenerateDeriver()
+	if err != nil {
+		t.Fatal(err.Error())
+	}
+
+	salt := make([]byte, 20)
+	if _, err := rand.Read(salt); err != nil {
+		t.Fatal(err.Error())
+	}
+
+	context := []byte("Test context")
+
+	// Derive an AES-256 key.
+	material := make([]byte, 32)
+	if err := d.Derive(salt, context, material); err != nil {
+		t.Fatal(err.Error())
+	}
+
+	material2 := make([]byte, 32)
+	if err := d.Derive(salt, context, material2); err != nil {
+		t.Fatal(err.Error())
+	}
+
+	if len(material) != len(material2) {
+		t.Fatal("The Deriver generated two different lengths of keys")
+	}
+
+	for i := range material {
+		if material[i] != material2[i] {
+			t.Fatal("The Deriver is not deterministic")
+		}
+	}
+}
+
+func TestMarshalDeriver(t *testing.T) {
+	d, err := GenerateDeriver()
+	if err != nil {
+		t.Fatal(err.Error())
+	}
+
+	ck, err := MarshalDeriverProto(d)
+	if err != nil {
+		t.Fatal(err.Error())
+	}
+
+	d2, err := UnmarshalDeriverProto(ck)
+	if err != nil {
+		t.Fatal(err.Error())
+	}
+
+	// Make sure both derivers derive the same keys given the same input.
+	salt := make([]byte, 20)
+	if _, err := rand.Read(salt); err != nil {
+		t.Fatal(err.Error())
+	}
+
+	context := []byte("Test context")
+
+	// Derive an AES-256 key.
+	material := make([]byte, 32)
+	if err := d.Derive(salt, context, material); err != nil {
+		t.Fatal(err.Error())
+	}
+
+	material2 := make([]byte, 32)
+	if err := d2.Derive(salt, context, material2); err != nil {
+		t.Fatal(err.Error())
+	}
+
+	if len(material) != len(material2) {
+		t.Fatal("The Deriver generated two different lengths of keys")
 	}
 
-	if b, err := k.Verify(msg, ctxt, []byte(sig)); (!b || err != nil) {
-		t.Error("The message didn't pass verification")
+	for i := range material {
+		if material[i] != material2[i] {
+			t.Fatal("The Deriver is not deterministic")
+		}
 	}
 }
diff --git a/go/src/cloudproxy/tao/tao.go b/go/src/cloudproxy/tao/tao.go
index f9ed0cc..59b3b79 100644
--- a/go/src/cloudproxy/tao/tao.go
+++ b/go/src/cloudproxy/tao/tao.go
@@ -48,41 +48,41 @@ package tao
 type Sealer interface {
 	// Seal protects the given data for the given hosted program and
 	// returns an opaque protected blob that can be unsealed later.
 	Seal(data, policy []byte) ([]byte, error)
 }
 
 type SealUnsealer interface {
 	Sealer
 
 	// Unseal opens a blob created by Seal if the hosted program matches
 	// the program that sealed the data.
 	Unseal(sealed []byte) (data, policy []byte, err error)
 }
 
 type Attester interface {
 	// Attest generates a cryptographic attestation to a given data blob
 	// for a given hosted program.
 	Attest(s *Statement) (*Attestation, error)
 }
 
-type Verifier interface {
+type AttestationVerifier interface {
 	// Verify verifies an attestation and returns the statement attested
 	// to.
 	Verify(a *Attestation) (*Statement, bool)
 }
 
 // The Tao is a combination of other interfaces.
 type Tao interface {
 	SealUnsealer
 	Attester
 
 	// GetRandomBytes fills the given slice with random bytes, up to the
 	// length of the slice.
 	GetRandomBytes(bytes []byte) error
 }
 
 // These values repesent the current sealing policies for the Tao.
 var SealPolicyDefault string = "self"
 var SealPolicyConservative string = "few"
 var SealPolicyLiberal string = "any"
 
diff --git a/go/src/cloudproxy/tao/tao_client.go b/go/src/cloudproxy/tao/tao_client.go
index 13f3a53..4835969 100644
--- a/go/src/cloudproxy/tao/tao_client.go
+++ b/go/src/cloudproxy/tao/tao_client.go
@@ -14,89 +14,89 @@ type TaoClient struct {
 }
 
 func (t *TaoClient) GetRandomBytes(bytes []byte) (err error) {
 	r := &TaoRPCRequest{
 		Rpc:  new(TaoRPCOperation),
 		Size: proto.Int32(int32(len(bytes))),
 	}
 
 	*r.Rpc = TaoRPCOperation_TAO_RPC_GET_RANDOM_BYTES
 	s := new(TaoRPCResponse)
 	err = t.Parent.Call("TaoServer.GetRandomBytes", r, s)
 	if err != nil {
 		return err
 	}
 
 	copy(bytes, s.Data)
 	return nil
 }
 
 func (t *TaoClient) Seal(data, policy []byte) ([]byte, error) {
-  rpcData := make([]byte, len(data))
-  copy(rpcData, data)
-  r := &TaoRPCRequest{
-    Rpc: new(TaoRPCOperation),
-    Data: rpcData,
-    Policy: proto.String(string(policy)),
-  }
-
-  *r.Rpc = TaoRPCOperation_TAO_RPC_SEAL
-  s := new(TaoRPCResponse)
-  err := t.Parent.Call("TaoServer.Seal", r, s)
-  if err != nil {
-    return nil, err
-  }
-
-  sealed := make([]byte, len(s.Data))
-  copy(sealed, s.Data)
-  return sealed, nil
+	rpcData := make([]byte, len(data))
+	copy(rpcData, data)
+	r := &TaoRPCRequest{
+		Rpc:    new(TaoRPCOperation),
+		Data:   rpcData,
+		Policy: proto.String(string(policy)),
+	}
+
+	*r.Rpc = TaoRPCOperation_TAO_RPC_SEAL
+	s := new(TaoRPCResponse)
+	err := t.Parent.Call("TaoServer.Seal", r, s)
+	if err != nil {
+		return nil, err
+	}
+
+	sealed := make([]byte, len(s.Data))
+	copy(sealed, s.Data)
+	return sealed, nil
 }
 
 func (t *TaoClient) Unseal(sealed []byte) ([]byte, []byte, error) {
-  rpcSealed := make([]byte, len(sealed))
-  copy(rpcSealed, sealed)
-  r := &TaoRPCRequest{
-    Rpc: new(TaoRPCOperation),
-    Data: rpcSealed,
-  }
+	rpcSealed := make([]byte, len(sealed))
+	copy(rpcSealed, sealed)
+	r := &TaoRPCRequest{
+		Rpc:  new(TaoRPCOperation),
+		Data: rpcSealed,
+	}
 
-  *r.Rpc = TaoRPCOperation_TAO_RPC_UNSEAL
+	*r.Rpc = TaoRPCOperation_TAO_RPC_UNSEAL
 
-  s := new(TaoRPCResponse)
-  err := t.Parent.Call("TaoServer.Unseal", r, s)
-  if err != nil {
-    return nil, nil, err
-  }
+	s := new(TaoRPCResponse)
+	err := t.Parent.Call("TaoServer.Unseal", r, s)
+	if err != nil {
+		return nil, nil, err
+	}
 
-  unsealed := make([]byte, len(s.Data))
-  copy(unsealed, s.Data)
+	unsealed := make([]byte, len(s.Data))
+	copy(unsealed, s.Data)
 
-  return unsealed, []byte(*s.Policy), nil
+	return unsealed, []byte(*s.Policy), nil
 }
 
 func (t *TaoClient) Attest(stmt *Statement) (*Attestation, error) {
-  stData, err := proto.Marshal(stmt)
-  if err != nil {
-    return nil, err
-  }
-
-  r := &TaoRPCRequest{
-    Rpc: new(TaoRPCOperation),
-    Data: stData,
-  }
-
-  *r.Rpc = TaoRPCOperation_TAO_RPC_ATTEST
-
-  s := new(TaoRPCResponse)
-  err = t.Parent.Call("TaoServer.Attest", r, s)
-  if err != nil {
-    return nil, err
-  }
-
-  a := new(Attestation)
-  err = proto.Unmarshal(s.Data, a)
-  if err != nil {
-    return nil, err
-  }
-
-  return a, nil
+	stData, err := proto.Marshal(stmt)
+	if err != nil {
+		return nil, err
+	}
+
+	r := &TaoRPCRequest{
+		Rpc:  new(TaoRPCOperation),
+		Data: stData,
+	}
+
+	*r.Rpc = TaoRPCOperation_TAO_RPC_ATTEST
+
+	s := new(TaoRPCResponse)
+	err = t.Parent.Call("TaoServer.Attest", r, s)
+	if err != nil {
+		return nil, err
+	}
+
+	a := new(Attestation)
+	err = proto.Unmarshal(s.Data, a)
+	if err != nil {
+		return nil, err
+	}
+
+	return a, nil
 }
diff --git a/go/src/cloudproxy/tao/tao_rpc.pb.go b/go/src/cloudproxy/tao/tao_rpc.pb.go
index 66bc459..acb23a8 100644
--- a/go/src/cloudproxy/tao/tao_rpc.pb.go
+++ b/go/src/cloudproxy/tao/tao_rpc.pb.go
@@ -1,62 +1,65 @@
 // Code generated by protoc-gen-go.
 // source: tao_rpc.proto
 // DO NOT EDIT!
 
 package tao
 
 import proto "code.google.com/p/goprotobuf/proto"
 import math "math"
 
 // Reference imports to suppress errors if they are not otherwise used.
 var _ = proto.Marshal
 var _ = math.Inf
 
 type TaoRPCOperation int32
 
 const (
-	TaoRPCOperation_TAO_RPC_UNKNOWN          TaoRPCOperation = 0
-	TaoRPCOperation_TAO_RPC_GET_RANDOM_BYTES TaoRPCOperation = 1
-	TaoRPCOperation_TAO_RPC_SEAL             TaoRPCOperation = 2
-	TaoRPCOperation_TAO_RPC_UNSEAL           TaoRPCOperation = 3
-	TaoRPCOperation_TAO_RPC_ATTEST           TaoRPCOperation = 4
-	TaoRPCOperation_TAO_RPC_GET_TAO_NAME     TaoRPCOperation = 5
-	TaoRPCOperation_TAO_RPC_EXTEND_TAO_NAME  TaoRPCOperation = 6
+	TaoRPCOperation_TAO_RPC_UNKNOWN           TaoRPCOperation = 0
+	TaoRPCOperation_TAO_RPC_GET_RANDOM_BYTES  TaoRPCOperation = 1
+	TaoRPCOperation_TAO_RPC_SEAL              TaoRPCOperation = 2
+	TaoRPCOperation_TAO_RPC_UNSEAL            TaoRPCOperation = 3
+	TaoRPCOperation_TAO_RPC_ATTEST            TaoRPCOperation = 4
+	TaoRPCOperation_TAO_RPC_GET_TAO_NAME      TaoRPCOperation = 5
+	TaoRPCOperation_TAO_RPC_EXTEND_TAO_NAME   TaoRPCOperation = 6
+	TaoRPCOperation_TAO_RPC_GET_SHARED_SECRET TaoRPCOperation = 7
 )
 
 var TaoRPCOperation_name = map[int32]string{
 	0: "TAO_RPC_UNKNOWN",
 	1: "TAO_RPC_GET_RANDOM_BYTES",
 	2: "TAO_RPC_SEAL",
 	3: "TAO_RPC_UNSEAL",
 	4: "TAO_RPC_ATTEST",
 	5: "TAO_RPC_GET_TAO_NAME",
 	6: "TAO_RPC_EXTEND_TAO_NAME",
+	7: "TAO_RPC_GET_SHARED_SECRET",
 }
 var TaoRPCOperation_value = map[string]int32{
-	"TAO_RPC_UNKNOWN":          0,
-	"TAO_RPC_GET_RANDOM_BYTES": 1,
-	"TAO_RPC_SEAL":             2,
-	"TAO_RPC_UNSEAL":           3,
-	"TAO_RPC_ATTEST":           4,
-	"TAO_RPC_GET_TAO_NAME":     5,
-	"TAO_RPC_EXTEND_TAO_NAME":  6,
+	"TAO_RPC_UNKNOWN":           0,
+	"TAO_RPC_GET_RANDOM_BYTES":  1,
+	"TAO_RPC_SEAL":              2,
+	"TAO_RPC_UNSEAL":            3,
+	"TAO_RPC_ATTEST":            4,
+	"TAO_RPC_GET_TAO_NAME":      5,
+	"TAO_RPC_EXTEND_TAO_NAME":   6,
+	"TAO_RPC_GET_SHARED_SECRET": 7,
 }
 
 func (x TaoRPCOperation) Enum() *TaoRPCOperation {
 	p := new(TaoRPCOperation)
 	*p = x
 	return p
 }
 func (x TaoRPCOperation) String() string {
 	return proto.EnumName(TaoRPCOperation_name, int32(x))
 }
 func (x *TaoRPCOperation) UnmarshalJSON(data []byte) error {
 	value, err := proto.UnmarshalJSONEnum(TaoRPCOperation_value, data, "TaoRPCOperation")
 	if err != nil {
 		return err
 	}
 	*x = TaoRPCOperation(value)
 	return nil
 }
 
 type TaoRPCRequest struct {
diff --git a/go/src/cloudproxy/tao/tao_server.go b/go/src/cloudproxy/tao/tao_server.go
index 41898ee..1d44038 100644
--- a/go/src/cloudproxy/tao/tao_server.go
+++ b/go/src/cloudproxy/tao/tao_server.go
@@ -1,73 +1,73 @@
 package tao
 
 import (
 	"errors"
 
-  "code.google.com/p/goprotobuf/proto"
+	"code.google.com/p/goprotobuf/proto"
 )
 
 type TaoServer struct {
 	T Tao
 }
 
 func (ts *TaoServer) GetRandomBytes(r *TaoRPCRequest, s *TaoRPCResponse) error {
 	if r.GetRpc() != TaoRPCOperation_TAO_RPC_GET_RANDOM_BYTES {
 		return errors.New("wrong RPC type")
 	}
 
 	if r.GetSize() <= 0 {
 		return errors.New("Invalid array size")
 	}
 
 	s.Data = make([]byte, r.GetSize())
 	return ts.T.GetRandomBytes(s.GetData())
 }
 
 func (ts *TaoServer) Seal(r *TaoRPCRequest, s *TaoRPCResponse) error {
 	if r.GetRpc() != TaoRPCOperation_TAO_RPC_SEAL {
 		return errors.New("wrong RPC type")
 	}
 
-  sealed, err := ts.T.Seal(r.GetData(), []byte(r.GetPolicy()))
-  if err != nil {
-    return err
-  }
+	sealed, err := ts.T.Seal(r.GetData(), []byte(r.GetPolicy()))
+	if err != nil {
+		return err
+	}
 
-  s.Data = sealed
+	s.Data = sealed
 	return nil
 }
 
 func (ts *TaoServer) Unseal(r *TaoRPCRequest, s *TaoRPCResponse) error {
 	if r.GetRpc() != TaoRPCOperation_TAO_RPC_UNSEAL {
 		return errors.New("wrong RPC type")
 	}
 
-  data, policy, err := ts.T.Unseal(r.GetData())
-  if err != nil {
-    return err
-  }
+	data, policy, err := ts.T.Unseal(r.GetData())
+	if err != nil {
+		return err
+	}
 
-  s.Data = data
-  s.Policy = proto.String(string(policy))
+	s.Data = data
+	s.Policy = proto.String(string(policy))
 	return nil
 }
 
 func (ts *TaoServer) Attest(r *TaoRPCRequest, s *TaoRPCResponse) error {
 	if r.GetRpc() != TaoRPCOperation_TAO_RPC_ATTEST {
 		return errors.New("wrong RPC type")
 	}
 
-  stmt := new(Statement)
-  err := proto.Unmarshal(r.GetData(), stmt)
-  if err != nil {
-    return err
-  }
+	stmt := new(Statement)
+	err := proto.Unmarshal(r.GetData(), stmt)
+	if err != nil {
+		return err
+	}
 
-  a, err := ts.T.Attest(stmt)
-  if err != nil {
-    return err
-  }
+	a, err := ts.T.Attest(stmt)
+	if err != nil {
+		return err
+	}
 
-  s.Data, err = proto.Marshal(a)
+	s.Data, err = proto.Marshal(a)
 	return nil
 }
