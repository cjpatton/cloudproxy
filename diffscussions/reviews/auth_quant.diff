#* 
#* author: Kevin Walsh
#* email: kwalsh@holycross.edu
#* date: 2014-08-19T14:31:31-0400
#* 
#- tweak install.sh, run server in fg
#- 
#- 
#- added MakePredicate helper
#- 
#- 
#- spelling
#- 
#- 
#- auth logic quantification
#- 
#- Added TermVar, Forall, and Exists. TermVar uses a plain Identifier
#- with no parens, so Pred and PrinExt are now always printed with
#- parens. Says and Speaksfor now take a Term on the left.
#- 
#- 
#- remove some extra parens in auth print
#- 
#- 
#- fixed three BUGs in auth scanning
#- 
#- 
#- update auth doc
#- 
#- 
#- auth Bytes type
#- 
#- 
#- refactor auth String, ShortString, Format
#- 
#- 
#- added missing delegator in delegations
#- 
#- 
#- auth.Bytes; auth.Prin key is Term not str; base64 alternate text
#- 
#- 
#- test for ptr satisfying interface
#- 
#- 
diff --git a/go/install.sh b/go/install.sh
index 4320da7..208983f 100755
--- a/go/install.sh
+++ b/go/install.sh
@@ -324,42 +324,42 @@ function refresh()
 			fi
 		done
 	fi
 	tao_admin -show
 
 	# TODO(kwalsh) set up fserver user ACLs here.
 	#tao_admin -newusers tmroeder,jlm
 	#tao_admin -signacl ${TAO_ROOTDIR}/run/acls.ascii -acl_sig_path user_acls_sig
 	#mkdir -p file_client_files
 	#mkdir -p file_server_files
 	#mkdir -p file_server_meta
 
 	echo "Tao configuration is ready"
 }
 
 function startsvcs()
 {
 	if pgrep -x `shortname linux_host` >/dev/null; then
 		echo "LinuxHost service already running";
 	else
-		linux_host --service &
-		echo "LinuxTao service now running"
+		rm -f ${TAO_TEST}/linux_tao_host/admin_socket
+		linux_host --service
 	fi
 }
 
 function monitor()
 {
 	echo "Monitoring Tao files..."
 	(
 		cd ${TAO_TEST}
 		while true; do
 			inotifywait -e modify -e delete -e attrib $watchfiles >/dev/null 2>&1
 			echo "Files have changed, waiting for quiet..."
 			sleep 1
 			while inotifywait -t 3 -e modify -e delete -e attrib $watchfiles >/dev/null 2>&1; do
 				echo "Still waiting for quiet..."
 				sleep 1
 			done
 			echo "Restarting Tao services..."
 			refresh
 			stoptests
 			startsvcs
diff --git a/go/src/cloudproxy/tao/attestation.go b/go/src/cloudproxy/tao/attestation.go
index 6e4c93d..c253010 100644
--- a/go/src/cloudproxy/tao/attestation.go
+++ b/go/src/cloudproxy/tao/attestation.go
@@ -49,86 +49,97 @@ func (a *Attestation) ValidSigner() (auth.Prin, error) {
 		if !ok {
 			return auth.Prin{}, newError("tao: attestation signature invalid")
 		}
 		return signer, nil
 	default:
 		return auth.Prin{}, newError("tao: attestation signer principal unrecognized: %s", signer.String())
 	}
 }
 
 // Validate checks whether an attestation is valid and, if so, it returns the
 // statement conveyed by the attestation.
 func (a *Attestation) Validate() (auth.Says, error) {
 	signer, err := a.ValidSigner()
 	if err != nil {
 		return auth.Says{}, err
 	}
 	f, err := auth.UnmarshalForm(a.SerializedStatement)
 	if err != nil {
 		return auth.Says{}, err
 	}
-	stmt, ok := f.(auth.Says)
-	if !ok {
+	var stmt *auth.Says
+	if ptr, ok := f.(*auth.Says); ok {
+		stmt = ptr
+	} else if val, ok := f.(auth.Says); ok {
+		stmt = &val
+	} else {
 		return auth.Says{}, newError("tao: attestation statement has wrong type: %T", f)
 	}
 	if a.SerializedDelegation == nil {
 		// Case (1), no delegation present.
 		// Require that stmt.Speaker be a subprincipal of (or identical to) a.signer.
 		if !auth.SubprinOrIdentical(stmt.Speaker, signer) {
 			return auth.Says{}, newError("tao: attestation statement signer does not evidently speak for issuer")
 		}
 	} else {
 		// Case (2), delegation present.
 		// Require that:
 		// - delegation conveys delegator says delegate speaksfor delegator,
 		// - a.signer speaks for delegate
 		// - and delegator speaks for s.Speaker
 		var da Attestation
 		if err := proto.Unmarshal(a.SerializedDelegation, &da); err != nil {
 			return auth.Says{}, err
 		}
 		delegationStatement, err := da.Validate()
 		if err != nil {
 			return auth.Says{}, err
 		}
-		delegation, ok := delegationStatement.Message.(auth.Speaksfor)
-		if !ok || !delegationStatement.Speaker.Identical(delegation.Delegator) {
+		var delegation *auth.Speaksfor
+		if ptr, ok := delegationStatement.Message.(*auth.Speaksfor); ok {
+			delegation = ptr
+		} else if val, ok := delegationStatement.Message.(auth.Speaksfor); ok {
+			delegation = &val
+		} else {
+			return auth.Says{}, newError("tao: attestation delegation is wrong type")
+		}
+		if !delegationStatement.Speaker.Identical(delegation.Delegator) {
 			return auth.Says{}, newError("tao: attestation delegation is invalid")
 		}
 		if !auth.SubprinOrIdentical(delegation.Delegate, signer) {
 			return auth.Says{}, newError("tao: attestation delegation irrelevant to signer")
 		}
 		if !auth.SubprinOrIdentical(stmt.Speaker, delegation.Delegator) {
 			return auth.Says{}, newError("tao: attestation delegation irrelevant to issuer")
 		}
 		if stmt.Time == nil {
 			stmt.Time = delegationStatement.Time
 		} else if delegationStatement.Time != nil && *stmt.Time < *delegationStatement.Time {
 			stmt.Time = delegationStatement.Time
 		}
 		if stmt.Expiration == nil {
 			stmt.Expiration = delegationStatement.Expiration
 		} else if delegationStatement.Expiration != nil && *stmt.Expiration > *delegationStatement.Expiration {
 			stmt.Expiration = delegationStatement.Expiration
 		}
 	}
-	return stmt, nil
+	return *stmt, nil
 }
 
 // GenerateAttestation uses the signing key to generate an attestation for this
 // statement.
 func GenerateAttestation(s *Signer, delegation []byte, stmt auth.Says) (*Attestation, error) {
 	signer := s.ToPrincipal()
 
 	t := time.Now()
 	if stmt.Time == nil {
 		i := t.UnixNano()
 		stmt.Time = &i
 	}
 
 	if stmt.Expiration == nil {
 		i := t.Add(365 * 24 * time.Hour).UnixNano()
 		stmt.Expiration = &i
 	}
 
 	ser := auth.Marshal(stmt)
 
diff --git a/go/src/cloudproxy/tao/auth/ast.go b/go/src/cloudproxy/tao/auth/ast.go
index 9a9abf6..11ad7b7 100644
--- a/go/src/cloudproxy/tao/auth/ast.go
+++ b/go/src/cloudproxy/tao/auth/ast.go
@@ -28,240 +28,354 @@ type AuthLogicElement interface {
 
 	// String returns verbose pretty-printing text for the element.
 	String() string
 
 	// ShortString returns short debug-printing text for the element.
 	ShortString() string
 
 	// fmt.Formatter is satisfied by all elements. Using format %v will result in
 	// verbose pretty-printing, using format %s will result in short
 	// debug-printing, and other formats will use an unspecified format.
 	fmt.Formatter // Format(out fmt.State, verb rune)
 
 	isAuthLogicElement() // marker
 }
 
 // isAuthLogicElement ensures only appropriate types can be assigned to an
 // AuthLogicElement.
 func (t Prin) isAuthLogicElement()      {}
 func (t SubPrin) isAuthLogicElement()   {}
 func (t Str) isAuthLogicElement()       {}
+func (t Bytes) isAuthLogicElement()     {}
 func (t Int) isAuthLogicElement()       {}
+func (t TermVar) isAuthLogicElement()   {}
 func (f Pred) isAuthLogicElement()      {}
 func (f Const) isAuthLogicElement()     {}
 func (f Not) isAuthLogicElement()       {}
 func (f And) isAuthLogicElement()       {}
 func (f Or) isAuthLogicElement()        {}
 func (f Implies) isAuthLogicElement()   {}
 func (f Speaksfor) isAuthLogicElement() {}
 func (f Says) isAuthLogicElement()      {}
+func (f Forall) isAuthLogicElement()    {}
+func (f Exists) isAuthLogicElement()    {}
 
 // These declarations ensure all the appropriate types can be assigned to an
 // AuthLogicElement.
 var _ AuthLogicElement = Prin{}
 var _ AuthLogicElement = SubPrin{}
 var _ AuthLogicElement = Str("")
+var _ AuthLogicElement = Bytes(nil)
 var _ AuthLogicElement = Int(0)
+var _ AuthLogicElement = TermVar("X")
 var _ AuthLogicElement = Pred{}
 var _ AuthLogicElement = Const(false)
 var _ AuthLogicElement = Not{}
 var _ AuthLogicElement = And{}
 var _ AuthLogicElement = Or{}
 var _ AuthLogicElement = Implies{}
 var _ AuthLogicElement = Speaksfor{}
 var _ AuthLogicElement = Says{}
+var _ AuthLogicElement = Forall{}
+var _ AuthLogicElement = Exists{}
 
 // These declarations ensure all the appropriate types can be assigned to a
 // fmt.Scanner.
 var _ fmt.Scanner = &Prin{}
 var _ fmt.Scanner = &SubPrin{}
 var _ fmt.Scanner = new(Str)
+var _ fmt.Scanner = new(Bytes)
 var _ fmt.Scanner = new(Int)
+var _ fmt.Scanner = new(TermVar)
 var _ fmt.Scanner = &Pred{}
 var _ fmt.Scanner = new(Const)
 var _ fmt.Scanner = &Not{}
 var _ fmt.Scanner = &And{}
 var _ fmt.Scanner = &Or{}
 var _ fmt.Scanner = &Implies{}
 var _ fmt.Scanner = &Speaksfor{}
 var _ fmt.Scanner = &Says{}
+var _ fmt.Scanner = &Forall{}
+var _ fmt.Scanner = &Exists{}
 var _ fmt.Scanner = &AnyForm{}
 var _ fmt.Scanner = &AnyTerm{}
 
 // Prin uniquely identifies a principal by a public key, used to verify
 // signatures on credentials issued by the principal, and a sequence of zero or
 // more extensions to identify the subprincipal of that key.
 type Prin struct {
 	Type string  // either "key" or "tpm"
-	Key  []byte  // a marshalled CryptoKey protobuf structure with purpose CryptoKey.VERIFYING
+	Key  Term    // TermVar or Bytes with marshalled CryptoKey protobuf structure with purpose CryptoKey.VERIFYING
 	Ext  SubPrin // one or more extensions for descendents
 }
 
 // PrinExt is an extension of a principal.
 type PrinExt struct {
 	Name string // [A-Z][a-zA-Z0-9_]*
 	Arg  []Term
 }
 
 // SubPrin is a series of extensions of a principal.
 type SubPrin []PrinExt
 
 // Term is an argument to a predicate or a principal extension.
 type Term interface {
 	AuthLogicElement
 	Identical(other Term) bool
 	isTerm() // marker
 }
 
 // isTerm ensures only appropriate types can be assigned to a Term.
-func (t Prin) isTerm() {}
-func (t Str) isTerm()  {}
-func (t Int) isTerm()  {}
+func (t Prin) isTerm()    {}
+func (t Str) isTerm()     {}
+func (t Bytes) isTerm()   {}
+func (t Int) isTerm()     {}
+func (t TermVar) isTerm() {}
 
 // Str is a string used as a Term.
 type Str string
 
+// Bytes is a byte slice used as a Term.
+type Bytes []byte
+
 // Int is an int used as a Term.
 type Int int
 
+// TermVar is a term-valued variable.
+type TermVar string
+
 // Form is a formula in the Tao authorization logic.
 type Form interface {
 	AuthLogicElement
 	isForm() // marker
 }
 
 // isForm ensures only appropriate types can be assigned to a Form.
 func (f Pred) isForm()      {}
 func (f Const) isForm()     {}
 func (f Not) isForm()       {}
 func (f And) isForm()       {}
 func (f Or) isForm()        {}
 func (f Implies) isForm()   {}
 func (f Speaksfor) isForm() {}
 func (f Says) isForm()      {}
+func (f Forall) isForm()    {}
+func (f Exists) isForm()    {}
 
 // Pred is a predicate, i.e. a boolean-valued (pure) function.
 type Pred struct {
 	Name string // [A-Z][a-zA-Z0-9_]*
 	Arg  []Term
 }
 
 // Const conveys formula "true" or formula "false"
 type Const bool
 
 // Not conveys formula "not Negand"
 type Not struct {
 	Negand Form
 }
 
 // And conveys formula "Conjunct[0] and Conjunct[1] and ... and Conjunct[n]"
 type And struct {
 	Conjunct []Form
 }
 
 // Or conveys formula "Disjunct[0] or Disjunct[1] or ... or Disjunct[n]"
 type Or struct {
 	Disjunct []Form
 }
 
 // Implies conveys formula "Antecedent implies Consequent"
 type Implies struct {
 	Antecedent Form
 	Consequent Form
 }
 
 // Speaksfor conveys formula "Delegate speaksfor Delegator"
 type Speaksfor struct {
-	Delegate  Prin
-	Delegator Prin
+	Delegate  Term
+	Delegator Term
 }
 
 // Says conveys formula "Speaker from Time until Expiration says Message"
 type Says struct {
-	Speaker    Prin
+	Speaker    Term
 	Time       *int64 // nil to omit
 	Expiration *int64 // nil to omit
 	Message    Form
 }
 
 // Commences checks if statement f has a commencement time.
 func (f Says) Commences() bool {
 	return f.Time != nil
 }
 
 // Expires checks if statement f has an expiration time.
 func (f Says) Expires() bool {
 	return f.Expiration != nil
 }
 
+// Forall conveys formula "(forall Var : Body)" where Var ranges over Terms.
+type Forall struct {
+	Var  string
+	Body Form
+}
+
+// Exists conveys formula "(exists Var : Body)" where Var ranges over Terms.
+type Exists struct {
+	Var  string
+	Body Form
+}
+
 // Identical checks if an Int is identical to another Term.
 func (t Int) Identical(other Term) bool {
 	return t == other
 }
 
 // Identical checks if a Str is identical to another Term.
 func (t Str) Identical(other Term) bool {
 	return t == other
 }
 
-// Identical checks if a Prin is identical to another Term.
-func (t Prin) Identical(other Term) bool {
-	p, ok := other.(Prin)
-	if !ok {
+// Identical checks if a Bytes is identical to another Term.
+func (t Bytes) Identical(other Term) bool {
+	// other must be type Bytes or *Bytes
+	var b *Bytes
+	if ptr, ok := other.(*Bytes); ok {
+		b = ptr
+	} else if val, ok := other.(Bytes); ok {
+		b = &val
+	} else {
 		return false
 	}
-	if t.Type != p.Type || !bytes.Equal(t.Key, p.Key) || len(t.Ext) != len(p.Ext) {
+	return bytes.Equal([]byte(t), []byte(*b))
+}
+
+// Identical checks if a Prin is identical to another Term.
+func (t Prin) Identical(other Term) bool {
+	// other must be type Prin or *Prin
+	var p *Prin
+	if ptr, ok := other.(*Prin); ok {
+		p = ptr
+	} else if val, ok := other.(Prin); ok {
+		p = &val
+	} else {
 		return false
 	}
-	for i, e := range t.Ext {
-		if !e.Identical(p.Ext[i]) {
-			return false
-		}
-	}
-	return true
+	return t.Type == p.Type && t.Key.Identical(p.Key) && t.Ext.Identical(p.Ext)
+}
+
+// Identical checks if a TermVar is identical to another Term.
+func (t TermVar) Identical(other Term) bool {
+	return t == other
 }
 
 // Identical checks if one PrinExt is identical to another.
 func (e PrinExt) Identical(other PrinExt) bool {
 	if e.Name != other.Name || len(e.Arg) != len(other.Arg) {
 		return false
 	}
 	for i, a := range e.Arg {
 		if !a.Identical(other.Arg[i]) {
 			return false
 		}
 	}
 	return true
 }
 
 // Identical checks if one SubPrin is identical to another.
 func (s SubPrin) Identical(other SubPrin) bool {
 	if len(s) != len(other) {
 		return false
 	}
 	for i, e := range s {
 		if !e.Identical(other[i]) {
 			return false
 		}
 	}
 	return true
 }
 
 // SubprinOrIdentical checks whether child is a subprincipal of parent or is
 // identical to parent.
-func SubprinOrIdentical(child, parent Prin) bool {
-	if parent.Type != child.Type || !bytes.Equal(parent.Key, child.Key) || len(parent.Ext) > len(child.Ext) {
+func SubprinOrIdentical(child, parent Term) bool {
+	// Both must be type Prin or *Prin
+	var c, p *Prin
+	if ptr, ok := child.(*Prin); ok {
+		c = ptr
+	} else if val, ok := child.(Prin); ok {
+		c = &val
+	} else {
+		return false
+	}
+	if ptr, ok := parent.(*Prin); ok {
+		p = ptr
+	} else if val, ok := parent.(Prin); ok {
+		p = &val
+	} else {
+		return false
+	}
+	if p.Type != c.Type || !p.Key.Identical(c.Key) || len(p.Ext) > len(c.Ext) {
 		return false
 	}
-	for i, a := range parent.Ext {
-		if !a.Identical(child.Ext[i]) {
+	for i, a := range p.Ext {
+		if !a.Identical(c.Ext[i]) {
 			return false
 		}
 	}
 	return true
 }
 
+// MakeSubprincipal creates principal p.e... given principal p and extensions e.
 func (p Prin) MakeSubprincipal(e SubPrin) Prin {
 	other := Prin{Type: p.Type, Key: p.Key, Ext: append([]PrinExt{}, p.Ext...)}
 	other.Ext = append(other.Ext, []PrinExt(e)...)
 	return other
 }
+
+// MakePredicate creates a predicate with the given name and arguments.
+// Arguments can be Prin, Int (or integer types that be coerced to it), Str (or
+// string), or Prin. Anything else is coerced to Str.
+func MakePredicate(name string, arg ...interface{}) Pred {
+	terms := make([]Term, len(arg))
+	for i, a := range arg {
+		switch a := a.(type) {
+		case Int:
+			terms[i] = a
+		case Str:
+			terms[i] = a
+		case Bytes:
+			terms[i] = a
+		case Prin:
+			terms[i] = a
+		case *Int:
+			terms[i] = a
+		case *Str:
+			terms[i] = a
+		case *Bytes:
+			terms[i] = a
+		case *Prin:
+			terms[i] = a
+		case int:
+			terms[i] = Int(a)
+		case int32:
+			terms[i] = Int(int(a))
+		case int16:
+			terms[i] = Int(int(a))
+		case byte:
+			terms[i] = Int(int(a))
+		case string:
+			terms[i] = Str(a)
+		case []byte:
+			terms[i] = Bytes(a)
+		default:
+			terms[i] = Str(fmt.Sprintf("%v", a))
+		}
+	}
+	return Pred{name, terms}
+}
+
+// NewKeyPrin returns a new Prin of type "key" with the given key material.
+func NewKeyPrin(material []byte) Prin {
+	return Prin{Type: "key", Key: Bytes(material)}
+}
diff --git a/go/src/cloudproxy/tao/auth/auth_test.go b/go/src/cloudproxy/tao/auth/auth_test.go
index 72e1921..c1ebb2b 100644
--- a/go/src/cloudproxy/tao/auth/auth_test.go
+++ b/go/src/cloudproxy/tao/auth/auth_test.go
@@ -4,69 +4,71 @@
 // you may not use this file except in compliance with the License.
 // You may obtain a copy of the License at
 //
 //     http://www.apache.org/licenses/LICENSE-2.0
 //
 // Unless required by applicable law or agreed to in writing, software
 // distributed under the License is distributed on an "AS IS" BASIS,
 // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
 package auth
 
 import (
 	"fmt"
 	"strings"
 	"testing"
 )
 
 var key []string = []string{
-	`key("S2V5MQo=")`, // base64w("Key1")
-	`key("S2V5Mgo=")`, // base64w("Key2")
-	`tpm("S2V5Mwo=")`, // base64w("Key3")
+	`key([4b657930])`, // hex("Key1")
+	`key([4b657931])`, // hex("Key2")
+	`tpm({S2V5Mw==})`, // base64w("Key3")
 }
 
 var termtests []string = []string{
 	"42",
 	"0",
 	"-1",
 	`"Hello World"`,
 	`"Includes \n newlines and \t tabs"`,
+	"[010203abcdef]",
 	key[0],
 	key[1],
 	key[0] + ".Extension(1)",
-	key[0] + `.Extension(1).A.B(1).C(1, "Hello").D(` + key[1] + `.E(` + key[2] + `.G.H))`,
-	key[0] + ".E()",
+	key[0] + `.Extension(1).A().B(1).C(1, "Hello").D(` + key[1] + `.E(` + key[1] + `.G().H()))`,
+	key[0] + ".E(" + key[2] + ")",
+	"[01 02 03abcd ef]",
 }
 
 func TestParseTerm(t *testing.T) {
 	for i, s := range termtests {
 		var x AnyTerm
 		n, err := fmt.Sscanf(s, "%v", &x)
 		if err != nil {
 			t.Fatal(err.Error())
 		}
 		if n != 1 {
 			t.Fatal("incomplete parse")
 		}
-		if (i != len(termtests)-1) != (x.Term.String() == s) {
+		if (i < len(termtests)-2) != (x.Term.String() == s) {
 			t.Fatalf("bad print: %v vs %v", x.Term.String(), s)
 		}
 	}
 
 	s := termtests[0] + " " + termtests[3] + " " + termtests[4] + " " + termtests[6]
 	var w, x, y, z AnyTerm
 	n, err := fmt.Sscanf(s, "%v %v %v %v", &w, &x, &y, &z)
 	if err != nil {
 		t.Fatal(err.Error())
 	}
 	if n != 4 {
 		t.Fatal("incomplete parse")
 	}
 }
 
 func TestBinaryTerm(t *testing.T) {
 	for _, s := range termtests {
 		var x AnyTerm
 		fmt.Sscanf("("+s+")", "%v", &x)
 		f := x.Term
@@ -89,130 +91,138 @@ func TestScanTerm(t *testing.T) {
 		t.Fatal(err.Error())
 	}
 	if n != 2 || i1 != Int(42) || i2 != Int(-17) {
 		t.Fatal("incomplete parse")
 	}
 
 	var s1, s2 Str
 	n, err = fmt.Sscanf(`"a" "b"`, "%v %v", &s1, &s2)
 	if err != nil {
 		t.Fatal(err.Error())
 	}
 	if n != 2 || s1 != Str("a") || s2 != Str("b") {
 		t.Fatal("incomplete parse")
 	}
 
 	var p Prin
 	n, err = fmt.Sscanf(key[0]+`.A(1).B("2", "3")`, "%v", &p)
 	if err != nil {
 		t.Fatal(err.Error())
 	}
-	p2 := Prin{Key: []byte("abc"), Ext: SubPrin{
+	p2 := Prin{Type: "key", Key: Bytes([]byte("abc")), Ext: SubPrin{
 		PrinExt{"A", []Term{Int(1)}},
 		PrinExt{"B", []Term{Str("2"), Str("#")}},
 	}}
 	if n != 1 || p2.Identical(p) {
 		t.Fatal("incomplete parse")
 	}
 }
 
 func TestParseSentence(t *testing.T) {
 	var x Prin
 	s := `My name is ` + key[0] + `.Prog("foo", 1).Args("foo", "bar")`
 	n, err := fmt.Sscanf(s, "My name is %v", &x)
 	if err != nil {
 		t.Fatal(err.Error())
 	}
 	if n != 1 {
 		t.Fatal("incomplete parse")
 	}
 }
 
 func TestParsePred(t *testing.T) {
 	predtests := []string{
 		`P(42)`,
-		`Foo`,
+		`Foo()`,
 		`Pred(1, 2, 3)`,
 		`Foo(1, "a", ` + key[0] + `)`,
 		`Foo()`,
 	}
 
 	for _, s := range predtests {
 		var x Pred
 		n, err := fmt.Sscanf(s, "%v", &x)
 		if err != nil {
 			t.Fatal(err.Error())
 		}
 		if n != 1 {
 			t.Fatal("incomplete parse")
 		}
 		if s != "Foo()" && x.String() != s {
 			t.Fatalf("bad print: %v vs %s", x.String(), s)
 		}
 	}
 
 	s := predtests[0] + " " + predtests[1] + " " + predtests[2] + " " + predtests[3]
 	var w, x, y, z Pred
 	n, err := fmt.Sscanf(s, "%v %v %v %v", &w, &x, &y, &z)
 	if err != nil {
 		t.Fatal(err.Error())
 	}
 	if n != 4 {
 		t.Fatal("incomplete parse")
 	}
 }
 
 var formtests []string = []string{
 	`true`,
 	`false`,
 	key[0] + ` says true`,
 	key[0] + ` from 1 says true`,
 	key[0] + ` until 2 says true`,
 	key[0] + ` from 1 until 2 says true`,
-	key[0] + ` speaksfor ` + key[2],
-	key[0] + `.Sub(1).Sub(2) speaksfor ` + key[2] + `.Sub(1).Sub`,
+	key[0] + ` speaksfor ` + key[1],
+	key[0] + `.Sub(1).Sub(2) speaksfor ` + key[1] + `.Sub(1).Sub(2)`,
 	`P(1)`,
 	`P(1) and P(2)`,
 	`P(1) and P(2) and P(3) and P(4)`,
 	`P(1) or P(2)`,
 	`P(1) or P(2) or P(3) or P(4)`,
 	`P(1) implies P(2)`,
 	`P(1) implies P(2) implies P(3) or P(4)`,
 	`not P(1)`,
 	`not not P(1)`,
 	`not not not not P(1)`,
-	`P(1) and (` + key[0] + ` speaksfor ` + key[2] + `)`,
+	`P(1) and ` + key[0] + ` speaksfor ` + key[1],
 	`P(1) and P(2) and P(3) or P(4)`,
 	`P(1) and P(2) and (P(3) or P(4))`,
 	`P(1) and (P(2) or P(3)) and P(4)`,
 	`(P(1) or P(2)) and P(3) and P(4)`,
 	`P(1) and P(2) and P(3) implies P(4)`,
 	`P(1) and P(2) and (P(3) implies P(4))`,
 	`P(1) and (P(2) implies P(3)) and P(4)`,
 	`(P(1) implies P(2)) and P(3) and P(4)`,
 	`P(1) or P(2) or P(3) implies P(4)`,
 	`P(1) or P(2) or (P(3) implies P(4))`,
 	`P(1) or (P(2) implies P(3)) or P(4)`,
 	`(P(1) implies P(2)) or P(3) or P(4)`,
-	`P(1) or (` + key[0] + ` says P(2) or P(3))`,
-	`P(1) or (` + key[0] + ` says P(2)) or P(3)`,
-	`(((P(((1)), ("a")))))`,
+	`P(1) or ` + key[0] + ` says P(2) or P(3)`,
+	`forall X: P(X)`,
+	`forall X: forall Y: P(X, Y)`,
+	`forall X: forall Y: P(X, Y)`,
+	`exists X: P(X)`,
+	`exists X: exists Y: P(X, Y)`,
+	`forall X: P(X) implies exists Y: Q(X, Y) and R(X)`,
+	`P(1) and forall X: Q(X)`,
+	`(forall X: Q(X)) and P(1)`,
+	`forall X: forall Y: X says P(1) implies Y says P(1)`,
+	`(((P(((1)), (` + key[2] + `)))))`,
 }
 
 func TestParseForm(t *testing.T) {
 	for i, s := range formtests {
 		var x AnyForm
 		n, err := fmt.Sscanf("("+s+")", "%v", &x)
 		if err != nil {
 			t.Fatal(err.Error())
 		}
 		if n != 1 {
 			t.Fatal("incomplete parse")
 		}
 		if i != len(formtests)-1 && x.Form.String() != s && "("+x.Form.String()+")" != s {
 			t.Fatalf("bad print: %v vs %s", x.Form.String(), s)
 		}
 
 		// Try parsing with the specific type
 		switch v := x.Form.(type) {
 		case Says:
 			n, err = fmt.Sscanf("("+s+")", "%v", &v)
@@ -221,59 +231,68 @@ func TestParseForm(t *testing.T) {
 			n, err = fmt.Sscanf("("+s+")", "%v", &v)
 			x.Form = v
 		case Implies:
 			n, err = fmt.Sscanf("("+s+")", "%v", &v)
 			x.Form = v
 		case And:
 			n, err = fmt.Sscanf("("+s+")", "%v", &v)
 			x.Form = v
 		case Or:
 			n, err = fmt.Sscanf("("+s+")", "%v", &v)
 			x.Form = v
 		case Not:
 			n, err = fmt.Sscanf("("+s+")", "%v", &v)
 			x.Form = v
 		case Pred:
 			n, err = fmt.Sscanf("("+s+")", "%v", &v)
 			x.Form = v
 		case Const:
 			n, err = fmt.Sscanf("("+s+")", "%v", &v)
 			x.Form = v
+		case Forall:
+			n, err = fmt.Sscanf("("+s+")", "%v", &v)
+			x.Form = v
+		case Exists:
+			n, err = fmt.Sscanf("("+s+")", "%v", &v)
+			x.Form = v
 		default:
 			t.Fatalf("not reached")
 		}
 		if err != nil {
 			t.Fatal(err.Error())
 		}
 		if n != 1 {
 			t.Fatal("incomplete parse")
 		}
 		if i != len(formtests)-1 && x.Form.String() != s && "("+x.Form.String()+")" != s {
 			t.Fatalf("bad print: %v vs %s", x.Form.String(), s)
 		}
 	}
 }
 
 func TestParseShortForm(t *testing.T) {
 	for _, s := range formtests {
 		var x, y AnyForm
-		fmt.Sscanf("("+s+")", "%v", &x)
+		_, err := fmt.Sscanf("("+s+")", "%v", &x)
+		if err != nil {
+			t.Fatal(err)
+		}
 		if x.Form.String() != x.Form.ShortString() {
 			t.Fatalf("bad short string: %s vs %s", x.Form.String(), x.Form.ShortString())
 		}
 
 		longstr := `"abcdefghijklmnopqrstuvwxyz"`
 		shortstr := `"abcdefghij"...`
 		short := strings.Replace(s, `"a"`, longstr, -1)
 		fmt.Sscanf("("+short+")", "%v", &y)
 		shortened := strings.Replace(x.Form.String(), `"a"`, shortstr, -1)
 		if shortened != y.Form.ShortString() {
 			t.Fatalf("bad short string: %s vs %s", y.Form.ShortString(), shortened)
 		}
 
 		if y.Form.String() != fmt.Sprintf("%v", y.Form) {
 			t.Fatalf("bad long format: %s vs %s", x.Form.String(), fmt.Sprintf("%v", x.Form))
 		}
 		if shortened != fmt.Sprintf("%s", y.Form) {
 			t.Fatalf("bad short format: %s vs %s", shortened, fmt.Sprintf("%s", x.Form))
 		}
 
@@ -327,20 +346,49 @@ func TestTrivialConjuncts(t *testing.T) {
 	p := And{}
 	if p.String() != "true" || p.ShortString() != p.String() {
 		t.Fatalf("bad print for empty conjunct ")
 	}
 	q := Or{}
 	if q.String() != "false" || q.ShortString() != q.String() {
 		t.Fatalf("bad print for empty disnjunct ")
 	}
 	var f AnyForm
 	s := "P(1, 2, 3)"
 	fmt.Sscanf(s, "%v", &f)
 	p = And{Conjunct: []Form{f.Form}}
 	if p.String() != s || p.ShortString() != s {
 		t.Fatalf("bad print for unary conjunct ")
 	}
 	q = Or{Disjunct: []Form{f.Form}}
 	if q.String() != s || q.ShortString() != s {
 		t.Fatalf("bad print for unary disnjunct ")
 	}
 }
+
+type ptest struct {
+	name string
+	args []interface{}
+	s    string
+}
+
+type testStringer bool
+
+func (t testStringer) String() string {
+	return "test"
+}
+
+func TestMakePredicate(t *testing.T) {
+	tests := []ptest{
+		ptest{"Foo", nil, "Foo()"},
+		ptest{"Foo", []interface{}{}, "Foo()"},
+		ptest{"Foo", []interface{}{1, 2, 3}, "Foo(1, 2, 3)"},
+		ptest{"Foo", []interface{}{"a", 2, Prin{Type: "key", Key: Bytes([]byte("abc"))}}, `Foo("a", 2, key([616263]))`},
+		ptest{"Foo", []interface{}{3.14, testStringer(false), true}, `Foo("3.14", "test", "true")`},
+	}
+
+	for _, test := range tests {
+		pred := MakePredicate(test.name, test.args...)
+		if pred.String() != test.s {
+			t.Fatalf("MakePredicate failed for %v vs. %v", test.s, pred)
+		}
+	}
+}
diff --git a/go/src/cloudproxy/tao/auth/binary.go b/go/src/cloudproxy/tao/auth/binary.go
index 8b6eeb8..7ca4f45 100644
--- a/go/src/cloudproxy/tao/auth/binary.go
+++ b/go/src/cloudproxy/tao/auth/binary.go
@@ -7,98 +7,135 @@
 //     http://www.apache.org/licenses/LICENSE-2.0
 //
 // Unless required by applicable law or agreed to in writing, software
 // distributed under the License is distributed on an "AS IS" BASIS,
 // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
 package auth
 
 // This file implements Marshal() and Unmarshal() functions for elements.
 
 import (
 	"fmt"
 )
 
 const (
 	_ = iota
 
 	// Term tags
-	tagPrin // string, []byte, SubPrin
-	tagStr  // string
-	tagInt  // int
+	tagPrin    // string, Term, SubPrin
+	tagStr     // string
+	tagBytes   // string
+	tagInt     // int
+	tagTermVar // string
 
 	// Form tags
 	tagPred      // string, []Term
 	tagConst     // bool
 	tagNot       // Form
 	tagAnd       // []Form
 	tagOr        // []Form
 	tagImplies   // Form, Form
 	tagSpeaksfor // Prin, Prin
 	tagSays      // Prin, bool+int, bool+int, Form
+	tagForall    // string, Form
+	tagExists    // string, Form
 
 	// Other tags
 	tagSubPrin // [](string, []Term)
 )
 
+// Context holds outer variable bindings in the order they appear.
+// Context []string
+//
+// (c *Context) push(q *string) {
+// 	c = append(c, q)
+// }
+//
+// (c *Context) pop() {
+// 	c = c[:len(c)-1]
+// }
+//
+// (c *Context) deBruijn(q *string) int {
+// 	n := len(c)
+// 	for i := n-1; i >= 0; i-- {
+// 		if c[i] == q {
+// 			return n-i
+// 		}
+// 	}
+// 	return 0
+// }
+
 // Marshal encodes a Form or Term.
 func Marshal(e AuthLogicElement) []byte {
 	buf := new(Buffer)
 	e.Marshal(buf)
 	return buf.Bytes()
 }
 
 // Marshal encodes a Prin.
 func (t Prin) Marshal(buf *Buffer) {
 	buf.EncodeVarint(tagPrin)
 	buf.EncodeString(t.Type)
-	buf.EncodeString(string(t.Key))
+	t.Key.Marshal(buf)
 	t.Ext.Marshal(buf)
 }
 
 // Marshal encodes a Prin.
 func (s SubPrin) Marshal(buf *Buffer) {
 	buf.EncodeVarint(tagSubPrin)
 	buf.EncodeVarint(int64(len(s)))
 	for _, e := range s {
 		buf.EncodeString(e.Name)
 		buf.EncodeVarint(int64(len(e.Arg)))
 		for _, a := range e.Arg {
 			a.Marshal(buf)
 		}
 	}
 }
 
 // Marshal encodes a Str.
 func (t Str) Marshal(buf *Buffer) {
 	buf.EncodeVarint(tagStr)
 	buf.EncodeString(string(t))
 }
 
+// Marshal encodes a Bytes.
+func (t Bytes) Marshal(buf *Buffer) {
+	buf.EncodeVarint(tagBytes)
+	buf.EncodeString(string(t))
+}
+
 // Marshal encodes an Int.
 func (t Int) Marshal(buf *Buffer) {
 	buf.EncodeVarint(tagInt)
 	buf.EncodeVarint(int64(t))
 }
 
+// Marshal encodes a TermVar.
+func (t TermVar) Marshal(buf *Buffer) {
+	buf.EncodeVarint(tagTermVar)
+	buf.EncodeString(string(t))
+}
+
 // Marshal encodes a Pred.
 func (f Pred) Marshal(buf *Buffer) {
 	buf.EncodeVarint(tagPred)
 	buf.EncodeString(f.Name)
 	buf.EncodeVarint(int64(len(f.Arg)))
 	for _, e := range f.Arg {
 		e.Marshal(buf)
 	}
 }
 
 // Marshal encodes a Const.
 func (f Const) Marshal(buf *Buffer) {
 	buf.EncodeVarint(tagConst)
 	buf.EncodeBool(bool(f))
 }
 
 // Marshal encodes a Not.
 func (f Not) Marshal(buf *Buffer) {
 	buf.EncodeVarint(tagNot)
 	f.Negand.Marshal(buf)
@@ -134,93 +171,105 @@ func (f Speaksfor) Marshal(buf *Buffer) {
 	buf.EncodeVarint(tagSpeaksfor)
 	f.Delegate.Marshal(buf)
 	f.Delegator.Marshal(buf)
 }
 
 // Marshal encodes a Says.
 func (f Says) Marshal(buf *Buffer) {
 	buf.EncodeVarint(tagSays)
 	f.Speaker.Marshal(buf)
 	buf.EncodeBool(f.Commences())
 	if f.Commences() {
 		buf.EncodeVarint(*f.Time)
 	}
 	buf.EncodeBool(f.Expires())
 	if f.Expires() {
 		buf.EncodeVarint(*f.Expiration)
 	}
 	f.Message.Marshal(buf)
 }
 
+// Marshal encodes a Forall.
+func (f Forall) Marshal(buf *Buffer) {
+	buf.EncodeVarint(tagForall)
+	buf.EncodeString(f.Var)
+	f.Body.Marshal(buf)
+}
+
+// Marshal encodes an Exists.
+func (f Exists) Marshal(buf *Buffer) {
+	buf.EncodeVarint(tagExists)
+	buf.EncodeString(f.Var)
+	f.Body.Marshal(buf)
+}
+
 // decodeStr decodes a Str without the leading tag.
 func decodeStr(buf *Buffer) (Str, error) {
 	s, err := buf.DecodeString()
 	return Str(s), err
 }
 
+// decodeBytes decodes a Bytes without the leading tag.
+func decodeBytes(buf *Buffer) (Bytes, error) {
+	s, err := buf.DecodeString()
+	return Bytes([]byte(s)), err
+}
+
 // decodeInt decodes an Int without the leading tag.
 func decodeInt(buf *Buffer) (Int, error) {
 	i, err := buf.DecodeVarint()
 	return Int(i), err
 }
 
+// decodeTermVar decodes a TermVar without the leading tag.
+func decodeTermVar(buf *Buffer) (TermVar, error) {
+	v, err := buf.DecodeString()
+	return TermVar(v), err
+}
+
 // decodeNameAndArgs decodes a name ad term array without leading tags.
 func decodeNameAndArgs(buf *Buffer) (name string, args []Term, err error) {
 	name, err = buf.DecodeString()
 	if err != nil {
 		return
 	}
 	n, err := buf.DecodeVarint()
 	args = make([]Term, n)
 	for i := int64(0); i < n; i++ {
 		args[i], err = unmarshalTerm(buf)
 		if err != nil {
 			return
 		}
 	}
 	return
 }
 
-// unmarshalPrin decodes a Prin.
-func unmarshalPrin(buf *Buffer) (p Prin, err error) {
-	tag, err := buf.DecodeVarint()
-	if err != nil {
-		return
-	}
-	if tag != tagPrin {
-		err = fmt.Errorf("unexpected tag: %d", tag)
-		return
-	}
-	return decodePrin(buf)
-}
-
 // decodePrin decodes a Prin without the leading tag.
 func decodePrin(buf *Buffer) (p Prin, err error) {
 	p.Type, err = buf.DecodeString()
 	if err != nil {
 		return
 	}
-	k, err := buf.DecodeString()
+	p.Key, err = unmarshalTerm(buf)
 	if err != nil {
 		return
 	}
-	p.Key = []byte(k)
 	p.Ext, err = unmarshalSubPrin(buf)
 	return
 }
 
 // unmarshalSubPrin decodes a SubPrin.
 func unmarshalSubPrin(buf *Buffer) (s SubPrin, err error) {
 	tag, err := buf.DecodeVarint()
 	if err != nil {
 		return
 	}
 	if tag != tagSubPrin {
 		err = fmt.Errorf("unexpected tag: %d", tag)
 		return
 	}
 	return decodeSubPrin(buf)
 }
 
 // decodeSubPrin decodes a SubPrin without the leading tag.
 func decodeSubPrin(buf *Buffer) (s SubPrin, err error) {
 	n, err := buf.DecodeVarint()
@@ -229,56 +278,60 @@ func decodeSubPrin(buf *Buffer) (s SubPrin, err error) {
 	}
 	for i := int64(0); i < n; i++ {
 		name, args, err := decodeNameAndArgs(buf)
 		if err != nil {
 			return s, err
 		}
 		s = append(s, PrinExt{name, args})
 	}
 	return
 }
 
 // unmarshalTerm decodes a Term.
 func unmarshalTerm(buf *Buffer) (t Term, err error) {
 	tag, err := buf.DecodeVarint()
 	if err != nil {
 		return nil, err
 	}
 	switch tag {
 	case tagStr:
 		return decodeStr(buf)
+	case tagBytes:
+		return decodeBytes(buf)
 	case tagInt:
 		return decodeInt(buf)
 	case tagPrin:
 		return decodePrin(buf)
+	case tagTermVar:
+		return decodeTermVar(buf)
 	default:
 		return nil, fmt.Errorf("unexpected tag: %d", tag)
 	}
 }
 
 // UnmarshalPrin decodes a Prin.
 func UnmarshalPrin(bytes []byte) (p Prin, err error) {
 	t, err := UnmarshalTerm(bytes)
 	if err != nil {
 		return
 	}
-	p, ok := t.(Prin)
+	p, ok := t.(Prin) // will always be value type here
 	if !ok {
 		err = fmt.Errorf("expected Prin, found %T", t)
 	}
 	return
 }
 
 // UnmarshalTerm decodes a Term.
 func UnmarshalTerm(bytes []byte) (Term, error) {
 	buf := &Buffer{bytes}
 	t, err := unmarshalTerm(buf)
 	if err != nil {
 		return nil, err
 	}
 	if len(buf.Bytes()) != 0 {
 		return nil, fmt.Errorf("unexpected trailing bytes")
 	}
 	return t, nil
 }
 
 // UnmarshalSubPrin decodes a SubPrin.
@@ -313,40 +366,44 @@ func unmarshalForm(buf *Buffer) (Form, error) {
 	if err != nil {
 		return nil, err
 	}
 	switch tag {
 	case tagPred:
 		return decodePred(buf)
 	case tagConst:
 		return decodeConst(buf)
 	case tagNot:
 		return decodeNot(buf)
 	case tagAnd:
 		return decodeAnd(buf)
 	case tagOr:
 		return decodeOr(buf)
 	case tagImplies:
 		return decodeImplies(buf)
 	case tagSpeaksfor:
 		return decodeSpeaksfor(buf)
 	case tagSays:
 		return decodeSays(buf)
+	case tagForall:
+		return decodeForall(buf)
+	case tagExists:
+		return decodeExists(buf)
 	default:
 		return nil, fmt.Errorf("unexpected tag: %d", tag)
 	}
 }
 
 // decodePred decodes a Pred without the leading tag.
 func decodePred(buf *Buffer) (Pred, error) {
 	name, args, err := decodeNameAndArgs(buf)
 	return Pred{name, args}, err
 }
 
 // decodeConst decodes a Const without the leading tag.
 func decodeConst(buf *Buffer) (Const, error) {
 	b, err := buf.DecodeBool()
 	return Const(b), err
 }
 
 // decodeNot decodes a Not without the leading tag.
 func decodeNot(buf *Buffer) (Not, error) {
 	f, err := unmarshalForm(buf)
@@ -380,59 +437,79 @@ func decodeOr(buf *Buffer) (or Or, err error) {
 		if err != nil {
 			return or, err
 		}
 		or.Disjunct = append(or.Disjunct, f)
 	}
 	return
 }
 
 // decodeImplies decodes an Implies without the leading tag.
 func decodeImplies(buf *Buffer) (implies Implies, err error) {
 	implies.Antecedent, err = unmarshalForm(buf)
 	if err != nil {
 		return
 	}
 	implies.Consequent, err = unmarshalForm(buf)
 	return
 }
 
 // decodeSpeaksfor decodes an Speaksfor without the leading tag.
 func decodeSpeaksfor(buf *Buffer) (sfor Speaksfor, err error) {
-	sfor.Delegate, err = unmarshalPrin(buf)
+	sfor.Delegate, err = unmarshalTerm(buf)
 	if err != nil {
 		return
 	}
-	sfor.Delegator, err = unmarshalPrin(buf)
+	sfor.Delegator, err = unmarshalTerm(buf)
 	return
 }
 
 // decodeSays decodes an Says without the leading tag.
 func decodeSays(buf *Buffer) (says Says, err error) {
-	says.Speaker, err = unmarshalPrin(buf)
+	says.Speaker, err = unmarshalTerm(buf)
 	if err != nil {
 		return
 	}
 	commences, err := buf.DecodeBool()
 	if err != nil {
 		return
 	}
 	if commences {
 		t, err := buf.DecodeVarint()
 		if err != nil {
 			return says, err
 		}
 		says.Time = &t
 	}
 	expires, err := buf.DecodeBool()
 	if err != nil {
 		return
 	}
 	if expires {
 		t, err := buf.DecodeVarint()
 		if err != nil {
 			return says, err
 		}
 		says.Expiration = &t
 	}
 	says.Message, err = unmarshalForm(buf)
 	return
 }
+
+// decodeForall decodes a Forall without the leading tag.
+func decodeForall(buf *Buffer) (forall Forall, err error) {
+	forall.Var, err = buf.DecodeString()
+	if err != nil {
+		return
+	}
+	forall.Body, err = unmarshalForm(buf)
+	return
+}
+
+// decodeExists decodes an Exists without the leading tag.
+func decodeExists(buf *Buffer) (exists Exists, err error) {
+	exists.Var, err = buf.DecodeString()
+	if err != nil {
+		return
+	}
+	exists.Body, err = unmarshalForm(buf)
+	return
+}
diff --git a/go/src/cloudproxy/tao/auth/doc.go b/go/src/cloudproxy/tao/auth/doc.go
index 8b4b3e9..5422d33 100644
--- a/go/src/cloudproxy/tao/auth/doc.go
+++ b/go/src/cloudproxy/tao/auth/doc.go
@@ -1,147 +1,167 @@
 // Copyright (c) 2014, Kevin Walsh.  All rights reserved.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
 // You may obtain a copy of the License at
 //
 //     http://www.apache.org/licenses/LICENSE-2.0
 //
 // Unless required by applicable law or agreed to in writing, software
 // distributed under the License is distributed on an "AS IS" BASIS,
 // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
 // Package auth supports Tao authorization and authentication, primarily by
 // defining and implementing a logic for describing principals, their trust
 // relationships, and their beliefs.
 //
 // The grammar for a formula in the logic is roughly:
-//   Form ::= Prin [from Time] [until Time] says Form
-//          | Prin speaksfor Prin
+//   Form ::= Term [from Time] [until Time] says Form
+//          | Term speaksfor Term
+//          | forall TermVar : Form
+//          | exists TermVar : Form
 //          | Form implies Form
 //          | Form or Form or ...
 //          | Form and Form and ...
 //          | not Form
 //          | Pred | false | true
 //
+// Quantification variables range over Terms.
+//  TermVar : Identifier
+//
 // Times are integers interpreted as 64-bit unix timestamps.
 //   Time ::= int64
 //
 // Predicates are like boolean-valued pure functions, with a name and zero or
 // more terms as arguments.
 //   Pred ::= Identifier(Term, Term, ...)
 //          | Identifier()
-//          | Identifier
 //
 // Terms are concrete values, like strings, integers, or names of principals.
-//   Term ::= string | int | Prin
+//   Term ::= Str | Bytes | Int | Prin | TermVar
+//
+// Int can be any Go int. Str is a double-quoted Go string. Bytes is written as
+// pairs of hex digits, optionally separated by whitespace, between square
+// brackets. Bytes can also be written as base64w without whitespace between
+// curly braces.
 //
 // Principal names specify a key, and zero or more extensions to specify a
 // sub-principal of that key.
-//   Prin ::= key(string)
-//          | key(string).PrinExt.PrinExt...
+//   Prin ::= key(Term)
+//          | key(Term).PrinExt.PrinExt...
 //   PrinExt ::= Identifier(Term, Term, ...)
 //             | Identifier()
-//             | Identifier
 //
-// Identifiers for predicate and principal extension names are limited to simple
-// ascii printable identifiers, with inital upper-case, and no punctuation
-// except '_':
+// Identifiers for predicate and principal extension names and quantification
+// variables are limited to simple ascii printable identifiers, with inital
+// upper-case, and no punctuation except '_':
 //   PredName ::= [A-Z][a-zA-Z0-9_]*
 //   ExtName ::= [A-Z][a-zA-Z0-9_]*
 //
 // The keywords used in the above grammar are:
-//   from, until, says, speaskfor, implies, or, and, not, false, true, key
-// The punctuation used are:
-//   '(', ')', ',', '.'
+//   from, until, says, speaskfor, forall, exists, implies, or, and, not, false,
+//   true, key
+// The punctuation used are those for strings and byte slices, plus:
+//   '(', ')', ',', '.', ':'
+//
+// It is possible to represent nonsensical formulas, so some sanity checking may
+// be called for. For example, in general:
+//   1. The left operand of Says should be Prin or TermVar, as should both
+//   operands of Speaksfor.
+//   2. All TermVar variables should be bound.
+//   3. Conjunctions should have at least one conjunct.
+//   4. Disjunctions should have at least one disjunct.
+//   5. Identifiers should be legal using the above rules.
+//   6. The parameter for key() should be TermVar or Bytes.
+// Specific applications may impose additional restrictions on the structure of
+// formulas they accept.
 //
 // All of the above elements have three distinct representations. The first
 // representation is ast-like, with each element represented by an appropriate
 // Go type, e.g. an int, a string, or a struct containing pointers (or
 // interfaces) for child elements. This representation is meant to be easy to
 // programmatically construct, split apart using type switches, rearrange,
 // traverse, etc.
 //
 // The second representation is textual, which is convenient for humans but
 // isn't canonical and can involve tricky parsing. When parsing elements from
-// text, whitespace is ignored between elements (except around the suprincipal
-// dot operator and before the open paren of a Pred, Prin, or, PrinExt), the
-// above list shows the productions in order of increasing precedence for binary
-// Form operators when parenthesis are omitted, parenthesis can be used for
-// specifying precedence explicitly, and elements of the same precedence are
-// parsed left to right. When pretty-printing elements to text, a single space
-// is used before and after keywords and after commas. Elements can also be
-// pretty-printed with elision, in which case keys and long strings are
-// truncated.
+// text:
+//   Whitespace is ignored between elements (except around the suprincipal dot
+//     operator, and before the open paren of a Pred, Prin, or, PrinExt);
+//   For binary operators taking two Forms, the above list shows the productions
+//     in order of increasing precedence;
+//   In all other cases, operations are parsed left to right;
+//   Parenthesis can be used for specifying precedence explicitly.
+// When pretty-printing elements to text, a single space is used before and
+// after keywords, commas, and colons. Elements can also be pretty-printed with
+// elision, in which case keys and long strings are truncated.
 //
 // The third representation is an encoded sequence of bytes. This is meant to be
 // compact, relatively easy to parse, and suitable for passing over sockets,
 // network connections, etc. The encoding format is custom-designed, but is
 // roughly similar to the format used by protobuf.
 //
 // Several alternative encodings were considered:
 //
 //   Protobuf encoding with protobuf definitions: This would require either
 //   duplicating all Form and Term types as proto definitions, then writing
 //   conversion and validation code. The encoding would likely not be space
 //   efficient, and it would be essentially Tao's only hard dependency on
 //   protobuf.
 //
 //   Protobuf encoding with hand-written encoding/decoding: The goprotobuf
 //   library currently lacks good support for this. Also, protobuf allows
 //   encoded data to be shuffled, making decoding much more complicated than
 //   necessary.
 //
 //   encoding/gob: Not language-agnostic. The self-describing datatype encoding
 //   scheme is probably overkill as well.
 //
 //   strings using textual representation of Form and Term elements: This
 //   pulls into all TCB a somewhat complex lexer and parser. The encoding is
 //   also not space efficient.
 //
 // The encoding we use instead is meant to be conceptually simple, reasonably
 // space efficient, and simple to decode. And unlike most of the other schemes
 // agove, strictness rather than flexibility is preferred. For example, when
 // decoding a Form used for authorization, unrecognized fields should not be
 // silently skipped, and unexpected types should not be silently coerced.
 //
 // Each element is encoded as a type tag followed by encodings for one or more
-// values. The tag is encoded as an plain (i.e. not zig-zag encoded) varint, and
+// values. The tag is encoded as a plain (i.e. not zig-zag encoded) varint, and
 // it determines the meaning, number, and types of the values. Values are
 // encoded according to their type:
 //
 //   An integer or bool is encoded as plain varint.
 //
 //   A string is encoded as a length (plain varint) followed by raw bytes.
 //
 //   A pointer is encoded the same as a boolean optionally followed by a value.
 //
 //   Variable-length slices (e.g. for conjuncts, disjuncts, predicate arguments)
 //   are encoded as a count (plain varint) followed by the encoding for the each
 //   element.
 //
 //   An embedded struct or interface is encoded as a tag and encoded value.
 //
 // Differences from protobuf:
 //
 //   Our tags carry implicit type information. In protobuf, the low 3 bits of
 //   each tag carries an explicit type marker. That allows protobuf to skip over
 //   unrecognized fields (not a design goal for us). It also means protobuf can
 //   only handle 15 unique tags before overflowing to 2 byte encodings.
 //
 //   Our tags describe both the meaning and the type of all enclosed values, and
 //   we use tags only when the meaning or type can vary (i.e. for interface
 //   types). Protobuf uses tags for every enclosed value, and those tags also
 //   carry type information. Protobuf is more efficient when there are many
 //   optional fields. For us, nearly all fields are required.
 //
 //   Enclosed values in our encoding must appear in order. Protobuf values can
 //   appear in any order. Protobuf encodings can concatenated, truncated, etc.,
 //   all non-features for us.
 //
 // Note: In most cases, a tag appears only when the type would be ambiguous,
-// i.e. when encoding Term or Form. When encoding Says and Speaksfor, however,
-// the enclosed Prin values are not ambiguous, but we include the tag anyway for
-// consistency since all other Prin values have a tag.
+// i.e. when encoding Term or Form.
 package auth
diff --git a/go/src/cloudproxy/tao/auth/format.go b/go/src/cloudproxy/tao/auth/format.go
index ac45696..a39e9dd 100644
--- a/go/src/cloudproxy/tao/auth/format.go
+++ b/go/src/cloudproxy/tao/auth/format.go
@@ -3,91 +3,259 @@
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
 // You may obtain a copy of the License at
 //
 //     http://www.apache.org/licenses/LICENSE-2.0
 //
 // Unless required by applicable law or agreed to in writing, software
 // distributed under the License is distributed on an "AS IS" BASIS,
 // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
 package auth
 
 // This file implements Format() functions for pretty-printing elements.
 // When printed with format verb %v, the "verbose" long form is used.
 // When printed with format verb %s, the "short" elided form is used.
 // When printed with other verbs, the output format is unspecified.
 
 import (
+	"encoding/base64"
 	"fmt"
 )
 
-// Format outputs a pretty-printed Form or Term.
-func format(out fmt.State, verb rune, e AuthLogicElement) {
-	if verb == 's' {
-		fmt.Fprintf(out, "%s", e.ShortString())
+// Format outputs a pretty-printed Prin.
+func (p Prin) Format(out fmt.State, verb rune) {
+	fmt.Fprintf(out, "%s(", p.Type)
+	p.Key.Format(out, verb)
+	fmt.Fprint(out, ")")
+	p.Ext.Format(out, verb)
+}
+
+// Format outputs a pretty-printed PrinExt.
+func (e PrinExt) Format(out fmt.State, verb rune) {
+	formatNameAndArg(out, e.Name, e.Arg, verb)
+}
+
+// formatNameAndArg outputs a pretty-printed name and argument list using short
+// or long formats.
+func formatNameAndArg(out fmt.State, name string, arg []Term, verb rune) {
+	fmt.Fprintf(out, "%s(", name)
+	for i, a := range arg {
+		if i > 0 {
+			fmt.Fprint(out, ", ")
+		}
+		a.Format(out, verb)
+	}
+	fmt.Fprint(out, ")")
+}
+
+// Format outputs a pretty-printed SubPrin.
+func (p SubPrin) Format(out fmt.State, verb rune) {
+	for _, e := range p {
+		fmt.Fprint(out, ".")
+		e.Format(out, verb)
+	}
+}
+
+// Format outputs a pretty-printed Str.
+func (t Str) Format(out fmt.State, verb rune) {
+	if verb == 's' && len(string(t)) > 15 {
+		fmt.Fprintf(out, "%.10q...", string(t))
 	} else {
-		fmt.Fprintf(out, "%s", e.String())
+		fmt.Fprintf(out, "%q", string(t))
 	}
 }
 
-// Format outputs a pretty-printed Prin using short or long formats.
-func (e Prin) Format(out fmt.State, verb rune) {
-	format(out, verb, e)
+// Format outputs a pretty-printed Bytes.
+func (t Bytes) Format(out fmt.State, verb rune) {
+	if out.Flag('#') {
+		// use alternate format: base64w
+		s := base64.URLEncoding.EncodeToString([]byte(t))
+		if verb == 's' && len(string(t)) > 25 {
+			fmt.Fprintf(out, "{%s...}", s[:20])
+		} else {
+			fmt.Fprintf(out, "{%s}", s)
+		}
+	} else {
+		// use default format: hex
+		if verb == 's' && len(string(t)) > 25 {
+			fmt.Fprintf(out, "[%02x...]", []byte(t)[:20])
+		} else {
+			fmt.Fprintf(out, "[%02x]", []byte(t))
+		}
+	}
 }
 
-// Format outputs a pretty-printed SubPrin using short or long formats.
-func (e SubPrin) Format(out fmt.State, verb rune) {
-	format(out, verb, e)
+// Format outputs a pretty-printed Int.
+func (t Int) Format(out fmt.State, verb rune) {
+	fmt.Fprintf(out, "%d", int64(t))
 }
 
-// Format outputs a pretty-printed Str using short or long formats.
-func (e Str) Format(out fmt.State, verb rune) {
-	format(out, verb, e)
+// Format outputs a pretty-printed TermVar.
+func (t TermVar) Format(out fmt.State, verb rune) {
+	fmt.Fprint(out, string(t))
 }
 
-// Format outputs a pretty-printed Int using short or long formats.
-func (e Int) Format(out fmt.State, verb rune) {
-	format(out, verb, e)
+// Format outputs a pretty-printed Pred.
+func (f Pred) Format(out fmt.State, verb rune) {
+	formatNameAndArg(out, f.Name, f.Arg, verb)
 }
 
-// Format outputs a pretty-printed Pred using short or long formats.
-func (e Pred) Format(out fmt.State, verb rune) {
-	format(out, verb, e)
+// Format outputs a pretty-printed Const.
+func (f Const) Format(out fmt.State, verb rune) {
+	if f == true {
+		fmt.Fprint(out, "true")
+	} else {
+		fmt.Fprint(out, "false")
+	}
 }
 
-// Format outputs a pretty-printed Const using short or long formats.
-func (e Const) Format(out fmt.State, verb rune) {
-	format(out, verb, e)
+// Format outputs a pretty-printed Not.
+func (f Not) Format(out fmt.State, verb rune) {
+	fmt.Fprint(out, "not ")
+	formatFormWithParens(out, precedenceHigh, true, f.Negand, verb)
 }
 
-// Format outputs a pretty-printed Not using short or long formats.
-func (e Not) Format(out fmt.State, verb rune) {
-	format(out, verb, e)
+// Format outputs a pretty-printed And.
+func (f And) Format(out fmt.State, verb rune) {
+	if len(f.Conjunct) == 0 {
+		fmt.Fprint(out, "true")
+	} else if len(f.Conjunct) == 1 {
+		f.Conjunct[0].Format(out, verb)
+	} else {
+		n := len(f.Conjunct)
+		for i, e := range f.Conjunct {
+			if i > 0 {
+				fmt.Fprint(out, " and ")
+			}
+			formatFormWithParens(out, precedenceAnd, i == n-1, e, verb)
+		}
+	}
 }
 
-// Format outputs a pretty-printed And using short or long formats.
-func (e And) Format(out fmt.State, verb rune) {
-	format(out, verb, e)
+// Format outputs a pretty-printed Or.
+func (f Or) Format(out fmt.State, verb rune) {
+	if len(f.Disjunct) == 0 {
+		fmt.Fprint(out, "false")
+	} else if len(f.Disjunct) == 1 {
+		f.Disjunct[0].Format(out, verb)
+	} else {
+		n := len(f.Disjunct)
+		for i, e := range f.Disjunct {
+			if i > 0 {
+				fmt.Fprint(out, " or ")
+			}
+			formatFormWithParens(out, precedenceOr, i == n-1, e, verb)
+		}
+	}
+}
+
+// Format outputs a pretty-printed Implies.
+func (f Implies) Format(out fmt.State, verb rune) {
+	formatFormWithParens(out, precedenceLow+1, false, f.Antecedent, verb)
+	fmt.Fprint(out, " implies ")
+	formatFormWithParens(out, precedenceLow, true, f.Consequent, verb)
 }
 
-// Format outputs a pretty-printed Or using short or long formats.
-func (e Or) Format(out fmt.State, verb rune) {
-	format(out, verb, e)
+// Format outputs a pretty-printed Speaksfor.
+func (f Speaksfor) Format(out fmt.State, verb rune) {
+	f.Delegate.Format(out, verb)
+	fmt.Fprint(out, " speaksfor ")
+	f.Delegator.Format(out, verb)
+}
+
+// Format outputs a pretty-printed Says.
+func (f Says) Format(out fmt.State, verb rune) {
+	f.Speaker.Format(out, verb)
+	if f.Commences() {
+		fmt.Fprintf(out, " from %d", *f.Time)
+	}
+	if f.Expires() {
+		fmt.Fprintf(out, " until %d", *f.Expiration)
+	}
+	fmt.Fprint(out, " says ")
+	f.Message.Format(out, verb)
 }
 
-// Format outputs a pretty-printed Implies using short or long formats.
-func (e Implies) Format(out fmt.State, verb rune) {
-	format(out, verb, e)
+// Format outputs a pretty-printed Forall.
+func (f Forall) Format(out fmt.State, verb rune) {
+	fmt.Fprintf(out, "forall %s: ", f.Var)
+	f.Body.Format(out, verb)
 }
 
-// Format outputs a pretty-printed Speaksfor using short or long formats.
-func (e Speaksfor) Format(out fmt.State, verb rune) {
-	format(out, verb, e)
+// Exists outputs a pretty-printed Exists.
+func (f Exists) Format(out fmt.State, verb rune) {
+	fmt.Fprintf(out, "exists %s: ", f.Var)
+	f.Body.Format(out, verb)
 }
 
-// Format outputs a pretty-printed Says using short or long formats.
-func (e Says) Format(out fmt.State, verb rune) {
-	format(out, verb, e)
+const (
+	precedenceLow = iota // lowest: implies, says, right speaksfor, right forall, right exists
+	precedenceOr
+	precedenceAnd
+	precedenceHigh // not, true, false, Pred, left speaksfor, left forall, left exists
+)
+
+// precedence returns an integer indicating the relative precedence of f.
+func precedence(f Form, right bool) int {
+	switch f := f.(type) {
+	case Says, Speaksfor, Forall, Exists, *Says, *Speaksfor, *Forall, *Exists:
+		if right {
+			return precedenceHigh
+		} else {
+			return precedenceLow
+		}
+	case Implies, *Implies:
+		return precedenceLow
+	case Or:
+		if len(f.Disjunct) == 0 {
+			return precedenceHigh // Or{} == false
+		} else if len(f.Disjunct) == 1 {
+			return precedence(f.Disjunct[0], right) // Or{f} == f
+		} else {
+			return precedenceOr
+		}
+	case *Or:
+		if len(f.Disjunct) == 0 {
+			return precedenceHigh // Or{} == false
+		} else if len(f.Disjunct) == 1 {
+			return precedence(f.Disjunct[0], right) // Or{f} == f
+		} else {
+			return precedenceOr
+		}
+	case And:
+		if len(f.Conjunct) == 0 {
+			return precedenceHigh // And{} == true
+		} else if len(f.Conjunct) == 1 {
+			return precedence(f.Conjunct[0], right) // And{f} == f
+		} else {
+			return precedenceAnd
+		}
+	case *And:
+		if len(f.Conjunct) == 0 {
+			return precedenceHigh // And{} == true
+		} else if len(f.Conjunct) == 1 {
+			return precedence(f.Conjunct[0], right) // And{f} == f
+		} else {
+			return precedenceAnd
+		}
+	case Not, Pred, Const, *Not, *Pred, *Const:
+		return precedenceHigh
+	default:
+		panic("not reached")
+	}
+}
+
+// formatFormWithParens outputs either f or (f), depending on how level compares
+// to the precedence of f and whether f appears on the right side of a binary
+// operator.
+func formatFormWithParens(out fmt.State, level int, right bool, f Form, verb rune) {
+	if level > precedence(f, right) {
+		fmt.Fprint(out, "(")
+		f.Format(out, verb)
+		fmt.Fprint(out, ")")
+	} else {
+		f.Format(out, verb)
+	}
 }
diff --git a/go/src/cloudproxy/tao/auth/lexer.go b/go/src/cloudproxy/tao/auth/lexer.go
index 2acea21..545650f 100644
--- a/go/src/cloudproxy/tao/auth/lexer.go
+++ b/go/src/cloudproxy/tao/auth/lexer.go
@@ -6,172 +6,231 @@
 //
 //     http://www.apache.org/licenses/LICENSE-2.0
 //
 // Unless required by applicable law or agreed to in writing, software
 // distributed under the License is distributed on an "AS IS" BASIS,
 // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
 // This code borrows from the lexer design and implementation described
 // by Rob Pike, "Lexical Scanning in Go", GTUG Sydney, Aug 30, 2011.
 // See: http://cuddle.googlecode.com/hg/talk/lex.html#slide-40
 //
 // It also borrows from the lexer in package
 // github.com/kevinawalsh/datalog/dlengine.
 
 package auth
 
 import (
 	"bytes"
+	"encoding/base64"
+	"encoding/hex"
 	"fmt"
 	"io"
 	"unicode"
 	"unicode/utf8"
 )
 
 // token is a value returned from the lexer.
 type token struct {
 	typ itemType
 	val interface{} // string, int64, error, or nil
 }
 
 // itemType identifies the type of lex items.
 type itemType int
 
 const (
 	itemError          itemType = iota // value contains error
 	itemUnexpectedRune                 // value contains the rune
 	itemEOF                            // value is nil
 	itemKeyword                        // value contains the keyword
 	itemIdentifier                     // value contains the identifer
 	itemStr                            // value contains the string
+	itemBytes                          // value contains the []byte slice
 	itemInt                            // value contains the int64
 	itemLP                             // value contains '('
 	itemRP                             // value contains ')'
 	itemComma                          // value contains ','
 	itemDot                            // value contains '.'
+	itemColon                          // value contains ':'
 	itemWhitespace                     // value contains ' ', '\t', '\n', etc.
 )
 
 var (
 	tokenFrom      = token{itemKeyword, "from"}
 	tokenUntil     = token{itemKeyword, "until"}
 	tokenSays      = token{itemKeyword, "says"}
 	tokenSpeaksfor = token{itemKeyword, "speaksfor"}
+	tokenForall    = token{itemKeyword, "forall"}
+	tokenExists    = token{itemKeyword, "exists"}
 	tokenImplies   = token{itemKeyword, "implies"}
 	tokenOr        = token{itemKeyword, "or"}
 	tokenAnd       = token{itemKeyword, "and"}
 	tokenNot       = token{itemKeyword, "not"}
 	tokenFalse     = token{itemKeyword, "false"}
 	tokenTrue      = token{itemKeyword, "true"}
 	tokenKey       = token{itemKeyword, "key"}
 	tokenTPM       = token{itemKeyword, "tpm"}
 	tokenLP        = token{itemLP, '('}
 	tokenRP        = token{itemRP, ')'}
 	tokenComma     = token{itemComma, ','}
 	tokenDot       = token{itemDot, '.'}
+	tokenColon     = token{itemColon, ':'}
 	tokenEOF       = token{itemEOF, nil}
 )
 
 // String returns pretty-printed token, e.g. for debugging.
 func (i token) String() string {
 	switch i.typ {
 	case itemError:
 		return fmt.Sprintf("Error{%v}", i.val)
 	case itemUnexpectedRune:
 		return fmt.Sprintf("UnexpectedRune{%v}", i.val)
 	case itemEOF:
 		return "EOF{}"
 	case itemKeyword:
 		return fmt.Sprintf("Keyword{%q}", i.val)
 	case itemIdentifier:
 		return fmt.Sprintf("Identifier{%q}", i.val)
 	case itemStr:
 		return fmt.Sprintf("Str{%q}", i.val)
+	case itemBytes:
+		return fmt.Sprintf("Bytes{%02x}", i.val)
 	case itemInt:
 		return fmt.Sprintf("Int{%v}", i.val)
-	case itemLP, itemRP, itemComma, itemDot:
+	case itemLP, itemRP, itemComma, itemDot, itemColon:
 		return fmt.Sprintf("Punct{%q}", i.val)
 	default:
 		panic("not reached")
 	}
 }
 
 // reader provides input to the scanner.
 type reader interface {
 	io.RuneScanner // for ReadRune, UnreadRune
 	io.Reader      // for Fscanf
 }
 
 // lexer holds the state of the scanner.
 type lexer struct {
 	input reader       // the input being scanned.
 	val   bytes.Buffer // accumulated runes returned from next().
 	width int          // width of last rune returned from next().
 	done  *token       // token found at end of input.
 }
 
 const eof rune = 0
 
 func (l *lexer) lexMain() token {
 	for {
 		switch r := l.next(); {
 		case r == eof:
 			return tokenEOF
 		case unicode.IsSpace(r):
 			l.reset()
 		case r == '(':
-			return token{itemLP, r}
+			return tokenLP
 		case r == ')':
-			return token{itemRP, r}
+			return tokenRP
 		case r == ',':
-			return token{itemComma, r}
+			return tokenComma
 		case r == '.':
-			return token{itemDot, r}
+			return tokenDot
+		case r == ':':
+			return tokenColon
 		case r == '"':
 			l.backup()
 			return l.lexStr()
+		case r == '[' || r == '{':
+			l.backup()
+			return l.lexBytes()
 		case r == '-' || digit(r):
 			l.backup()
 			return l.lexInt()
 		case lower(r):
 			l.backup()
 			return l.lexKeyword()
 		case upper(r):
 			l.backup()
 			return l.lexIdentifier()
 		default:
 			l.backup()
 			return token{itemUnexpectedRune, r}
 		}
 	}
 }
 
 func (l *lexer) lexStr() token {
 	var s string
 	if _, err := fmt.Fscanf(l.input, "%q", &s); err != nil {
 		return token{itemError, err}
 	}
 	return token{itemStr, s}
 }
 
+func (l *lexer) lexBytes() token {
+	r := l.next()
+	if r == '[' {
+		var b []byte
+		s := ""
+		for {
+			r = l.next()
+			switch {
+			case hexChar(r):
+				s += string(r)
+			case unicode.IsSpace(r) || r == ']':
+				x, err := hex.DecodeString(s)
+				if err != nil {
+					return token{itemError, err}
+				}
+				b = append(b, x...)
+				if r == ']' {
+					return token{itemBytes, b}
+				}
+			default:
+				return token{itemError, fmt.Errorf("expected bytes, found %q", s)}
+			}
+		}
+	} else if r == '{' {
+		s := ""
+		for {
+			r = l.next()
+			switch {
+			case lower(r) || upper(r) || digit(r) || r == '+' || r == '/' || r == '=' || r == '\r' || r == '\n':
+				s += string(r)
+			case r == '}':
+				b, err := base64.URLEncoding.DecodeString(s)
+				if err != nil {
+					return token{itemError, err}
+				}
+				return token{itemBytes, b}
+			default:
+				return token{itemError, fmt.Errorf("expected base64w, found %q", s)}
+			}
+		}
+	} else {
+		return token{itemError, fmt.Errorf("expected '[' or '{', found %q", r)}
+	}
+}
+
 func (l *lexer) lexInt() token {
 	var i int64
 	if _, err := fmt.Fscanf(l.input, "%d", &i); err != nil {
 		return token{itemError, err}
 	}
 	return token{itemInt, i}
 }
 
 func (l *lexer) lexKeyword() token {
 	for {
 		r := l.next()
 		if !lower(r) {
 			l.backup()
 			t := token{itemKeyword, l.reset()}
 			return t
 		}
 	}
 }
 
 func (l *lexer) lexIdentifier() token {
@@ -180,40 +239,44 @@ func (l *lexer) lexIdentifier() token {
 		r := l.next()
 		if !(lower(r) || upper(r) || digit(r) || r == '_') {
 			l.backup()
 			return token{itemIdentifier, l.reset()}
 		}
 	}
 }
 
 func digit(r rune) bool {
 	return '0' <= r && r <= '9'
 }
 
 func lower(r rune) bool {
 	return 'a' <= r && r <= 'z'
 }
 
 func upper(r rune) bool {
 	return 'A' <= r && r <= 'Z'
 }
 
+func hexChar(r rune) bool {
+	return ('0' <= r && r <= '9') || ('a' <= r && r <= 'f') || ('A' <= r && r <= 'F')
+}
+
 // next returns the next rune in the input.
 func (l *lexer) next() (r rune) {
 	r, n, err := l.input.ReadRune()
 	if err == io.EOF {
 		l.width = 0
 		return eof
 	}
 	l.val.WriteRune(r)
 	// BUG(kwalsh) fmt.ScanState.ReadRune() returns incorrect length. See issue
 	// 8512 here: https://code.google.com/p/go/issues/detail?id=8512
 	n = utf8.RuneLen(r)
 	l.width = n
 	return r
 }
 
 // backup steps back one rune. Can be called only once per call of next.
 func (l *lexer) backup() {
 	if l.width > 0 {
 		l.input.UnreadRune()
 		l.val.Truncate(l.val.Len() - l.width)
diff --git a/go/src/cloudproxy/tao/auth/parser.go b/go/src/cloudproxy/tao/auth/parser.go
index c022fc4..79d7499 100644
--- a/go/src/cloudproxy/tao/auth/parser.go
+++ b/go/src/cloudproxy/tao/auth/parser.go
@@ -5,41 +5,40 @@
 // You may obtain a copy of the License at
 //
 //     http://www.apache.org/licenses/LICENSE-2.0
 //
 // Unless required by applicable law or agreed to in writing, software
 // distributed under the License is distributed on an "AS IS" BASIS,
 // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
 // This code borrows heavily from the parser design and implementation for the
 // template package. See http://golang.org/src/pkg/text/template/parse/parse.go
 //
 // It also borrows from the parser in package
 // github.com/kevinawalsh/datalog/dlengine
 // licensed by the author here under the above Apache License, Version 2.0.
 
 package auth
 
 import (
-	"encoding/base64"
 	"fmt"
 )
 
 // The functions in this file use one token lookahead, but only when more input
 // is actually called for. The lexer may read one rune ahead while getting a
 // token, but will unread that rune when the token is completed. The goal is to
 // allow parsing an element out of a string or input stream that contains other
 // data after the element.
 //
 // The parseX() functions properly handle outer parenthesis. For
 // example, parsePred() will accept "P(1)", "(P(1))", and " ( ((P((1 )) ) ))".
 // The expectX() functions do not allow outer parenthesis. So
 // expectPred() will handle "P(1)" and "P( (( 1) ))", but not "(P(1))".
 //
 // Onless otherwise documented, in all cases the parseX() and expectX()
 // functions are greedy, consuming input until either an error is encountered or
 // the element can't be expanded further.
 
 // parser holds the state of the recursive descent parser.
 type parser struct {
@@ -94,52 +93,48 @@ func (p *parser) expectCloseParens(n int) error {
 	}
 	return nil
 }
 
 // expectPrin expects a Prin.
 func (p *parser) expectPrin() (prin Prin, err error) {
 	if p.cur() != tokenTPM && p.cur() != tokenKey {
 		err = fmt.Errorf(`expected "key" or "tpm", found %v`, p.cur())
 		return
 	}
 	prin.Type = p.cur().val.(string)
 	p.advance()
 	if r := p.lex.peek(); r != '(' {
 		err = fmt.Errorf(`expected '(' directly after "key", found %q`, r)
 		return
 	}
 	err = p.expect(tokenLP)
 	if err != nil {
 		return
 	}
-	key, err := p.parseStr()
+	prin.Key, err = p.expectTerm()
 	if err != nil {
 		return
 	}
 	err = p.expect(tokenRP)
 	if err != nil {
 		return
 	}
-	prin.Key, err = base64.URLEncoding.DecodeString(string(key))
-	if err != nil {
-		return
-	}
 	for p.lex.peek() == '.' {
 		prin.Ext, err = p.expectSubPrin()
 	}
 	return
 }
 
 // parsePrin parses a Prin with optional outer parens.
 func (p *parser) parsePrin() (prin Prin, err error) {
 	n := p.skipOpenParens()
 	prin, err = p.expectPrin()
 	if err != nil {
 		return
 	}
 	err = p.expectCloseParens(n)
 	return
 }
 
 // expectSubPrin expects a SubPrin.
 func (p *parser) expectSubPrin() (s SubPrin, err error) {
 	if p.cur() != tokenDot {
@@ -149,134 +144,192 @@ func (p *parser) expectSubPrin() (s SubPrin, err error) {
 	p.advance()
 	name, args, err := p.expectNameAndArgs()
 	if err != nil {
 		return
 	}
 	s = append(s, PrinExt{name, args})
 	for p.lex.peek() == '.' {
 		if p.cur() != tokenDot {
 			panic("not reached")
 		}
 		p.advance()
 		name, args, err = p.expectNameAndArgs()
 		if err != nil {
 			return
 		}
 		s = append(s, PrinExt{name, args})
 	}
 	return
 }
 
-// expectNameAndArgs expects an identifier, optionally followed by
-// a parenthesized list of zero or more comma-separated terms.
-func (p *parser) expectNameAndArgs() (string, []Term, error) {
+// expectNameAndArgs expects an identifier followed by a parenthesized list of
+// zero or more comma-separated terms.
+func (p *parser) expectNameAndArgs() (name string, args []Term, err error) {
+	name, hadParen, args, err := p.expectIdentifierOrNameAndArgs()
+	if !hadParen {
+		err = fmt.Errorf("expected '(', found %v", p.cur())
+	}
+	return
+}
+
+// expectIdentifierOrNameAndArgs expects an identifier, optionally followed by a
+// parenthesized list of zero or more comma-separated terms.
+func (p *parser) expectIdentifierOrNameAndArgs() (name string, hadParen bool, args []Term, err error) {
 	if p.cur().typ != itemIdentifier {
-		return "", nil, fmt.Errorf("expected identifier, found %v", p.cur())
+		err = fmt.Errorf("expected identifier, found %v", p.cur())
+		return
 	}
-	name := p.cur().val.(string)
+	name = p.cur().val.(string)
 	p.advance()
 	if p.lex.peek() != '(' {
 		// no parens
-		return name, nil, nil
+		return
 	}
 	if p.cur() != tokenLP {
 		panic("not reached")
 	}
+	hadParen = true
 	p.advance()
 	if p.cur() == tokenRP {
 		// empty parens
 		p.advance()
-		return name, nil, nil
+		return
 	}
-	var args []Term
 	for {
-		t, err := p.parseTerm()
+		var t Term
+		t, err = p.parseTerm()
 		if err != nil {
-			return "", nil, err
+			return
 		}
 		args = append(args, t)
 		if p.cur() != tokenComma {
 			break
 		}
 		p.advance()
 	}
-	err := p.expect(tokenRP)
-	if err != nil {
-		return "", nil, err
-	}
-	return name, args, nil
+	err = p.expect(tokenRP)
+	return
 }
 
 // expectStr expects a Str.
 func (p *parser) expectStr() (Str, error) {
 	if p.cur().typ != itemStr {
 		return "", fmt.Errorf("expected string, found %v", p.cur())
 	}
 	t := Str(p.cur().val.(string))
 	p.advance()
 	return t, nil
 }
 
 // parseStr parses a Str with optional outer parens.
 func (p *parser) parseStr() (t Str, err error) {
 	n := p.skipOpenParens()
 	t, err = p.expectStr()
 	if err != nil {
 		return
 	}
 	err = p.expectCloseParens(n)
 	return
 }
 
+// expectBytes expects a Bytes.
+func (p *parser) expectBytes() (Bytes, error) {
+	if p.cur().typ != itemBytes {
+		return nil, fmt.Errorf("expected bytes, found %v", p.cur())
+	}
+	t := Bytes(p.cur().val.([]byte))
+	p.advance()
+	return t, nil
+}
+
+// parseBytes parses a Bytes with optional outer parens.
+func (p *parser) parseBytes() (t Bytes, err error) {
+	n := p.skipOpenParens()
+	t, err = p.expectBytes()
+	if err != nil {
+		return
+	}
+	err = p.expectCloseParens(n)
+	return
+}
+
 // expectInt expects an Int.
 func (p *parser) expectInt() (Int, error) {
 	if p.cur().typ != itemInt {
 		return 0, fmt.Errorf("expected int, found %v", p.cur())
 	}
 	t := Int(p.cur().val.(int64))
 	p.advance()
 	return t, nil
 }
 
 // parseInt parses an Int with optional outer parens.
 func (p *parser) parseInt() (Int, error) {
 	n := p.skipOpenParens()
 	t, err := p.expectInt()
 	if err != nil {
 		return 0, err
 	}
 	err = p.expectCloseParens(n)
 	if err != nil {
 		return 0, err
 	}
 	return t, nil
 }
 
+// expectTermVar expects a TermVar.
+func (p *parser) expectTermVar() (TermVar, error) {
+	if p.cur().typ != itemIdentifier {
+		return "", fmt.Errorf("expected identifier, found %v", p.cur())
+	}
+	t := TermVar(p.cur().val.(string))
+	p.advance()
+	return t, nil
+}
+
+// parseTermVar parses a TermVar with optional outer parens.
+func (p *parser) parseTermVar() (TermVar, error) {
+	n := p.skipOpenParens()
+	t, err := p.expectTermVar()
+	if err != nil {
+		return "", err
+	}
+	err = p.expectCloseParens(n)
+	if err != nil {
+		return "", err
+	}
+	return t, nil
+}
+
 // expectTerm expects a Term.
 func (p *parser) expectTerm() (Term, error) {
 	switch p.cur().typ {
 	case itemStr:
 		return p.expectStr()
+	case itemBytes:
+		return p.expectBytes()
 	case itemInt:
 		return p.expectInt()
 	case itemKeyword:
 		return p.expectPrin()
+	case itemIdentifier:
+		return p.expectTermVar()
 	default:
 		return nil, fmt.Errorf("expected term, found %v", p.cur())
 	}
 }
 
 // parseTerm parses a Term with optional outer parens.
 func (p *parser) parseTerm() (Term, error) {
 	n := p.skipOpenParens()
 	t, err := p.expectTerm()
 	if err != nil {
 		return nil, err
 	}
 	err = p.expectCloseParens(n)
 	if err != nil {
 		return nil, err
 	}
 	return t, nil
 }
 
 // expectPred expects a Pred.
@@ -304,153 +357,195 @@ func (p *parser) expectConst() (f Const, err error) {
 	if p.cur() != tokenTrue && p.cur() != tokenFalse {
 		err = fmt.Errorf("expected Const, found %v", p.cur())
 		return
 	}
 	f = Const(p.cur() == tokenTrue)
 	p.advance()
 	return
 }
 
 // parseConst parses a Const with optional outer parens.
 func (p *parser) parseConst() (f Const, err error) {
 	n := p.skipOpenParens()
 	f, err = p.expectConst()
 	if err != nil {
 		return
 	}
 	err = p.expectCloseParens(n)
 	return
 }
 
-// expectFrom optionally expects a "(from|until) int" clause for a says formula.
+// expectQuantification expects a Forall or an Exists.
+func (p *parser) expectQuantification(greedy bool) (f Form, err error) {
+	typ := p.cur()
+	if typ != tokenForall && typ != tokenExists {
+		err = fmt.Errorf(`expected "forall" or "exists", found %v`, p.cur())
+		return
+	}
+	p.advance()
+	if p.cur().typ != itemIdentifier {
+		return nil, fmt.Errorf("expected identifier, found %v", p.cur())
+	}
+	name := p.cur().val.(string)
+	p.advance()
+	err = p.expect(tokenColon)
+	if err != nil {
+		return
+	}
+	body, err := p.parseForm(greedy)
+	if err != nil {
+		return
+	}
+	if typ == tokenForall {
+		return Forall{name, body}, nil
+	} else {
+		return Exists{name, body}, nil
+	}
+}
+
+// expectOptionalTime optionally expects a "(from|until) int" clause for a says formula.
 func (p *parser) expectOptionalTime(t token) (*int64, error) {
 	if p.cur() != t {
 		return nil, nil
 	}
 	p.advance()
 	i, err := p.parseInt()
 	if err != nil {
 		return nil, err
 	}
 	val := int64(i)
 	return &val, nil
 }
 
-// expectSaysOrSpeaksfor expects a says or speaksfor formula. If greedy is true,
-// this will parse as much input as possible. Otherwise, it will take only as
-// much input as needed to make a valid formula.
-func (p *parser) expectSaysOrSpeaksfor(greedy bool) (Form, error) {
-	// Prin [from Time] [until Time] says Form
-	// Prin speaksfor Prin
-	prin, err := p.parsePrin()
-	if err != nil {
-		return nil, err
+// expectTermOperation expects a formula involving a term, i.e. a predicate, a
+// says, or a speaksfor formula. If greedy is true, this will parse as much
+// input as possible. Otherwise, it will take only as much input as needed to
+// make a valid formula.
+func (p *parser) expectTermOperation(greedy bool) (Form, error) {
+	// Identifier(Term...)
+	// Term [from Time] [until Time] says Form
+	// Term speaksfor Term
+	var t Term
+	var err error
+	switch p.cur().typ {
+	case itemStr, itemBytes, itemInt, itemKeyword:
+		t, err = p.expectTerm()
+		if err != nil {
+			return nil, err
+		}
+	case itemIdentifier:
+		name, hadParen, args, err := p.expectIdentifierOrNameAndArgs()
+		if err != nil {
+			return nil, err
+		}
+		if hadParen {
+			return Pred{name, args}, nil
+		}
+		t = TermVar(name)
 	}
 	switch p.cur() {
 	case tokenSpeaksfor:
 		p.advance()
-		d, err := p.parsePrin()
+		d, err := p.parseTerm()
 		if err != nil {
 			return nil, err
 		}
-		return Speaksfor{prin, d}, nil
+		return Speaksfor{t, d}, nil
 	case tokenFrom, tokenUntil, tokenSays:
 		from, err := p.expectOptionalTime(tokenFrom)
 		if err != nil {
 			return nil, err
 		}
 		until, err := p.expectOptionalTime(tokenUntil)
 		if err != nil {
 			return nil, err
 		}
 		if from == nil {
 			from, err = p.expectOptionalTime(tokenFrom)
 			if err != nil {
 				return nil, err
 			}
 		}
 		if p.cur() != tokenSays {
 			if from == nil && until == nil {
 				return nil, fmt.Errorf(`expected "from", "until" or "says", found %v`, p.cur())
 			} else if until == nil {
 				return nil, fmt.Errorf(`expected "until" or "says", found %v`, p.cur())
 			} else if from == nil {
 				return nil, fmt.Errorf(`expected "from" or "says", found %v`, p.cur())
 			} else {
 				return nil, fmt.Errorf(`expected "says", found %v`, p.cur())
 			}
 		}
 		p.advance()
-		var msg Form
-		if greedy {
-			msg, err = p.parseForm()
-		} else {
-			msg, err = p.parseFormAtHigh(true)
-		}
+		msg, err := p.parseForm(greedy)
 		if err != nil {
 			return nil, err
 		}
-		return Says{prin, from, until, msg}, nil
+		return Says{t, from, until, msg}, nil
 	default:
 		return nil, fmt.Errorf(`expected "speaksfor", "from", "until", or "says", found %v`, p.cur())
 	}
 }
 
 // The functions follow normal precedence rules, e.g. roughly:
-// L = O imp I | I
+// L = quant V : L | I
+// I = O imp I | I
 // O = A or A or A or ... or A | A
 // A = H and H and H ... and H | H
-// H = not N | ( L ) | P(x) | true | false | P says L | P speaksfor P
+// H = not N | ( L ) | P(x) | true | false | T says L | T speaksfor T
 
 // parseFormAtHigh parses a Form, but stops at any binary Form operator. If
 // greedy is true, this will parse as much input as possible. Otherwise, it will
 // parse only as much input as needed to make a valid formula.
 func (p *parser) parseFormAtHigh(greedy bool) (Form, error) {
 	switch p.cur() {
 	case tokenLP:
 		p.advance()
-		f, err := p.parseForm()
+		f, err := p.parseForm(true)
 		if err != nil {
 			return nil, err
 		}
 		err = p.expect(tokenRP)
 		if err != nil {
 			return nil, err
 		}
 		return f, nil
 	case tokenTrue, tokenFalse:
 		return p.expectConst()
 	case tokenNot:
 		p.advance()
 		f, err := p.parseFormAtHigh(greedy)
 		if err != nil {
 			return nil, err
 		}
 		return Not{f}, nil
+	case tokenForall, tokenExists:
+		return p.expectQuantification(greedy)
 	case tokenKey, tokenTPM:
-		return p.expectSaysOrSpeaksfor(greedy)
-	default:
-		if p.cur().typ == itemIdentifier {
-			return p.expectPred()
-		}
-		return nil, fmt.Errorf("expected Form, found %v", p.cur())
+		return p.expectTermOperation(greedy)
+	}
+	switch p.cur().typ {
+	case itemStr, itemBytes, itemInt, itemIdentifier:
+		return p.expectTermOperation(greedy)
 	}
+	return nil, fmt.Errorf("expected Form, found %v", p.cur())
 }
 
 // parseFormAtAnd parses a Form, but stops when it reaches a binary Form
 // operator of lower precedence than "and".
 func (p *parser) parseFormAtAnd() (Form, error) {
 	f, err := p.parseFormAtHigh(true)
 	if err != nil {
 		return nil, err
 	}
 	if p.cur() != tokenAnd {
 		return f, nil
 	}
 	and, ok := f.(And)
 	if !ok {
 		and = And{Conjunct: []Form{f}}
 	}
 	for p.cur() == tokenAnd {
 		p.advance()
 		g, err := p.parseFormAtHigh(true)
 		if err != nil {
@@ -469,51 +564,52 @@ func (p *parser) parseFormAtOr() (Form, error) {
 		return nil, err
 	}
 	if p.cur() != tokenOr {
 		return f, nil
 	}
 	or, ok := f.(Or)
 	if !ok {
 		or = Or{Disjunct: []Form{f}}
 	}
 	for p.cur() == tokenOr {
 		p.advance()
 		g, err := p.parseFormAtAnd()
 		if err != nil {
 			return nil, err
 		}
 		or.Disjunct = append(or.Disjunct, g)
 	}
 	return or, nil
 }
 
-// parseForm parses a Form. This function is greedy: it consumes as much input
-// as possible until either an error or EOF is encountered.
-func (p *parser) parseForm() (Form, error) {
+// parseForm parses a Form. If greedy=true, this consumes as much input as
+// possible until either an error or EOF is encountered. Otherwise, this
+// consumes only as much input as necessary to obtain a valid formula. For
+// example, "(p says a and b ...)" and "p says (a and b ...) will always be
+// parsed in their entirety, but given "p says a and b ... " and greedy=false,
+// only "p says a" will be parsed.
+func (p *parser) parseForm(greedy bool) (Form, error) {
+	if !greedy {
+		return p.parseFormAtHigh(false)
+	}
+	if p.cur() == tokenForall || p.cur() == tokenExists {
+		return p.expectQuantification(true)
+	}
 	f, err := p.parseFormAtOr()
 	if err != nil {
 		return nil, err
 	}
 	if p.cur() != tokenImplies {
 		return f, nil
 	}
 	p.advance()
-	g, err := p.parseForm()
+	g, err := p.parseForm(greedy)
 	if err != nil {
 		return nil, err
 	}
 	return Implies{f, g}, nil
 }
 
-// parseShortestForm parses the shortest valid Form. This function is not
-// greedy: it consumes only as much input as necessary to obtain a valid
-// formula. For example, "(p says a and b ...)" and "p says (a and b ...) will
-// be parsed in their entirety, but given "p says a and b ... ", only "p says a"
-// will be parsed.
-func (p *parser) parseShortestForm() (Form, error) {
-	return p.parseFormAtHigh(false)
-}
-
 func newParser(input reader) *parser {
 	lex := lex(input)
 	return &parser{lex: lex}
 }
diff --git a/go/src/cloudproxy/tao/auth/scan.go b/go/src/cloudproxy/tao/auth/scan.go
index a825c56..4960a0a 100644
--- a/go/src/cloudproxy/tao/auth/scan.go
+++ b/go/src/cloudproxy/tao/auth/scan.go
@@ -67,175 +67,236 @@ func (t *AnyTerm) Scan(state fmt.ScanState, verb rune) error {
 	parser := newParser(state)
 	term, err := parser.parseTerm()
 	if err != nil {
 		return err
 	}
 	t.Term = term
 	return nil
 }
 
 // Scan parses a Str, with optional outer parens.
 func (t *Str) Scan(state fmt.ScanState, verb rune) error {
 	parser := newParser(state)
 	s, err := parser.parseStr()
 	if err != nil {
 		return err
 	}
 	*t = s
 	return nil
 }
 
+// Scan parses a Bytes, with optional outer parens.
+func (t *Bytes) Scan(state fmt.ScanState, verb rune) error {
+	parser := newParser(state)
+	b, err := parser.parseBytes()
+	if err != nil {
+		return err
+	}
+	*t = b
+	return nil
+}
+
 // Scan parses an Int, with optional outer parens.
 func (t *Int) Scan(state fmt.ScanState, verb rune) error {
 	parser := newParser(state)
 	i, err := parser.parseInt()
 	if err != nil {
 		return err
 	}
 	*t = i
 	return nil
 }
 
+// Scan parses a TermVar, with optional outer parens.
+func (t *TermVar) Scan(state fmt.ScanState, verb rune) error {
+	parser := newParser(state)
+	v, err := parser.parseTermVar()
+	if err != nil {
+		return err
+	}
+	*t = v
+	return nil
+}
+
 // AnyForm is a struct that can be used in when scanning for a Form, since Form
 // itself is an interface and interface pointers are not valid receivers.
 // TODO(kwalsh) Can this be accomplished with a pointer to interface?
 type AnyForm struct {
 	Form Form
 }
 
 // Scan parses a Form, with optional outer parens. This function is not greedy:
 // it consumes only as much input as necessary to obtain a valid formula. For
 // example, "(p says a and b ...)" and "p says (a and b ...) will be parsed in
 // their entirety, but given "p says a and b ... ", only "p says a" will be
 // parsed.
 func (f *AnyForm) Scan(state fmt.ScanState, verb rune) error {
 	parser := newParser(state)
-	form, err := parser.parseShortestForm()
+	form, err := parser.parseForm(false)
 	if err != nil {
 		return err
 	}
 	f.Form = form
 	return nil
 }
 
 // Scan parses a Pred, with optional outer parens.
 func (f *Pred) Scan(state fmt.ScanState, verb rune) error {
 	parser := newParser(state)
 	pred, err := parser.parsePred()
 	if err != nil {
 		return err
 	}
 	*f = pred
 	return nil
 }
 
 // Scan parses a Const, with optional outer parens. This function is not greedy.
 func (f *Const) Scan(state fmt.ScanState, verb rune) error {
 	parser := newParser(state)
 	c, err := parser.parseConst()
 	if err != nil {
 		return err
 	}
 	*f = c
 	return nil
 }
 
 // Scan parses a Not, with optional outer parens. This function is not greedy.
 func (f *Not) Scan(state fmt.ScanState, verb rune) error {
 	parser := newParser(state)
-	form, err := parser.parseShortestForm()
+	form, err := parser.parseForm(false)
 	if err != nil {
 		return err
 	}
 	n, ok := form.(Not)
 	if !ok {
 		return fmt.Errorf(`expecting "not": %s`, form)
 	}
 	*f = n
 	return nil
 }
 
 // Scan parses an And, with required outer parens. This function is not greedy.
-// BUG(kwalsh): This won't succeed unless there are outer parens. For
-// consistency, perhaps I need to make non-greedy parse functions for each
-// operator?
 func (f *And) Scan(state fmt.ScanState, verb rune) error {
 	parser := newParser(state)
-	form, err := parser.parseShortestForm()
+	form, err := parser.parseForm(false)
 	if err != nil {
 		return err
 	}
 	n, ok := form.(And)
-	if !ok {
-		return fmt.Errorf(`expecting "and": %s`, form)
+	if ok {
+		*f = n
+		return nil
 	}
-	*f = n
+	err = parser.expect(tokenAnd)
+	if err != nil {
+		return err
+	}
+	m, err := parser.parseForm(false)
+	*f = And{Conjunct: []Form{n, m}}
 	return nil
 }
 
 // Scan parses an Or, with required outer parens. This function is not greedy.
-// BUG(kwalsh): This won't succeed unless there are outer parens. For
-// consistency, perhaps I need to make non-greedy parse functions for each
-// operator?
 func (f *Or) Scan(state fmt.ScanState, verb rune) error {
 	parser := newParser(state)
-	form, err := parser.parseShortestForm()
+	form, err := parser.parseForm(false)
 	if err != nil {
 		return err
 	}
 	n, ok := form.(Or)
-	if !ok {
-		return fmt.Errorf(`expecting "or": %s`, form)
+	if ok {
+		*f = n
+		return nil
 	}
-	*f = n
+	err = parser.expect(tokenOr)
+	if err != nil {
+		return err
+	}
+	m, err := parser.parseForm(false)
+	*f = Or{Disjunct: []Form{n, m}}
 	return nil
 }
 
 // Scan parses an Implies, with required outer parens. This function is not
 // greedy.
-// BUG(kwalsh): This won't succeed unless there are outer parens. For
-// consistency, perhaps I need to make non-greedy parse functions for each
-// operator?
 func (f *Implies) Scan(state fmt.ScanState, verb rune) error {
 	parser := newParser(state)
-	form, err := parser.parseShortestForm()
+	form, err := parser.parseForm(false)
 	if err != nil {
 		return err
 	}
 	n, ok := form.(Implies)
-	if !ok {
-		return fmt.Errorf(`expecting "implies": %s`, form)
+	if ok {
+		*f = n
+		return nil
 	}
-	*f = n
+	err = parser.expect(tokenImplies)
+	if err != nil {
+		return err
+	}
+	m, err := parser.parseForm(false)
+	*f = Implies{n, m}
 	return nil
 }
 
 // Scan parses a Says, with optional outer parens. This function is not greedy.
 func (f *Says) Scan(state fmt.ScanState, verb rune) error {
 	parser := newParser(state)
-	form, err := parser.parseShortestForm()
+	form, err := parser.parseForm(false)
 	if err != nil {
 		return err
 	}
 	n, ok := form.(Says)
 	if !ok {
 		return fmt.Errorf(`expecting "says": %s`, form)
 	}
 	*f = n
 	return nil
 }
 
 // Scan parses a Speaksfor, with optional outer parens. This function is not
 // greedy.
 func (f *Speaksfor) Scan(state fmt.ScanState, verb rune) error {
 	parser := newParser(state)
-	form, err := parser.parseShortestForm()
+	form, err := parser.parseForm(false)
 	if err != nil {
 		return err
 	}
 	n, ok := form.(Speaksfor)
 	if !ok {
 		return fmt.Errorf(`expecting "speaksfor": %s`, form)
 	}
 	*f = n
 	return nil
 }
+
+// Scan parses a Forall, with optional outer parens. This function is not greedy.
+func (f *Forall) Scan(state fmt.ScanState, verb rune) error {
+	parser := newParser(state)
+	form, err := parser.parseForm(false)
+	if err != nil {
+		return err
+	}
+	n, ok := form.(Forall)
+	if !ok {
+		return fmt.Errorf(`expecting "forall": %s`, form)
+	}
+	*f = n
+	return nil
+}
+
+// Scan parses an Exists, with optional outer parens. This function is not greedy.
+func (f *Exists) Scan(state fmt.ScanState, verb rune) error {
+	parser := newParser(state)
+	form, err := parser.parseForm(false)
+	if err != nil {
+		return err
+	}
+	n, ok := form.(Exists)
+	if !ok {
+		return fmt.Errorf(`expecting "exists": %s`, form)
+	}
+	*f = n
+	return nil
+}
diff --git a/go/src/cloudproxy/tao/auth/shortstring.go b/go/src/cloudproxy/tao/auth/shortstring.go
index 8a90a20..443471c 100644
--- a/go/src/cloudproxy/tao/auth/shortstring.go
+++ b/go/src/cloudproxy/tao/auth/shortstring.go
@@ -1,184 +1,107 @@
 // Copyright (c) 2014, Kevin Walsh.  All rights reserved.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
 // You may obtain a copy of the License at
 //
 //     http://www.apache.org/licenses/LICENSE-2.0
 //
 // Unless required by applicable law or agreed to in writing, software
 // distributed under the License is distributed on an "AS IS" BASIS,
 // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
 package auth
 
-// This file implements ShortString() functions for pretty-printing elements
-// with elision.
-
-// TODO(kwalsh) Perhaps elision can be supported under fmt.Printf() using verb
-// modifiers, flags, precision, etc.?
-
 import (
-	"bytes"
-	"encoding/base64"
 	"fmt"
-	"io"
 )
 
+// Note: Yes, all of these functions are identical, but I don't see a way of
+// making this shorter in Go.
+
 // ShortString returns an elided pretty-printed Prin.
-func (p Prin) ShortString() string {
-	var out bytes.Buffer
-	if len(p.Key) > 15 {
-		fmt.Fprintf(&out, "%s(%.10q...)", p.Type, base64.URLEncoding.EncodeToString(p.Key))
-	} else {
-		fmt.Fprintf(&out, "%s(%q)", p.Type, base64.URLEncoding.EncodeToString(p.Key))
-	}
-	for _, e := range p.Ext {
-		fmt.Fprintf(&out, ".%s", e.ShortString())
-	}
-	return out.String()
+func (e Prin) ShortString() string {
+	return fmt.Sprintf("%s", e)
 }
 
 // ShortString returns an elided pretty-printed PrinExt.
 func (e PrinExt) ShortString() string {
-	return nameAndArgShortString(e.Name, e.Arg)
+	return fmt.Sprintf("%s", e)
 }
 
 // ShortString returns an elided pretty-printed SubPrin.
-func (s SubPrin) ShortString() string {
-	var out bytes.Buffer
-	for _, e := range s {
-		fmt.Fprintf(&out, ".%s", e.ShortString())
-	}
-	return out.String()
-}
-
-// nameAndArgShortString returns an elided pretty-printed name and argument list.
-func nameAndArgShortString(name string, arg []Term) string {
-	if len(arg) == 0 {
-		return name
-	}
-	var out bytes.Buffer
-	fmt.Fprintf(&out, "%s(", name)
-	for i, a := range arg {
-		if i > 0 {
-			fmt.Fprintf(&out, ", ")
-		}
-		fmt.Fprintf(&out, "%s", a.ShortString())
-	}
-	fmt.Fprintf(&out, ")")
-	return out.String()
+func (e SubPrin) ShortString() string {
+	return fmt.Sprintf("%s", e)
 }
 
 // ShortString returns an elided pretty-printed Int.
-func (t Int) ShortString() string {
-	return fmt.Sprintf("%d", int64(t))
+func (e Int) ShortString() string {
+	return fmt.Sprintf("%s", e)
 }
 
 // ShortString returns an elided pretty-printed Str.
-func (t Str) ShortString() string {
-	if len(string(t)) > 15 {
-		return fmt.Sprintf("%.10q...", string(t))
-	} else {
-		return fmt.Sprintf("%q", string(t))
-	}
+func (e Str) ShortString() string {
+	return fmt.Sprintf("%s", e)
+}
+
+// ShortString returns a pretty-printed Bytes.
+func (e Bytes) ShortString() string {
+	return fmt.Sprintf("%s", e)
+}
+
+// ShortString returns an elided pretty-printed TermVar.
+func (e TermVar) ShortString() string {
+	return fmt.Sprintf("%s", e)
 }
 
 // ShortString returns an elided pretty-printed Pred.
-func (p Pred) ShortString() string {
-	return nameAndArgShortString(p.Name, p.Arg)
+func (e Pred) ShortString() string {
+	return fmt.Sprintf("%s", e)
 }
 
 // ShortString returns an elided pretty-printed Const.
-func (f Const) ShortString() string {
-	if f == true {
-		return "true"
-	} else {
-		return "false"
-	}
+func (e Const) ShortString() string {
+	return fmt.Sprintf("%s", e)
 }
 
 // ShortString returns an elided pretty-printed Not.
-func (f Not) ShortString() string {
-	var out bytes.Buffer
-	fmt.Fprintf(&out, "not ")
-	printShortFormWithParens(&out, precedenceHigh, f.Negand)
-	return out.String()
+func (e Not) ShortString() string {
+	return fmt.Sprintf("%s", e)
 }
 
 // ShortString returns an elided pretty-printed And.
-func (f And) ShortString() string {
-	if len(f.Conjunct) == 0 {
-		return "true"
-	} else if len(f.Conjunct) == 1 {
-		return f.Conjunct[0].ShortString()
-	} else {
-		var out bytes.Buffer
-		for i, e := range f.Conjunct {
-			if i > 0 {
-				fmt.Fprintf(&out, " and ")
-			}
-			printShortFormWithParens(&out, precedenceAnd, e)
-		}
-		return out.String()
-	}
+func (e And) ShortString() string {
+	return fmt.Sprintf("%s", e)
 }
 
 // ShortString returns an elided pretty-printed Or.
-func (f Or) ShortString() string {
-	if len(f.Disjunct) == 0 {
-		return "false"
-	} else if len(f.Disjunct) == 1 {
-		return f.Disjunct[0].ShortString()
-	} else {
-		var out bytes.Buffer
-		for i, e := range f.Disjunct {
-			if i > 0 {
-				fmt.Fprintf(&out, " or ")
-			}
-			printShortFormWithParens(&out, precedenceOr, e)
-		}
-		return out.String()
-	}
+func (e Or) ShortString() string {
+	return fmt.Sprintf("%s", e)
 }
 
 // ShortString returns an elided pretty-printed Implies.
-func (f Implies) ShortString() string {
-	var out bytes.Buffer
-	printShortFormWithParens(&out, precedenceImplies+1, f.Antecedent)
-	fmt.Fprintf(&out, " implies ")
-	printShortFormWithParens(&out, precedenceImplies, f.Consequent)
-	return out.String()
+func (e Implies) ShortString() string {
+	return fmt.Sprintf("%s", e)
 }
 
 // ShortString returns an elided pretty-printed Speaksfor.
-func (f Speaksfor) ShortString() string {
-	return fmt.Sprintf("%s speaksfor %s", f.Delegate.ShortString(), f.Delegator.ShortString())
+func (e Speaksfor) ShortString() string {
+	return fmt.Sprintf("%s", e)
 }
 
 // ShortString returns an elided pretty-printed Says.
-func (f Says) ShortString() string {
-	speaker := f.Speaker.ShortString()
-	message := f.Message.ShortString()
-	if f.Commences() && f.Expires() {
-		return fmt.Sprintf("%s from %d until %d says %s", speaker, *f.Time, *f.Expiration, message)
-	} else if f.Commences() {
-		return fmt.Sprintf("%s from %d says %s", speaker, *f.Time, message)
-	} else if f.Expires() {
-		return fmt.Sprintf("%s until %d says %s", speaker, *f.Expiration, message)
-	} else {
-		return fmt.Sprintf("%s says %s", speaker, message)
-	}
-}
-
-// printFormWithParens prints either elided f or (f), depending on ho level
-// compares to the precedence of f.
-func printShortFormWithParens(out io.Writer, level int, f Form) {
-	if level > precedence(f) {
-		fmt.Fprintf(out, "(%s)", f.ShortString())
-	} else {
-		fmt.Fprintf(out, "%s", f.ShortString())
-	}
+func (e Says) ShortString() string {
+	return fmt.Sprintf("%s", e)
+}
+
+// ShortString returns an elided pretty-printed Forall.
+func (e Forall) ShortString() string {
+	return fmt.Sprintf("%s", e)
+}
+
+// ShortString returns an elided pretty-printed Exists.
+func (e Exists) ShortString() string {
+	return fmt.Sprintf("%s", e)
 }
diff --git a/go/src/cloudproxy/tao/auth/string.go b/go/src/cloudproxy/tao/auth/string.go
index d7f5a46..138e48d 100644
--- a/go/src/cloudproxy/tao/auth/string.go
+++ b/go/src/cloudproxy/tao/auth/string.go
@@ -1,213 +1,107 @@
 // Copyright (c) 2014, Kevin Walsh.  All rights reserved.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
 // You may obtain a copy of the License at
 //
 //     http://www.apache.org/licenses/LICENSE-2.0
 //
 // Unless required by applicable law or agreed to in writing, software
 // distributed under the License is distributed on an "AS IS" BASIS,
 // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
 package auth
 
-// This file implements String() functions for pretty-printing elements.
-
 import (
-	"bytes"
-	"encoding/base64"
 	"fmt"
-	"io"
 )
 
+// Note: Yes, all of these functions are identical, but I don't see a way of
+// making this shorter in Go.
+
 // String returns a pretty-printed Prin.
-func (p Prin) String() string {
-	var out bytes.Buffer
-	fmt.Fprintf(&out, "%s(%q)", p.Type, base64.URLEncoding.EncodeToString(p.Key))
-	for _, e := range p.Ext {
-		fmt.Fprintf(&out, ".%s", e.String())
-	}
-	return out.String()
+func (e Prin) String() string {
+	return fmt.Sprintf("%v", e)
 }
 
 // String returns a pretty-printed PrinExt.
 func (e PrinExt) String() string {
-	return nameAndArgString(e.Name, e.Arg)
-}
-
-// String returns an elided pretty-printed SubPrin.
-func (s SubPrin) String() string {
-	var out bytes.Buffer
-	for _, e := range s {
-		fmt.Fprintf(&out, ".%s", e.String())
-	}
-	return out.String()
-}
-
-// nameAndArgString returns a pretty-printed name and argument list.
-func nameAndArgString(name string, arg []Term) string {
-	if len(arg) == 0 {
-		return name
-	}
-	var out bytes.Buffer
-	fmt.Fprintf(&out, "%s(", name)
-	for i, a := range arg {
-		if i > 0 {
-			fmt.Fprintf(&out, ", ")
-		}
-		fmt.Fprintf(&out, "%s", a.String())
-	}
-	fmt.Fprintf(&out, ")")
-	return out.String()
+	return fmt.Sprintf("%v", e)
+}
+
+// String returns a pretty-printed SubPrin.
+func (e SubPrin) String() string {
+	return fmt.Sprintf("%v", e)
 }
 
 // String returns a pretty-printed Int.
-func (t Int) String() string {
-	return fmt.Sprintf("%d", int64(t))
+func (e Int) String() string {
+	return fmt.Sprintf("%v", e)
 }
 
 // String returns a pretty-printed Str.
-func (t Str) String() string {
-	return fmt.Sprintf("%q", string(t))
+func (e Str) String() string {
+	return fmt.Sprintf("%v", e)
+}
+
+// String returns a pretty-printed Bytes.
+func (e Bytes) String() string {
+	return fmt.Sprintf("%v", e)
+}
+
+// String returns a pretty-printed TermVar.
+func (e TermVar) String() string {
+	return fmt.Sprintf("%v", e)
 }
 
 // String returns a pretty-printed Pred.
-func (p Pred) String() string {
-	return nameAndArgString(p.Name, p.Arg)
+func (e Pred) String() string {
+	return fmt.Sprintf("%v", e)
 }
 
 // String returns a pretty-printed Const.
-func (f Const) String() string {
-	if f == true {
-		return "true"
-	} else {
-		return "false"
-	}
+func (e Const) String() string {
+	return fmt.Sprintf("%v", e)
 }
 
 // String returns a pretty-printed Not.
-func (f Not) String() string {
-	var out bytes.Buffer
-	fmt.Fprintf(&out, "not ")
-	printFormWithParens(&out, precedenceHigh, f.Negand)
-	return out.String()
+func (e Not) String() string {
+	return fmt.Sprintf("%v", e)
 }
 
 // String returns a pretty-printed And.
-func (f And) String() string {
-	if len(f.Conjunct) == 0 {
-		return "true"
-	} else if len(f.Conjunct) == 1 {
-		return f.Conjunct[0].String()
-	} else {
-		var out bytes.Buffer
-		for i, e := range f.Conjunct {
-			if i > 0 {
-				fmt.Fprintf(&out, " and ")
-			}
-			printFormWithParens(&out, precedenceAnd, e)
-		}
-		return out.String()
-	}
+func (e And) String() string {
+	return fmt.Sprintf("%v", e)
 }
 
 // String returns a pretty-printed Or.
-func (f Or) String() string {
-	if len(f.Disjunct) == 0 {
-		return "false"
-	} else if len(f.Disjunct) == 1 {
-		return f.Disjunct[0].String()
-	} else {
-		var out bytes.Buffer
-		for i, e := range f.Disjunct {
-			if i > 0 {
-				fmt.Fprintf(&out, " or ")
-			}
-			printFormWithParens(&out, precedenceOr, e)
-		}
-		return out.String()
-	}
+func (e Or) String() string {
+	return fmt.Sprintf("%v", e)
 }
 
 // String returns a pretty-printed Implies.
-func (f Implies) String() string {
-	var out bytes.Buffer
-	printFormWithParens(&out, precedenceImplies+1, f.Antecedent)
-	fmt.Fprintf(&out, " implies ")
-	printFormWithParens(&out, precedenceImplies, f.Consequent)
-	return out.String()
+func (e Implies) String() string {
+	return fmt.Sprintf("%v", e)
 }
 
 // String returns a pretty-printed Speaksfor.
-func (f Speaksfor) String() string {
-	return fmt.Sprintf("%s speaksfor %s", f.Delegate.String(), f.Delegator.String())
+func (e Speaksfor) String() string {
+	return fmt.Sprintf("%v", e)
 }
 
 // String returns a pretty-printed Says.
-func (f Says) String() string {
-	speaker := f.Speaker.String()
-	message := f.Message.String()
-	if f.Commences() && f.Expires() {
-		return fmt.Sprintf("%s from %d until %d says %s", speaker, *f.Time, *f.Expiration, message)
-	} else if f.Commences() {
-		return fmt.Sprintf("%s from %d says %s", speaker, *f.Time, message)
-	} else if f.Expires() {
-		return fmt.Sprintf("%s until %d says %s", speaker, *f.Expiration, message)
-	} else {
-		return fmt.Sprintf("%s says %s", speaker, message)
-	}
-}
-
-const (
-	precedenceSays = iota // lowest
-	precedenceSpeaksfor
-	precedenceImplies
-	precedenceOr
-	precedenceAnd
-	precedenceHigh // not, true, false, Pred
-)
+func (e Says) String() string {
+	return fmt.Sprintf("%v", e)
+}
+
+// String returns a pretty-printed Forall.
+func (e Forall) String() string {
+	return fmt.Sprintf("%v", e)
+}
 
-// precedence returns an integer indicating the relative precedence of f.
-func precedence(f Form) int {
-	switch f := f.(type) {
-	case Says:
-		return precedenceSays
-	case Speaksfor:
-		return precedenceSpeaksfor
-	case Implies:
-		return precedenceImplies
-	case Or:
-		if len(f.Disjunct) == 0 {
-			return precedenceHigh // Or{} == false
-		} else if len(f.Disjunct) == 1 {
-			return precedence(f.Disjunct[0]) // Or{f} == f
-		} else {
-			return precedenceOr
-		}
-	case And:
-		if len(f.Conjunct) == 0 {
-			return precedenceHigh // And{} == true
-		} else if len(f.Conjunct) == 1 {
-			return precedence(f.Conjunct[0]) // And{f} == f
-		} else {
-			return precedenceAnd
-		}
-	case Not, Pred, Const:
-		return precedenceHigh
-	default:
-		panic("not reached")
-	}
-}
-
-// printFormWithParens prints either f or (f), depending on how level compares
-// to the precedence of f.
-func printFormWithParens(out io.Writer, level int, f Form) {
-	if level > precedence(f) {
-		fmt.Fprintf(out, "(%s)", f.String())
-	} else {
-		fmt.Fprintf(out, "%s", f.String())
-	}
+// String returns a pretty-printed Exists.
+func (e Exists) String() string {
+	return fmt.Sprintf("%v", e)
 }
diff --git a/go/src/cloudproxy/tao/fake_tao_test.go b/go/src/cloudproxy/tao/fake_tao_test.go
index 3f192ba..f5233e5 100644
--- a/go/src/cloudproxy/tao/fake_tao_test.go
+++ b/go/src/cloudproxy/tao/fake_tao_test.go
@@ -113,125 +113,131 @@ func (f *FakeTao) GetSharedSecret(n int, policy string) ([]byte, error) {
 // implicit.
 func (f *FakeTao) Seal(data []byte, policy string) ([]byte, error) {
 	// The FakeTao insists on the trivial policy, since it just encrypts the bytes directly
 	if policy != SealPolicyDefault {
 		return nil, newError("The FakeTao requires SealPolicyDefault")
 	}
 
 	return f.keys.CryptingKey.Encrypt(data)
 }
 
 // Unseal decrypts data that has been sealed by the Seal operation, but only if
 // the policy specified during the Seal operation is satisfied.
 func (f *FakeTao) Unseal(sealed []byte) (data []byte, policy string, err error) {
 	data, err = f.keys.CryptingKey.Decrypt(sealed)
 	policy = SealPolicyDefault
 	return data, policy, err
 }
 
 // Attest requests that the Tao host sign a statement on behalf of the caller.
 func (f *FakeTao) Attest(issuer *auth.Prin, time, expiration *int64, message auth.Form) (*Attestation, error) {
-
+	child := f.name.MakeSubprincipal(f.nameExtension)
 	if issuer == nil {
-		issuer = &f.name
-	} else if !issuer.Identical(f.name) {
-		return nil, newError("Invalid issuer in statement")
+		issuer = &child
+	} else if !auth.SubprinOrIdentical(issuer, child) {
+		return nil, newError("Invalid issuer in statement: %s may not speak for %s", child, issuer)
 	}
 
 	stmt := auth.Says{Speaker: *issuer, Time: time, Expiration: expiration, Message: message}
 
 	var delegation []byte
 	if f.keys.Delegation != nil {
 		var err error
 		delegation, err = proto.Marshal(f.keys.Delegation)
 		if err != nil {
 			return nil, err
 		}
 	}
 
 	return GenerateAttestation(f.keys.SigningKey, delegation, stmt)
 }
 
 func TestInMemoryInit(t *testing.T) {
-	_, err := NewFakeTao(auth.Prin{Type: "key", Key: []byte("test")}, "", nil)
+	_, err := NewFakeTao(auth.NewKeyPrin([]byte("test")), "", nil)
 	if err != nil {
 		t.Fatal("Couldn't initialize a FakeTao in memory:", err)
 	}
 }
 
 func TestFakeTaoRandom(t *testing.T) {
-	ft, err := NewFakeTao(auth.Prin{Type: "key", Key: []byte("test")}, "", nil)
+	ft, err := NewFakeTao(auth.NewKeyPrin([]byte("test")), "", nil)
 	if err != nil {
 		t.Fatal("Couldn't initialize a FakeTao in memory:", err)
 	}
 
 	if _, err := ft.GetRandomBytes(10); err != nil {
 		t.Fatal("Couldn't get 10 random bytes:", err)
 	}
 }
 
 func TestFakeTaoSeal(t *testing.T) {
-	ft, err := NewFakeTao(auth.Prin{Type: "key", Key: []byte("test")}, "", nil)
+	ft, err := NewFakeTao(auth.NewKeyPrin([]byte("test")), "", nil)
 	if err != nil {
 		t.Fatal("Couldn't initialize a FakeTao in memory:", err)
 	}
 
 	r := mrand.New(mrand.NewSource(time.Now().UnixNano()))
 	b := make([]byte, 33)
 	for i := range b {
 		b[i] = byte(r.Intn(256))
 	}
 
 	_, err = ft.Seal(b, SealPolicyDefault)
 	if err != nil {
 		t.Fatal("Couldn't seal data in the FakeTao under the default policy:", err)
 	}
 }
 
 func TestFakeTaoUnseal(t *testing.T) {
-	ft, err := NewFakeTao(auth.Prin{Type: "key", Key: []byte("test")}, "", nil)
+	ft, err := NewFakeTao(auth.NewKeyPrin([]byte("test")), "", nil)
 	if err != nil {
 		t.Fatal("Couldn't initialize a FakeTao in memory:", err)
 	}
 
 	r := mrand.New(mrand.NewSource(time.Now().UnixNano()))
 	b := make([]byte, 33)
 	for i := range b {
 		b[i] = byte(r.Intn(256))
 	}
 
 	s, err := ft.Seal(b, SealPolicyDefault)
 	if err != nil {
 		t.Fatal("Couldn't seal data in the FakeTao under the default policyL", err)
 	}
 
 	u, p, err := ft.Unseal(s)
 	if string(p) != SealPolicyDefault {
 		t.Fatal("Invalid policy returned by Unseal")
 	}
 
 	if len(u) != len(b) {
 		t.Fatal("Invalid unsealed length")
 	}
 
 	for i, v := range u {
 		if v != b[i] {
 			t.Fatalf("Incorrect byte at position %d", i)
 		}
 	}
 }
 
 func TestFakeTaoAttest(t *testing.T) {
-	ft, err := NewFakeTao(auth.Prin{Type: "key", Key: []byte("test")}, "", nil)
+	ft, err := NewFakeTao(auth.NewKeyPrin([]byte("test")), "", nil)
 	if err != nil {
 		t.Fatal("Couldn't initialize a FakeTao in memory:", err)
 	}
 
+	self, err := ft.GetTaoName()
+	if err != nil {
+		t.Fatal("Couldn't get own name:", err)
+	}
+
 	stmt := auth.Speaksfor{
-		Delegate: auth.Prin{Type: "key", Key: []byte("BogusKeyBytes1")},
+		Delegate:  auth.NewKeyPrin([]byte("BogusKeyBytes1")),
+		Delegator: self,
 	}
 
 	_, err = ft.Attest(nil, nil, nil, stmt)
 	if err != nil {
 		t.Fatal("Couldn't attest to a statement in the FakeTao:", err)
 	}
 }
diff --git a/go/src/cloudproxy/tao/guard.go b/go/src/cloudproxy/tao/guard.go
index d913274..32198ee 100644
--- a/go/src/cloudproxy/tao/guard.go
+++ b/go/src/cloudproxy/tao/guard.go
@@ -6,47 +6,40 @@
 //
 //     http://www.apache.org/licenses/LICENSE-2.0
 //
 // Unless required by applicable law or agreed to in writing, software
 // distributed under the License is distributed on an "AS IS" BASIS,
 // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
 // This interface was derived from the code in src/tao/tao_guard.h.
 
 package tao
 
 import (
 	"errors"
 
 	"cloudproxy/tao/auth"
 	"cloudproxy/util"
 )
 
-// MakePredicate constructs an authorization predicate of the form:
-//   Authorize(name, op, args...).
-// TODO(tmroeder): implement this function.
-func MakePredicate(name auth.Prin, op string, args []string) string {
-	return ""
-}
-
 // Guard is an interface for evaluating policy decisions.
 type Guard interface {
 	// Subprincipal returns a unique subprincipal for this policy.
 	Subprincipal() auth.SubPrin
 
 	// Save writes all presistent policy data to disk, signed by key.
 	Save(key *Signer) error
 
 	// Authorize adds an authorization for a principal to perform an
 	// operation.
 	Authorize(name auth.Prin, op string, args []string) error
 
 	// Retract removes an authorization for a principal to perform an
 	// operation, essentially reversing the effect of an Authorize() call
 	// with identical name, op, and args. Note: this reverses the effect of
 	// an Authorize() call with identical parameters of the equivalent
 	// AddRule() call. However, particularly when expressive policies are
 	// supported (e.g., an "authorize all" rule), other rules may still be
 	// in place authorizing the principal to perform the operation.
 	Retract(name auth.Prin, op string, args []string) error
@@ -100,41 +93,41 @@ const (
 
 // errTrivialGuard is the error returned for all non-trivial policy operations
 // on the TrivialGuard.
 var errTrivialGuard = errors.New("can't perform policy operations on TrivialGuard")
 
 // SubprincipalName returns subprincipal TrivialGuard(<policy>).
 func (t TrivialGuard) Subprincipal() auth.SubPrin {
 	var policy string
 	switch t {
 	case ConservativeGuard:
 		policy = "Conservative"
 	case LiberalGuard:
 		policy = "Liberal"
 	default:
 		policy = "Unspecified"
 	}
 	e := auth.PrinExt{Name: "TrivialGuard", Arg: []auth.Term{auth.Str(policy)}}
 	return auth.SubPrin{e}
 }
 
-// Save writes all presistent policy data to disk, signed by key.
+// Save writes all persistent policy data to disk, signed by key.
 func (t TrivialGuard) Save(key *Signer) error {
 	return nil // nothing to save
 }
 
 // Authorize adds an authorization for a principal to perform an
 // operation.
 func (t TrivialGuard) Authorize(name auth.Prin, op string, args []string) error {
 	if t != LiberalGuard {
 		return util.Logged(errTrivialGuard)
 	}
 	return nil
 }
 
 // Retract removes an authorization for a principal to perform an
 // operation, essentially reversing the effect of an Authorize() call
 // with identical name, op, and args. Note: this reverses the effect of
 // an Authorize() call with identical parameters of the equivalent
 // AddRule() call. However, particularly when expressive policies are
 // supported (e.g., an "authorize all" rule), other rules may still be
 // in place authorizing the principal to perform the operation.
diff --git a/go/src/cloudproxy/tao/guard_test.go b/go/src/cloudproxy/tao/guard_test.go
index d9d262d..bc7807c 100644
--- a/go/src/cloudproxy/tao/guard_test.go
+++ b/go/src/cloudproxy/tao/guard_test.go
@@ -21,41 +21,41 @@ import (
 )
 
 func testNewTrivialLiberalGuard(t *testing.T) Guard {
 	tg := LiberalGuard
 	if tg.Subprincipal().String() != `.TrivialGuard("Liberal")` {
 		t.Fatal("Wrong subprincipal name for trivial liberal guard")
 	}
 
 	return tg
 }
 
 func testNewTrivialConservativeGuard(t *testing.T) Guard {
 	tg := ConservativeGuard
 	if tg.Subprincipal().String() != `.TrivialGuard("Conservative")` {
 		t.Fatal("Wrong subprincipal name for trivial conservative guard")
 	}
 
 	return tg
 }
 
-var testPrin auth.Prin = auth.Prin{Type: "key", Key: []byte("testkey")}
+var testPrin auth.Prin = auth.NewKeyPrin([]byte("testkey"))
 
 func testTrivialGuardAuthorize(t *testing.T, tg Guard, expect bool) {
 	if err := tg.Authorize(testPrin, "testop", []string{}); (err == nil) != expect {
 		t.Fatal("Authorize command unexpected result on trivial guard")
 	}
 }
 
 func testTrivialGuardRetract(t *testing.T, tg Guard, expect bool) {
 	if err := tg.Retract(testPrin, "testop", []string{}); (err == nil) != expect {
 		t.Fatal("Retract command unexpected result on trivial guard")
 	}
 }
 
 func testTrivialGuardIsAuthorized(t *testing.T, tg Guard, expect bool) {
 	b := tg.IsAuthorized(testPrin, "testop", []string{})
 	if b != expect {
 		t.Fatal("Got an unexpected result from IsAuthorized on a trivial guard")
 	}
 }
 
diff --git a/go/src/cloudproxy/tao/host_test.go b/go/src/cloudproxy/tao/host_test.go
index 6b49d02..0efb341 100644
--- a/go/src/cloudproxy/tao/host_test.go
+++ b/go/src/cloudproxy/tao/host_test.go
@@ -20,41 +20,41 @@ import (
 
 	"cloudproxy/tao/auth"
 )
 
 var testChild = auth.SubPrin{auth.PrinExt{Name: "TestChild"}}
 
 func testNewTaoRootHost(t *testing.T) Host {
 	th, err := NewTaoRootHost()
 	if err != nil {
 		t.Fatal("Couldn't create a new RootHost:", err)
 	}
 
 	if err := th.AddedHostedProgram(testChild); err != nil {
 		t.Fatal("Couldn't add a test child program:", err)
 	}
 
 	return th
 }
 
 func testNewTaoStackedHost(t *testing.T) Host {
-	ft, err := NewFakeTao(auth.Prin{Type: "key", Key: []byte("test")}, "", nil)
+	ft, err := NewFakeTao(auth.NewKeyPrin([]byte("test")), "", nil)
 	if err != nil {
 		t.Fatal("Couldn't set up a FakeTao for the StackedHost")
 	}
 
 	th, err := NewTaoStackedHost(ft)
 	if err != nil {
 		t.Fatal("Couldn't set up a StackedHost over a FakeTao")
 	}
 
 	return th
 }
 
 func testTaoHostRandomBytes(t *testing.T, th Host) {
 	b, err := th.GetRandomBytes(testChild, 10)
 	if err != nil {
 		t.Fatal("Couldn't get random bytes from the Host:", err)
 	}
 
 	if len(b) != 10 {
 		t.Fatal("The length of the returned random bytes is not 10")
diff --git a/go/src/cloudproxy/tao/keys.go b/go/src/cloudproxy/tao/keys.go
index a882eac..eed1e6c 100644
--- a/go/src/cloudproxy/tao/keys.go
+++ b/go/src/cloudproxy/tao/keys.go
@@ -78,41 +78,41 @@ type Deriver struct {
 
 // GenerateSigner creates a new Signer with a fresh key.
 func GenerateSigner() (*Signer, error) {
 	ec, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)
 	if err != nil {
 		return nil, err
 	}
 
 	return &Signer{ec}, nil
 }
 
 // ToPrincipal produces a "key" type Prin for this signer. This contains a
 // serialized CryptoKey for the public half of this signing key.
 func (s *Signer) ToPrincipal() auth.Prin {
 	ck := MarshalPublicSignerProto(s)
 
 	// proto.Marshal won't fail here since we fill all required fields of the
 	// message. Propagating impossible errors just leads to clutter later.
 	data, _ := proto.Marshal(ck)
 
-	return auth.Prin{Type: "key", Key: data}
+	return auth.NewKeyPrin(data)
 }
 
 // MarshalSignerDER serializes the signer to DER.
 func MarshalSignerDER(s *Signer) ([]byte, error) {
 	return x509.MarshalECPrivateKey(s.ec)
 }
 
 // UnmarshalSignerDER deserializes a Signer from DER.
 func UnmarshalSignerDER(signer []byte) (*Signer, error) {
 	k := new(Signer)
 	var err error
 	if k.ec, err = x509.ParseECPrivateKey(signer); err != nil {
 		return nil, err
 	}
 
 	return k, nil
 }
 
 // X509Details is a simplified version of pkix.Name, suitable for most purposes.
 // All of the fields are optional.
@@ -367,51 +367,59 @@ func (v *Verifier) Verify(data []byte, context string, sig []byte) (bool, error)
 		return false, err
 	}
 
 	b, err := contextualizedSHA256(sd.Header, data, context, sha256.Size)
 	if err != nil {
 		return false, err
 	}
 
 	return ecdsa.Verify(v.ec, b, ecSig.R, ecSig.S), nil
 }
 
 // ToPrincipal produces a "key" type Prin for this verifier. This contains a
 // serialized CryptoKey for this key.
 func (v *Verifier) ToPrincipal() auth.Prin {
 	ck := MarshalVerifierProto(v)
 
 	// proto.Marshal won't fail here since we fill all required fields of the
 	// message. Propagating impossible errors just leads to clutter later.
 	data, _ := proto.Marshal(ck)
 
-	return auth.Prin{Type: "key", Key: data}
+	return auth.NewKeyPrin(data)
 }
 
 // FromPrincipal deserializes a Verifier from a Prin.
 func FromPrincipal(prin auth.Prin) (*Verifier, error) {
 	if prin.Type != "key" {
-		return nil, newError("invalid key principal type")
+		return nil, newError("invalid key principal")
+	}
+	var b auth.Bytes
+	if ptr, ok := prin.Key.(*auth.Bytes); ok {
+		b = *ptr
+	} else if val, ok := prin.Key.(auth.Bytes); ok {
+		b = val
+	} else {
+		return nil, newError("invalid key material")
 	}
 
 	var ck CryptoKey
-	if err := proto.Unmarshal(prin.Key, &ck); err != nil {
+	if err := proto.Unmarshal(b, &ck); err != nil {
 		return nil, err
 	}
 
 	if *ck.Version != CryptoVersion_CRYPTO_VERSION_1 {
 		return nil, newError("bad version")
 	}
 
 	if *ck.Purpose != CryptoKey_VERIFYING {
 		return nil, newError("bad purpose")
 	}
 
 	if *ck.Algorithm != CryptoKey_ECDSA_SHA {
 		return nil, newError("bad algorithm")
 	}
 
 	var ecvk ECDSA_SHA_VerifyingKeyV1
 	if err := proto.Unmarshal(ck.Key, &ecvk); err != nil {
 		return nil, err
 	}
 
@@ -1063,46 +1071,51 @@ func (k *Keys) loadCert() error {
 	}
 	defer f.Close()
 
 	der, err := ioutil.ReadAll(f)
 	if err != nil {
 		return err
 	}
 
 	k.Cert, err = x509.ParseCertificate(der)
 	return err
 }
 
 // NewTemporaryTaoDelegatedKeys initializes a set of temporary keys under a host
 // Tao, using the Tao to generate a delegation for the signing key. Since these
 // keys are never stored on disk, they are not sealed to the Tao.
 func NewTemporaryTaoDelegatedKeys(keyTypes KeyType, t Tao) (*Keys, error) {
 	k, err := NewTemporaryKeys(keyTypes)
 	if err != nil {
 		return nil, err
 	}
+	self, err := t.GetTaoName()
+	if err != nil {
+		return nil, err
+	}
 
 	if k.SigningKey != nil {
 		s := &auth.Speaksfor{
-			Delegate: k.SigningKey.ToPrincipal(),
+			Delegate:  k.SigningKey.ToPrincipal(),
+			Delegator: self,
 		}
-		if k.Delegation, err = t.Attest(nil, nil, nil, s); err != nil {
+		if k.Delegation, err = t.Attest(&self, nil, nil, s); err != nil {
 			return nil, err
 		}
 	}
 
 	return k, nil
 }
 
 // PBEEncrypt encrypts plaintext using a password to generate a key. Note that
 // since this is for private program data, we don't try for compatibility with
 // the C++ Tao version of the code.
 func PBEEncrypt(plaintext, password []byte) ([]byte, error) {
 	if password == nil || len(password) == 0 {
 		return nil, newError("null or empty password")
 	}
 
 	pbed := &PBEData{
 		Version: CryptoVersion_CRYPTO_VERSION_1.Enum(),
 		Cipher:  proto.String("aes128-ctr"),
 		Hmac:    proto.String("sha256"),
 		// The IV is required, so we include it, but this algorithm doesn't use it.
@@ -1322,40 +1335,45 @@ func NewOnDiskTaoSealedKeys(keyTypes KeyType, t Tao, path, policy string) (*Keys
 
 		// TODO(tmroeder): defer zeroKeyset(cks)
 
 		m, err := proto.Marshal(cks)
 		if err != nil {
 			return nil, err
 		}
 		defer zeroBytes(m)
 
 		enc, err := t.Seal(m, policy)
 		if err != nil {
 			return nil, err
 		}
 
 		if err = util.WritePath(k.SealedKeysetPath(), enc, 0700, 0600); err != nil {
 			return nil, err
 		}
 
 		// Get and write a delegation.
 		if k.SigningKey != nil {
+			self, err := t.GetTaoName()
+			if err != nil {
+				return nil, err
+			}
 			s := &auth.Speaksfor{
-				Delegate: k.SigningKey.ToPrincipal(),
+				Delegate:  k.SigningKey.ToPrincipal(),
+				Delegator: self,
 			}
-			if k.Delegation, err = t.Attest(nil, nil, nil, s); err != nil {
+			if k.Delegation, err = t.Attest(&self, nil, nil, s); err != nil {
 				return nil, err
 			}
 
 			m, err := proto.Marshal(k.Delegation)
 			if err != nil {
 				return nil, err
 			}
 
 			if err = util.WritePath(k.DelegationPath(), m, 0700, 0600); err != nil {
 				return nil, err
 			}
 		}
 	}
 
 	return k, nil
 }
diff --git a/go/src/cloudproxy/tao/keys_test.go b/go/src/cloudproxy/tao/keys_test.go
index 296021b..0807297 100644
--- a/go/src/cloudproxy/tao/keys_test.go
+++ b/go/src/cloudproxy/tao/keys_test.go
@@ -377,53 +377,53 @@ func TestNewOnDiskPBESigner(t *testing.T) {
 	}
 	defer os.RemoveAll(tempDir)
 
 	password := []byte(`don't use this password`)
 	k, err := NewOnDiskPBEKeys(Signing, password, tempDir, nil)
 	if err != nil {
 		t.Fatal("Couldn't create on-disk PBE keys:", err)
 	}
 
 	if k.SigningKey == nil || k.CryptingKey != nil || k.DerivingKey != nil {
 		t.Fatal("Couldn't generate the right keys")
 	}
 
 	_, err = NewOnDiskPBEKeys(Signing, password, tempDir, nil)
 	if err != nil {
 		t.Fatal("Couldn't recover the serialized keys:", err)
 	}
 }
 
 func TestNewTemporaryTaoDelegatedKeys(t *testing.T) {
-	ft, err := NewFakeTao(auth.Prin{Type: "key", Key: []byte("test")}, "", nil)
+	ft, err := NewFakeTao(auth.NewKeyPrin([]byte("test")), "", nil)
 	if err != nil {
 		t.Fatal("Couldn't initialize a FakeTao:", err)
 	}
 
 	_, err = NewTemporaryTaoDelegatedKeys(Signing|Crypting|Deriving, ft)
 	if err != nil {
 		t.Fatal("Couldn't initialize a temporary hosted keyset:", err)
 	}
 }
 
 func TestNewOnDiskTaoSealedKeys(t *testing.T) {
 	tempDir, err := ioutil.TempDir("", "TestInitHosted")
 	if err != nil {
 		t.Fatal(err.Error())
 	}
 	defer os.RemoveAll(tempDir)
 
-	ft, err := NewFakeTao(auth.Prin{Type: "key", Key: []byte("test")}, "", nil)
+	ft, err := NewFakeTao(auth.NewKeyPrin([]byte("test")), "", nil)
 	if err != nil {
 		t.Fatal("Couldn't initialize a FakeTao:", err)
 	}
 
 	_, err = NewOnDiskTaoSealedKeys(Signing|Crypting|Deriving, ft, tempDir, SealPolicyDefault)
 	if err != nil {
 		t.Fatal("Couldn't initialize a hosted keyset:", err)
 	}
 
 	_, err = NewOnDiskTaoSealedKeys(Signing|Crypting|Deriving, ft, tempDir, SealPolicyDefault)
 	if err != nil {
 		t.Fatal("Couldn't read back a sealed, hosted keyset:", err)
 	}
 }
diff --git a/go/src/cloudproxy/tao/linux_host.go b/go/src/cloudproxy/tao/linux_host.go
index cf420f9..4324430 100644
--- a/go/src/cloudproxy/tao/linux_host.go
+++ b/go/src/cloudproxy/tao/linux_host.go
@@ -38,44 +38,40 @@ type LinuxHost struct {
 	childFactory   LinuxProcessFactory
 	hostedPrograms []*LinuxHostChild
 	hpm            sync.RWMutex
 	nextChildID    uint
 	idm            sync.Mutex
 }
 
 // NewStackedLinuxHost creates a new LinuxHost as a hosted program of an existing
 // host Tao.
 func NewStackedLinuxHost(path string, guard Guard, hostTao Tao) (*LinuxHost, error) {
 	lh := &LinuxHost{
 		path:  path,
 		guard: guard,
 	}
 
 	subprin := guard.Subprincipal()
 	if err := hostTao.ExtendTaoName(subprin); err != nil {
 		return nil, err
 	}
 
-	if err := hostTao.ExtendTaoName(subprin); err != nil {
-		return nil, err
-	}
-
 	k, err := NewOnDiskTaoSealedKeys(Signing|Crypting|Deriving, hostTao, path, SealPolicyDefault)
 	if err != nil {
 		return nil, err
 	}
 
 	lh.taoHost, err = NewTaoStackedHostFromKeys(k, hostTao)
 	if err != nil {
 		return nil, err
 	}
 
 	return lh, nil
 }
 
 // NewRootLinuxHost creates a new LinuxHost as a standalone Host that can
 // provide the Tao to hosted Linux processes.
 func NewRootLinuxHost(path string, guard Guard, password []byte) (*LinuxHost, error) {
 	lh := &LinuxHost{guard: guard}
 	k, err := NewOnDiskPBEKeys(Signing|Crypting|Deriving, password, path, nil)
 	if err != nil {
 		return nil, err
diff --git a/go/src/cloudproxy/tao/linux_host_test.go b/go/src/cloudproxy/tao/linux_host_test.go
index 0f36ad7..f410779 100644
--- a/go/src/cloudproxy/tao/linux_host_test.go
+++ b/go/src/cloudproxy/tao/linux_host_test.go
@@ -12,41 +12,41 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
 package tao
 
 import (
 	"bytes"
 	"io/ioutil"
 	"os"
 	"testing"
 
 	"cloudproxy/tao/auth"
 )
 
 func testNewStackedLinuxHost(t *testing.T) (*LinuxHost, string) {
 	tmpdir, err := ioutil.TempDir("/tmp", "test_new_stacked_linux_host")
 	if err != nil {
 		t.Fatal("Couldn't get a temp directory for the new stacked linux host")
 	}
 
-	ft, err := NewFakeTao(auth.Prin{Type: "key", Key: []byte("test")}, "", nil)
+	ft, err := NewFakeTao(auth.NewKeyPrin([]byte("test")), "", nil)
 	if err != nil {
 		t.Fatal("Couldn't create a new fake Tao:", err)
 	}
 
 	tg := LiberalGuard
 	lh, err := NewStackedLinuxHost(tmpdir, &tg, ft)
 	if err != nil {
 		os.RemoveAll(tmpdir)
 		t.Fatal("Couldn't create a new stacked Linux host")
 	}
 
 	return lh, tmpdir
 }
 
 func testNewRootLinuxHost(t *testing.T) (*LinuxHost, string) {
 	tmpdir, err := ioutil.TempDir("/tmp", "test_new_root_linux_host")
 	if err != nil {
 		t.Fatal("Couldn't get a temp directory for the new root linux host")
 	}
 
diff --git a/go/src/cloudproxy/tao/linux_process_factory.go b/go/src/cloudproxy/tao/linux_process_factory.go
index f678f6b..cf201e9 100644
--- a/go/src/cloudproxy/tao/linux_process_factory.go
+++ b/go/src/cloudproxy/tao/linux_process_factory.go
@@ -1,68 +1,66 @@
 // Copyright (c) 2014, Google Inc.  All rights reserved.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
 // You may obtain a copy of the License at
 //
 //     http://www.apache.org/licenses/LICENSE-2.0
 //
 // Unless required by applicable law or agreed to in writing, software
 // distributed under the License is distributed on an "AS IS" BASIS,
 // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
 package tao
 
 import (
 	"crypto/sha256"
-	"fmt"
 	"io"
 	"io/ioutil"
 	"os"
 	"os/exec"
 	"path"
 	"strings"
 
 	"cloudproxy/tao/auth"
 	"cloudproxy/util"
 )
 
 // In the C++ Tao, these functions are methods on a stateless class. So, in Go,
 // the struct is empty. But we don't make them functions on their own, since we
 // want to support multiple hosted-program factory implementations against an
 // interface in the future.
 
 // A LinuxProcessFactory supports methods for creating Linux processes as
 // hosted programs.
 type LinuxProcessFactory struct{}
 
 // FormatHostedProgramSubprin produces a string that represents a subprincipal
 // with the given ID and hash.
 func FormatHostedProgramSubprin(id uint, hash []byte) auth.SubPrin {
 	var args []auth.Term
 	if id != 0 {
 		args = append(args, auth.Int(id))
 	}
-	hashstr := fmt.Sprintf("%x", hash)
-	args = append(args, auth.Str(hashstr))
+	args = append(args, auth.Bytes(hash))
 	return auth.SubPrin{auth.PrinExt{Name: "Program", Arg: args}}
 }
 
 // MakeHostedProgramSubprin computes the hash of a program to get its
 // hosted-program subprincipal. In the process, it copies the program to a
 // temporary file controlled by this code and returns the path to that new
 // binary.
 func (LinuxProcessFactory) MakeHostedProgramSubprin(id uint, prog string) (subprin auth.SubPrin, temppath string, err error) {
 	// To avoid a time-of-check-to-time-of-use error, we copy the file
 	// bytes to a temp file as we read them. This temp-file path is
 	// returned so it can be used to start the program.
 	td, err := ioutil.TempDir("/tmp", "cloudproxy_linux_host")
 	if err != nil {
 		return
 	}
 
 	temppath = path.Join(td, "hosted_program")
 	tf, err := os.OpenFile(temppath, os.O_CREATE|os.O_RDWR, 0700)
 	defer tf.Close()
 	if err != nil {
