#* 
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-07-22T16:25:42-0700
#* 
#-
#- This is a first pass over the port of the *Host infrastructure. It's still
#- missing some tests, especially for the actual channel implementation, and I'm
#- sure the TaoGuard interface will change given an implementation of
#- datalog. It also probably needs some work wrt signal handling for the Linux
#- admin interface and more support on that front. But I think it would be best
#- if we were both able to work on this, so I'd like to get this checked
#- in. Feel free to ignore the test code, since they're basically just smoke
#- tests. And obviously, the *.pb.go code is just generated code from the usual
#- .proto files.
#- 
#- First part of the linux host system support code for the Tao on Linux using processes as hosted programs
#- 
#- 
#- First cut of port of the LinuxHost support for hosted programs as processes
#- 
#- 
#- Added simple tests for the TaoHost implementations
#- 
#- 
#- Added simple tests for the two types of TrivialGuard TaoGuards
#- 
#- 
#- gofmt and renaming a file to match its purpose better
#- 
#- 
#- Added simple tests for direct calls to LinuxHost
#- 
#- 
#- Added simple tests for the LinuxHostServer
#- 
#- 
diff --git a/go/src/cloudproxy/tao/attestation.proto b/go/src/cloudproxy/tao/attestation.proto
new file mode 120000
index 0000000..15d40dc
--- /dev/null
+++ b/go/src/cloudproxy/tao/attestation.proto
@@ -0,0 +1 @@
+../../../../src/tao/attestation.proto
\ No newline at end of file
diff --git a/go/src/cloudproxy/tao/fake_tao_test.go b/go/src/cloudproxy/tao/fake_tao_test.go
index 6f291e2..a56e5e2 100644
--- a/go/src/cloudproxy/tao/fake_tao_test.go
+++ b/go/src/cloudproxy/tao/fake_tao_test.go
@@ -116,83 +116,56 @@ func (f *FakeTao) GetSharedSecret(n int, policy string) ([]byte, error) {
 // implicit.
 func (f *FakeTao) Seal(data []byte, policy string) ([]byte, error) {
 	// The FakeTao insists on the trivial policy, since it just encrypts the bytes directly
 	if policy != SealPolicyDefault {
 		return nil, errors.New("The FakeTao requires SealPolicyDefault")
 	}
 
 	return f.keys.CryptingKey.Encrypt(data)
 }
 
 // Unseal decrypts data that has been sealed by the Seal operation, but only if
 // the policy specified during the Seal operation is satisfied.
 func (f *FakeTao) Unseal(sealed []byte) (data []byte, policy string, err error) {
 	data, err = f.keys.CryptingKey.Decrypt(sealed)
 	policy = SealPolicyDefault
 	return data, policy, err
 }
 
 // Attest requests that the Tao host sign a Statement on behalf of the caller.
 func (f *FakeTao) Attest(stmt *Statement) (*Attestation, error) {
-	st := new(Statement)
-	proto.Merge(st, stmt)
-
-	if st.Issuer == nil {
-		st.Issuer = proto.String(f.name)
-	} else if st.GetIssuer() != f.name {
+	if stmt.Issuer == nil {
+		stmt.Issuer = proto.String(f.name)
+	} else if stmt.GetIssuer() != f.name {
 		return nil, errors.New("Invalid issuer in statement")
 	}
 
-	if st.Time == nil {
-		st.Time = proto.Int64(time.Now().UnixNano())
-	}
-
-	if st.Expiration == nil {
-		st.Expiration = proto.Int64(time.Now().Add(365 * 24 * time.Hour).UnixNano())
-	}
-
-	ser, err := proto.Marshal(st)
-	if err != nil {
-		return nil, err
-	}
-
-	sig, err := f.keys.SigningKey.Sign(ser, AttestationSigningContext)
-	if err != nil {
-		return nil, err
-	}
-
-	a := &Attestation{
-		SerializedStatement: ser,
-		Signature:           sig,
-		Signer:              proto.String(f.name),
-	}
-
+	var delegation []byte
 	if f.keys.Delegation != nil {
-		sd, err := proto.Marshal(f.keys.Delegation)
+		var err error
+		delegation, err = proto.Marshal(f.keys.Delegation)
 		if err != nil {
 			return nil, err
 		}
-
-		a.SerializedDelegation = sd
 	}
 
-	return a, nil
+	return GenerateAttestation(f.keys.SigningKey, delegation, stmt)
 }
 
 func TestInMemoryInit(t *testing.T) {
 	_, err := NewFakeTao("test", "", nil)
 	if err != nil {
 		t.Fatal("Couldn't initialize a FakeTao in memory:", err)
 	}
 }
 
 func TestFakeTaoRandom(t *testing.T) {
 	ft, err := NewFakeTao("test", "", nil)
 	if err != nil {
 		t.Fatal("Couldn't initialize a FakeTao in memory:", err)
 	}
 
 	if _, err := ft.GetRandomBytes(10); err != nil {
 		t.Fatal("Couldn't get 10 random bytes:", err)
 	}
 }
 
diff --git a/go/src/cloudproxy/tao/keys.proto b/go/src/cloudproxy/tao/keys.proto
new file mode 120000
index 0000000..6260f3d
--- /dev/null
+++ b/go/src/cloudproxy/tao/keys.proto
@@ -0,0 +1 @@
+../../../../src/tao/keys.proto
\ No newline at end of file
diff --git a/go/src/cloudproxy/tao/linux_admin_rpc.pb.go b/go/src/cloudproxy/tao/linux_admin_rpc.pb.go
new file mode 100644
index 0000000..47e8eda
--- /dev/null
+++ b/go/src/cloudproxy/tao/linux_admin_rpc.pb.go
@@ -0,0 +1,196 @@
+// Code generated by protoc-gen-go.
+// source: linux_admin_rpc.proto
+// DO NOT EDIT!
+
+/*
+Package tao is a generated protocol buffer package.
+
+It is generated from these files:
+	linux_admin_rpc.proto
+
+It has these top-level messages:
+	LinuxAdminRPCRequest
+	LinuxAdminRPCHostedProgramList
+	LinuxAdminRPCResponse
+*/
+package tao
+
+import proto "code.google.com/p/goprotobuf/proto"
+import math "math"
+
+// Reference imports to suppress errors if they are not otherwise used.
+var _ = proto.Marshal
+var _ = math.Inf
+
+type LinuxAdminRPCRequestType int32
+
+const (
+	LinuxAdminRPCRequestType_LINUX_ADMIN_RPC_UNKNOWN              LinuxAdminRPCRequestType = 0
+	LinuxAdminRPCRequestType_LINUX_ADMIN_RPC_SHUTDOWN             LinuxAdminRPCRequestType = 1
+	LinuxAdminRPCRequestType_LINUX_ADMIN_RPC_START_HOSTED_PROGRAM LinuxAdminRPCRequestType = 2
+	LinuxAdminRPCRequestType_LINUX_ADMIN_RPC_STOP_HOSTED_PROGRAM  LinuxAdminRPCRequestType = 3
+	LinuxAdminRPCRequestType_LINUX_ADMIN_RPC_KILL_HOSTED_PROGRAM  LinuxAdminRPCRequestType = 4
+	LinuxAdminRPCRequestType_LINUX_ADMIN_RPC_GET_TAO_HOST_NAME    LinuxAdminRPCRequestType = 5
+	LinuxAdminRPCRequestType_LINUX_ADMIN_RPC_LIST_HOSTED_PROGRAMS LinuxAdminRPCRequestType = 6
+)
+
+var LinuxAdminRPCRequestType_name = map[int32]string{
+	0: "LINUX_ADMIN_RPC_UNKNOWN",
+	1: "LINUX_ADMIN_RPC_SHUTDOWN",
+	2: "LINUX_ADMIN_RPC_START_HOSTED_PROGRAM",
+	3: "LINUX_ADMIN_RPC_STOP_HOSTED_PROGRAM",
+	4: "LINUX_ADMIN_RPC_KILL_HOSTED_PROGRAM",
+	5: "LINUX_ADMIN_RPC_GET_TAO_HOST_NAME",
+	6: "LINUX_ADMIN_RPC_LIST_HOSTED_PROGRAMS",
+}
+var LinuxAdminRPCRequestType_value = map[string]int32{
+	"LINUX_ADMIN_RPC_UNKNOWN":              0,
+	"LINUX_ADMIN_RPC_SHUTDOWN":             1,
+	"LINUX_ADMIN_RPC_START_HOSTED_PROGRAM": 2,
+	"LINUX_ADMIN_RPC_STOP_HOSTED_PROGRAM":  3,
+	"LINUX_ADMIN_RPC_KILL_HOSTED_PROGRAM":  4,
+	"LINUX_ADMIN_RPC_GET_TAO_HOST_NAME":    5,
+	"LINUX_ADMIN_RPC_LIST_HOSTED_PROGRAMS": 6,
+}
+
+func (x LinuxAdminRPCRequestType) Enum() *LinuxAdminRPCRequestType {
+	p := new(LinuxAdminRPCRequestType)
+	*p = x
+	return p
+}
+func (x LinuxAdminRPCRequestType) String() string {
+	return proto.EnumName(LinuxAdminRPCRequestType_name, int32(x))
+}
+func (x *LinuxAdminRPCRequestType) UnmarshalJSON(data []byte) error {
+	value, err := proto.UnmarshalJSONEnum(LinuxAdminRPCRequestType_value, data, "LinuxAdminRPCRequestType")
+	if err != nil {
+		return err
+	}
+	*x = LinuxAdminRPCRequestType(value)
+	return nil
+}
+
+type LinuxAdminRPCRequest struct {
+	Rpc              *LinuxAdminRPCRequestType `protobuf:"varint,1,req,name=rpc,enum=tao.LinuxAdminRPCRequestType" json:"rpc,omitempty"`
+	Seq              *uint64                   `protobuf:"varint,2,req,name=seq" json:"seq,omitempty"`
+	Data             []byte                    `protobuf:"bytes,3,opt,name=data" json:"data,omitempty"`
+	Path             *string                   `protobuf:"bytes,4,opt,name=path" json:"path,omitempty"`
+	Args             []string                  `protobuf:"bytes,5,rep,name=args" json:"args,omitempty"`
+	XXX_unrecognized []byte                    `json:"-"`
+}
+
+func (m *LinuxAdminRPCRequest) Reset()         { *m = LinuxAdminRPCRequest{} }
+func (m *LinuxAdminRPCRequest) String() string { return proto.CompactTextString(m) }
+func (*LinuxAdminRPCRequest) ProtoMessage()    {}
+
+func (m *LinuxAdminRPCRequest) GetRpc() LinuxAdminRPCRequestType {
+	if m != nil && m.Rpc != nil {
+		return *m.Rpc
+	}
+	return LinuxAdminRPCRequestType_LINUX_ADMIN_RPC_UNKNOWN
+}
+
+func (m *LinuxAdminRPCRequest) GetSeq() uint64 {
+	if m != nil && m.Seq != nil {
+		return *m.Seq
+	}
+	return 0
+}
+
+func (m *LinuxAdminRPCRequest) GetData() []byte {
+	if m != nil {
+		return m.Data
+	}
+	return nil
+}
+
+func (m *LinuxAdminRPCRequest) GetPath() string {
+	if m != nil && m.Path != nil {
+		return *m.Path
+	}
+	return ""
+}
+
+func (m *LinuxAdminRPCRequest) GetArgs() []string {
+	if m != nil {
+		return m.Args
+	}
+	return nil
+}
+
+type LinuxAdminRPCHostedProgramList struct {
+	Name             []string `protobuf:"bytes,1,rep,name=name" json:"name,omitempty"`
+	Pid              []int32  `protobuf:"varint,2,rep,name=pid" json:"pid,omitempty"`
+	XXX_unrecognized []byte   `json:"-"`
+}
+
+func (m *LinuxAdminRPCHostedProgramList) Reset()         { *m = LinuxAdminRPCHostedProgramList{} }
+func (m *LinuxAdminRPCHostedProgramList) String() string { return proto.CompactTextString(m) }
+func (*LinuxAdminRPCHostedProgramList) ProtoMessage()    {}
+
+func (m *LinuxAdminRPCHostedProgramList) GetName() []string {
+	if m != nil {
+		return m.Name
+	}
+	return nil
+}
+
+func (m *LinuxAdminRPCHostedProgramList) GetPid() []int32 {
+	if m != nil {
+		return m.Pid
+	}
+	return nil
+}
+
+type LinuxAdminRPCResponse struct {
+	Rpc   *LinuxAdminRPCRequestType `protobuf:"varint,1,req,name=rpc,enum=tao.LinuxAdminRPCRequestType" json:"rpc,omitempty"`
+	Seq   *uint64                   `protobuf:"varint,2,req,name=seq" json:"seq,omitempty"`
+	Error *string                   `protobuf:"bytes,3,opt,name=error" json:"error,omitempty"`
+	Data  []byte                    `protobuf:"bytes,4,opt,name=data" json:"data,omitempty"`
+	// serialized LinuxAdminRPCHostedProgramList
+	Reason           *string `protobuf:"bytes,5,opt,name=reason" json:"reason,omitempty"`
+	XXX_unrecognized []byte  `json:"-"`
+}
+
+func (m *LinuxAdminRPCResponse) Reset()         { *m = LinuxAdminRPCResponse{} }
+func (m *LinuxAdminRPCResponse) String() string { return proto.CompactTextString(m) }
+func (*LinuxAdminRPCResponse) ProtoMessage()    {}
+
+func (m *LinuxAdminRPCResponse) GetRpc() LinuxAdminRPCRequestType {
+	if m != nil && m.Rpc != nil {
+		return *m.Rpc
+	}
+	return LinuxAdminRPCRequestType_LINUX_ADMIN_RPC_UNKNOWN
+}
+
+func (m *LinuxAdminRPCResponse) GetSeq() uint64 {
+	if m != nil && m.Seq != nil {
+		return *m.Seq
+	}
+	return 0
+}
+
+func (m *LinuxAdminRPCResponse) GetError() string {
+	if m != nil && m.Error != nil {
+		return *m.Error
+	}
+	return ""
+}
+
+func (m *LinuxAdminRPCResponse) GetData() []byte {
+	if m != nil {
+		return m.Data
+	}
+	return nil
+}
+
+func (m *LinuxAdminRPCResponse) GetReason() string {
+	if m != nil && m.Reason != nil {
+		return *m.Reason
+	}
+	return ""
+}
+
+func init() {
+	proto.RegisterEnum("tao.LinuxAdminRPCRequestType", LinuxAdminRPCRequestType_name, LinuxAdminRPCRequestType_value)
+}
diff --git a/go/src/cloudproxy/tao/linux_admin_rpc.proto b/go/src/cloudproxy/tao/linux_admin_rpc.proto
new file mode 120000
index 0000000..98532d8
--- /dev/null
+++ b/go/src/cloudproxy/tao/linux_admin_rpc.proto
@@ -0,0 +1 @@
+../../../../src/tao/linux_admin_rpc.proto
\ No newline at end of file
diff --git a/go/src/cloudproxy/tao/linux_host.go b/go/src/cloudproxy/tao/linux_host.go
new file mode 100644
index 0000000..eecf915
--- /dev/null
+++ b/go/src/cloudproxy/tao/linux_host.go
@@ -0,0 +1,333 @@
+// Copyright (c) 2014, Google Inc.  All rights reserved.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package tao
+
+import (
+	"errors"
+	"sync"
+	"syscall"
+
+	"code.google.com/p/goprotobuf/proto"
+)
+
+// A LinuxHost is a Tao host environment in which hosted programs are Linux
+// processes. A Unix domain socket accepts administrative commands for
+// controlling the host, e.g., for starting hosted processes, stopping hosted
+// processes, or shutting down the host. A LinuxTao can be run in stacked mode
+// (on top of a host Tao) or in root mode (without an underlying host Tao).
+type LinuxHost struct {
+	path           string
+	guard          TaoGuard
+	taoHost        TaoHost
+	childFactory   LinuxProcessFactory
+	hostedPrograms map[string]*LinuxHostServer
+	hpm            sync.RWMutex
+	nextChildID    uint
+	idm            sync.Mutex
+}
+
+// NewStackedLinuxHost creates a new LinuxHost as a hosted program of an existing
+// host Tao.
+func NewStackedLinuxHost(path string, guard TaoGuard, hostTao Tao) (*LinuxHost, error) {
+	lh := &LinuxHost{
+		path:  path,
+		guard: guard,
+	}
+
+	subprin := guard.SubprincipalName()
+	if err := hostTao.ExtendTaoName(subprin); err != nil {
+		return nil, err
+	}
+
+	if err := hostTao.ExtendTaoName(subprin); err != nil {
+		return nil, err
+	}
+
+	k, err := NewOnDiskTaoSealedKeys(Signing|Crypting|Deriving, hostTao, path, SealPolicyDefault)
+	if err != nil {
+		return nil, err
+	}
+
+	lh.taoHost, err = NewTaoStackedHostFromKeys(k, hostTao)
+	if err != nil {
+		return nil, err
+	}
+
+	return lh, nil
+}
+
+// NewRootLinuxHost creates a new LinuxHost as a standalone Host that can
+// provide the Tao to hosted Linux processes.
+func NewRootLinuxHost(path string, guard TaoGuard, password []byte) (*LinuxHost, error) {
+	lh := &LinuxHost{guard: guard}
+	k, err := NewOnDiskPBEKeys(Signing|Crypting|Deriving, password, path)
+	if err != nil {
+		return nil, err
+	}
+
+	lh.taoHost, err = NewTaoRootHostFromKeys(k)
+	if err != nil {
+		return nil, err
+	}
+
+	return lh, nil
+}
+
+// HandleGetTaoName returns a Tao name for this child subprincipal.
+func (lh *LinuxHost) HandleGetTaoName(childSubprin string) string {
+	return lh.taoHost.TaoHostName() + "::" + childSubprin
+}
+
+// HandleGetRandomBytes gets random bytes from the TaoHost.
+func (lh *LinuxHost) HandleGetRandomBytes(childSubprin string, n int) ([]byte, error) {
+	return lh.taoHost.GetRandomBytes(childSubprin, n)
+}
+
+// HandleGetSharedSecret derives a tag for the secret and generates one from
+// the TaoHost.
+func (lh *LinuxHost) HandleGetSharedSecret(childSubprin string, n int, policy string) ([]byte, error) {
+	// Compute the tag based on the policy identifier and childSubprin.
+	var tag string
+	switch policy {
+	case SharedSecretPolicyDefault:
+	case SharedSecretPolicyConservative:
+		// We are using a master key-deriving key shared among all
+		// similar LinuxHost instances. For LinuxHost, the default
+		// and conservative policies means any process running the same
+		// program binary as the caller hosted on a similar
+		// LinuxHost.
+		// TODO(kwalsh) conservative policy could include PID or other
+		// child info.
+		tag = policy + "|" + childSubprin
+	case SharedSecretPolicyLiberal:
+		// The most liberal we can do is allow any hosted process
+		// running on a similar LinuxHost instance.
+		tag = policy
+	default:
+		return nil, errors.New("policy not supported for GetSharedSecret: " + policy)
+	}
+
+	return lh.taoHost.GetSharedSecret(tag, n)
+}
+
+// HandleSeal seals data for the given policy and child subprincipal.
+func (lh *LinuxHost) HandleSeal(childSubprin string, data []byte, policy string) ([]byte, error) {
+	lhsb := &LinuxHostSealedBundle{
+		Policy: proto.String(policy),
+		Data:   data,
+	}
+
+	switch policy {
+	case SharedSecretPolicyDefault:
+	case SharedSecretPolicyConservative:
+		// We are using a master key-deriving key shared among all
+		// similar LinuxHost instances. For LinuxHost, the default
+		// and conservative policies means any process running the same
+		// program binary as the caller hosted on a similar
+		// LinuxHost.
+		lhsb.PolicyInfo = proto.String(childSubprin)
+	case SharedSecretPolicyLiberal:
+		// The most liberal we can do is allow any hosted process
+		// running on a similar LinuxHost instance. So, we don't set
+		// any policy info.
+	default:
+		return nil, errors.New("policy not supported for Seal: " + policy)
+	}
+
+	m, err := proto.Marshal(lhsb)
+	if err != nil {
+		return nil, err
+	}
+	defer zeroBytes(m)
+
+	return lh.taoHost.Encrypt(m)
+}
+
+// HandleUnseal unseals data and checks its policy information to see if this
+// Unseal operation is authorized.
+func (lh *LinuxHost) HandleUnseal(childSubprin string, sealed []byte) ([]byte, string, error) {
+	decrypted, err := lh.taoHost.Decrypt(sealed)
+	if err != nil {
+		return nil, "", err
+	}
+	defer zeroBytes(decrypted)
+
+	var lhsb LinuxHostSealedBundle
+	if err := proto.Unmarshal(decrypted, &lhsb); err != nil {
+		return nil, "", err
+	}
+
+	if lhsb.Policy == nil {
+		return nil, "", errors.New("invalid policy in sealed data")
+	}
+
+	policy := *lhsb.Policy
+	switch policy {
+	case SharedSecretPolicyDefault:
+	case SharedSecretPolicyConservative:
+		if lhsb.PolicyInfo == nil || childSubprin != *lhsb.PolicyInfo {
+			return nil, "", errors.New("principal not authorized for unseal")
+		}
+	case SharedSecretPolicyLiberal:
+		// Allow all
+		break
+	default:
+		return nil, "", errors.New("policy not supported for Unseal: " + policy)
+	}
+
+	return lhsb.Data, policy, nil
+}
+
+// HandleAttest performs policy checking and performs attestation for a child
+// subprincipal.
+func (lh *LinuxHost) HandleAttest(childSubprin string, stmt *Statement) (*Attestation, error) {
+	if stmt.Delegate == nil && stmt.PredicateName == nil {
+		return nil, errors.New("must supply either delegate or predicate_name in statement for attestation")
+	}
+
+	return lh.taoHost.Attest(childSubprin, stmt)
+}
+
+// StartHostedProgram starts a new program based on an admin RPC request.
+func (lh *LinuxHost) StartHostedProgram(r *LinuxAdminRPCRequest, s *LinuxAdminRPCResponse) error {
+	if r.Path == nil {
+		return errors.New("hosted program creation request is missing path")
+	}
+
+	lh.idm.Lock()
+	id := lh.nextChildID
+	lh.nextChildID++
+	lh.idm.Unlock()
+
+	subprin, temppath, err := lh.childFactory.MakeHostedProgramSubprin(id, *r.Path)
+	if err != nil {
+		return err
+	}
+
+	lh.hpm.RLock()
+	_, ok := lh.hostedPrograms[subprin]
+	lh.hpm.RUnlock()
+	if ok {
+		return errors.New("hosted program " + subprin + " already exists")
+	}
+
+	// TODO(tmroeder): do we want to support concurrent updates to policy? Then we need a lock here, too.
+	name := lh.taoHost.TaoHostName()
+	if !lh.guard.IsAuthorized(name+"::"+subprin, "Execute", []string{}) {
+		return errors.New("Hosted program " + subprin + " denied authorization to execute on host " + name)
+	}
+
+	lhs, err := lh.childFactory.StartHostedProgram(lh, temppath, r.Args, subprin)
+	if err != nil {
+		return err
+	}
+
+	lh.hpm.Lock()
+	lh.hostedPrograms[subprin] = lhs
+	lh.hpm.Unlock()
+
+	s.Data = []byte(subprin)
+	return nil
+}
+
+// StopHostedProgram stops a running hosted program based on an admin RPC
+// request.
+func (lh *LinuxHost) StopHostedProgram(r *LinuxAdminRPCRequest, s *LinuxAdminRPCResponse) error {
+	if r.Data == nil {
+		return errors.New("missing child subprincipal")
+	}
+
+	// TODO(tmroeder): this implementation should be extended to support
+	// multiple clients with the same subprincipal name.
+	subprin := string(r.Data)
+	lh.hpm.Lock()
+	defer lh.hpm.Unlock()
+	lph, ok := lh.hostedPrograms[subprin]
+	if !ok {
+		return errors.New("no subprincipal " + subprin)
+	}
+
+	// Close the channel before sending SIGTERM
+	lph.channel.Close()
+
+	// For Stop, we send SIGTERM
+	var sigterm int = 15
+	if err := syscall.Kill(lph.Cmd.Process.Pid, syscall.Signal(sigterm)); err != nil {
+		return err
+	}
+
+	delete(lh.hostedPrograms, subprin)
+	return nil
+}
+
+// ListHostedPrograms returns a list of hosted programs to the caller.
+func (lh *LinuxHost) ListHostedPrograms(r *LinuxAdminRPCRequest, s *LinuxAdminRPCResponse) error {
+	lh.hpm.RLock()
+	subprins := make([]string, len(lh.hostedPrograms))
+	pids := make([]int32, len(lh.hostedPrograms))
+	for k, v := range lh.hostedPrograms {
+		subprins = append(subprins, k)
+		pids = append(pids, int32(v.Cmd.Process.Pid))
+	}
+	lh.hpm.RUnlock()
+
+	info := &LinuxAdminRPCHostedProgramList{
+		Name: subprins,
+		Pid:  pids,
+	}
+
+	var err error
+	s.Data, err = proto.Marshal(info)
+	if err != nil {
+		return err
+	}
+
+	return nil
+}
+
+// KillHostedProgram kills a running hosted program based on an admin RPC
+// request.
+func (lh *LinuxHost) KillHostedProgram(r *LinuxAdminRPCRequest, s *LinuxAdminRPCResponse) error {
+	if r.Data == nil {
+		return errors.New("missing child subprincipal")
+	}
+
+	// TODO(tmroeder): this implementation should be extended to support
+	// multiple clients with the same subprincipal name.
+	subprin := string(r.Data)
+	lh.hpm.Lock()
+	defer lh.hpm.Unlock()
+	lph, ok := lh.hostedPrograms[subprin]
+	if !ok {
+		return errors.New("no subprincipal " + subprin)
+	}
+
+	// Close the channel before sending SIGTERM
+	lph.channel.Close()
+
+	// For kill, we use the Go call on Process.
+	if err := lph.Cmd.Process.Kill(); err != nil {
+		return err
+	}
+
+	delete(lh.hostedPrograms, subprin)
+	return nil
+}
+
+// GetTaoHostName returns the name of the TaoHost used by the LinuxHost.
+func (lh *LinuxHost) GetTaoHostName(r *LinuxAdminRPCRequest, s *LinuxAdminRPCResponse) error {
+	s.Data = []byte(lh.taoHost.TaoHostName())
+	return nil
+}
diff --git a/go/src/cloudproxy/tao/linux_host.pb.go b/go/src/cloudproxy/tao/linux_host.pb.go
new file mode 100644
index 0000000..8615fec
--- /dev/null
+++ b/go/src/cloudproxy/tao/linux_host.pb.go
@@ -0,0 +1,56 @@
+// Code generated by protoc-gen-go.
+// source: linux_host.proto
+// DO NOT EDIT!
+
+/*
+Package tao is a generated protocol buffer package.
+
+It is generated from these files:
+	linux_host.proto
+
+It has these top-level messages:
+	LinuxHostSealedBundle
+*/
+package tao
+
+import proto "code.google.com/p/goprotobuf/proto"
+import math "math"
+
+// Reference imports to suppress errors if they are not otherwise used.
+var _ = proto.Marshal
+var _ = math.Inf
+
+type LinuxHostSealedBundle struct {
+	Policy           *string `protobuf:"bytes,1,req,name=policy" json:"policy,omitempty"`
+	PolicyInfo       *string `protobuf:"bytes,2,opt,name=policy_info" json:"policy_info,omitempty"`
+	Data             []byte  `protobuf:"bytes,3,req,name=data" json:"data,omitempty"`
+	XXX_unrecognized []byte  `json:"-"`
+}
+
+func (m *LinuxHostSealedBundle) Reset()         { *m = LinuxHostSealedBundle{} }
+func (m *LinuxHostSealedBundle) String() string { return proto.CompactTextString(m) }
+func (*LinuxHostSealedBundle) ProtoMessage()    {}
+
+func (m *LinuxHostSealedBundle) GetPolicy() string {
+	if m != nil && m.Policy != nil {
+		return *m.Policy
+	}
+	return ""
+}
+
+func (m *LinuxHostSealedBundle) GetPolicyInfo() string {
+	if m != nil && m.PolicyInfo != nil {
+		return *m.PolicyInfo
+	}
+	return ""
+}
+
+func (m *LinuxHostSealedBundle) GetData() []byte {
+	if m != nil {
+		return m.Data
+	}
+	return nil
+}
+
+func init() {
+}
diff --git a/go/src/cloudproxy/tao/linux_host.proto b/go/src/cloudproxy/tao/linux_host.proto
new file mode 120000
index 0000000..c3abb1a
--- /dev/null
+++ b/go/src/cloudproxy/tao/linux_host.proto
@@ -0,0 +1 @@
+../../../../src/tao/linux_host.proto
\ No newline at end of file
diff --git a/go/src/cloudproxy/tao/linux_host_server.go b/go/src/cloudproxy/tao/linux_host_server.go
new file mode 100644
index 0000000..b76c2f3
--- /dev/null
+++ b/go/src/cloudproxy/tao/linux_host_server.go
@@ -0,0 +1,119 @@
+//  Copyright (c) 2014, Google Inc.  All rights reserved.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package tao
+
+import (
+	"errors"
+	"io"
+	"os/exec"
+
+	"code.google.com/p/goprotobuf/proto"
+)
+
+// A LinuxHostServer wraps a LinuxHost and serves its methods across a net/rpc
+// connection to a hosted program.
+type LinuxHostServer struct {
+	host         *LinuxHost
+	channel      io.ReadWriteCloser
+	ChildSubprin string
+	Cmd          *exec.Cmd
+}
+
+// GetTaoName returns the Tao principal name assigned to the caller.
+func (lhs *LinuxHostServer) GetTaoName(r *TaoRPCRequest, s *TaoRPCResponse) error {
+	s.Data = []byte(lhs.host.HandleGetTaoName(lhs.ChildSubprin))
+	return nil
+}
+
+// ExtendTaoName irreversibly extends the Tao principal name of the caller.
+func (lhs *LinuxHostServer) ExtendTaoName(r *TaoRPCRequest, s *TaoRPCResponse) error {
+	lhs.ChildSubprin += "::" + string(r.Data)
+	return nil
+}
+
+// GetRandomBytes returns a slice of n random bytes.
+func (lhs *LinuxHostServer) GetRandomBytes(r *TaoRPCRequest, s *TaoRPCResponse) error {
+	if r.Size == nil || *r.Size <= 0 {
+		return errors.New("Invalid array size")
+	}
+
+	var err error
+	s.Data, err = lhs.host.HandleGetRandomBytes(lhs.ChildSubprin, int(*r.Size))
+	if err != nil {
+		return err
+	}
+
+	return nil
+}
+
+// Rand produces an io.Reader for random bytes from this Tao.  This should
+// never be called on the LinuxHostServer, since it's handled transparently by
+// TaoClient.
+func (lhs *LinuxHostServer) Rand(r *TaoRPCRequest, s *TaoRPCResponse) error {
+	return errors.New("not implemented")
+}
+
+// GetSharedSecret returns a slice of n secret bytes.
+func (lhs *LinuxHostServer) GetSharedSecret(r *TaoRPCRequest, s *TaoRPCResponse) error {
+	var err error
+	s.Data, err = lhs.host.HandleGetSharedSecret(lhs.ChildSubprin, int(*r.Size), string(r.Data))
+	if err != nil {
+		return err
+	}
+
+	return nil
+}
+
+// Seal encrypts data so only certain hosted programs can unseal it.
+func (lhs *LinuxHostServer) Seal(r *TaoRPCRequest, s *TaoRPCResponse) error {
+	var err error
+	s.Data, err = lhs.host.HandleSeal(lhs.ChildSubprin, r.Data, *r.Policy)
+	if err != nil {
+		return err
+	}
+
+	return nil
+}
+
+// Unseal decrypts data that has been sealed by the Seal() operation, but only
+// if the policy specified during the Seal() operation is satisfied.
+func (lhs *LinuxHostServer) Unseal(r *TaoRPCRequest, s *TaoRPCResponse) error {
+	var err error
+	var policy string
+	s.Data, policy, err = lhs.host.HandleUnseal(lhs.ChildSubprin, r.Data)
+	if err != nil {
+		return err
+	}
+
+	s.Policy = proto.String(policy)
+	return nil
+}
+
+// Attest requests the Tao host sign a Statement on behalf of the caller.
+func (lhs *LinuxHostServer) Attest(r *TaoRPCRequest, s *TaoRPCResponse) error {
+	stmt := new(Statement)
+	err := proto.Unmarshal(r.Data, stmt)
+	if err != nil {
+		return err
+	}
+
+	a, err := lhs.host.HandleAttest(lhs.ChildSubprin, stmt)
+	if err != nil {
+		return err
+	}
+
+	s.Data, err = proto.Marshal(a)
+	return err
+}
diff --git a/go/src/cloudproxy/tao/linux_host_server_test.go b/go/src/cloudproxy/tao/linux_host_server_test.go
new file mode 100644
index 0000000..f57bbd1
--- /dev/null
+++ b/go/src/cloudproxy/tao/linux_host_server_test.go
@@ -0,0 +1,159 @@
+//  Copyright (c) 2014, Google Inc.  All rights reserved.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package tao
+
+import (
+	"bytes"
+	"os"
+	"strconv"
+	"testing"
+	"time"
+
+	"code.google.com/p/goprotobuf/proto"
+)
+
+func testNewLinuxHostServer(t *testing.T) (*LinuxHostServer, string) {
+	lh, tmpdir := testNewRootLinuxHost(t)
+
+	// The channel and Cmd are used by admin operations in the Linux host,
+	// so they don't need to be filled here.
+	lhs := &LinuxHostServer{
+		host:         lh,
+		ChildSubprin: "test child",
+	}
+	return lhs, tmpdir
+}
+
+func TestLinuxHostServerGetTaoName(t *testing.T) {
+	r := &TaoRPCRequest{}
+	s := &TaoRPCResponse{}
+	lhs, tmpdir := testNewLinuxHostServer(t)
+	defer os.RemoveAll(tmpdir)
+	if err := lhs.GetTaoName(r, s); err != nil {
+		t.Fatal("Couldn't get the Tao name from the LinuxHostServer:", err)
+	}
+
+	if s.Data == nil {
+		t.Fatal("Couldn't get a name back from GetTaoName on LinuxHostServer")
+	}
+}
+
+func TestLinuxHostServerExtendTaoName(t *testing.T) {
+	r := &TaoRPCRequest{
+		Data: []byte("extension"),
+	}
+	s := &TaoRPCResponse{}
+	lhs, tmpdir := testNewLinuxHostServer(t)
+	defer os.RemoveAll(tmpdir)
+	if err := lhs.ExtendTaoName(r, s); err != nil {
+		t.Fatal("Couldn't extend the Tao name through LinuxHostServer:", err)
+	}
+}
+
+func TestLinuxHostServerGetRandomBytes(t *testing.T) {
+	r := &TaoRPCRequest{
+		Size: proto.Int32(10),
+	}
+	s := &TaoRPCResponse{}
+	lhs, tmpdir := testNewLinuxHostServer(t)
+	defer os.RemoveAll(tmpdir)
+	if err := lhs.GetRandomBytes(r, s); err != nil {
+		t.Fatal("Couldn't get random bytes from LinuxHostServer:", err)
+	}
+
+	if len(s.Data) != 10 {
+		t.Fatal("Wrong number of bytes returned from GetRandomBytes on LinuxHostServer. Expected 10 and got " + strconv.Itoa(len(s.Data)))
+	}
+}
+
+func TestLinuxHostServerRand(t *testing.T) {
+	r := &TaoRPCRequest{}
+	s := &TaoRPCResponse{}
+	lhs, tmpdir := testNewLinuxHostServer(t)
+	defer os.RemoveAll(tmpdir)
+	if err := lhs.Rand(r, s); err == nil {
+		t.Fatal("Incorrect received nil error from Rand on LinuxHostServer")
+	}
+}
+
+func TestLinuxHostServerSealUnseal(t *testing.T) {
+	r := &TaoRPCRequest{
+		Data: []byte{1, 2, 3, 4, 5},
+		Policy: proto.String(SealPolicyDefault),
+	}
+	s := &TaoRPCResponse{}
+	lhs, tmpdir := testNewLinuxHostServer(t)
+	defer os.RemoveAll(tmpdir)
+	if err := lhs.Seal(r, s); err != nil {
+		t.Fatal("Couldn't seal the data using LinuxHostServer")
+	}
+
+	if len(s.Data) == 0 {
+		t.Fatal("Invalid sealed data from LinuxHostServer")
+	}
+
+	r2 := &TaoRPCRequest{
+		Data: s.Data,
+	}
+	s2 := &TaoRPCResponse{}
+	if err := lhs.Unseal(r2, s2); err != nil {
+		t.Fatal("Couldn't unseal data sealed by LinuxHostServer")
+	}
+
+	if !bytes.Equal(s2.Data, r.Data) {
+		t.Fatal("Incorrect data unsealed by Seal/Unseal on LinuxHostServer")
+	}
+}
+
+func TestLinuxHostServerAttest(t *testing.T) {
+	rt := &TaoRPCRequest{}
+	st := &TaoRPCResponse{}
+	lhs, tmpdir := testNewLinuxHostServer(t)
+	defer os.RemoveAll(tmpdir)
+	if err := lhs.GetTaoName(rt, st); err != nil {
+		t.Fatal("Couldn't get the Tao name from the LinuxHostServer:", err)
+	}
+
+	stmt := &Statement{
+		Issuer: proto.String(string(st.Data)),
+		Time: proto.Int64(time.Now().UnixNano()),
+		Expiration: proto.Int64(time.Now().Add(24*time.Hour).UnixNano()),
+		PredicateName: proto.String("FakePredicate"),
+	}
+
+	m, err := proto.Marshal(stmt)
+	if err != nil {
+		t.Fatal("Couldn't marshal a statement for a call to Attest on LinuxHostServer:", err)
+	}
+
+	r := &TaoRPCRequest{
+		Data: m,
+	}
+	s := &TaoRPCResponse{}
+	if err := lhs.Attest(r, s); err != nil {
+		t.Fatal("Couldn't attest to data through LinuxHostServer:", err)
+	}
+
+	if len(s.Data) == 0 {
+		t.Fatal("Invalid marshalled Attestation data returned by LinuxHostServer")
+	}
+
+	var a Attestation
+	if err := proto.Unmarshal(s.Data, &a); err != nil {
+		t.Fatal("Couldn't unmarshal into an Attestation the data returned by Attest on LinuxHostServer")
+	}
+
+	// TODO(tmroeder): verify the attestation
+}
diff --git a/go/src/cloudproxy/tao/linux_host_test.go b/go/src/cloudproxy/tao/linux_host_test.go
new file mode 100644
index 0000000..fd59c0e
--- /dev/null
+++ b/go/src/cloudproxy/tao/linux_host_test.go
@@ -0,0 +1,207 @@
+//  Copyright (c) 2014, Google Inc.  All rights reserved.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package tao
+
+import (
+	"bytes"
+	"io/ioutil"
+	"os"
+	"testing"
+
+	"code.google.com/p/goprotobuf/proto"
+)
+
+func testNewStackedLinuxHost(t *testing.T) (*LinuxHost, string) {
+	tmpdir, err := ioutil.TempDir("/tmp", "test_new_stacked_linux_host")
+	if err != nil {
+		t.Fatal("Couldn't get a temp directory for the new stacked linux host")
+	}
+
+	tg := NewTrivialGuard(LiberalPolicy)
+	ft, err := NewFakeTao("test", "", nil)
+	if err != nil {
+		t.Fatal("Couldn't create a new fake Tao:", err)
+	}
+
+	lh, err := NewStackedLinuxHost(tmpdir, tg, ft)
+	if err != nil {
+		os.RemoveAll(tmpdir)
+		t.Fatal("Couldn't create a new stacked Linux host")
+	}
+
+	return lh, tmpdir
+}
+
+func testNewRootLinuxHost(t *testing.T) (*LinuxHost, string) {
+	tmpdir, err := ioutil.TempDir("/tmp", "test_new_root_linux_host")
+	if err != nil {
+		t.Fatal("Couldn't get a temp directory for the new root linux host")
+	}
+
+	tg := NewTrivialGuard(LiberalPolicy)
+	password := []byte("bad password")
+	lh, err := NewRootLinuxHost(tmpdir, tg, password)
+	if err != nil {
+		os.RemoveAll(tmpdir)
+		t.Fatal("Couldn't create a new stacked Linux host")
+	}
+
+	return lh, tmpdir
+}
+
+func TestNewStackedLinuxHost(t *testing.T) {
+	_, td := testNewStackedLinuxHost(t)
+	defer os.RemoveAll(td)
+}
+
+func TestNewRootLinuxHost(t *testing.T) {
+	_, td := testNewRootLinuxHost(t)
+	defer os.RemoveAll(td)
+}
+
+// Test the methods directly instead of testing them across a channel.
+
+var testChildLH string = "test child"
+
+func testLinuxHostHandleGetTaoName(t *testing.T, lh *LinuxHost) {
+	if lh.HandleGetTaoName(testChildLH) != lh.taoHost.TaoHostName()+"::"+testChildLH {
+		t.Fatal("Incorrect construction of Tao name")
+	}
+}
+
+func testLinuxHostHandleGetRandomBytes(t *testing.T, lh *LinuxHost) {
+	b, err := lh.HandleGetRandomBytes(testChildLH, 10)
+	if err != nil {
+		t.Fatal("Failed to get random bytes from the Linux host:", err)
+	}
+
+	if len(b) != 10 {
+		t.Fatal("Linux host returned the incorrect number of random bytes")
+	}
+}
+
+func testLinuxHostHandleGetSharedSecret(t *testing.T, lh *LinuxHost) {
+	b, err := lh.HandleGetSharedSecret(testChildLH, 10, SharedSecretPolicyDefault)
+	if err != nil {
+		t.Fatal("Couldn't get a shared secret from the Linux host:", err)
+	}
+
+	b2, err := lh.HandleGetSharedSecret(testChildLH, 10, SharedSecretPolicyDefault)
+	if err != nil {
+		t.Fatal("Couldn't get a second shared secret from the Linux host:", err)
+	}
+
+	if len(b) == 0 || !bytes.Equal(b, b2) {
+		t.Fatal("Invalid or inconsistent secrets returned from HandleGetSharedSecret in the Linux host")
+	}
+}
+
+func testLinuxHostHandleSealUnseal(t *testing.T, lh *LinuxHost) {
+	data := []byte{1, 2, 3, 4, 5, 6, 7}
+	b, err := lh.HandleSeal(testChildLH, data, SharedSecretPolicyDefault)
+	if err != nil {
+		t.Fatal("Couldn't seal the data:", err)
+	}
+
+	d, policy, err := lh.HandleUnseal(testChildLH, b)
+	if err != nil {
+		t.Fatal("Couldn't unseal the sealed data")
+	}
+
+	if !bytes.Equal(d, data) {
+		t.Fatal("Incorrect unsealed data")
+	}
+
+	if policy != SharedSecretPolicyDefault {
+		t.Fatal("Wrong policy returned by Unseal")
+	}
+}
+
+func testLinuxHostHandleAttest(t *testing.T, lh *LinuxHost) {
+	stmt := &Statement{
+		PredicateName: proto.String("FakePredicate"),
+	}
+
+	a, err := lh.HandleAttest(testChildLH, stmt)
+	if err != nil {
+		t.Fatal("Couldn't create Attestation")
+	}
+
+	if a == nil {
+		t.Fatal("Returned invalid Attestation from Attest")
+	}
+
+	// TODO(tmroeder): verify this attestation.
+}
+
+func testRootLinuxHostHandleGetTaoName(t *testing.T) {
+	lh, td := testNewRootLinuxHost(t)
+	defer os.RemoveAll(td)
+	testLinuxHostHandleGetTaoName(t, lh)
+}
+
+func testRootLinuxHostHandleGetRandomBytes(t *testing.T) {
+	lh, td := testNewRootLinuxHost(t)
+	defer os.RemoveAll(td)
+	testLinuxHostHandleGetRandomBytes(t, lh)
+}
+
+func testRootLinuxHostHandleGetSharedSecret(t *testing.T) {
+	lh, td := testNewRootLinuxHost(t)
+	defer os.RemoveAll(td)
+	testLinuxHostHandleGetSharedSecret(t, lh)
+}
+
+func testRootLinuxHostHandleSealUnseal(t *testing.T) {
+	lh, td := testNewRootLinuxHost(t)
+	defer os.RemoveAll(td)
+	testLinuxHostHandleSealUnseal(t, lh)
+}
+
+func testRootLinuxHostHandleAttest(t *testing.T) {
+	lh, td := testNewRootLinuxHost(t)
+	defer os.RemoveAll(td)
+	testLinuxHostHandleAttest(t, lh)
+}
+
+func testStackedLinuxHostHandleGetTaoName(t *testing.T) {
+	lh, td := testNewStackedLinuxHost(t)
+	defer os.RemoveAll(td)
+	testLinuxHostHandleGetTaoName(t, lh)
+}
+
+func testStackedLinuxHostHandleGetRandomBytes(t *testing.T) {
+	lh, td := testNewStackedLinuxHost(t)
+	defer os.RemoveAll(td)
+	testLinuxHostHandleGetRandomBytes(t, lh)
+}
+
+func testStackedLinuxHostHandleGetSharedSecret(t *testing.T) {
+	lh, td := testNewStackedLinuxHost(t)
+	defer os.RemoveAll(td)
+	testLinuxHostHandleGetSharedSecret(t, lh)
+}
+
+func testStackedLinuxHostHandleSealUnseal(t *testing.T) {
+	lh, td := testNewStackedLinuxHost(t)
+	defer os.RemoveAll(td)
+	testLinuxHostHandleSealUnseal(t, lh)
+}
+
+func testStackedLinuxHostHandleAttest(t *testing.T) {
+	lh, td := testNewStackedLinuxHost(t)
+	defer os.RemoveAll(td)
+	testLinuxHostHandleAttest(t, lh)
+}
diff --git a/go/src/cloudproxy/tao/linux_process_factory.go b/go/src/cloudproxy/tao/linux_process_factory.go
new file mode 100644
index 0000000..4101032
--- /dev/null
+++ b/go/src/cloudproxy/tao/linux_process_factory.go
@@ -0,0 +1,133 @@
+// Copyright (c) 2014, Google Inc.  All rights reserved.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package tao
+
+import (
+	"crypto/sha256"
+	"encoding/hex"
+	"io"
+	"io/ioutil"
+	"net/rpc"
+	"os"
+	"os/exec"
+	"path"
+	"strconv"
+
+	"cloudproxy/util"
+)
+
+// In the C++ Tao, these functions are methods on a stateless class. So, in Go,
+// the struct is empty. But we don't make them functions on their own, since we
+// want to support multiple hosted-program factory implementations against an
+// interface in the future.
+
+// A LinuxProcessFactory supports methods for creating Linux processes as
+// hosted programs.
+type LinuxProcessFactory struct{}
+
+// FormatHostedProgramSubprin produces a string that represents a subprincipal
+// with the given ID and hash.
+func FormatHostedProgramSubprin(id uint, hash []byte) string {
+	var out string
+	if id != 0 {
+		out += "Process(" + strconv.Itoa(int(id)) + ",\""
+	} else {
+		out += "Program(\""
+	}
+
+	// The C++ Tao uses a method to escape quotes here, but that's not
+	// necessary in this case, since the hash is getting converted to hex,
+	// which can't include quotes.
+	out += hex.EncodeToString(hash)
+	out += "\")"
+	return out
+}
+
+// MakeHostedProgramSubprin computes the hash of a program to get its
+// hosted-program subprincipal. In the process, it copies the program to a
+// temporary file controlled by this code and returns the path to that new
+// binary.
+func (LinuxProcessFactory) MakeHostedProgramSubprin(id uint, prog string) (subprin, temppath string, err error) {
+	// To avoid a time-of-check-to-time-of-use error, we copy the file
+	// bytes to a temp file as we read them. This temp-file path is
+	// returned so it can be used to start the program.
+	td, err := ioutil.TempDir("/tmp", "cloudproxy_linux_host")
+	if err != nil {
+		return
+	}
+
+	temppath = path.Join(td, "hosted_program")
+	tf, err := os.OpenFile(temppath, os.O_RDWR, 0700)
+	defer tf.Close()
+	if err != nil {
+		return
+	}
+
+	inf, err := os.Open(prog)
+	defer inf.Close()
+	if err != nil {
+		return
+	}
+
+	// Read from the input file and write to the temp file.
+	tr := io.TeeReader(inf, tf)
+	b, err := ioutil.ReadAll(tr)
+	if err != nil {
+		return
+	}
+
+	h := sha256.Sum256(b)
+	subprin = FormatHostedProgramSubprin(id, h[:])
+	return
+}
+
+// StartHostedProgram uses a path, arguments, and a subprincipal name to create
+// a LinuxHostServer that manages messages to and from hosted processes under
+// Linux.
+func (LinuxProcessFactory) StartHostedProgram(lh *LinuxHost, prog string, args []string, subprin string) (*LinuxHostServer, error) {
+	// Get a pipe pair for communication with the child.
+	serverRead, clientWrite, err := os.Pipe()
+	if err != nil {
+		return nil, err
+	}
+
+	clientRead, serverWrite, err := os.Pipe()
+	if err != nil {
+		return nil, err
+	}
+
+	rw := util.NewPairReadWriteCloser(serverRead, serverWrite)
+	c := &exec.Cmd{
+		Path:       prog,
+		Stdin:      os.Stdin,
+		Stdout:     os.Stdout,
+		Stderr:     os.Stderr,
+		ExtraFiles: []*os.File{clientRead, clientWrite},
+		// TODO(tmroeder): change the user of the hosted program here.
+	}
+
+	if err := c.Start(); err != nil {
+		return nil, err
+	}
+
+	lph := &LinuxHostServer{lh, rw, subprin, c}
+	server := rpc.NewServer()
+	if err := server.Register(lph); err != nil {
+		return nil, err
+	}
+
+	go server.ServeConn(rw)
+	return lph, nil
+}
diff --git a/go/src/cloudproxy/tao/tao_guard.go b/go/src/cloudproxy/tao/tao_guard.go
new file mode 100644
index 0000000..01fff9a
--- /dev/null
+++ b/go/src/cloudproxy/tao/tao_guard.go
@@ -0,0 +1,241 @@
+// Copyright (c) 2014, Google Inc.  All rights reserved.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// This interface was derived from the code in src/tao/tao_guard.h.
+
+package tao
+
+import (
+	"errors"
+)
+
+// MakePredicate constructs an authorization predicate of the form:
+//   Authorize(name, op, args...).
+// TODO(tmroeder): implement this function.
+func MakePredicate(name, op string, args []string) string {
+	return ""
+}
+
+// A TaoGuard is an interface for evaluating policy decisions.
+type TaoGuard interface {
+	// SubprincipalName returns a unique name for this policy, one that can
+	// be used as a subprincipal name.
+	SubprincipalName() string
+
+	// GuardTypeName returns a name for this type of guard, one that be
+	// used as a predicate name.
+	GuardTypeName() string
+
+	// Authorize adds an authorization for a principal to perform an
+	// operation.
+	Authorize(name, op string, args []string) error
+
+	// Retract removes an authorization for a principal to perform an
+	// operation, essentially reversing the effect of an Authorize() call
+	// with identical name, op, and args. Note: this reverses the effect of
+	// an Authorize() call with identical parameters of the equivalent
+	// AddRule() call. However, particularly when expressive policies are
+	// supported (e.g., an "authorize all" rule), other rules may still be
+	// in place authorizing the principal to perform the operation.
+	Retract(name, op string, args []string) error
+
+	// IsAuthorized checks whether a principal is authorized to perform an
+	// operation.
+	IsAuthorized(name, op string, args []string) bool
+
+	// AddRule adds a policy rule. Subclasses should support at least rules
+	// of the form: Authorized(P, op, args...). This is equivalent to
+	// calling Authorize(P, op, args...) with each of the arguments
+	// converted to either a string or integer.
+	AddRule(rule string) error
+
+	// RetractRule removes a rule previously added via AddRule() or the
+	// equivalent Authorize() call.
+	RetractRule(rule string) error
+
+	// Clear removes all rules.
+	Clear() error
+
+	// Query the policy. Implementations of this interface should support
+	// at least queries of the form: Authorized(P, op, args...).
+	Query(query string) bool
+
+	// RuleCount returns a count of the total number of rules.
+	RuleCount() int
+
+	// GetRule returns the ith policy rule, if it exists.
+	GetRule(i int) string
+
+	// RuleDebugString returns a debug string for the ith policy rule, if
+	// it exists.
+	RuleDebugString(i int) string
+
+	// DebugString returns a string suitable for showing users
+	// authorization info.
+	DebugString() string
+}
+
+// A PolicyType specifies the type of policy to use in the TrivialGuard.
+type PolicyType int
+
+// The types of TrivialGuard Policy.
+const (
+	ConservativePolicy PolicyType = 1 << iota
+	LiberalPolicy
+)
+
+// errTrivialGuard is the error returned for all non-trivial policy operations
+// on the TrivialGuard.
+var errTrivialGuard = errors.New("can't perform policy operations on the TrivialGuard")
+
+// A TrivialGuard implements either the ConservativePolicy (always Deny) or the
+// LiberalPolicy (always Accept).
+type TrivialGuard struct {
+	policy PolicyType
+}
+
+// NewTrivialGuard returns TrivialGuard with the specified policy.
+func NewTrivialGuard(policy PolicyType) TaoGuard {
+	return &TrivialGuard{policy}
+}
+
+// SubprincipalName returns a subprincipal name for the TrivialGuard as
+// 'TrivialGuard("<type>")' where type is the policy type.
+func (t *TrivialGuard) SubprincipalName() string {
+	switch t.policy {
+	case ConservativePolicy:
+		return "TrivialGuard(\"Conservative\")"
+	case LiberalPolicy:
+		return "TrivialGuard(\"Liberal\")"
+	default:
+		return "UnknownSubprincipal"
+	}
+}
+
+// GuardTypeName returns "TrivialGuard" as the type of this guard.
+func (t *TrivialGuard) GuardTypeName() string {
+	switch t.policy {
+	case ConservativePolicy:
+		return "TrivialConservativeGuard"
+	case LiberalPolicy:
+		return "TrivialLiberalGuard"
+	default:
+		return "UnknownGuard"
+	}
+}
+
+// Authorize adds an authorization for a principal to perform an
+// operation.
+func (t *TrivialGuard) Authorize(name, op string, args []string) error {
+	return errTrivialGuard
+}
+
+// Retract removes an authorization for a principal to perform an
+// operation, essentially reversing the effect of an Authorize() call
+// with identical name, op, and args. Note: this reverses the effect of
+// an Authorize() call with identical parameters of the equivalent
+// AddRule() call. However, particularly when expressive policies are
+// supported (e.g., an "authorize all" rule), other rules may still be
+// in place authorizing the principal to perform the operation.
+func (t *TrivialGuard) Retract(name, op string, args []string) error {
+	return errTrivialGuard
+}
+
+// IsAuthorized checks whether a principal is authorized to perform an
+// operation.
+func (t *TrivialGuard) IsAuthorized(name, op string, args []string) bool {
+	switch t.policy {
+	case ConservativePolicy:
+		return false
+	case LiberalPolicy:
+		return true
+	default:
+		return false
+	}
+}
+
+// AddRule adds a policy rule. Subclasses should support at least rules
+// of the form: Authorized(P, op, args...). This is equivalent to
+// calling Authorize(P, op, args...) with each of the arguments
+// converted to either a string or integer.
+func (t *TrivialGuard) AddRule(rule string) error {
+	return errTrivialGuard
+}
+
+// RetractRule removes a rule previously added via AddRule() or the
+// equivalent Authorize() call.
+func (t *TrivialGuard) RetractRule(rule string) error {
+	return errTrivialGuard
+}
+
+// Clear removes all rules.
+func (t *TrivialGuard) Clear() error {
+	return errTrivialGuard
+}
+
+// Query the policy. Implementations of this interface should support
+// at least queries of the form: Authorized(P, op, args...).
+func (t *TrivialGuard) Query(query string) bool {
+	switch t.policy {
+	case ConservativePolicy:
+		return false
+	case LiberalPolicy:
+		return true
+	default:
+		return false
+	}
+}
+
+// RuleCount returns a count of the total number of rules.
+func (t *TrivialGuard) RuleCount() int {
+	return 1
+}
+
+// GetRule returns the ith policy rule, if it exists.
+func (t *TrivialGuard) GetRule(i int) string {
+	switch t.policy {
+	case ConservativePolicy:
+		return "Deny All"
+	case LiberalPolicy:
+		return "Allow All"
+	default:
+		return "Unknown Policy"
+	}
+}
+
+// RuleDebugString returns a debug string for the ith policy rule, if
+// it exists.
+func (t *TrivialGuard) RuleDebugString(i int) string {
+	switch t.policy {
+	case ConservativePolicy:
+		return "Deny All"
+	case LiberalPolicy:
+		return "Allow All"
+	default:
+		return "Unknown Policy"
+	}
+}
+
+// DebugString returns a string suitable for showing users
+// authorization info.
+func (t *TrivialGuard) DebugString() string {
+	switch t.policy {
+	case ConservativePolicy:
+		return "Trivial Conservative Policy (a.k.a. \"deny all\")"
+	case LiberalPolicy:
+		return "Trivial Liberal Policy (a.k.a. \"allow all\")"
+	default:
+		return "Unknown Policy"
+	}
+}
diff --git a/go/src/cloudproxy/tao/tao_guard_test.go b/go/src/cloudproxy/tao/tao_guard_test.go
new file mode 100644
index 0000000..dafcbea
--- /dev/null
+++ b/go/src/cloudproxy/tao/tao_guard_test.go
@@ -0,0 +1,200 @@
+// Copyright (c) 2014, Google Inc.  All rights reserved.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package tao
+
+import (
+	"testing"
+)
+
+func testNewTrivialLiberalGuard(t *testing.T) TaoGuard {
+	tg := NewTrivialGuard(LiberalPolicy)
+	if tg.SubprincipalName() != "TrivialGuard(\"Liberal\")" {
+		t.Fatal("Wrong subprincipal name for trivial liberal guard")
+	}
+
+	if tg.GuardTypeName() != "TrivialLiberalGuard" {
+		t.Fatal("Wrong guard type name from trivial liberal guard")
+	}
+
+	return tg
+}
+
+func testNewTrivialConservativeGuard(t *testing.T) TaoGuard {
+	tg := NewTrivialGuard(ConservativePolicy)
+	if tg.SubprincipalName() != "TrivialGuard(\"Conservative\")" {
+		t.Fatal("Wrong subprincipal name for trivial conservative guard")
+	}
+
+	if tg.GuardTypeName() != "TrivialConservativeGuard" {
+		t.Fatal("Wrong guard type name from trivial conservative guard")
+	}
+
+	return tg
+}
+
+func testTrivialGuardAuthorize(t *testing.T, tg TaoGuard) {
+	if err := tg.Authorize("testname", "testop", []string{}); err == nil {
+		t.Fatal("Authorize command incorrectly succeeded on trivial guard")
+	}
+}
+
+func testTrivialGuardRetract(t *testing.T, tg TaoGuard) {
+	if err := tg.Retract("testname", "testop", []string{}); err == nil {
+		t.Fatal("Retract command incorrectly succeeded on trivial guard")
+	}
+}
+
+func testTrivialGuardIsAuthorized(t *testing.T, tg TaoGuard, expect bool) {
+	b := tg.IsAuthorized("testname", "testop", []string{})
+	if b != expect {
+		t.Fatal("Got an unexpected result from IsAuthorized on a trivial guard")
+	}
+}
+
+func testTrivialGuardAddRule(t *testing.T, tg TaoGuard) {
+	if err := tg.AddRule("fake rule"); err == nil {
+		t.Fatal("AddRule command incorrectly succeeded on trivial guard")
+	}
+}
+
+func testTrivialGuardRetractRule(t *testing.T, tg TaoGuard) {
+	if err := tg.RetractRule("fake rule"); err == nil {
+		t.Fatal("RetractRule command incorrectly succeeded on trivial guard")
+	}
+}
+
+func testTrivialGuardClear(t *testing.T, tg TaoGuard) {
+	if err := tg.Clear(); err == nil {
+		t.Fatal("Clear command incorrectly succeeded on trivial guard")
+	}
+}
+
+func testTrivialGuardQuery(t *testing.T, tg TaoGuard, expected bool) {
+	if tg.Query("fake query") != expected {
+		t.Fatal("Query command incorrectly succeeded on trivial guard")
+	}
+}
+
+func testTrivialGuardRuleCount(t *testing.T, tg TaoGuard) {
+	if tg.RuleCount() != 1 {
+		t.Fatal("The rule count for a trivial guard was not exactly 1")
+	}
+}
+
+func testTrivialGuardGetRule(t *testing.T, tg TaoGuard, expected string) {
+	if tg.GetRule(0) != expected {
+		t.Fatal("Got an unexpected rule from GetRule(0) on a trivial guard")
+	}
+}
+
+func testTrivialGuardRuleDebugString(t *testing.T, tg TaoGuard, expected string) {
+	if tg.RuleDebugString(0) != expected {
+		t.Fatal("Got an unexpected rule from RuleDebugString(0) on a trivial guard")
+	}
+}
+
+func testTrivialGuardDebugString(t *testing.T, tg TaoGuard, expected string) {
+	if tg.DebugString() != expected {
+		t.Fatal("Got an unexpected rule from DebugString() on a trivial guard")
+	}
+}
+
+func TestTrivialLiberalGuardAuthorize(t *testing.T) {
+	testTrivialGuardAuthorize(t, testNewTrivialLiberalGuard(t))
+}
+
+func TestTrivialLiberalGuardRetract(t *testing.T) {
+	testTrivialGuardRetract(t, testNewTrivialLiberalGuard(t))
+}
+
+func TestTrivialLiberalGuardIsAuthorized(t *testing.T) {
+	testTrivialGuardIsAuthorized(t, testNewTrivialLiberalGuard(t), true)
+}
+
+func TestTrivialLiberalGuardAddRule(t *testing.T) {
+	testTrivialGuardAddRule(t, testNewTrivialLiberalGuard(t))
+}
+
+func TestTrivialLiberalGuardRetractRule(t *testing.T) {
+	testTrivialGuardRetractRule(t, testNewTrivialLiberalGuard(t))
+}
+
+func TestTrivialLiberalGuardClear(t *testing.T) {
+	testTrivialGuardClear(t, testNewTrivialLiberalGuard(t))
+}
+
+func TestTrivialLiberalGuardQuery(t *testing.T) {
+	testTrivialGuardQuery(t, testNewTrivialLiberalGuard(t), true)
+}
+
+func TestTrivialLiberalGuardRuleCount(t *testing.T) {
+	testTrivialGuardRuleCount(t, testNewTrivialLiberalGuard(t))
+}
+
+func TestTrivialLiberalGuardGetRule(t *testing.T) {
+	testTrivialGuardGetRule(t, testNewTrivialLiberalGuard(t), "Allow All")
+}
+
+func TestTrivialLiberalGuardRuleDebugString(t *testing.T) {
+	testTrivialGuardRuleDebugString(t, testNewTrivialLiberalGuard(t), "Allow All")
+}
+
+func TestTrivialLiberalGuardDebugString(t *testing.T) {
+	testTrivialGuardDebugString(t, testNewTrivialLiberalGuard(t), "Trivial Liberal Policy (a.k.a. \"allow all\")")
+}
+
+func TestTrivialConservativeGuardAuthorize(t *testing.T) {
+	testTrivialGuardAuthorize(t, testNewTrivialConservativeGuard(t))
+}
+
+func TestTrivialConservativeGuardRetract(t *testing.T) {
+	testTrivialGuardRetract(t, testNewTrivialConservativeGuard(t))
+}
+
+func TestTrivialConservativeGuardIsAuthorized(t *testing.T) {
+	testTrivialGuardIsAuthorized(t, testNewTrivialConservativeGuard(t), false)
+}
+
+func TestTrivialConservativeGuardAddRule(t *testing.T) {
+	testTrivialGuardAddRule(t, testNewTrivialConservativeGuard(t))
+}
+
+func TestTrivialConservativeGuardRetractRule(t *testing.T) {
+	testTrivialGuardRetractRule(t, testNewTrivialConservativeGuard(t))
+}
+
+func TestTrivialConservativeGuardClear(t *testing.T) {
+	testTrivialGuardClear(t, testNewTrivialConservativeGuard(t))
+}
+
+func TestTrivialConservativeGuardQuery(t *testing.T) {
+	testTrivialGuardQuery(t, testNewTrivialConservativeGuard(t), false)
+}
+
+func TestTrivialConservativeGuardRuleCount(t *testing.T) {
+	testTrivialGuardRuleCount(t, testNewTrivialConservativeGuard(t))
+}
+
+func TestTrivialConservativeGuardGetRule(t *testing.T) {
+	testTrivialGuardGetRule(t, testNewTrivialConservativeGuard(t), "Deny All")
+}
+
+func TestTrivialConservativeGuardRuleDebugString(t *testing.T) {
+	testTrivialGuardRuleDebugString(t, testNewTrivialConservativeGuard(t), "Deny All")
+}
+
+func TestTrivialConservativeGuardDebugString(t *testing.T) {
+	testTrivialGuardDebugString(t, testNewTrivialConservativeGuard(t), "Trivial Conservative Policy (a.k.a. \"deny all\")")
+}
diff --git a/go/src/cloudproxy/tao/tao_host.go b/go/src/cloudproxy/tao/tao_host.go
new file mode 100644
index 0000000..156073a
--- /dev/null
+++ b/go/src/cloudproxy/tao/tao_host.go
@@ -0,0 +1,56 @@
+// Copyright (c) 2014, Google Inc.  All rights reserved.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package tao
+
+// TaoHost provides a generic interface  for a Tao host that can be configured
+// and driven by a variety of host environments. Generally, the host
+// environment is responsible for enforcing and managing policy, managing
+// hosted programs (e.g. measuring, naming, starting, stopping), communication
+// with hosted programs (e.g. channel creation, RPC reception), and other
+// host-specific details.
+//
+// Because the environment calls TaoHost in response to requests from hosted
+// processes invoking the Tao interface, several TaoHost methods resemble
+// methods in Tao. Semantics and method signatures differ slightly, however,
+// since the environment can add context (e.g., the subprincipal name of the
+// requesting child) or do part of the implementation (e.g., manage policy on
+// seal/unseal).
+type TaoHost interface {
+	// GetRandomBytes returns a slice of n random bytes.
+	GetRandomBytes(childSubprin string, n int) (bytes []byte, err error)
+
+	// GetSharedSecret returns a slice of n secret bytes.
+	GetSharedSecret(tag string, n int) (bytes []byte, err error)
+
+	// Attest requests the Tao host sign a Statement on behalf of the caller.
+	Attest(childSubprin string, stmt *Statement) (*Attestation, error)
+
+	// Encrypt data so that only this host can access it.
+	Encrypt(data []byte) (encrypted []byte, err error)
+
+	// Decrypt data that only this host can access.
+	Decrypt(encrypted []byte) (data []byte, err error)
+
+	// Notify this TaoHost that a new hosted program has been created.
+	AddedHostedProgram(childSubprin string) error
+
+	// Notify this TaoHost that a hosted program has been killed.
+	RemovedHostedProgram(childSubprin string) error
+
+	// Get the Tao principal name assigned to this hosted Tao host. The
+	// name encodes the full path from the root Tao, through all
+	// intermediary Tao hosts, to this hosted Tao host.
+	TaoHostName() string
+}
diff --git a/go/src/cloudproxy/tao/tao_host_test.go b/go/src/cloudproxy/tao/tao_host_test.go
new file mode 100644
index 0000000..3546055
--- /dev/null
+++ b/go/src/cloudproxy/tao/tao_host_test.go
@@ -0,0 +1,158 @@
+// Copyright (c) 2014, Google Inc.  All rights reserved.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package tao
+
+import (
+	"bytes"
+	"testing"
+)
+
+var testChild string = "test child"
+
+func testNewTaoRootHost(t *testing.T) TaoHost {
+	th, err := NewTaoRootHost()
+	if err != nil {
+		t.Fatal("Couldn't create a new TaoRootHost:", err)
+	}
+
+	if err := th.AddedHostedProgram(testChild); err != nil {
+		t.Fatal("Couldn't add a test child program:", err)
+	}
+
+	return th
+}
+
+func testNewTaoStackedHost(t *testing.T) TaoHost {
+	ft, err := NewFakeTao("test tao", "", nil)
+	if err != nil {
+		t.Fatal("Couldn't set up a FakeTao for the TaoStackedHost")
+	}
+
+	th, err := NewTaoStackedHost(ft)
+	if err != nil {
+		t.Fatal("Couldn't set up a TaoStackedHost over a FakeTao")
+	}
+
+	return th
+}
+
+func testTaoHostRandomBytes(t *testing.T, th TaoHost) {
+	b, err := th.GetRandomBytes(testChild, 10)
+	if err != nil {
+		t.Fatal("Couldn't get random bytes from the TaoHost:", err)
+	}
+
+	if len(b) != 10 {
+		t.Fatal("The length of the returned random bytes is not 10")
+	}
+}
+
+func testTaoHostSharedSecretFailure(t *testing.T, th TaoHost) {
+	tag := "test tag"
+	_, err := th.GetSharedSecret(tag, 10)
+	if err == nil {
+		t.Fatal("A TaoHost that doesn't support shared secrets created one")
+	}
+}
+
+func testTaoHostAttest(t *testing.T, th TaoHost) {
+	var st Statement
+	a, err := th.Attest(testChild, &st)
+	if err != nil {
+		t.Fatal("Couldn't attest to an empty Statement:", err)
+	}
+
+	if a == nil {
+		t.Fatal("Incorrectly returned an empty attestation from a successful Attest")
+	}
+}
+
+func testTaoHostEncryption(t *testing.T, th TaoHost) {
+	data := []byte{1, 2, 3, 4, 5, 6, 7}
+	e, err := th.Encrypt(data)
+	if err != nil {
+		t.Fatal("Couldn't encrypt data")
+	}
+
+	d, err := th.Decrypt(e)
+	if err != nil {
+		t.Fatal("Couldn't decrypt encrypted data")
+	}
+
+	if !bytes.Equal(d, data) {
+		t.Fatal("Decrypted data didn't match original data")
+	}
+}
+
+func testTaoHostName(t *testing.T, th TaoHost) {
+	n := th.TaoHostName()
+	if n == "" {
+		t.Fatal("TaoHostName returned an invalid TaoHost name")
+	}
+}
+
+func testTaoHostRemovedHostedProgram(t *testing.T, th TaoHost) {
+	if err := th.RemovedHostedProgram(testChild); err != nil {
+		t.Fatal("Couldn't remove an existing hosted program")
+	}
+}
+
+func TestTaoRootHostRandomBytes(t *testing.T) {
+	testTaoHostRandomBytes(t, testNewTaoRootHost(t))
+}
+
+func TestTaoRootHostSharedSecretFailure(t *testing.T) {
+	testTaoHostSharedSecretFailure(t, testNewTaoRootHost(t))
+}
+
+func TestTaoRootHostAttest(t *testing.T) {
+	testTaoHostAttest(t, testNewTaoRootHost(t))
+}
+
+func TestTaoRootHostEncryption(t *testing.T) {
+	testTaoHostEncryption(t, testNewTaoRootHost(t))
+}
+
+func TestTaoRootHostName(t *testing.T) {
+	testTaoHostName(t, testNewTaoRootHost(t))
+}
+
+func TestTaoRootHostRemovedHostedProgram(t *testing.T) {
+	testTaoHostRemovedHostedProgram(t, testNewTaoRootHost(t))
+}
+
+func TestTaoStackedHostRandomBytes(t *testing.T) {
+	testTaoHostRandomBytes(t, testNewTaoStackedHost(t))
+}
+
+func TestTaoStackedHostSharedSecretFailure(t *testing.T) {
+	testTaoHostSharedSecretFailure(t, testNewTaoStackedHost(t))
+}
+
+func TestTaoStackedHostAttest(t *testing.T) {
+	testTaoHostAttest(t, testNewTaoStackedHost(t))
+}
+
+func TestTaoStackedHostEncryption(t *testing.T) {
+	testTaoHostEncryption(t, testNewTaoStackedHost(t))
+}
+
+func TestTaoStackedHostName(t *testing.T) {
+	testTaoHostName(t, testNewTaoStackedHost(t))
+}
+
+func TestTaoStackedHostRemovedHostedProgram(t *testing.T) {
+	testTaoHostRemovedHostedProgram(t, testNewTaoStackedHost(t))
+}
diff --git a/go/src/cloudproxy/tao/tao_root_host.go b/go/src/cloudproxy/tao/tao_root_host.go
new file mode 100644
index 0000000..7c61d69
--- /dev/null
+++ b/go/src/cloudproxy/tao/tao_root_host.go
@@ -0,0 +1,176 @@
+// Copyright (c) 2014, Google Inc.  All rights reserved.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package tao
+
+import (
+	"crypto/rand"
+	"errors"
+	"strings"
+	"time"
+
+	"code.google.com/p/goprotobuf/proto"
+)
+
+// A TaoRootHost is a standalone implementation of TaoHost.
+type TaoRootHost struct {
+	keys        *Keys
+	taoHostName string
+}
+
+// NewTaoRootHostFromKeys takes ownership of an existing set of keys and
+// returns a TaoRootHost that uses these keys.
+func NewTaoRootHostFromKeys(k *Keys) (TaoHost, error) {
+	if k.SigningKey == nil || k.CryptingKey == nil || k.VerifyingKey == nil {
+		return nil, errors.New("missing required key for TaoRootHost")
+	}
+
+	n, err := k.SigningKey.ToPrincipalName()
+	if err != nil {
+		return nil, err
+	}
+
+	t := &TaoRootHost{
+		keys:        k,
+		taoHostName: n,
+	}
+
+	return t, nil
+}
+
+// NewTaoRootHost generates a new TaoRootHost with a fresh set of temporary
+// keys.
+func NewTaoRootHost() (TaoHost, error) {
+	k, err := NewTemporaryKeys(Signing | Crypting)
+	if err != nil {
+		return nil, err
+	}
+
+	return NewTaoRootHostFromKeys(k)
+}
+
+// GetRandomBytes returns a slice of n random bytes.
+func (t *TaoRootHost) GetRandomBytes(childSubprin string, n int) (bytes []byte, err error) {
+	b := make([]byte, n)
+	if _, err := rand.Read(b); err != nil {
+		return nil, err
+	}
+
+	return b, nil
+}
+
+// GetSharedSecret returns a slice of n secret bytes.
+func (t *TaoRootHost) GetSharedSecret(tag string, n int) (bytes []byte, err error) {
+	if t.keys.DerivingKey == nil {
+		return nil, errors.New("this TaoRootHost does not implement shared secrets")
+	}
+
+	// For now, all our key deriving with keys.DerivingKey uses a fixed 0-length salt.
+	salt := make([]byte, 0)
+	material := make([]byte, n)
+	if err := t.keys.DerivingKey.Derive(salt, []byte(tag), material); err != nil {
+		return nil, err
+	}
+
+	return material, nil
+}
+
+// GenerateAttestation uses the signing key to generate an attestation for this
+// statement.
+func GenerateAttestation(s *Signer, delegation []byte, stmt *Statement) (*Attestation, error) {
+	signerName, err := s.ToPrincipalName()
+	if err != nil {
+		return nil, err
+	}
+
+	st := new(Statement)
+	proto.Merge(st, stmt)
+
+	t := time.Now()
+	if st.Time == nil {
+		st.Time = proto.Int64(t.UnixNano())
+	}
+
+	if st.Expiration == nil {
+		st.Expiration = proto.Int64(t.Add(365 * 24 * time.Hour).UnixNano())
+	}
+
+	ser, err := proto.Marshal(st)
+	if err != nil {
+		return nil, err
+	}
+
+	sig, err := s.Sign(ser, AttestationSigningContext)
+	if err != nil {
+		return nil, err
+	}
+
+	a := &Attestation{
+		SerializedStatement: ser,
+		Signature:           sig,
+		Signer:              proto.String(signerName),
+	}
+
+	if len(delegation) > 0 {
+		a.SerializedDelegation = delegation
+	}
+
+	return a, nil
+}
+
+// IsSubprincipalOrIdentical checks that the child name either is identical to
+// to the parent name or starts with "parentName::".
+func IsSubprincipalOrIdentical(childName, parentName string) bool {
+	return (childName == parentName) || strings.HasPrefix(childName, parentName+"::")
+}
+
+// Attest requests the Tao host sign a Statement on behalf of the caller.
+func (t *TaoRootHost) Attest(childSubprin string, stmt *Statement) (*Attestation, error) {
+	if stmt.Issuer != nil {
+		if !IsSubprincipalOrIdentical(*stmt.Issuer, t.taoHostName+"::"+childSubprin) {
+			return nil, errors.New("invalid issuer in statement")
+		}
+	} else {
+		stmt.Issuer = proto.String(t.taoHostName + "::" + childSubprin)
+	}
+
+	return GenerateAttestation(t.keys.SigningKey, nil /* delegation */, stmt)
+}
+
+// Encrypt data so that only this host can access it.
+func (t *TaoRootHost) Encrypt(data []byte) (encrypted []byte, err error) {
+	return t.keys.CryptingKey.Encrypt(data)
+}
+
+// Decrypt data that only this host can access.
+func (t *TaoRootHost) Decrypt(encrypted []byte) (data []byte, err error) {
+	return t.keys.CryptingKey.Decrypt(encrypted)
+}
+
+// Notify this TaoHost that a new hosted program has been created.
+func (t *TaoRootHost) AddedHostedProgram(childSubprin string) error {
+	return nil
+}
+
+// Notify this TaoHost that a hosted program has been killed.
+func (t *TaoRootHost) RemovedHostedProgram(childSubprin string) error {
+	return nil
+}
+
+// Get the Tao principal name assigned to this hosted Tao host. The
+// name encodes the full path from the root Tao, through all
+// intermediary Tao hosts, to this hosted Tao host.
+func (t *TaoRootHost) TaoHostName() string {
+	return t.taoHostName
+}
diff --git a/go/src/cloudproxy/tao/tao_server.go b/go/src/cloudproxy/tao/tao_server.go
deleted file mode 100644
index 36f7686..0000000
--- a/go/src/cloudproxy/tao/tao_server.go
+++ /dev/null
@@ -1,121 +0,0 @@
-//  Copyright (c) 2014, Google Inc.  All rights reserved.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package tao
-
-import (
-	"errors"
-
-	"code.google.com/p/goprotobuf/proto"
-)
-
-// A TaoServer wraps a Tao and serves its methods across a net/rpc connection.
-type TaoServer struct {
-	T Tao
-}
-
-// GetTaoName returns the Tao principal name assigned to the caller.
-func (ts *TaoServer) GetTaoName(r *TaoRPCRequest, s *TaoRPCResponse) error {
-	name, err := ts.T.GetTaoName()
-	if err != nil {
-		return err
-	}
-
-	s.Data = []byte(name)
-	return nil
-}
-
-// ExtendTaoName irreversibly extends the Tao principal name of the caller.
-func (ts *TaoServer) ExtendTaoName(r *TaoRPCRequest, s *TaoRPCResponse) error {
-	if err := ts.T.ExtendTaoName(string(r.Data)); err != nil {
-		return err
-	}
-
-	return nil
-}
-
-// GetRandomBytes returns a slice of n random bytes.
-func (ts *TaoServer) GetRandomBytes(r *TaoRPCRequest, s *TaoRPCResponse) error {
-	if r.GetSize() <= 0 {
-		return errors.New("Invalid array size")
-	}
-
-	var err error
-	s.Data, err = ts.T.GetRandomBytes(int(r.GetSize()))
-	if err != nil {
-		return err
-	}
-
-	return nil
-}
-
-// Rand produces an io.Reader for random bytes from this Tao.  This should
-// never be called on the TaoServer, since it's handled transparently by
-// TaoClient.
-func (ts *TaoServer) Rand(r *TaoRPCRequest, s *TaoRPCResponse) error {
-	return nil
-}
-
-// GetSharedSecret returns a slice of n secret bytes.
-func (ts *TaoServer) GetSharedSecret(r *TaoRPCRequest, s *TaoRPCResponse) error {
-	var err error
-	s.Data, err = ts.T.GetSharedSecret(int(*r.Size), string(r.Data))
-	if err != nil {
-		return err
-	}
-
-	return nil
-}
-
-// Seal encrypts data so only certain hosted programs can unseal it.
-func (ts *TaoServer) Seal(r *TaoRPCRequest, s *TaoRPCResponse) error {
-	var err error
-	s.Data, err = ts.T.Seal(r.Data, *r.Policy)
-	if err != nil {
-		return err
-	}
-
-	return nil
-}
-
-// Unseal decrypts data that has been sealed by the Seal() operation, but only
-// if the policy specified during the Seal() operation is satisfied.
-func (ts *TaoServer) Unseal(r *TaoRPCRequest, s *TaoRPCResponse) error {
-	var err error
-	var policy string
-	s.Data, policy, err = ts.T.Unseal(r.Data)
-	if err != nil {
-		return err
-	}
-
-	s.Policy = proto.String(policy)
-	return nil
-}
-
-// Attest requests the Tao host sign a Statement on behalf of the caller.
-func (ts *TaoServer) Attest(r *TaoRPCRequest, s *TaoRPCResponse) error {
-	stmt := new(Statement)
-	err := proto.Unmarshal(r.Data, stmt)
-	if err != nil {
-		return err
-	}
-
-	a, err := ts.T.Attest(stmt)
-	if err != nil {
-		return err
-	}
-
-	s.Data, err = proto.Marshal(a)
-	return err
-}
diff --git a/go/src/cloudproxy/tao/tao_server_test.go b/go/src/cloudproxy/tao/tao_server_test.go
deleted file mode 100644
index ef70e25..0000000
--- a/go/src/cloudproxy/tao/tao_server_test.go
+++ /dev/null
@@ -1,104 +0,0 @@
-//  Copyright (c) 2014, Google Inc.  All rights reserved.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package tao
-
-import (
-	"net/rpc"
-	"testing"
-	"time"
-
-	"cloudproxy/util"
-	"code.google.com/p/goprotobuf/proto"
-)
-
-func TestTaoChanServer(t *testing.T) {
-	serverWrite := make(chan []byte)
-	clientWrite := make(chan []byte)
-	c := &util.ChanReadWriteCloser{
-		R: serverWrite,
-		W: clientWrite,
-	}
-
-	s := &util.ChanReadWriteCloser{
-		R: clientWrite,
-		W: serverWrite,
-	}
-
-	server := rpc.NewServer()
-	tao, err := NewFakeTao("test", "", nil)
-	if err != nil {
-		t.Fatal("Couldn't initialize the FakeTao:", err)
-	}
-
-	ts := &TaoServer{
-		T: tao,
-	}
-
-	err = server.Register(ts)
-	if err != nil {
-		t.Fatal("Couldn't register the server:", err)
-	}
-
-	go server.ServeConn(s)
-
-	tc, err := NewTaoRPC(c, "TaoServer")
-	if err != nil {
-		t.Fatal("Couldn't set up a TaoRPC client to TaoServer:", err)
-	}
-
-	b, err := tc.GetRandomBytes(10)
-	if err != nil {
-		t.Fatal("Couldn't get random bytes:", err)
-	}
-
-	// Seal, Unseal, and Attest to the bytes
-	sealed, err := tc.Seal(b, SealPolicyDefault)
-	if err != nil {
-		t.Fatal("Couldn't seal the data:", err)
-	}
-
-	unsealed, policy, err := tc.Unseal(sealed)
-	if err != nil {
-		t.Fatal("Couldn't unseal the data:", err)
-	}
-
-	if string(policy) != SealPolicyDefault {
-		t.Fatal("Invalid policy returned by the Tao")
-	}
-
-	if len(unsealed) != len(b) {
-		t.Fatal("Invalid unsealed length")
-	}
-
-	for i, v := range unsealed {
-		if v != b[i] {
-			t.Fatalf("Incorrect value returned at byte %d\n", i)
-		}
-	}
-
-	stmt := &Statement{
-		// TODO(tmroeder): Issuer, Time, and Expiration are required, but they
-		// should be optional.
-		Issuer:     proto.String("test"),
-		Time:       proto.Int64(time.Now().UnixNano()),
-		Expiration: proto.Int64(time.Now().UnixNano() + 100),
-		Delegate:   proto.String(string(b)),
-	}
-
-	_, err = tc.Attest(stmt)
-	if err != nil {
-		t.Fatal("Couldn't attest to the bytes:", err)
-	}
-}
diff --git a/go/src/cloudproxy/tao/tao_stacked_host.go b/go/src/cloudproxy/tao/tao_stacked_host.go
new file mode 100644
index 0000000..ebff647
--- /dev/null
+++ b/go/src/cloudproxy/tao/tao_stacked_host.go
@@ -0,0 +1,147 @@
+// Copyright (c) 2014, Google Inc.  All rights reserved.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package tao
+
+import (
+	"errors"
+
+	"code.google.com/p/goprotobuf/proto"
+)
+
+// A TaoStackedHost implements TaoHost over an existing host Tao.
+type TaoStackedHost struct {
+	taoHostName string
+	hostTao     Tao
+	keys        *Keys
+}
+
+// NewTaoStackedHostFromKeys takes ownership of an existing set of keys and
+// returns a TaoStackedHost that uses these keys over an existing host Tao.
+func NewTaoStackedHostFromKeys(k *Keys, t Tao) (TaoHost, error) {
+	if k.SigningKey == nil || k.CryptingKey == nil || k.VerifyingKey == nil {
+		return nil, errors.New("missing required key for TaoStackedHost")
+	}
+
+	n, err := t.GetTaoName()
+	if err != nil {
+		return nil, err
+	}
+
+	tsh := &TaoStackedHost{
+		keys:        k,
+		taoHostName: n,
+		hostTao:     t,
+	}
+
+	return tsh, nil
+}
+
+// NewTaoStackedHost generates a new TaoStackedHost with a fresh set of temporary
+// keys.
+func NewTaoStackedHost(t Tao) (TaoHost, error) {
+	k, err := NewTemporaryKeys(Signing | Crypting)
+	if err != nil {
+		return nil, err
+	}
+
+	return NewTaoStackedHostFromKeys(k, t)
+}
+
+// GetRandomBytes returns a slice of n random bytes.
+func (t *TaoStackedHost) GetRandomBytes(childSubprin string, n int) (bytes []byte, err error) {
+	return t.hostTao.GetRandomBytes(n)
+}
+
+// GetSharedSecret returns a slice of n secret bytes.
+func (t *TaoStackedHost) GetSharedSecret(tag string, n int) (bytes []byte, err error) {
+	if t.keys.DerivingKey == nil {
+		return nil, errors.New("this TaoStackedHost does not implement shared secrets")
+	}
+
+	// For now, all our key deriving with keys.DerivingKey uses a fixed 0-length salt.
+	salt := make([]byte, 0)
+	material := make([]byte, n)
+	if err := t.keys.DerivingKey.Derive(salt, []byte(tag), material); err != nil {
+		return nil, err
+	}
+
+	return material, nil
+}
+
+// Attest requests the Tao host sign a Statement on behalf of the caller.
+func (t *TaoStackedHost) Attest(childSubprin string, stmt *Statement) (*Attestation, error) {
+	if stmt.Issuer != nil {
+		if !IsSubprincipalOrIdentical(*stmt.Issuer, t.taoHostName+"::"+childSubprin) {
+			return nil, errors.New("invalid issuer in statement")
+		}
+	} else {
+		stmt.Issuer = proto.String(t.taoHostName + "::" + childSubprin)
+	}
+
+	if t.keys == nil || t.keys.SigningKey == nil {
+		return t.hostTao.Attest(stmt)
+	} else {
+		return GenerateAttestation(t.keys.SigningKey, nil /* delegation */, stmt)
+	}
+}
+
+// Encrypt data so that only this host can access it.
+func (t *TaoStackedHost) Encrypt(data []byte) (encrypted []byte, err error) {
+	if t.keys == nil || t.keys.CryptingKey == nil {
+		// TODO(tmroeder) (from TODO(kwalsh) in tao_stacked_host.cc):
+		// where should the policy come from here?
+		return t.hostTao.Seal(data, SealPolicyDefault)
+	} else {
+		return t.keys.CryptingKey.Encrypt(data)
+	}
+}
+
+// Decrypt data that only this host can access.
+func (t *TaoStackedHost) Decrypt(encrypted []byte) (data []byte, err error) {
+	if t.keys == nil || t.keys.CryptingKey == nil {
+		// TODO(tmroeder) (from TODO(kwalsh) in tao_stacked_host.cc):
+		// where should the policy come from here?
+		var policy string
+		data, policy, err = t.hostTao.Unseal(encrypted)
+		if err != nil {
+			return nil, err
+		}
+
+		if policy != SealPolicyDefault {
+			return nil, errors.New("unsealed data with uncertain provenance")
+		}
+
+		return data, nil
+	} else {
+		return t.keys.CryptingKey.Decrypt(encrypted)
+	}
+}
+
+// Notify this TaoHost that a new hosted program has been created.
+func (t *TaoStackedHost) AddedHostedProgram(childSubprin string) error {
+	return nil
+}
+
+// Notify this TaoHost that a hosted program has been killed.
+func (t *TaoStackedHost) RemovedHostedProgram(childSubprin string) error {
+	return nil
+}
+
+// Get the Tao principal name assigned to this hosted Tao host. The
+// name encodes the full path from the root Tao, through all
+// intermediary Tao hosts, to this hosted Tao host.
+func (t *TaoStackedHost) TaoHostName() string {
+	return t.taoHostName
+}
