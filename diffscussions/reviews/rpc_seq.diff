#* 
#* author: Kevin Walsh
#* email: kwalsh@holycross.edu
#* date: 2014-07-16T15:07:23-0400
#* 
#- Put sequence numbers in rpc messages.
#- 
#- Check sequence numbers on responses (for debug).
#-
#- Combine 'success' and 'reason' fields into a single
#- optional 'error' field.
#-
#- Propagate a few error messages from linux tao.
#-
diff --git a/src/tao/linux_admin_rpc.cc b/src/tao/linux_admin_rpc.cc
index eed7f67..ce9a7cd 100644
--- a/src/tao/linux_admin_rpc.cc
+++ b/src/tao/linux_admin_rpc.cc
@@ -9,107 +9,109 @@
 // you may not use this file except in compliance with the License.
 // You may obtain a copy of the License at
 //
 //     http://www.apache.org/licenses/LICENSE-2.0
 //
 // Unless required by applicable law or agreed to in writing, software
 // distributed under the License is distributed on an "AS IS" BASIS,
 // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 // See the License for the specific language governing permissions and
 // limitations under the License.
 #include "tao/linux_admin_rpc.h"
 
 #include <glog/logging.h>
 
 #include "tao/util.h"
 
 namespace tao {
 bool LinuxAdminRPC::GetTaoHostName(string *name) {
   LinuxAdminRPCRequest rpc;
   rpc.set_rpc(LINUX_ADMIN_RPC_GET_TAO_HOST_NAME);
-  return Request(rpc, name);
+  return Request(&rpc, name);
 }
 
 bool LinuxAdminRPC::Shutdown() {
   LinuxAdminRPCRequest rpc;
   rpc.set_rpc(LINUX_ADMIN_RPC_SHUTDOWN);
-  return Request(rpc, nullptr /* data */);
+  return Request(&rpc, nullptr /* data */);
 }
 
 bool LinuxAdminRPC::StartHostedProgram(const string &path,
                                        const list<string> &args,
                                        string *child_subprin) {
   LinuxAdminRPCRequest rpc;
   rpc.set_rpc(LINUX_ADMIN_RPC_START_HOSTED_PROGRAM);
   rpc.set_path(path);
   for (const string &arg : args) rpc.add_args(arg);
-  return Request(rpc, child_subprin);
+  return Request(&rpc, child_subprin);
 }
 
 bool LinuxAdminRPC::StopHostedProgram(const string &child_subprin) {
   LinuxAdminRPCRequest rpc;
   rpc.set_rpc(LINUX_ADMIN_RPC_STOP_HOSTED_PROGRAM);
   rpc.set_data(child_subprin);
-  return Request(rpc, nullptr /* data */);
+  return Request(&rpc, nullptr /* data */);
 }
 
 bool LinuxAdminRPC::KillHostedProgram(const string &child_subprin) {
   LinuxAdminRPCRequest rpc;
   rpc.set_rpc(LINUX_ADMIN_RPC_KILL_HOSTED_PROGRAM);
   rpc.set_data(child_subprin);
-  return Request(rpc, nullptr /* data */);
+  return Request(&rpc, nullptr /* data */);
 }
 
 bool LinuxAdminRPC::ListHostedPrograms(list<pair<string, int>> *child_info) {
   LinuxAdminRPCRequest rpc;
   rpc.set_rpc(LINUX_ADMIN_RPC_LIST_HOSTED_PROGRAMS);
   string data;
   LinuxAdminRPCHostedProgramList info;
-  if (!Request(rpc, &data) || !info.ParseFromString(data) ||
+  if (!Request(&rpc, &data) || !info.ParseFromString(data) ||
       info.name_size() != info.pid_size())
     return false;
   child_info->clear();
   for (int i = 0; i < info.name_size(); i++) {
     child_info->push_back(make_pair(info.name(i), info.pid(i)));
   }
   return true;
 }
 
-bool LinuxAdminRPC::Request(const LinuxAdminRPCRequest &req, string *data) {
+bool LinuxAdminRPC::Request(LinuxAdminRPCRequest *req, string *data) {
+  req->set_seq(++last_seq_);
   LinuxAdminRPCResponse resp;
   bool eof;
-
-  if (!channel_->SendMessage(req)) {
+  if (!channel_->SendMessage(*req)) {
     failure_msg_ = "Channel send failed";
     LOG(ERROR) << "Admin RPC to LinuxTao host failed: " << failure_msg_;
     return false;
   }
   if (!channel_->ReceiveMessage(&resp, &eof)) {
     failure_msg_ = "Channel receive failed";
     LOG(ERROR) << "Admin RPC to LinuxTao host failed: " << failure_msg_;
     return false;
   }
   if (eof) {
     failure_msg_ = "Channel is closed";
     LOG(ERROR) << "Admin RPC to LinuxTao host failed: " << failure_msg_;
     return false;
   }
-  if (!resp.success()) {
-    if (resp.has_reason() && resp.reason().size() > 0)
-      failure_msg_ = resp.reason();
-    else
-      failure_msg_ = "Unknown failure from Tao host";
+  if (resp.has_error()) {
+    failure_msg_ = resp.error();
+    LOG(ERROR) << "Admin RPC to LinuxTao host failed: " << failure_msg_;
+    return false;
+  }
+  if (resp.seq() != req->seq()) {
+    failure_msg_ = "Unexpected sequence number in response";
     LOG(ERROR) << "Admin RPC to LinuxTao host failed: " << failure_msg_;
     return false;
   }
   if (data != nullptr) {
     if (!resp.has_data()) {
       failure_msg_ = "Malformed response (missing data)";
       LOG(ERROR) << "Admin RPC to LinuxTao host failed: " << failure_msg_;
       return false;
     }
     data->assign(resp.data());
   }
   return true;
 }
 
 }  // namespace tao
diff --git a/src/tao/linux_admin_rpc.h b/src/tao/linux_admin_rpc.h
index bab0bf7..b1dcc9c 100644
--- a/src/tao/linux_admin_rpc.h
+++ b/src/tao/linux_admin_rpc.h
@@ -69,31 +69,34 @@ class LinuxAdminRPC {
   virtual bool KillHostedProgram(const string &child_subprin);
 
   /// Request from LinuxTao a list of hosted programs.
   /// @param[out] child_info A list of <child_subprin, pid> pairs.
   virtual bool ListHostedPrograms(list<pair<string, int>> *child_info);
 
   virtual string GetRecentErrorMessage() const { return failure_msg_; }
   virtual string ResetRecentErrorMessage() {
     string msg = failure_msg_;
     failure_msg_ = "";
     return msg;
   }
 
  protected:
   /// The channel over which to send and receive messages.
   unique_ptr<MessageChannel> channel_;
 
   /// Most recent RPC failure message, if any.
   string failure_msg_;
 
+  /// Most recent RPC sequence number.
+  unsigned int last_seq_;
+
  private:
   /// Do an RPC request/response interaction with the LinuxTao host.
-  /// @param req The request to send.
+  /// @param[in,out] req The request to send. The sequence number is set.
   /// @param[out] data The returned data, if not nullptr.
-  bool Request(const LinuxAdminRPCRequest &req, string *data);
+  bool Request(LinuxAdminRPCRequest *req, string *data);
 
   DISALLOW_COPY_AND_ASSIGN(LinuxAdminRPC);
 };
 }  // namespace tao
 
 #endif  // TAO_LINUX_ADMIN_RPC_H_
diff --git a/src/tao/linux_admin_rpc.proto b/src/tao/linux_admin_rpc.proto
index 18b663a..d6119b7 100644
--- a/src/tao/linux_admin_rpc.proto
+++ b/src/tao/linux_admin_rpc.proto
@@ -14,38 +14,40 @@
 // Unless required by applicable law or agreed to in writing, software
 // distributed under the License is distributed on an "AS IS" BASIS,
 // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
 package tao;
 
 enum LinuxAdminRPCRequestType {
   LINUX_ADMIN_RPC_UNKNOWN = 0;  // unused
   LINUX_ADMIN_RPC_SHUTDOWN = 1;
   LINUX_ADMIN_RPC_START_HOSTED_PROGRAM = 2;
   LINUX_ADMIN_RPC_STOP_HOSTED_PROGRAM = 3;
   LINUX_ADMIN_RPC_KILL_HOSTED_PROGRAM = 4;
   LINUX_ADMIN_RPC_GET_TAO_HOST_NAME = 5;
   LINUX_ADMIN_RPC_LIST_HOSTED_PROGRAMS = 6;
 }
 
 message LinuxAdminRPCRequest {
   required LinuxAdminRPCRequestType rpc = 1;
-  optional bytes data = 2;
-  optional string path = 3;
-  repeated string args = 4;
+  required uint64 seq = 2;
+  optional bytes data = 3;
+  optional string path = 4;
+  repeated string args = 5;
 }
 
 message LinuxAdminRPCHostedProgramList {
   repeated string name = 1;
   repeated int32 pid = 2;
 }
 
 message LinuxAdminRPCResponse {
   required LinuxAdminRPCRequestType rpc = 1;
-  required bool success = 2;
-  optional bytes data = 3; // either a string or 
-						   // serialized LinuxAdminRPCHostedProgramList
-  optional string reason = 4; // reason in case of failure
+  required uint64 seq = 2;
+  optional string error = 3;
+  optional bytes data = 4;    // either a string or
+                              // serialized LinuxAdminRPCHostedProgramList
+  optional string reason = 5; // reason in case of failure
 }
 
diff --git a/src/tao/linux_host.cc b/src/tao/linux_host.cc
index 02a1aaf..d118be7 100644
--- a/src/tao/linux_host.cc
+++ b/src/tao/linux_host.cc
@@ -82,187 +82,201 @@ bool LinuxHost::InitRoot(const string &pass) {
 bool LinuxHost::Init() {
   if (!tao_host_->Init()) {
     LOG(ERROR) << "Could not initialize TaoHost";
     return false;
   }
   child_factory_.reset(new LinuxProcessFactory());
   child_channel_factory_.reset(new PipeFactory());
   admin_channel_factory_.reset(
       new UnixSocketFactory(FilePath(path_).Append("admin_socket").value()));
   if (!admin_channel_factory_->Init()) {
     LOG(ERROR) << "Could not initialize admin channel socket";
     return false;
   }
   return true;
 }
 
 bool LinuxHost::HandleTaoRPC(HostedLinuxProcess *child,
                              const TaoRPCRequest &rpc,
                              TaoRPCResponse *resp) const {
   resp->set_rpc(rpc.rpc());
-
+  resp->set_seq(rpc.seq());
   string result_data;
   string result_policy;
+  Statement s;
   bool success = false;
+  // TODO(kwalsh) Propagate better error messages
+  string failure_msg = "Operation failed";
   switch (rpc.rpc()) {
     case TAO_RPC_GET_TAO_NAME:
       LOG(INFO) << "GetTaoName() for ::" << elideString(child->subprin);
       result_data = tao_host_->TaoHostName() + "::" + child->subprin;
+      resp->set_data(result_data);
       success = true;
       break;
     case TAO_RPC_EXTEND_TAO_NAME:
       LOG(INFO) << "ExtendTaoName() for ::" << elideString(child->subprin);
       if (!rpc.has_data() && rpc.data() != "") {
-        LOG(ERROR) << "Invalid RPC: must supply data for ExtendName";
+        failure_msg = "Invalid RPC: must supply data for ExtendName";
+        LOG(ERROR) << failure_msg;
         break;
       }
       // TODO(kwalsh) Sanity checking on subprin format.
       child->subprin += "::" + rpc.data();
       success = true;
       break;
     case TAO_RPC_GET_RANDOM_BYTES:
       LOG(INFO) << "GetRandomBytes() for ::" << elideString(child->subprin);
       if (!rpc.has_size()) {
         LOG(ERROR) << "Invalid RPC: must supply arguments for GetRandomBytes";
         break;
       }
       success =
           tao_host_->GetRandomBytes(child->subprin, rpc.size(), &result_data);
+      if (success) resp->set_data(result_data);
       break;
     case TAO_RPC_GET_SHARED_SECRET:
       LOG(INFO) << "GetSharedSecret() for ::" << elideString(child->subprin);
       if (!rpc.has_size() || !rpc.has_policy()) {
-        LOG(ERROR) << "Invalid RPC: must supply arguments for GetSharedSecret";
+        failure_msg = "Invalid RPC: must supply arguments for GetSharedSecret";
+        LOG(ERROR) << failure_msg;
         break;
       }
       success = HandleGetSharedSecret(child->subprin, rpc.size(), rpc.policy(),
                                       &result_data);
+      if (success) resp->set_data(result_data);
       break;
     case TAO_RPC_ATTEST:
       LOG(INFO) << "Attest() for ::" << elideString(child->subprin);
       if (!rpc.has_data()) {
-        LOG(ERROR) << "Invalid RPC: must supply arguments for GetRandomBytes";
+        failure_msg = "Invalid RPC: must supply arguments for GetRandomBytes";
+        LOG(ERROR) << failure_msg;
         break;
-      } else {
-        Statement s;
-        if (!s.ParsePartialFromString(rpc.data()) ||
-            !(s.has_delegate() || s.has_predicate_name())) {
-          LOG(ERROR) << "Invalid RPC: must supply legal partial statement";
-          break;
-        } else {
-          success = tao_host_->Attest(child->subprin, &s, &result_data);
-        }
       }
+      if (!s.ParsePartialFromString(rpc.data()) ||
+          !(s.has_delegate() || s.has_predicate_name())) {
+        failure_msg = "Invalid RPC: must supply legal partial statement";
+        LOG(ERROR) << failure_msg;
+        break;
+      }
+      success = tao_host_->Attest(child->subprin, &s, &result_data);
+      if (success) resp->set_data(result_data);
       break;
     case TAO_RPC_SEAL:
       LOG(INFO) << "Seal() for ::" << elideString(child->subprin);
       if (!rpc.has_data()) {
         LOG(ERROR) << "Invalid RPC: must supply data for Seal";
         break;
       }
       success =
           HandleSeal(child->subprin, rpc.data(), rpc.policy(), &result_data);
+      if (success) resp->set_data(result_data);
       break;
     case TAO_RPC_UNSEAL:
       LOG(INFO) << "Unseal() for ::" << elideString(child->subprin);
       if (!rpc.has_data()) {
         LOG(ERROR) << "Invalid RPC: must supply sealed data for Unseal";
         break;
       }
       success = HandleUnseal(child->subprin, rpc.data(), &result_data,
                              &result_policy);
-      if (success) resp->set_policy(result_policy);
+      if (success) {
+        resp->set_data(result_data);
+        resp->set_policy(result_policy);
+      }
       break;
     default:
       LOG(ERROR) << "Unknown Tao RPC " << rpc.rpc();
-      resp->set_reason("Unknown Tao RPC");
+      failure_msg = "Unknown Tao RPC";
       success = false;
       break;
   }
-  LOG(INFO) << "Result: " << (success ? "OK" : "FAIL");
-
-  resp->set_success(success);
-  if (success) resp->set_data(result_data);
-  // TODO(kwalsh) Propagate other error messages?
-
+  if (!success) {
+    resp->set_error(failure_msg);
+    LOG(INFO) << "Result: FAIL (" << failure_msg << ")";
+  } else {
+    LOG(INFO) << "Result: OK";
+  }
   return true;
 }
 
 bool LinuxHost::HandleAdminRPC(const LinuxAdminRPCRequest &rpc,
                                LinuxAdminRPCResponse *resp,
                                bool *shutdown_request) {
   resp->set_rpc(rpc.rpc());
+  resp->set_seq(rpc.seq());
   bool success = false;
   string child_subprin, tao_name;
-  string failure_msg;
+  string failure_msg = "Unknown error";
   switch (rpc.rpc()) {
     case LINUX_ADMIN_RPC_SHUTDOWN:
       LOG(INFO) << "Shutdown()";
       *shutdown_request = true;
       success = true;
       break;
     case LINUX_ADMIN_RPC_START_HOSTED_PROGRAM:
       LOG(INFO) << "StartHostedProgram()";
       success = HandleStartHostedProgram(rpc, &child_subprin, &failure_msg);
-      if (success)
-        resp->set_data(child_subprin);
-      else
-        resp->set_reason(failure_msg);
+      if (success) resp->set_data(child_subprin);
       break;
     case LINUX_ADMIN_RPC_STOP_HOSTED_PROGRAM:
       LOG(INFO) << "StopHostedProgram()";
       success = HandleStopHostedProgram(rpc, SIGTERM, &failure_msg);
-      if (!success) resp->set_reason(failure_msg);
       break;
     case LINUX_ADMIN_RPC_LIST_HOSTED_PROGRAMS:
       LOG(INFO) << "ListHostedPrograms()";
       {
         LinuxAdminRPCHostedProgramList info;
         for (auto &child : hosted_processes_) {
           info.add_name(child->subprin);
           info.add_pid(child->pid);
         }
         string data;
         success = info.SerializeToString(&data);
-        if (success) resp->set_data(data);
+        if (success)
+          resp->set_data(data);
+        else
+          failure_msg = "Could not serialize hosted program list";
       }
       break;
     case LINUX_ADMIN_RPC_KILL_HOSTED_PROGRAM:
       LOG(INFO) << "KillHostedProgram()";
       success = HandleStopHostedProgram(rpc, SIGKILL, &failure_msg);
-      if (!success) resp->set_reason(failure_msg);
       break;
     case LINUX_ADMIN_RPC_GET_TAO_HOST_NAME:
       LOG(INFO) << "GetTaoHostName()";
       resp->set_data(tao_host_->TaoHostName());
       success = true;
       break;
     default:
       LOG(ERROR) << "Unknown Linux Admin RPC " << rpc.rpc();
-      resp->set_reason("Unknown Linux Admin RPC");
+      failure_msg = "Unknown Linux Admin RPC";
       success = false;
       break;
   }
 
-  LOG(INFO) << "Result: " << (success ? "OK" : "FAIL");
-  resp->set_success(success);
-
+  if (!success) {
+    resp->set_error(failure_msg);
+    LOG(INFO) << "Result: FAIL (" << failure_msg << ")";
+  } else {
+    LOG(INFO) << "Result: OK";
+  }
   return true;
 }
 
 bool LinuxHost::HandleStartHostedProgram(const LinuxAdminRPCRequest &rpc,
                                          string *child_subprin,
                                          string *failure_msg) {
   if (!rpc.has_path()) {
     failure_msg->assign("Hosted program creation request is missing path");
     LOG(ERROR) << *failure_msg;
     return false;
   }
   string path = rpc.path();
   list<string> args;
   for (int i = 0; i < rpc.args_size(); i++) {
     args.push_back(rpc.args(i));
   }
 
   // What is in a name?
   // * We add program hash: child can't be trusted to add that.
   // * We don't add arg hash: child can add it at top of main if desired. If the
diff --git a/src/tao/tao_rpc.cc b/src/tao/tao_rpc.cc
index ef7ff47..069bffa 100644
--- a/src/tao/tao_rpc.cc
+++ b/src/tao/tao_rpc.cc
@@ -10,115 +10,118 @@
 // You may obtain a copy of the License at
 //
 //     http://www.apache.org/licenses/LICENSE-2.0
 //
 // Unless required by applicable law or agreed to in writing, software
 // distributed under the License is distributed on an "AS IS" BASIS,
 // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 // See the License for the specific language governing permissions and
 // limitations under the License.
 #include "tao/tao_rpc.h"
 
 #include <glog/logging.h>
 
 #include "tao/fd_message_channel.h"
 
 namespace tao {
 
 bool TaoRPC::GetTaoName(string *name) {
   TaoRPCRequest rpc;
   rpc.set_rpc(TAO_RPC_GET_TAO_NAME);
-  return Request(rpc, name, nullptr /* policy */);
+  return Request(&rpc, name, nullptr /* policy */);
 }
 
 bool TaoRPC::ExtendTaoName(const string &subprin) {
   TaoRPCRequest rpc;
   rpc.set_rpc(TAO_RPC_EXTEND_TAO_NAME);
   rpc.set_data(subprin);
-  return Request(rpc, nullptr /* data */, nullptr /* policy */);
+  return Request(&rpc, nullptr /* data */, nullptr /* policy */);
 }
 
 bool TaoRPC::GetRandomBytes(size_t size, string *bytes) {
   TaoRPCRequest rpc;
   rpc.set_rpc(TAO_RPC_GET_RANDOM_BYTES);
   rpc.set_size(size);
-  return Request(rpc, bytes, nullptr /* policy */);
+  return Request(&rpc, bytes, nullptr /* policy */);
 }
 
 bool TaoRPC::GetSharedSecret(size_t size, const string &policy, string *bytes) {
   TaoRPCRequest rpc;
   rpc.set_rpc(TAO_RPC_GET_SHARED_SECRET);
   rpc.set_size(size);
   rpc.set_policy(policy);
-  return Request(rpc, bytes, nullptr /* policy */);
+  return Request(&rpc, bytes, nullptr /* policy */);
 }
 
 bool TaoRPC::Attest(const Statement &stmt, string *attestation) {
   string serialized_stmt;
   if (!stmt.SerializePartialToString(&serialized_stmt)) {
     LOG(ERROR) << "Could not serialize partial statement";
     return false;
   }
   TaoRPCRequest rpc;
   rpc.set_rpc(TAO_RPC_ATTEST);
   rpc.set_data(serialized_stmt);
-  return Request(rpc, attestation, nullptr /* policy */);
+  return Request(&rpc, attestation, nullptr /* policy */);
 }
 
 bool TaoRPC::Seal(const string &data, const string &policy, string *sealed) {
   TaoRPCRequest rpc;
   rpc.set_rpc(TAO_RPC_SEAL);
   rpc.set_data(data);
   rpc.set_policy(policy);
-  return Request(rpc, sealed, nullptr /* policy */);
+  return Request(&rpc, sealed, nullptr /* policy */);
 }
 
 bool TaoRPC::Unseal(const string &sealed, string *data, string *policy) {
   TaoRPCRequest rpc;
   rpc.set_rpc(TAO_RPC_UNSEAL);
   rpc.set_data(sealed);
-  return Request(rpc, data, policy);
+  return Request(&rpc, data, policy);
 }
 
-bool TaoRPC::Request(const TaoRPCRequest &req, string *data, string *policy) {
+bool TaoRPC::Request(TaoRPCRequest *req, string *data, string *policy) {
+  req->set_seq(++last_seq_);
   TaoRPCResponse resp;
   bool eof;
-  if (!channel_->SendMessage(req)) {
+  if (!channel_->SendMessage(*req)) {
     failure_msg_ = "Channel send failed";
     LOG(ERROR) << "RPC to Tao host failed: " << failure_msg_;
     return false;
   }
   if (!channel_->ReceiveMessage(&resp, &eof)) {
     failure_msg_ = "Channel receive failed";
     LOG(ERROR) << "RPC to Tao host failed: " << failure_msg_;
     return false;
   }
   if (eof) {
     failure_msg_ = "Channel is closed";
     LOG(ERROR) << "RPC to Tao host failed: " << failure_msg_;
     return false;
   }
-  if (!resp.success()) {
-    if (resp.has_reason() && resp.reason().size() > 0)
-      failure_msg_ = resp.reason();
-    else
-      failure_msg_ = "Unknown failure from Tao host";
+  if (resp.has_error()) {
+    failure_msg_ = resp.error();
+    LOG(ERROR) << "RPC to Tao host failed: " << failure_msg_;
+    return false;
+  }
+  if (resp.seq() != req->seq()) {
+    failure_msg_ = "Unexpected sequence number in response";
     LOG(ERROR) << "RPC to Tao host failed: " << failure_msg_;
     return false;
   }
   if (data != nullptr) {
     if (!resp.has_data()) {
       failure_msg_ = "Malformed response (missing data)";
       LOG(ERROR) << "RPC to Tao host failed: " << failure_msg_;
       return false;
     }
     data->assign(resp.data());
   }
   if (policy != nullptr) {
     if (!resp.has_policy()) {
       failure_msg_ = "Malformed response (missing policy)";
       LOG(ERROR) << "RPC to Tao host failed: " << failure_msg_;
       return false;
     }
     policy->assign(resp.policy());
   }
   return true;
diff --git a/src/tao/tao_rpc.h b/src/tao/tao_rpc.h
index 48fe776..984f2f4 100644
--- a/src/tao/tao_rpc.h
+++ b/src/tao/tao_rpc.h
@@ -51,32 +51,35 @@ class TaoRPC : public Tao {
   virtual bool GetSharedSecret(size_t size, const string &policy,
                                string *bytes);
   virtual bool Attest(const Statement &stmt, string *attestation);
   virtual bool Seal(const string &data, const string &policy, string *sealed);
   virtual bool Unseal(const string &sealed, string *data, string *policy);
   virtual string GetRecentErrorMessage() const { return failure_msg_; }
   virtual string ResetRecentErrorMessage() {
     string msg = failure_msg_;
     failure_msg_ = "";
     return msg;
   }
   /// @}
 
  protected:
   /// The channel over which to send and receive messages.
   unique_ptr<MessageChannel> channel_;
 
   /// Most recent RPC failure message, if any.
   string failure_msg_;
 
+  /// Most recent RPC sequence number.
+  unsigned int last_seq_;
+
  private:
   /// Do an RPC request/response interaction with the host Tao.
-  /// @param req The request to send.
+  /// @param[in,out] req The request to send. The sequence number is set.
   /// @param[out] data The returned data, if not nullptr.
   /// @param[out] policy The returned policy, if not nullptr.
-  bool Request(const TaoRPCRequest &req, string *data, string *policy);
+  bool Request(TaoRPCRequest *req, string *data, string *policy);
 
   DISALLOW_COPY_AND_ASSIGN(TaoRPC);
 };
 }  // namespace tao
 
 #endif  // TAO_TAO_RPC_H_
