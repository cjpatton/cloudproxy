#* 
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-07-20T22:51:10-0700
#* 
#- Fixed problems from the tpm2.diff review
#- 
#- 
#**
#** author: Kevin Walsh
#** email: kwalsh@holycross.edu
#** date: 2014-07-22T15:30:42-0400
#**
#-- Looks good. Possible minor bug (easy fix) and a clarification (no changes
#-- needed) below. Unless you make drastic changes, or my clarification below is
#-- totally off base, I don't need a bounce for this.
diff --git a/go/src/tpm/tpm.go b/go/src/tpm/tpm.go
index a8d01ea..28fe9a7 100644
--- a/go/src/tpm/tpm.go
+++ b/go/src/tpm/tpm.go
@@ -68,156 +68,178 @@ func Pack(ch CommandHeader, cmd []interface{}) ([]byte, error) {
 	if err := binary.Write(buf, binary.BigEndian, ch); err != nil {
 		return nil, err
 	}
 
 	for _, c := range cmd {
 		if err := binary.Write(buf, binary.BigEndian, c); err != nil {
 			return nil, err
 		}
 	}
 
 	return buf.Bytes(), nil
 }
 
 // A ResponseHeader is a header for TPM responses.
 type ResponseHeader struct {
 	Tag  uint16
 	Size uint32
 	Res  uint32
 }
 
-// Unpack decodes from a byte array a sequence of elements that either either
+// A SliceSize is used to detect incoming variable-sized array responses.
+type SliceSize uint32
+
+// Unpack decodes from a byte array a sequence of elements that are either
 // pointers to fixed length types or slices of fixed-length types. It uses
 // binary.Read to do the decoding.
 func Unpack(b []byte, resp []interface{}) error {
-	// Note that this only makes sense if the elements of resp are either
-	// pointers or slices, since otherwise the decoded values just get thrown
-	// away.
 	buf := bytes.NewBuffer(b)
+	var nextSliceSize SliceSize
 	for _, r := range resp {
+		if nextSliceSize > 0 {
#*
#* author: Kevin Walsh
#* email: kwalsh@holycross.edu
#* date: 2014-07-22T15:27:09-0400
#*
#- Bug if tpm can return zero SliceSize? I realize you can't use negative as
#- sentinel b/c SliceSize must be uint32. So just use a separate
#- nextThingIsASliceThatNeedsResizing bool variable. Or resizeNext bool.
#-
+			// This must be a byte slice to resize.
+			bs, ok := r.([]byte)
+			if !ok {
+				return errors.New("a *SliceSize must be followed by a []byte")
+			}
+
+			if int(nextSliceSize) > len(b) {
+				return errors.New("the TPM returned more bytes than can fit in the supplied slice")
+			}
+
+			// Resize the slice to match the number of bytes the TPM says it
+			// returned for this value.
+			r = bs[:nextSliceSize]
+			nextSliceSize = 0
#*
#* author: Kevin Walsh
#* email: kwalsh@holycross.edu
#* date: 2014-07-22T15:22:05-0400
#*
#- Clarification about the intended interface here: You reslice into r, but you
#- don't actually modify the caller's slice, right? So the caller must reslice
#- the array after a successful call? I see GetRandom does return b[:outSize],
#- for example, so I'm guessing this is as intended. And the caller can always
#- do this b/c they have the SliceSize from the preceding argument.
#-
+		}
+
+		// Note that this only makes sense if the elements of resp are either
+		// pointers or slices, since otherwise the decoded values just get
+		// thrown away.
 		if err := binary.Read(buf, binary.BigEndian, r); err != nil {
 			return err
 		}
+
+		if ss, ok := r.(*SliceSize); ok {
+			nextSliceSize = *ss
+		}
+	}
+
+	if buf.Len() > 0 {
+		return errors.New("unread bytes in the TPM response")
 	}
 
 	return nil
 }
 
 // submitTPMRequest sends a structure to the TPM device file and gets results
 // back, interpreting them as a new provided structure.
 func submitTPMRequest(f *os.File, tag uint16, ord uint32, in []interface{}, out []interface{}) error {
 	ch := CommandHeader{tag, 0, ord}
 	inb, err := Pack(ch, in)
 	if err != nil {
 		return err
 	}
 
 	if _, err := f.Write(inb); err != nil {
 		return err
 	}
 
 	// Try to read the whole thing, but handle the case where it's just a
 	// ResponseHeader and not the body, since that's what happens in the error
 	// case.
 	var rh ResponseHeader
 	outSize := PackedSize(out)
 	if outSize < 0 {
 		return errors.New("invalid out arguments")
 	}
 
 	rhSize := binary.Size(rh)
 	outb := make([]byte, rhSize+outSize)
 	if _, err := f.Read(outb); err != nil {
 		return err
 	}
 
-	rhbuf := bytes.NewBuffer(outb)
-	if err := binary.Read(rhbuf, binary.BigEndian, &rh); err != nil {
+	if err := Unpack(outb[:rhSize], []interface{}{&rh}); err != nil {
 		return err
 	}
 
 	// Check success before trying to read the rest of the result.
 	if rh.Tag != tagRSPCommand {
 		return errors.New("inconsistent tag returned by TPM")
 	}
 
 	if rh.Res != 0 {
-		return opError(rh.Res)
+		return tpmError(rh.Res)
 	}
 
 	if rh.Size > uint32(rhSize) {
 		if err := Unpack(outb[rhSize:], out); err != nil {
 			return err
 		}
-	} else if len(out) > 0 {
-		return errors.New("expected results, but none were returned in a successful response")
 	}
 
 	return nil
 }
 
 // ReadPCR reads a PCR value from the TPM.
 func ReadPCR(f *os.File, pcr uint32) ([]byte, error) {
 	in := []interface{}{pcr}
 	v := make([]byte, PCRSize)
 	out := []interface{}{v}
 	if err := submitTPMRequest(f, tagRQUCommand, ordPCRRead, in, out); err != nil {
 		return nil, err
 	}
 
 	return v, nil
 }
 
 // An OIAPResponse is a response to an OIAPCommand.
 type OIAPResponse struct {
 	Auth      uint32
 	NonceEven [20]byte
 }
 
 // OIAP sends an OIAP command to the TPM and gets back an auth value and a
 // nonce.
 func OIAP(f *os.File) (*OIAPResponse, error) {
 	var resp OIAPResponse
 	out := []interface{}{&resp}
 	if err := submitTPMRequest(f, tagRQUCommand, ordOIAP, nil, out); err != nil {
 		return nil, err
 	}
 
 	return &resp, nil
 }
 
 // GetRandom gets random bytes from the TPM.
 func GetRandom(f *os.File, size uint32) ([]byte, error) {
 	in := []interface{}{size}
 
-	var outSize uint32
+	var outSize SliceSize
 	b := make([]byte, int(size))
 	out := []interface{}{&outSize, b}
 
 	if err := submitTPMRequest(f, tagRQUCommand, ordGetRandom, in, out); err != nil {
 		return nil, err
 	}
 
-	if outSize > size {
-		return nil, errors.New("wrong size from GetRandom")
-	}
-
 	return b[:outSize], nil
 }
 
 // An OSAPCommand is a command sent for OSAP authentication.
 type OSAPCommand struct {
 	EntityType  uint16
 	EntityValue uint32
 	OddOSAP     [20]byte
 }
 
 // An OSAPResponse is a TPM reply to an OSAPCommand.
 type OSAPResponse struct {
 	Auth      uint32
 	NonceEven [20]byte
 	EvenOSAP  [20]byte
 }
 
 // OSAP sends an OSAPCommand to the TPM and gets back authentication
 // information in an OSAPResponse.
 func OSAP(f *os.File, entityType uint16, entityValue uint32, oddOSAP [20]byte) (*OSAPResponse, error) {
diff --git a/go/src/tpm/tpm_errors.go b/go/src/tpm/tpm_errors.go
index 043ea89..91ff267 100644
--- a/go/src/tpm/tpm_errors.go
+++ b/go/src/tpm/tpm_errors.go
@@ -1,218 +1,216 @@
 package tpm
 
 import (
 	"strconv"
 )
 
-// A TPMError is an error value from the TPM.
-type opError uint32
+// A tpmError is an error value from the TPM.
+type tpmError uint32
 
 // Error produces a string for the given TPM Error code
-func (o opError) Error() string {
-	if s, ok := opErrMsgs[o]; ok {
+func (o tpmError) Error() string {
+	if s, ok := tpmErrMsgs[o]; ok {
 		return "tpm: " + s
 	}
 
 	return "tpm: unknown error code " + strconv.Itoa(int(o))
 }
 
 // These are the TPM error codes from the spec.
 const (
-	_                = iota
-	AuthFail opError = iota
-	BadIndex
-	BadParameter
-	AuditFailure
-	ClearDisabled
-	Deactivated
-	Disabled
-	DisabledCmd
-	Fail
-	BadOrdinal
-	InstallDisabled
-	InvalidKeyHandle
-	KeyNotFound
-	InappropriateEnc
-	MigrateFail
-	InvalidPCRInfo
-	NoSpace
-	NoSRK
-	NotSealedBlob
-	OwnerSet
-	Resources
-	ShortRandom
-	NoSize // This is TPM_SIZE in the TPM spec, but Size is too generic for us.
-	WrongPCRVal
-	BadParamSize
-	SHAThread
-	SHAError
-	FailedSelfTest
-	Auth2Fail
-	BadTag
-	IOError
-	EncryptError
-	DecryptError
-	InvalidAuthHandle
-	NoEndorsement
-	InvalidKeyUsage
-	WrongEntityType
-	InvalidPostInit
-	InappropriateSig
-	BadKeyProperty
-	BadMigration
-	BadScheme
-	BadDatasize
-	BadMode
-	BadPresence
-	BadVersion
-	NoWrapTransport
-	AuditFailUnsuccessful
-	AuditFailSuccessful
-	NotResetable
-	NotLocal
-	BadType
-	InvalidResource
-	NotFIPS
-	InvalidFamily
-	NoNVPermission
-	RequiresSign
-	KeyNotSupported
-	AuthConflict
-	AreaLocked
-	BadLocality
-	ReadOnly
-	PerNoWrite
-	FamilyCount
-	WriteLocked
-	BadAttributes
-	InvalidStructure
-	KeyOwnerControl
-	BadCounter
-	NotFullWrite
-	ContextGap
-	MaxNVWrites
-	NoOperator
-	ResourceMissing
-	DelegateLock
-	DelegateFamliy
-	DelegateAdmin
-	TransportNotExclusive
-	OwnerControl
-	DAAResources
-	DAAInputData0
-	DAAInputData1
-	DAAIssuerSettings
-	DAASettings
-	DAAState
-	DAAIssuerVailidity
-	DAAWrongW
-	BadHandle
-	BadDelegate
-	BadContext
-	TooManyContexts
-	MATicketSignature
-	MADestination
-	MASource
-	MAAuthority
+	_                    = iota
+	ErrAuthFail tpmError = iota
+	ErrBadIndex
+	ErrBadParameter
+	ErrAuditFailure
+	ErrClearDisabled
+	ErrDeactivated
+	ErrDisabled
+	ErrDisabledCmd
+	ErrFail
+	ErrBadOrdinal
+	ErrInstallDisabled
+	ErrInvalidKeyHandle
+	ErrKeyNotFound
+	ErrInappropriateEnc
+	ErrMigrateFail
+	ErrInvalidPCRInfo
+	ErrNoSpace
+	ErrNoSRK
+	ErrNotSealedBlob
+	ErrOwnerSet
+	ErrResources
+	ErrShortRandom
+	ErrSize
+	ErrWrongPCRVal
+	ErrBadParamSize
+	ErrSHAThread
+	ErrSHAError
+	ErrFailedSelfTest
+	ErrAuth2Fail
+	ErrBadTag
+	ErrIOError
+	ErrEncryptError
+	ErrDecryptError
+	ErrInvalidAuthHandle
+	ErrNoEndorsement
+	ErrInvalidKeyUsage
+	ErrWrongEntityType
+	ErrInvalidPostInit
+	ErrInappropriateSig
+	ErrBadKeyProperty
+	ErrBadMigration
+	ErrBadScheme
+	ErrBadDatasize
+	ErrBadMode
+	ErrBadPresence
+	ErrBadVersion
+	ErrNoWrapTransport
+	ErrAuditFailUnsuccessful
+	ErrAuditFailSuccessful
+	ErrNotResetable
+	ErrNotLocal
+	ErrBadType
+	ErrInvalidResource
+	ErrNotFIPS
+	ErrInvalidFamily
+	ErrNoNVPermission
+	ErrRequiresSign
+	ErrKeyNotSupported
+	ErrAuthConflict
+	ErrAreaLocked
+	ErrBadLocality
+	ErrReadOnly
+	ErrPerNoWrite
+	ErrFamilyCount
+	ErrWriteLocked
+	ErrBadAttributes
+	ErrInvalidStructure
+	ErrKeyOwnerControl
+	ErrBadCounter
+	ErrNotFullWrite
+	ErrContextGap
+	ErrMaxNVWrites
+	ErrNoOperator
+	ErrResourceMissing
+	ErrDelegateLock
+	ErrDelegateFamliy
+	ErrDelegateAdmin
+	ErrTransportNotExclusive
+	ErrOwnerControl
+	ErrDAAResources
+	ErrDAAInputData0
+	ErrDAAInputData1
+	ErrDAAIssuerSettings
+	ErrDAASettings
+	ErrDAAState
+	ErrDAAIssuerVailidity
+	ErrDAAWrongW
+	ErrBadHandle
+	ErrBadDelegate
+	ErrBadContext
+	ErrTooManyContexts
+	ErrMATicketSignature
+	ErrMADestination
+	ErrMASource
+	ErrMAAuthority
 )
 
-// opErrMsgs maps opError codes to their associated error strings. Normally, Go
-// error messages must start with a lower-case character. However, in this case,
-// these are the strings defined in the spec.
-var opErrMsgs = map[opError]string{
-	AuthFail:              "Authentication failed",
-	BadIndex:              "The index to a PCR, DIR or other register is incorrect",
-	BadParameter:          "One or more parameter is bad",
-	AuditFailure:          "An operation completed successfully but the auditing of that operation failed",
-	ClearDisabled:         "The clear disable flag is set and all clear operations now require physical access",
-	Deactivated:           "The TPM is deactivated",
-	Disabled:              "The TPM is disabled",
-	DisabledCmd:           "The target command has been disabled",
-	Fail:                  "The operation failed",
-	BadOrdinal:            "The ordinal was unknown or inconsistent",
-	InstallDisabled:       "The ability to install an owner is disabled",
-	InvalidKeyHandle:      "The key handle can not be interpreted",
-	KeyNotFound:           "The key handle points to an invalid key",
-	InappropriateEnc:      "Unacceptable encryption scheme",
-	MigrateFail:           "Migration authorization failed",
-	InvalidPCRInfo:        "PCR information could not be interpreted",
-	NoSpace:               "No room to load key",
-	NoSRK:                 "There is no SRK set",
-	NotSealedBlob:         "An encrypted blob is invalid or was not created by this TPM",
-	OwnerSet:              "There is already an Owner",
-	Resources:             "The TPM has insufficient internal resources to perform the requested action",
-	ShortRandom:           "A random string was too short",
-	NoSize:                "The TPM does not have the space to perform the operation",
-	WrongPCRVal:           "The named PCR value does not match the current PCR value",
-	BadParamSize:          "The paramSize argument to the command has the incorrect value",
-	SHAThread:             "There is no existing SHA-1 thread",
-	SHAError:              "The calculation is unable to proceed because the existing SHA-1 thread has already encountered an error",
-	FailedSelfTest:        "Self-test has failed and the TPM has shutdown",
-	Auth2Fail:             "The authorization for the second key in a 2 key function failed authorization",
-	BadTag:                "The tag value sent to for a command is invalid",
-	IOError:               "An IO error occurred transmitting information to the TPM",
-	EncryptError:          "The encryption process had a problem",
-	DecryptError:          "The decryption process had a problem",
-	InvalidAuthHandle:     "An invalid handle was used",
-	NoEndorsement:         "The TPM does not have an EK installed",
-	InvalidKeyUsage:       "The usage of a key is not allowed",
-	WrongEntityType:       "The submitted entity type is not allowed",
-	InvalidPostInit:       "The command was received in the wrong sequence relative to Init and a subsequent Startup",
-	InappropriateSig:      "Signed data cannot include additional DER information",
-	BadKeyProperty:        "The key properties in KEY_PARAMs are not supported by this TPM",
-	BadMigration:          "The migration properties of this key are incorrect",
-	BadScheme:             "The signature or encryption scheme for this key is incorrect or not permitted in this situation",
-	BadDatasize:           "The size of the data (or blob) parameter is bad or inconsistent with the referenced key",
-	BadMode:               "A mode parameter is bad, such as capArea or subCapArea for GetCapability, physicalPresence parameter for PhysicalPresence, or migrationType for CreateMigrationBlob",
-	BadPresence:           "Either the physicalPresence or physicalPresenceLock bits have the wrong value",
-	BadVersion:            "The TPM cannot perform this version of the capability",
-	NoWrapTransport:       "The TPM does not allow for wrapped transport sessions",
-	AuditFailUnsuccessful: "TPM audit construction failed and th eunderlying command was returning a failure code also",
-	AuditFailSuccessful:   "TPM audit construction failed and the underlying command was returning success",
-	NotResetable:          "Attempt to reset a PCR register that does not have the resettable attribute",
-	NotLocal:              "Attempt to reset a PCR register that requires locality and locality modifier not part of command transport",
-	BadType:               "Make identity blob not properly typed",
-	InvalidResource:       "When saving context identified resource type does not match actual resource",
-	NotFIPS:               "The TPM is attempting to execute a command only available when in FIPS mode",
-	InvalidFamily:         "The command is attempting to use an invalid family ID",
-	NoNVPermission:        "The permission to manipulate the NV storage is not available",
-	RequiresSign:          "The operation requires a signed command",
-	KeyNotSupported:       "Wrong operation to load an NV key",
-	AuthConflict:          "NV_LoadKey blob requires both owner and blob authorization",
-	AreaLocked:            "The NV area is locked and not writeable",
-	BadLocality:           "The locality is incorrect for the attempted operation",
-	ReadOnly:              "The NV area is read only and can't be written to",
-	PerNoWrite:            "There is no protection on the write to the NV area",
-	FamilyCount:           "The family count value does not match",
-	WriteLocked:           "The NV area has already been written to",
-	BadAttributes:         "The NV area attributes conflict",
-	InvalidStructure:      "The structure tag and version are invalid or inconsistent",
-	KeyOwnerControl:       "The key is under control of the TPM Owner and can only be evicted by the TPM Owner",
-	BadCounter:            "The counter handle is incorrect",
-	NotFullWrite:          "The write is not a complete write of the area",
-	ContextGap:            "The gap between saved context counts is too large",
-	MaxNVWrites:           "The maximum number of NV writes without an owner has been exceeded",
-	NoOperator:            "No operator AuthData value is set",
-	ResourceMissing:       "The resource pointed to by context is not loaded",
-	DelegateLock:          "The delegate administration is locked",
-	DelegateFamliy:        "Attempt to manage a family other than the delegated family",
-	DelegateAdmin:         "Delegation table management not enabled",
-	TransportNotExclusive: "There was a command executed outside of an exclusive transport session",
-	OwnerControl:          "Attempt to context save a owner evict controlled key",
-	DAAResources:          "The DAA command has no resources available to execute the command",
-	DAAInputData0:         "The consistency check on DAA parameter inputData0 has failed",
-	DAAInputData1:         "The consistency check on DAA parameter inputData1 has failed",
-	DAAIssuerSettings:     "The consistency check on DAA_issuerSettings has failed",
-	DAASettings:           "The consistency check on DAA_tpmSpecific has failed",
-	DAAState:              "The atomic process indicated by the submitted DAA command is not the expected process",
-	DAAIssuerVailidity:    "The issuer's validity check has detected an inconsistency",
-	DAAWrongW:             "The consistency check on w has failed",
-	BadHandle:             "The handle is incorrect",
-	BadDelegate:           "Delegation is not correct",
-	BadContext:            "The context blob is invalid",
-	TooManyContexts:       "Too many contexts held by the TPM",
-	MATicketSignature:     "Migration authority signature validation failure",
-	MADestination:         "Migration destination not authenticated",
-	MASource:              "Migration source incorrect",
-	MAAuthority:           "Incorrect migration authority",
+// tpmErrMsgs maps tpmError codes to their associated error strings.
+var tpmErrMsgs = map[tpmError]string{
+	ErrAuthFail:              "authentication failed",
+	ErrBadIndex:              "the index to a PCR, DIR or other register is incorrect",
+	ErrBadParameter:          "one or more parameter is bad",
+	ErrAuditFailure:          "an operation completed successfully but the auditing of that operation failed",
+	ErrClearDisabled:         "the clear disable flag is set and all clear operations now require physical access",
+	ErrDeactivated:           "the TPM is deactivated",
+	ErrDisabled:              "the TPM is disabled",
+	ErrDisabledCmd:           "the target command has been disabled",
+	ErrFail:                  "the operation failed",
+	ErrBadOrdinal:            "the ordinal was unknown or inconsistent",
+	ErrInstallDisabled:       "the ability to install an owner is disabled",
+	ErrInvalidKeyHandle:      "the key handle can not be interpreted",
+	ErrKeyNotFound:           "the key handle points to an invalid key",
+	ErrInappropriateEnc:      "unacceptable encryption scheme",
+	ErrMigrateFail:           "migration authorization failed",
+	ErrInvalidPCRInfo:        "PCR information could not be interpreted",
+	ErrNoSpace:               "no room to load key",
+	ErrNoSRK:                 "there is no SRK set",
+	ErrNotSealedBlob:         "an encrypted blob is invalid or was not created by this TPM",
+	ErrOwnerSet:              "there is already an Owner",
+	ErrResources:             "the TPM has insufficient internal resources to perform the requested action",
+	ErrShortRandom:           "a random string was too short",
+	ErrSize:                  "the TPM does not have the space to perform the operation",
+	ErrWrongPCRVal:           "the named PCR value does not match the current PCR value",
+	ErrBadParamSize:          "the paramSize argument to the command has the incorrect value",
+	ErrSHAThread:             "there is no existing SHA-1 thread",
+	ErrSHAError:              "the calculation is unable to proceed because the existing SHA-1 thread has already encountered an error",
+	ErrFailedSelfTest:        "self-test has failed and the TPM has shutdown",
+	ErrAuth2Fail:             "the authorization for the second key in a 2 key function failed authorization",
+	ErrBadTag:                "the tag value sent to for a command is invalid",
+	ErrIOError:               "an IO error occurred transmitting information to the TPM",
+	ErrEncryptError:          "the encryption process had a problem",
+	ErrDecryptError:          "the decryption process had a problem",
+	ErrInvalidAuthHandle:     "an invalid handle was used",
+	ErrNoEndorsement:         "the TPM does not have an EK installed",
+	ErrInvalidKeyUsage:       "the usage of a key is not allowed",
+	ErrWrongEntityType:       "the submitted entity type is not allowed",
+	ErrInvalidPostInit:       "the command was received in the wrong sequence relative to Init and a subsequent Startup",
+	ErrInappropriateSig:      "signed data cannot include additional DER information",
+	ErrBadKeyProperty:        "the key properties in KEY_PARAMs are not supported by this TPM",
+	ErrBadMigration:          "the migration properties of this key are incorrect",
+	ErrBadScheme:             "the signature or encryption scheme for this key is incorrect or not permitted in this situation",
+	ErrBadDatasize:           "the size of the data (or blob) parameter is bad or inconsistent with the referenced key",
+	ErrBadMode:               "a mode parameter is bad, such as capArea or subCapArea for GetCapability, physicalPresence parameter for PhysicalPresence, or migrationType for CreateMigrationBlob",
+	ErrBadPresence:           "either the physicalPresence or physicalPresenceLock bits have the wrong value",
+	ErrBadVersion:            "the TPM cannot perform this version of the capability",
+	ErrNoWrapTransport:       "the TPM does not allow for wrapped transport sessions",
+	ErrAuditFailUnsuccessful: "TPM audit construction failed and th eunderlying command was returning a failure code also",
+	ErrAuditFailSuccessful:   "TPM audit construction failed and the underlying command was returning success",
+	ErrNotResetable:          "attempt to reset a PCR register that does not have the resettable attribute",
+	ErrNotLocal:              "attempt to reset a PCR register that requires locality and locality modifier not part of command transport",
+	ErrBadType:               "make identity blob not properly typed",
+	ErrInvalidResource:       "when saving context identified resource type does not match actual resource",
+	ErrNotFIPS:               "the TPM is attempting to execute a command only available when in FIPS mode",
+	ErrInvalidFamily:         "the command is attempting to use an invalid family ID",
+	ErrNoNVPermission:        "the permission to manipulate the NV storage is not available",
+	ErrRequiresSign:          "the operation requires a signed command",
+	ErrKeyNotSupported:       "wrong operation to load an NV key",
+	ErrAuthConflict:          "NV_LoadKey blob requires both owner and blob authorization",
+	ErrAreaLocked:            "the NV area is locked and not writeable",
+	ErrBadLocality:           "the locality is incorrect for the attempted operation",
+	ErrReadOnly:              "the NV area is read only and can't be written to",
+	ErrPerNoWrite:            "there is no protection on the write to the NV area",
+	ErrFamilyCount:           "the family count value does not match",
+	ErrWriteLocked:           "the NV area has already been written to",
+	ErrBadAttributes:         "the NV area attributes conflict",
+	ErrInvalidStructure:      "the structure tag and version are invalid or inconsistent",
+	ErrKeyOwnerControl:       "the key is under control of the TPM Owner and can only be evicted by the TPM Owner",
+	ErrBadCounter:            "the counter handle is incorrect",
+	ErrNotFullWrite:          "the write is not a complete write of the area",
+	ErrContextGap:            "the gap between saved context counts is too large",
+	ErrMaxNVWrites:           "the maximum number of NV writes without an owner has been exceeded",
+	ErrNoOperator:            "no operator AuthData value is set",
+	ErrResourceMissing:       "the resource pointed to by context is not loaded",
+	ErrDelegateLock:          "the delegate administration is locked",
+	ErrDelegateFamliy:        "attempt to manage a family other than the delegated family",
+	ErrDelegateAdmin:         "delegation table management not enabled",
+	ErrTransportNotExclusive: "there was a command executed outside of an exclusive transport session",
+	ErrOwnerControl:          "attempt to context save a owner evict controlled key",
+	ErrDAAResources:          "the DAA command has no resources available to execute the command",
+	ErrDAAInputData0:         "the consistency check on DAA parameter inputData0 has failed",
+	ErrDAAInputData1:         "the consistency check on DAA parameter inputData1 has failed",
+	ErrDAAIssuerSettings:     "the consistency check on DAA_issuerSettings has failed",
+	ErrDAASettings:           "the consistency check on DAA_tpmSpecific has failed",
+	ErrDAAState:              "the atomic process indicated by the submitted DAA command is not the expected process",
+	ErrDAAIssuerVailidity:    "the issuer's validity check has detected an inconsistency",
+	ErrDAAWrongW:             "the consistency check on w has failed",
+	ErrBadHandle:             "the handle is incorrect",
+	ErrBadDelegate:           "delegation is not correct",
+	ErrBadContext:            "the context blob is invalid",
+	ErrTooManyContexts:       "too many contexts held by the TPM",
+	ErrMATicketSignature:     "migration authority signature validation failure",
+	ErrMADestination:         "migration destination not authenticated",
+	ErrMASource:              "migration source incorrect",
+	ErrMAAuthority:           "incorrect migration authority",
 }
diff --git a/go/src/tpm/tpm_test.go b/go/src/tpm/tpm_test.go
index fdb8d66..9b9fffd 100644
--- a/go/src/tpm/tpm_test.go
+++ b/go/src/tpm/tpm_test.go
@@ -1,62 +1,59 @@
 package tpm
 
 import (
-	"encoding/hex"
 	"os"
 	"testing"
 )
 
 func TestEncoding(t *testing.T) {
 	ch := CommandHeader{tagRQUCommand, 0, ordOIAP}
 	var c uint32 = 137
 	in := []interface{}{c}
 
 	b, err := Pack(ch, in)
 	if err != nil {
 		t.Fatal("Couldn't pack the bytes:", err)
 	}
 
 	var hdr CommandHeader
 	var size uint32
 	out := []interface{}{&hdr, &size}
 	if err := Unpack(b, out); err != nil {
 		t.Fatal("Couldn't unpack the packed bytes")
 	}
 
 	if size != 137 {
 		t.Fatal("Got the wrong size back")
 	}
 }
 
 func TestReadPCR(t *testing.T) {
 	// Try to read PCR 18. For this to work, you have to have access to
 	// /dev/tpm0, and there has to be a TPM driver to answer requests.
 	f, err := os.OpenFile("/dev/tpm0", os.O_RDWR, 0600)
 	if err != nil {
 		t.Fatal("Can't open /dev/tpm0 for read/write:", err)
 	}
 
 	res, err := ReadPCR(f, 18)
 	if err != nil {
 		t.Fatal("Couldn't read PCR 18 from the TPM:", err)
 	}
 
-	resStr := hex.EncodeToString(res)
-	t.Logf("Got PCR 18 value %s\n", resStr)
+	t.Logf("Got PCR 18 value % x\n", res)
 }
 
 func TestGetRandom(t *testing.T) {
 	// Try to get 16 bytes of randomness from the TPM.
 	f, err := os.OpenFile("/dev/tpm0", os.O_RDWR, 0600)
 	if err != nil {
 		t.Fatal("Can't open /dev/tpm0 for read/write:", err)
 	}
 
 	b, err := GetRandom(f, 16)
 	if err != nil {
 		t.Fatal("Couldn't get 16 bytes of randomness from the TPM:", err)
 	}
 
-	s := hex.EncodeToString(b)
-	t.Logf("Got random bytes %s\n", s)
+	t.Logf("Got random bytes % x\n", b)
 }
