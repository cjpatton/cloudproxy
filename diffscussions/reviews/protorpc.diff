#* 
#* author: Kevin Walsh
#* email: kwalsh@holycross.edu
#* date: 2014-07-16T15:34:27-0400
#* 
#- go RPC codecs for protobufs.
#- 
#- The MessageStream class wraps a regular i/o stream and adds methods for
#- reading and writing delineated strings and marshaelled protobuf messages.
#-
#- The protorpc.go file provides client and server codecs for using net/rpc 
#- with protobuf as the encoding mechanism. There are some limitations on the
#- protobufs that can be used (see comment docs). The codecs use MessageStream
#- as a helper.
#-
#- The taorpc.go file uses net/rpc with the above codecs to provide a
#- client-side RPC stub for go programs to talk to a (C++ or go) host Tao over a
#- channel.
#- 
#*
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-07-16T13:02:05-0700
#*
#- High-level comments:
#- 
#- First, I'm still learning good Go style, so I'm open to disagreement on the
#- style-based comments I'll make here.
#- 
#- Instead of fmt, I've been using github.com/golang/glog for messages, since
#- then we can redirect them and use them like we do with google-glog in C++.
#- 
#- My best understanding of Go's variable style is to use := whenever possible,
#- and only to use var statements when necessary. I think many of the var
#- statements in the following code can be eliminated.
#- 
#- From this diff, it looks like these files are missing Apache 2 license
#- statements.
#**
#** author: Kevin Walsh
#** email: kwalsh@holycross.edu
#** date: 2014-07-16T17:00:27-0400
#**
#-- fmt - Agree, I think. I haven't yet learned go's log, glog, etc. yet, so fmt
#-- was a stopgap. Should we keep using fmt in places where we would use
#-- cout/printf, e.g. in top-level user-facing app code? (that is what "demo"
#-- was meant to be)
#--
#-- := - Agree. You can probably see my style evolving in real time. 
#--
#-- licenses - I deleted them all. Do you want the same boilerplate as C++? I'd
#-- just as soon delete all per-file legal boilerplate, but I know nothing and
#-- defer to you guys.
#--
diff --git a/go-kwalsh/src/cloudproxy/demo/demo.go b/go-kwalsh/src/cloudproxy/demo/demo.go
new file mode 100644
index 0000000..e043f1f
--- /dev/null
+++ b/go-kwalsh/src/cloudproxy/demo/demo.go1
@@ -0,0 +1,85 @@
+package main
+
+import (
+	"cloudproxy/tao"
#*
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-07-16T13:09:22-0700
#*
#- I think I'm dong this, too, but the style in Go is to put the standard
#- libraries first, then other sets of libraries. Since cloudproxy/tao is not
#- a standard library, it should come later, especially because it will
#- eventually be something like github.com/tmroeder/cloudproxy/tao.
#- 
#- I'll make sure I fix this in my code, too.
#- 
#**
#** author: Kevin Walsh
#** email: kwalsh@holycross.edu
#** date: 2014-07-16T17:04:40-0400
#**
#-- Will do.
#--
+	"errors"
+	"fmt"
+	"os"
+	"strconv"
+	"strings"
+)
+
+func hostTaoDemo() error {
+	if tao.Host == nil {
+		return errors.New("No host Tao available")
+	}
+
+	var err error
+
+	var name string
+	name, err = tao.Host.GetTaoName()
+	if err != nil {
+		return err
+	}
+	fmt.Printf("My root name is %s\n", name)
+
+	args := make([]string, len(os.Args))
+	for index, arg := range os.Args {
+		args[index] = strconv.Quote(arg)
+	}
+	subprin := "Args(" + strings.Join(args, ", ") + ")"
+	err = tao.Host.ExtendTaoName(subprin)
+	if err != nil {
+		return err
+	}
+
+	name, err = tao.Host.GetTaoName()
+	if err != nil {
+		return err
+	}
+	fmt.Printf("My full name is %s\n", name)
+
+	var random []byte
+	random, err = tao.Host.GetRandomBytes(10)
+	if err != nil {
+		return err
+	}
+	fmt.Printf("Random bytes  : % x\n", random)
+
+	var secret []byte
+	secret, err = tao.Host.GetSharedSecret(10, tao.SharedSecretPolicyDefault)
+	if err != nil {
+		return err
+	}
+	fmt.Printf("Shared secret : % x\n", secret)
+
+	var sealed []byte
+	sealed, err = tao.Host.Seal(random, tao.SealPolicyDefault)
+	if err != nil {
+		return err
+	}
+	fmt.Printf("Sealed bytes  : % x\n", sealed)
+
+	var unsealed []byte
+	var policy string
+	unsealed, policy, err = tao.Host.Unseal(sealed)
+	if err != nil {
+		return err
+	}
+	if policy != tao.SealPolicyDefault {
+		return errors.New("Unexpected policy on unseal")
+	}
+	fmt.Printf("Unsealed bytes: % x\n", unsealed)
+
+	return nil
+}
+
+func main() {
+	fmt.Printf("Go Tao Demo\n")
+
+	err := hostTaoDemo()
+	if err != nil {
+		fmt.Printf("Error: %s\n", err.Error())
+		return
+	}
+}
diff --git a/go-kwalsh/src/cloudproxy/tao/tao.go b/go-kwalsh/src/cloudproxy/tao/tao.go
new file mode 100644
index 0000000..8832f3e
--- /dev/null
+++ b/go-kwalsh/src/cloudproxy/tao/tao.go
@@ -0,0 +1,62 @@
+package tao
+
+import (
+	"fmt"
+	"os"
+)
+
+const (
+	HostTaoEnvVar = "GOOGLE_HOST_TAO"
+
+	SharedSecretPolicyDefault = "self"
+	SharedSecretPolicyConservative = "few"
+	SharedSecretPolicyLiberal = "any"
+
+	SealPolicyDefault = "self"
+	SealPolicyConservative = "few"
+	SealPolicyLiberal = "any"
+)
+
+// Tao is the fundamental Trustworthy Computing interface provided by a host to
+// its hosted programs. Each level of a system can act as a host by exporting
+// the Tao interface and providing Tao services to higher-level hosted programs.
+//
+// In most cases, a hosted program will use a stub Tao that performs RPC over a
+// channel to its host. The details of such RPC depend on the specific
+// implementation of the host: some hosted programs may use pipes to communicate
+// with their host, others may use sockets, etc.
+type Tao interface {
+	// GetTaoName returns the Tao principal name assigned to the caller.
+	GetTaoName() (name string, err error)
+
+	/// ExtendTaoName irreversibly extends the Tao principal name of the caller.
+	ExtendTaoName(subprin string) error
#*
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-07-16T13:12:49-0700
#*
#- Only double slash for Go
#- 
#**
#** author: Kevin Walsh
#** email: kwalsh@holycross.edu
#** date: 2014-07-16T17:05:01-0400
#**
#-- Will fix.
#--
+
+	// GetRandomBytes returns a slice of n random bytes.
+	GetRandomBytes(n int) (bytes []byte, err error)
#*
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-07-16T13:11:11-0700
#*
#- I've been wondering if maybe we should make the Go Tao implement io.Reader by
#- turning this into Read([]byte) (int, error). Then we could use the Tao in
#- place of rand.Read when we want to get randomness from the Tao.
#- 
#**
#** author: Kevin Walsh
#** email: kwalsh@holycross.edu
#** date: 2014-07-16T17:06:01-0400
#**
#-- That's a good idea. But let's make Read() a method on a member object, like
#-- tao.Rand.Read() instead. Though if Tao is an interface, I guess it has to be
#-- tao.Rand().Read(). So tao.Rand() returns an io.Reader, just like variable
#-- rand.Reader holds an io.Reader.
+
+	// GetSharedSecret returns a slice of n secret bytes.
+	GetSharedSecret(n int, policy string) (bytes []byte, err error)
+
+	// Attest requests the Tao host sign a Statement on behalf of the caller.
+	Attest(stmt *Statement) (*Attestation, error)
+
+	// Seal encrypts data so only certain hosted programs can unseal it.
+	Seal(data []byte, policy string) (sealed []byte, err error)
+
+	// Unseal decrypts data that has been sealed by the Seal() operation, but only
+	// if the policy specified during the Seal() operation is satisfied.
+	Unseal(sealed []byte) (data []byte, policy string, err error)
+}
+
+// Host is a pointer to host Tao underlying this hosted program.
#*
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-07-16T13:13:08-0700
#*
#- "to host Tao" -> "to the host Tao"
#- 
#**
#** author: Kevin Walsh
#** email: kwalsh@holycross.edu
#** date: 2014-07-16T17:11:37-0400
#**
#-- Will fix.
#--
+var Host Tao
+
+func init() {
+	tao, err := DeserializeTaoRPC(os.Getenv(HostTaoEnvVar))
+	if err != nil {
+		fmt.Println(err.Error())
+	} else {
+		Host = tao
+	}
+}
diff --git a/go-kwalsh/src/cloudproxy/tao/taorpc.go b/go-kwalsh/src/cloudproxy/tao/taorpc.go
new file mode 100644
index 0000000..2e64b00
--- /dev/null
+++ b/go-kwalsh/src/cloudproxy/tao/taorpc.go
@@ -0,0 +1,197 @@
+package tao
+
+import (
+	"cloudproxy/util"
+	"cloudproxy/util/protorpc"
+	"code.google.com/p/goprotobuf/proto"
+	"errors"
+	"math"
+	"net/rpc"
+	"strings"
+)
+
+var op_rpc_name = map[string]string{
#*
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-07-16T13:14:04-0700
#*
#- Naming: Go naming uses mixedCase rather than underscore_names.
#- See http://golang.org/doc/effective_go.html#names
#- 
#**
#** author: Kevin Walsh
#** email: kwalsh@holycross.edu
#** date: 2014-07-16T17:12:07-0400
#**
#-- Will fix.
#--
+		"Tao.GetRandomBytes": "TAO_RPC_GET_RANDOM_BYTES",
+		"Tao.Seal": "TAO_RPC_SEAL",
+		"Tao.Unseal": "TAO_RPC_UNSEAL",
+		"Tao.Attest": "TAO_RPC_ATTEST",
+		"Tao.GetTaoName": "TAO_RPC_GET_TAO_NAME",
+		"Tao.ExtendTaoName": "TAO_RPC_EXTEND_TAO_NAME",
+		"Tao.GetSharedSecret": "TAO_RPC_GET_SHARED_SECRET",
+}
+
+var op_go_name = make(map[string]string)
+
+func init() {
+	for go_name, rpc_name := range op_rpc_name{
+			op_go_name[rpc_name] = go_name
+	}
+}
+
+// Convert string "Tao.FooBar" into integer TaoRPCOperation_TAO_RPC_FOO_BAR.
+func goToRPC(m string) (TaoRPCOperation, error) {
+	op := TaoRPCOperation(TaoRPCOperation_value[op_rpc_name[m]])
+	if op == TaoRPCOperation(0) {
+		return op, protorpc.ErrBadRequestType
+	}
+	return op, nil
+}
+
+// Convert integer TaoRPCOperation_TAO_RPC_FOO_BAR into string "Tao.FooBar".
+func rpcToGo(op TaoRPCOperation) (string, error) {
+	s := op_go_name[TaoRPCOperation_name[int32(op)]]
+	if s == "" {
+		return "", protorpc.ErrBadRequestType
+	}
+	return s, nil
+}
+
+type taoMux struct{}
+
+func (taoMux) SetRequestHeader(req proto.Message, servicemethod string, seq uint64) error {
#*
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-07-16T13:16:43-0700
#*
#- I've never seen this receiver style before. I would think that if you don't
#- need to name the receiver, then there shouldn't be a receiver. This might
#- mean that you need to make the name a little longer to disambiguate it from
#- other similarly-named functions.
#- 
#- I've just come back from later in the code: I think I understand now: is this
#- needed to make the codecs work with net/rpc?
#- 
#**
#** author: Kevin Walsh
#** email: kwalsh@holycross.edu
#** date: 2014-07-16T17:13:05-0400
#**
#-- Yup. Elsewhere in the protorpc code it needs an object that satisfies the
#-- ProtoClientMux interface. Here I'm implementing such an object, which
#-- happens to not need any state whatsoever. I guess the alternative is to use
#-- function pointers instead of interfaces?
#--
+	m, ok := req.(*TaoRPCRequest)
+	if !ok || m == nil {
+		return protorpc.ErrBadRequestType
+	}
+	rpc, err := goToRPC(servicemethod)
+	if err != nil {
+		return err
+	}
+	m.Rpc = &rpc
+	m.Seq = &seq
+	return nil
+}
+
+func (taoMux) SetResponseHeader(req proto.Message, servicemethod string, seq uint64) error {
+	m, ok := req.(*TaoRPCResponse)
+	if !ok || m == nil {
+		return protorpc.ErrBadResponseType
+	}
+	rpc, err := goToRPC(servicemethod)
+	if err != nil {
+		return err
+	}
+	m.Rpc = &rpc
+	m.Seq = &seq
+	return nil
+}
+
+func (taoMux) GetServiceMethod(number uint64) (string, error) {
+	return rpcToGo(TaoRPCOperation(int32(number)))
+}
+
+// TaoRPC sends requests between this hosted program and the host Tao.
+type TaoRPC struct {
+	rpc *rpc.Client
+}
+
+func DeserializeTaoRPC(s string) (*TaoRPC, error) {
+	if s == "" {
+		return nil, errors.New("Missing host Tao spec. " +
+			"Make sure $" + HostTaoEnvVar +" is set.")
#*
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-07-16T13:19:03-0700
#*
#- Once again, I think I'm doing this in places in my code, but I
#- shouldn't be. The errors.New string should start with lower case.
#- See https://code.google.com/p/go-wiki/wiki/CodeReviewComments#Error_Strings
#- 
#**
#** author: Kevin Walsh
#** email: kwalsh@holycross.edu
#** date: 2014-07-16T17:20:34-0400
#**
#-- Will fix here and elsewhere.
#--
+	}
+	r := strings.TrimPrefix(s, "tao::TaoRPC+")
+	if r == s {
+		return nil, errors.New("Unrecognized $" + HostTaoEnvVar + " string: " + s)
+	}
+	ms, err := util.DeserializeFDMessageStream(r)
+	if err != nil {
+		return nil, errors.New("Unrecognized $" + HostTaoEnvVar + " string: " + s +
+			" (" + err.Error() + ")")
+	}
+	return &TaoRPC{protorpc.NewClient(ms, taoMux{})}, nil
+}
+
+type expectedResponse int
+
+const (
+	wantNothing = 0
+	wantData expectedResponse = 1 << iota
+	wantPolicy
+)
+
+var ErrMalformedResponse = errors.New("tao rpc: malformed response")
+
+func (t *TaoRPC) call(method string, r *TaoRPCRequest, e expectedResponse) (data []byte, policy string, err error) {
+  s := new(TaoRPCResponse)
+  err = t.rpc.Call(method, r, s)
+  if err != nil {
+    return
+  }
#*
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-07-16T13:23:46-0700
#*
#- go fmt
#- 
#**
#** author: Kevin Walsh
#** email: kwalsh@holycross.edu
#** date: 2014-07-16T17:20:53-0400
#**
#-- Will fix.
#--
+	if s.Error != nil {
+		err = errors.New(*s.Error)
+		return
+	}
+	if (s.Data != nil) != (e&wantData != 0) ||
+			(s.Policy != nil) != (e&wantPolicy != 0) {
+		err = ErrMalformedResponse
+		return
+	}
+	if s.Data != nil {
+		data = s.Data
+	}
+	if s.Policy != nil {
+		policy = *s.Policy
+	}
+	return
+}
+
+func (t *TaoRPC) GetTaoName() (string, error) {
+  r := &TaoRPCRequest{}
+	data, _, err := t.call("Tao.GetTaoName", r, wantData)
+	return string(data), err
+}
+
+func (t *TaoRPC) ExtendTaoName(subprin string) (error) {
+	r := &TaoRPCRequest{Data: []byte(subprin)}
+	_, _, err := t.call("Tao.ExtendTaoName", r, wantNothing)
+	return err
+}
+
+func (t *TaoRPC) GetRandomBytes(n int) ([]byte, error) {
+	if n > math.MaxUint32 {
+		return nil, errors.New("Request for too many random bytes")
+	}
+	r := &TaoRPCRequest{Size: proto.Int32(int32(n))}
+	bytes, _, err := t.call("Tao.GetRandomBytes", r, wantData)
+	return bytes, err
+}
+
+func (t *TaoRPC) GetSharedSecret(n int, policy string) ([]byte, error) {
+	if n > math.MaxUint32 {
+		return nil, errors.New("Request for too many secret bytes")
+	}
+	r := &TaoRPCRequest{Size: proto.Int32(int32(n)), Policy: proto.String(policy)}
+	bytes, _, err := t.call("Tao.GetSharedSecret", r, wantData)
+	return bytes, err
+}
+
+func (t *TaoRPC) Attest(stmt *Statement) (*Attestation, error) {
+	data, err := proto.Marshal(stmt)
+	if _, ok := err.(*proto.RequiredNotSetError); err != nil && !ok {
+		return nil, err
+	}
+	r := &TaoRPCRequest{Data: data}
+	bytes, _, err := t.call("Tao.Attest", r, wantData)
+	if err != nil {
+		return nil, err
+	}
+	var a Attestation
+	err = proto.Unmarshal(bytes, &a)
+	if err != nil {
+		return nil, err
+	}
+	return &a, nil
+}
+
+func (t *TaoRPC) Seal(data []byte, policy string) (sealed []byte, err error) {
+	r := &TaoRPCRequest{Data: data, Policy: proto.String(policy)}
+	sealed, _, err = t.call("Tao.Seal", r, wantData)
+	return
+}
+
+func (t *TaoRPC) Unseal(sealed []byte) (data []byte, policy string, err error) {
+	r := &TaoRPCRequest{Data: sealed}
+	data, policy, err = t.call("Tao.Unseal", r, wantData | wantPolicy)
+	return
+}
diff --git a/go-kwalsh/src/cloudproxy/util/fdmessagestream.go b/go-kwalsh/src/cloudproxy/util/fdmessagestream.go
new file mode 100644
index 0000000..a208eac
--- /dev/null
+++ b/go-kwalsh/src/cloudproxy/util/fdmessagestream.go
@@ -0,0 +1,28 @@
+package util
+
+import (
+	"errors"
+	"fmt"
+	"os"
+)
+
+// DeserializeFDMessageStream takes a string description of the form
+// "tao::FDMessageStream(X, Y)" and returns a MessageStream that uses file
+// descriptor X as the reader and file descriptor Y as the writer.
+func DeserializeFDMessageStream(s string) (*MessageStream, error) {
+	var readfd, writefd uintptr
+	_, err := fmt.Sscanf(s, "tao::FDMessageChannel(%d, %d)", &readfd, &writefd)
+	if err != nil {
+		return nil, errors.New("Unrecognized channel spec: " + s)
+	}
+	if readfd == writefd {
+		rw := os.NewFile(readfd, "read/write pipe")
+		return NewMessageStream(rw), nil
+	} else {
+		r := os.NewFile(readfd, "read pipe")
+		w := os.NewFile(writefd, "write pipe")
+		rw := NewPairReadWriteCloser(r, w)
+		return NewMessageStream(rw), nil
+	}
+}
+
diff --git a/go-kwalsh/src/cloudproxy/util/messages.go b/go-kwalsh/src/cloudproxy/util/messages.go
new file mode 100644
index 0000000..355aba2
--- /dev/null
+++ b/go-kwalsh/src/cloudproxy/util/messages.go
@@ -0,0 +1,25 @@
+package util
+
+import (
+	"code.google.com/p/goprotobuf/proto"
+)
+
+// A MessageReader is a stream from which protobuf messages can be read.
+type MessageReader interface {
+	ReadMessage(m proto.Message) error
+}
+
+// A MessageWriter is a stream to which protobuf messages can be written.
+type MessageWriter interface {
+	WriteMessage(m proto.Message) error
+}
+
+// A StringReader is a stream from which strings can be read.
+type StringReader interface {
+	ReadString() (string, error)
+}
+
+// A StringWriter is a stream to which strings can be written.
+type StringWriter interface {
+	WriteString(s string) (n int, err error)
+}
diff --git a/go-kwalsh/src/cloudproxy/util/messagestream.go b/go-kwalsh/src/cloudproxy/util/messagestream.go
new file mode 100644
index 0000000..955f173
--- /dev/null
+++ b/go-kwalsh/src/cloudproxy/util/messagestream.go
@@ -0,0 +1,89 @@
+package util
+
+import (
+	"code.google.com/p/goprotobuf/proto"
+	"encoding/binary"
+	"errors"
+	"io"
+	"math"
+)
+
+// A MessageStream is an io.ReadWriteCloser that can also read and write strings
+// and protobuf messages. Boundaries are preserved for strings and protobuf
+// messages using a 32-bit (network byte order) length prefix before the
+// contents of the string or marshalled protobuf message. MessageStream can also
+// enforce an upper-limit on the size of received messages.
+type MessageStream struct {
+	MaxMessageSize int // Negative means unlimited
+	io.ReadWriteCloser
+}
+
+const DefaultMaxMessageSize = 20 * 1024 * 1024
+
+var ErrMessageTooLarge = errors.New("messagestream: Message is too large")
+
+// WriteString writes a 32-bit length followed by the string.
+func (ms *MessageStream) WriteString(s string) (int, error) {
+	n := len(s)
+	if n > math.MaxUint32 {
+		return 0, ErrMessageTooLarge
+	}
+	var sizebytes [4]byte
+	binary.BigEndian.PutUint32(sizebytes[:], uint32(n))
+	n, err := ms.Write(sizebytes[:])
+	if err != nil {
+		return n, err
+	}
+	m, err := ms.Write([]byte(s))
+	return n+m, err
+}
+
+// ReadString reads a 32-bit length followed by a string.
+func (ms *MessageStream) ReadString() (string, error) {
+	var sizebytes [4]byte
+	_, err := io.ReadFull(ms, sizebytes[:])
+	if err != nil {
+		return "", err
+	}
+	n := binary.BigEndian.Uint32(sizebytes[:])
+	max := ms.MaxMessageSize
+	// We also check for int(n) to overflow so allocation below doesn't fail.
+	if int(n) < 0 || (max > 0 && int(n) > max) {
+		return "", ErrMessageTooLarge
+	}
+	strbytes := make([]byte, int(n))
+	_, err = io.ReadFull(ms, strbytes)
+	if err != nil {
+		return "", err
+	}
+	return string(strbytes), nil
+}
+
+// WriteMessage writes 32-bit length followed by a protobuf message.
+func (ms *MessageStream) WriteMessage(m proto.Message) (int, error) {
+	bytes, err := proto.Marshal(m)
+	if err != nil {
+		return 0, err
+	}
+	return ms.WriteString(string(bytes))
+}
+
+// ReadMessage reads a 32-bit length followed by a protobuf message.
+func (ms *MessageStream) ReadMessage(m proto.Message) error {
+	s, err := ms.ReadString()
+	if err != nil {
+		return err
+	}
+	err = proto.Unmarshal([]byte(s), m)
+	if err != nil {
+		return err
+	}
+	return nil
+}
+
+// NewMessageStream creates a MessageStream for the given pipe with a reception
+// limit of DefaultMaxMessageSize..
#*
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-07-16T13:31:43-0700
#*
#- ".." -> "."
#- 
#**
#** author: Kevin Walsh
#** email: kwalsh@holycross.edu
#** date: 2014-07-16T17:21:18-0400
#**
#-- Will fix.
#--
+func NewMessageStream(pipe io.ReadWriteCloser) *MessageStream {
+	return &MessageStream{DefaultMaxMessageSize, pipe}
+}
+
diff --git a/go-kwalsh/src/cloudproxy/util/pair.go b/go-kwalsh/src/cloudproxy/util/pair.go
new file mode 100644
index 0000000..959ad40
--- /dev/null
+++ b/go-kwalsh/src/cloudproxy/util/pair.go
@@ -0,0 +1,33 @@
+package util
+
+import (
+	"io"
+	"io/ioutil"
+)
+
+// A PairReadWriteCloser groups an io.ReadCloser and an io.WritCloser into a
#*
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-07-16T13:32:04-0700
#*
#- "io.WritCloser" -> "io.WriteCloser"
#- 
#**
#** author: Kevin Walsh
#** email: kwalsh@holycross.edu
#** date: 2014-07-16T17:21:33-0400
#**
#-- Will fix.
#--
+// single structure that implements the io.ReadWriteCloser interface. This can
+// be used to turn a pair of uni-directional streams into a single
+// bi-directional stream.
+type PairReadWriteCloser struct {
+	io.ReadCloser
+	io.WriteCloser
+}
+
+func (pair PairReadWriteCloser) Close() error {
+	err1 := pair.ReadCloser.Close()
+	err2 := pair.WriteCloser.Close()
+	if err1 != nil {
+		return err1
+	} else {
+		return err2
+	}
+}
+
+func NewPairReadWriteCloser(r io.ReadCloser, w io.WriteCloser) *PairReadWriteCloser {
+	if rw, _ := w.(io.ReadCloser); r == rw {
+		return &PairReadWriteCloser{ioutil.NopCloser(r), w}
+	} else {
+		return &PairReadWriteCloser{r, w}
+	}
+}
diff --git a/go-kwalsh/src/cloudproxy/util/protorpc/protorpc.go b/go-kwalsh/src/cloudproxy/util/protorpc/protorpc.go
new file mode 100644
index 0000000..8f12e33
--- /dev/null
+++ b/go-kwalsh/src/cloudproxy/util/protorpc/protorpc.go
@@ -0,0 +1,214 @@
+/*
+	Package protorpc implements a protobuf-based ClientCodec and ServerCodec for the
+	rpc package. Clients can make concurrent or asynchronous requests, and these
+	are handled in whatever order the servers choses.
#*
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-07-16T13:34:03-0700
#*
#- "servers choses" -> "server chooses" ?
#- 
#**
#** author: Kevin Walsh
#** email: kwalsh@holycross.edu
#** date: 2014-07-16T17:21:51-0400
#**
#-- Will fix.
#--
+
+	All service methods take two protobuf message pointers: a request and a
+	response. RPC service method strings and sequence numbers are not sent over
+	the connection separately from the requests and responses. Instead, the
+	request and response protobuf messages must carry this information. To this
+	end, both types of protobuf messages must begin with two fields: a method
+	number and a sequence number. The method number must have tag 1 and can be any
+	of the protobuf types that encode as a positive varint (uint32, enum, etc.).
+	The sequence number must have tag 2 and be of type uint64. For example, the
+	request (or response) protobuf definition might look like:
+
+	  enum MyOperation { MULTIPLY = 1; DIVIDE = 2; }
+	  message MyRequest {
+			required MyOperation op = 1;
+			required uint64 seq = 2;
+			... // additional fields here...
+		}
+	
+	Wire format: A request or response is encoded on the wire as a 32-bit length
+	(encoded in network byte order), followed by a marshalled protobuf message.
+	The separate length field is used for framing because the protobuf encoding
+	does not preserve message boundaries.
+*/
+
+package protorpc
+
+import (
+	"cloudproxy/util"
+	"code.google.com/p/goprotobuf/proto"
+	"errors"
+	"io"
+	"net/rpc"
+	"sync"
+)
+
+type ProtoClientMux interface {
+	// Set the service method string and sequence number for a request.
+	SetRequestHeader(req proto.Message, servicemethod string, seq uint64) error
+
+	// Get the service method string for a given method number
+	GetServiceMethod(number uint64) (string, error)
+}
+
+type clientCodec struct {
+	m *util.MessageStream
+	mux ProtoClientMux
+	sending sync.Mutex
+	resp []byte
+}
+
+// NewClientCodec returns a new rpc.ClientCodec using protobuf messages on conn,
+// where mux is used to match request messages with the appropriate service and
+// method.
+func NewClientCodec(conn io.ReadWriteCloser, mux ProtoClientMux) rpc.ClientCodec {
+	if m, ok := conn.(*util.MessageStream); ok {
+		return &clientCodec{m, mux, sync.Mutex{}, nil}
+	} else {
+		return &clientCodec{util.NewMessageStream(conn), mux, sync.Mutex{}, nil}
+	}
+}
+
+// NewClient returns a new rpc.Client to handle requests to the set of services
+// at the other end of the connection. 
+func NewClient(conn io.ReadWriteCloser, mux ProtoClientMux) *rpc.Client {
+	return rpc.NewClientWithCodec(NewClientCodec(conn, mux))
+}
+
+var ErrBadRequestType = errors.New("protorpc: bad request type")
+var ErrMissingRequest = errors.New("protorpc: missing request")
+var ErrBadResponseType = errors.New("protorpc: bad response type")
+var ErrMissingResponse = errors.New("protorpc: missing response")
+
+func (c *clientCodec) WriteRequest(r *rpc.Request, x interface{}) error {
#*
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-07-16T13:37:16-0700
#*
#- Doc string for this (and other methods)?
#- 
#**
#** author: Kevin Walsh
#** email: kwalsh@holycross.edu
#** date: 2014-07-16T17:22:11-0400
#**
#-- Will fix. These are implementing the rpc.ClientCode interface.
#--
+	y, ok := x.(proto.Message)
+	if !ok || y == nil {
+		return ErrBadRequestType
+	}
+	c.mux.SetRequestHeader(y, r.ServiceMethod, r.Seq)
+	c.sending.Lock()
+	_, err := c.m.WriteMessage(y) // writes htonl(length), marshal(y)
+	c.sending.Unlock()
+	return err
+}
+
+func (c *clientCodec) ReadResponseHeader(r *rpc.Response) error {
+	// We can't just c.m.ReadMessage(x) because we don't yet know the type of
+	// response message x. Instead, read the still-encoded message as a string,
+	// then decode it (partially) using the ProtoRPCHeader protobuf message type.
+	// Note: It is tempting to instead simply decode the first few fields directly
+	// using proto.DecodeVarint() and friends, but that would rely on the ordering
+	// of encoded fields which is not strictly guaranteed.
+	s, err := c.m.ReadString() // reads htonl(length), string
+	if err != nil {
+		return err
+	}
+	resp := []byte(s)
+	var hdr ProtoRPCHeader
+	err = proto.Unmarshal(resp, &hdr)
+	if err != nil {
+		return err
+	}
+	r.Seq = *hdr.Seq
+	r.ServiceMethod, err = c.mux.GetServiceMethod(*hdr.Op)
+	if err != nil {
+		return err
+	}
+	c.resp = resp
+	return nil
+}
+
+func (c *clientCodec) ReadResponseBody(x interface{}) error {
+	resp := c.resp
+	c.resp = nil
+	if x == nil {
+		return nil
+	}
+	if resp == nil {
+		return ErrMissingResponse
+	}
+	// Decode the response bytes again, this time using the correct response
+	// message type.
+	y, ok := x.(proto.Message)
+	if !ok || y == nil {
+		return ErrBadResponseType
+	}
+	return proto.Unmarshal(resp, y)
+}
+
+func (c *clientCodec) Close() error {
+	return c.m.Close()
+}
+
+type ProtoServerMux interface {
+	// Set the service method string and sequence number for a response.
+	SetResponseHeader(req proto.Message, servicemethod string, seq uint64) error
+
+	// Get the service method string for a given method number
+	GetServiceMethod(number uint64) (string, error)
+}
+
+type serverCodec struct {
+	m *util.MessageStream
+	mux ProtoServerMux
+	sending sync.Mutex
+	req []byte
+}
+
+// NewServerCodec returns a new rpc.ServerCodec using protobuf messages on conn,
+// where mux is used to match request messages with the appropriate service and
+// method.
+func NewServerCodec(conn io.ReadWriteCloser, mux ProtoServerMux) rpc.ServerCodec {
+	return &serverCodec{util.NewMessageStream(conn), mux, sync.Mutex{}, nil}
+}
+
+func (c *serverCodec) ReadRequestHeader(r *rpc.Request) error {
+	// This is almost identical to ReadResponseHeader(), above.
+	s, err := c.m.ReadString() // reads htonl(length), string
+	if err != nil {
+		return err
+	}
+	req := []byte(s)
+	var hdr ProtoRPCHeader
+	err = proto.Unmarshal(req, &hdr)
+	if err != nil {
+		return err
+	}
+	r.Seq = *hdr.Seq
+	r.ServiceMethod, err = c.mux.GetServiceMethod(*hdr.Op)
+	if err != nil {
+		return err
+	}
+	c.req = req
+	return nil
+}
+
+func (c *serverCodec) ReadRequestBody(x interface{}) error {
+	// This is almost identical to ReadResponseBody(), above.
+	req := c.req
+	c.req = nil
+	if x == nil {
+		return nil
+	}
+	if req == nil {
+		return ErrMissingRequest
+	}
+	// Decode the request bytes again, this time using the correct request
+	// message type.
+	y, ok := x.(proto.Message)
+	if !ok || y == nil {
+		return ErrBadRequestType
+	}
+	return proto.Unmarshal(req, y)
+}
+
+func (c *serverCodec) WriteResponse(r *rpc.Response, x interface{}) error {
+	y, ok := x.(proto.Message)
+	if !ok || y == nil {
+		return ErrBadResponseType
+	}
+	c.mux.SetResponseHeader(y, r.ServiceMethod, r.Seq)
+	c.sending.Lock()
+	_, err := c.m.WriteMessage(y) // writes htonl(length), marshal(req)
+	c.sending.Unlock()
+	return err
+}
+
+func (c *serverCodec) Close() error {
+	return c.m.Close()
+}
+
diff --git a/go-kwalsh/src/cloudproxy/util/protorpc/protorpc.proto b/go-kwalsh/src/cloudproxy/util/protorpc/protorpc.proto
new file mode 100644
index 0000000..645ffc2
--- /dev/null
+++ b/go-kwalsh/src/cloudproxy/util/protorpc/protorpc.proto
@@ -0,0 +1,14 @@
+package protorpc;
+
+message ProtoRPCHeader {
+  // Protobuf RPC requests and responses should include at least these fields:
+  
+  // The operation to be performed (for a request) or that was performed (for a
+  // response). Tag must be 1. Type can be any varint-encoded type, e.g. enum,
+  // int32, sint64. The name can be anything.
+  required uint64 op = 1;
+
+  // The sequence number for the operation. Tag must be 2. Type can be any
+  // varint-encoded type.The name can be anything.
+  required uint64 seq = 2;
+}
#*
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-07-16T13:43:08-0700
#*
#- This is a very nice use of protobuf punning. This is the first time I've
#- actually be happy that one protobuf can be read as another.
#- 
#**
#** author: Kevin Walsh
#** email: kwalsh@holycross.edu
#** date: 2014-07-16T17:23:01-0400
#**
#-- I'm glad you like it. It took an unreasonable amount of time for me come up
#-- with this solution. A lot better than decoding the protobufs by hand, which
#-- is the approach I started with.
#--
