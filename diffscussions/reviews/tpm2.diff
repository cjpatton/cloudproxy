#* 
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-07-20T15:52:08-0700
#* 
#- Fixed problems exposed in the tpm*.go code review
#- 
#- 
diff --git a/go/src/tpm/tpm.go b/go/src/tpm/tpm.go
index 14e31b3..5a56c88 100644
--- a/go/src/tpm/tpm.go
+++ b/go/src/tpm/tpm.go
@@ -1,261 +1,232 @@
 // Package tpm supports direct communication with a tpm device under Linux.
 package tpm
 
 import (
 	"bytes"
 	"encoding/binary"
 	"errors"
 	"os"
-	"strconv"
 )
 
-// TPM constants for messages.
+// Supported TPM commands.
 const (
-	TagRQUCommand uint16 = 0x00C1
-	OrdPCRExtend  uint32 = 0x00000014
-	OrdPCRRead    uint32 = 0x00000015
-	OrdOSAP       uint32 = 0x0000000B
-	OrdOIAP       uint32 = 0x0000000A
-	OrdGetRandom  uint32 = 0x00000046
-	PCRSize       int    = 20
+	tagRQUCommand uint16 = 0x00C1
+	tagRSPCommand uint16 = 0x00C4
 )
 
-// A Result is a return value from the TPM.
-type Result uint32
-
+// Supported TPM operations.
 const (
-	Success Result = iota
-	BuffTooSmallError
-	UnauthorizedError
-	FunctionFailedError
+	ordOSAP      uint32 = 0x0000000B
+	ordOIAP      uint32 = 0x0000000A
+	ordPCRExtend uint32 = 0x00000014
+	ordPCRRead   uint32 = 0x00000015
+	ordGetRandom uint32 = 0x00000046
 )
 
-// resultErrors maps Results to their associated error strings.
-var resultErrors = map[Result]string{
-	Success:             "success",
-	BuffTooSmallError:   "buffer too small",
-	UnauthorizedError:   "unauthorized",
-	FunctionFailedError: "function failed",
-}
-
-// Error produces a string for the given TPM Error code
-func (r Result) Error() string {
-	if s, ok := resultErrors[r]; ok {
-		return s
-	}
-
-	return "Unknown error code " + strconv.Itoa(int(r))
-}
+// Each PCR has a fixed size of 20 bytes.
+const PCRSize int = 20
 
 // A CommandHeader is the header for a TPM command.
 type CommandHeader struct {
 	Tag  uint16
 	Size uint32
 	Cmd  uint32
 }
 
 // PackedSize computes the size of a sequence of types that can be passed to
 // binary.Read or binary.Write.
 func PackedSize(elts []interface{}) int {
 	// Add the total size to the header.
 	var size int
 	for i := range elts {
 		s := binary.Size(elts[i])
 		if s == -1 {
 			return -1
 		}
 
 		size += s
 	}
 
 	return size
 }
 
 // Pack takes a sequence of elements that are either of fixed length or slices
 // of fixed-length types and packs them into a single byte array using
-// binary.Write. The first element of the sequence must be a *CommandHeader.
-func Pack(cmd []interface{}) ([]byte, error) {
-	hdr, ok := cmd[0].(*CommandHeader)
-	if !ok {
-		return nil, errors.New("first packed element must be a CommandHeader")
-	}
-
-	size := PackedSize(cmd)
-	if size <= 0 {
+// binary.Write.
+func Pack(ch CommandHeader, cmd []interface{}) ([]byte, error) {
+	hdrSize := binary.Size(ch)
+	bodySize := PackedSize(cmd)
+	if bodySize <= 0 {
 		return nil, errors.New("can't compute the size of the command")
 	}
 
-	hdr.Size = uint32(size)
+	size := hdrSize + bodySize
+	ch.Size = uint32(size)
 	buf := bytes.NewBuffer(make([]byte, 0, size))
-	for i := range cmd {
-		if err := binary.Write(buf, binary.BigEndian, cmd[i]); err != nil {
+
+	// The header goes first, unsurprisingly.
+	if err := binary.Write(buf, binary.BigEndian, ch); err != nil {
+		return nil, err
+	}
+
+	for _, c := range cmd {
+		if err := binary.Write(buf, binary.BigEndian, c); err != nil {
 			return nil, err
 		}
 	}
 
 	return buf.Bytes(), nil
 }
 
 // A header for TPM responses.
 type ResponseHeader struct {
 	Tag  uint16
 	Size uint32
-	Res  Result
+	Res  uint32
 }
 
 // Unpack decodes from a byte array a sequence of elements that either either
 // pointers to fixed length types or slices of fixed-length types. It uses
-// binary.Read to do the decoding. If the first element of the resp sequence is
-// a *ResponseHeader, then the Result field will be checked for success.
+// binary.Read to do the decoding.
 func Unpack(b []byte, resp []interface{}) error {
-	hdr, ok := resp[0].(*ResponseHeader)
+	// Note that this only makes sense if the elements of resp are either
+	// pointers or slices, since otherwise the decoded values just get thrown
+	// away.
 	buf := bytes.NewBuffer(b)
-	var start int
-	if ok {
-		if err := binary.Read(buf, binary.BigEndian, hdr); err != nil {
-			return err
-		}
-
-		if hdr.Res != Success {
-			return hdr.Res
-		}
-		start = 1
-	}
-
-	for i := start; i < len(resp); i++ {
-		if err := binary.Read(buf, binary.BigEndian, resp[i]); err != nil {
+	for _, r := range resp {
+		if err := binary.Read(buf, binary.BigEndian, r); err != nil {
 			return err
 		}
 	}
 
 	return nil
 }
 
 // submitTPMRequest sends a structure to the TPM device file and gets results
 // back, interpreting them as a new provided structure.
-func submitTPMRequest(f *os.File, in []interface{}, out []interface{}) error {
-	inb, err := Pack(in)
+func submitTPMRequest(f *os.File, tag uint16, ord uint32, in []interface{}, out []interface{}) error {
+	ch := CommandHeader{tag, 0, ord}
+	inb, err := Pack(ch, in)
 	if err != nil {
 		return err
 	}
 
 	if _, err := f.Write(inb); err != nil {
 		return err
 	}
 
+	// Try to read the whole thing, but handle the case where it's just a
+	// ResponseHeader and not the body, since that's what happens in the error
+	// case.
+	var rh ResponseHeader
 	outSize := PackedSize(out)
-	if outSize <= 0 {
-		return errors.New("can't compute the size of the response")
+	if outSize < 0 {
+		return errors.New("invalid out arguments")
 	}
 
-	// TODO(tmroeder): this assumes (probably incorrectly) that the TPM will
-	// write the same number of bytes whether the command succeeds or not. It's
-	// more likely that the TPM will return only a response header if the
-	// command fails. In that case, I need to read the response header first,
-	// then decide what action to take. And I should probably separate out the
-	// header from the rest of the output interface.
-	outb := make([]byte, outSize)
+	rhSize := binary.Size(rh)
+	outb := make([]byte, rhSize+outSize)
 	if _, err := f.Read(outb); err != nil {
 		return err
 	}
 
-	if err := Unpack(outb, out); err != nil {
+	rhbuf := bytes.NewBuffer(outb)
+	if err := binary.Read(rhbuf, binary.BigEndian, &rh); err != nil {
 		return err
 	}
 
+	// Check success before trying to read the rest of the result.
+	if rh.Tag != tagRSPCommand {
+		return errors.New("inconsistent tag returned by TPM")
+	}
+
+	if rh.Res != 0 {
+		return opError(rh.Res)
+	}
+
+	if rh.Size > uint32(rhSize) {
+		if err := Unpack(outb[rhSize:], out); err != nil {
+			return err
+		}
+	} else if len(out) > 0 {
+		return errors.New("expected results, but none were returned in a successful response")
+	}
+
 	return nil
 }
 
 // ReadPCR reads a PCR value from the TPM.
 func ReadPCR(f *os.File, pcr uint32) ([]byte, error) {
-	in := []interface{}{
-		&CommandHeader{TagRQUCommand, 0, OrdPCRRead},
-		pcr,
-	}
-
-	// The TPM is supposed to return the 20-byte PCR value
+	in := []interface{}{pcr}
 	v := make([]byte, PCRSize)
-	if err := submitTPMRequest(f, in, []interface{}{v}); err != nil {
+	out := []interface{}{v}
+	if err := submitTPMRequest(f, tagRQUCommand, ordPCRRead, in, out); err != nil {
 		return nil, err
 	}
 
 	return v, nil
 }
 
 // The response to an OIAPCommand.
 type OIAPResponse struct {
 	Auth      uint32
 	NonceEven [20]byte
 }
 
 // OIAP sends an OIAP command to the TPM and gets back an auth value and a
 // nonce.
 func OIAP(f *os.File) (*OIAPResponse, error) {
-	in := []interface{}{&CommandHeader{TagRQUCommand, 0, OrdOIAP}}
-
-	var rh ResponseHeader
 	var resp OIAPResponse
-	out := []interface{}{&rh, &resp}
-
-	if err := submitTPMRequest(f, in, out); err != nil {
+	out := []interface{}{&resp}
+	if err := submitTPMRequest(f, tagRQUCommand, ordOIAP, nil, out); err != nil {
 		return nil, err
 	}
 
 	return &resp, nil
 }
 
 // GetRandom gets random bytes from the TPM.
 func GetRandom(f *os.File, size uint32) ([]byte, error) {
-	in := []interface{}{
-		&CommandHeader{TagRQUCommand, 0, OrdGetRandom},
-		size,
-	}
+	in := []interface{}{size}
 
-	var rh ResponseHeader
 	var outSize uint32
 	b := make([]byte, int(size))
-	out := []interface{}{&rh, &outSize, b}
+	out := []interface{}{&outSize, b}
 
-	if err := submitTPMRequest(f, in, out); err != nil {
+	if err := submitTPMRequest(f, tagRQUCommand, ordGetRandom, in, out); err != nil {
 		return nil, err
 	}
 
-	if outSize != size {
+	if outSize > size {
 		return nil, errors.New("wrong size from GetRandom")
 	}
 
-	return b, nil
+	return b[:outSize], nil
 }
 
 // An OSAPCommand is a command sent for OSAP authentication.
 type OSAPCommand struct {
-	EntryType  uint16
-	EntryValue uint32
-	OddOSAP    [20]byte
+	EntityType  uint16
+	EntityValue uint32
+	OddOSAP     [20]byte
 }
 
 // An OSAPResponse is a TPM reply to an OSAPCommand.
 type OSAPResponse struct {
 	Auth      uint32
 	NonceEven [20]byte
 	EvenOSAP  [20]byte
 }
 
 // OSAP sends an OSAPCommand to the TPM and gets back authentication
 // information in an OSAPResponse.
-func OSAP(f *os.File, entryType uint16, entryValue uint32, oddOSAP [20]byte) (*OSAPResponse, error) {
-	in := []interface{}{
-		&CommandHeader{TagRQUCommand, 0, OrdOSAP},
-		OSAPCommand{entryType, entryValue, oddOSAP},
-	}
-
-	var rh ResponseHeader
+func OSAP(f *os.File, entityType uint16, entityValue uint32, oddOSAP [20]byte) (*OSAPResponse, error) {
+	in := []interface{}{OSAPCommand{entityType, entityValue, oddOSAP}}
 	var resp OSAPResponse
-	out := []interface{}{&rh, &resp}
-
-	if err := submitTPMRequest(f, in, out); err != nil {
+	out := []interface{}{&resp}
+	if err := submitTPMRequest(f, tagRQUCommand, ordOSAP, in, out); err != nil {
 		return nil, err
 	}
 
 	return &resp, nil
 }
diff --git a/go/src/tpm/tpm_errors.go b/go/src/tpm/tpm_errors.go
new file mode 100644
index 0000000..043ea89
--- /dev/null
+++ b/go/src/tpm/tpm_errors.go
@@ -0,0 +1,218 @@
+package tpm
+
+import (
+	"strconv"
+)
+
+// A TPMError is an error value from the TPM.
+type opError uint32
+
+// Error produces a string for the given TPM Error code
+func (o opError) Error() string {
+	if s, ok := opErrMsgs[o]; ok {
+		return "tpm: " + s
+	}
+
+	return "tpm: unknown error code " + strconv.Itoa(int(o))
+}
+
+// These are the TPM error codes from the spec.
+const (
+	_                = iota
+	AuthFail opError = iota
+	BadIndex
+	BadParameter
+	AuditFailure
+	ClearDisabled
+	Deactivated
+	Disabled
+	DisabledCmd
+	Fail
+	BadOrdinal
+	InstallDisabled
+	InvalidKeyHandle
+	KeyNotFound
+	InappropriateEnc
+	MigrateFail
+	InvalidPCRInfo
+	NoSpace
+	NoSRK
+	NotSealedBlob
+	OwnerSet
+	Resources
+	ShortRandom
+	NoSize // This is TPM_SIZE in the TPM spec, but Size is too generic for us.
+	WrongPCRVal
+	BadParamSize
+	SHAThread
+	SHAError
+	FailedSelfTest
+	Auth2Fail
+	BadTag
+	IOError
+	EncryptError
+	DecryptError
+	InvalidAuthHandle
+	NoEndorsement
+	InvalidKeyUsage
+	WrongEntityType
+	InvalidPostInit
+	InappropriateSig
+	BadKeyProperty
+	BadMigration
+	BadScheme
+	BadDatasize
+	BadMode
+	BadPresence
+	BadVersion
+	NoWrapTransport
+	AuditFailUnsuccessful
+	AuditFailSuccessful
+	NotResetable
+	NotLocal
+	BadType
+	InvalidResource
+	NotFIPS
+	InvalidFamily
+	NoNVPermission
+	RequiresSign
+	KeyNotSupported
+	AuthConflict
+	AreaLocked
+	BadLocality
+	ReadOnly
+	PerNoWrite
+	FamilyCount
+	WriteLocked
+	BadAttributes
+	InvalidStructure
+	KeyOwnerControl
+	BadCounter
+	NotFullWrite
+	ContextGap
+	MaxNVWrites
+	NoOperator
+	ResourceMissing
+	DelegateLock
+	DelegateFamliy
+	DelegateAdmin
+	TransportNotExclusive
+	OwnerControl
+	DAAResources
+	DAAInputData0
+	DAAInputData1
+	DAAIssuerSettings
+	DAASettings
+	DAAState
+	DAAIssuerVailidity
+	DAAWrongW
+	BadHandle
+	BadDelegate
+	BadContext
+	TooManyContexts
+	MATicketSignature
+	MADestination
+	MASource
+	MAAuthority
+)
+
+// opErrMsgs maps opError codes to their associated error strings. Normally, Go
+// error messages must start with a lower-case character. However, in this case,
+// these are the strings defined in the spec.
+var opErrMsgs = map[opError]string{
+	AuthFail:              "Authentication failed",
+	BadIndex:              "The index to a PCR, DIR or other register is incorrect",
+	BadParameter:          "One or more parameter is bad",
+	AuditFailure:          "An operation completed successfully but the auditing of that operation failed",
+	ClearDisabled:         "The clear disable flag is set and all clear operations now require physical access",
+	Deactivated:           "The TPM is deactivated",
+	Disabled:              "The TPM is disabled",
+	DisabledCmd:           "The target command has been disabled",
+	Fail:                  "The operation failed",
+	BadOrdinal:            "The ordinal was unknown or inconsistent",
+	InstallDisabled:       "The ability to install an owner is disabled",
+	InvalidKeyHandle:      "The key handle can not be interpreted",
+	KeyNotFound:           "The key handle points to an invalid key",
+	InappropriateEnc:      "Unacceptable encryption scheme",
+	MigrateFail:           "Migration authorization failed",
+	InvalidPCRInfo:        "PCR information could not be interpreted",
+	NoSpace:               "No room to load key",
+	NoSRK:                 "There is no SRK set",
+	NotSealedBlob:         "An encrypted blob is invalid or was not created by this TPM",
+	OwnerSet:              "There is already an Owner",
+	Resources:             "The TPM has insufficient internal resources to perform the requested action",
+	ShortRandom:           "A random string was too short",
+	NoSize:                "The TPM does not have the space to perform the operation",
+	WrongPCRVal:           "The named PCR value does not match the current PCR value",
+	BadParamSize:          "The paramSize argument to the command has the incorrect value",
+	SHAThread:             "There is no existing SHA-1 thread",
+	SHAError:              "The calculation is unable to proceed because the existing SHA-1 thread has already encountered an error",
+	FailedSelfTest:        "Self-test has failed and the TPM has shutdown",
+	Auth2Fail:             "The authorization for the second key in a 2 key function failed authorization",
+	BadTag:                "The tag value sent to for a command is invalid",
+	IOError:               "An IO error occurred transmitting information to the TPM",
+	EncryptError:          "The encryption process had a problem",
+	DecryptError:          "The decryption process had a problem",
+	InvalidAuthHandle:     "An invalid handle was used",
+	NoEndorsement:         "The TPM does not have an EK installed",
+	InvalidKeyUsage:       "The usage of a key is not allowed",
+	WrongEntityType:       "The submitted entity type is not allowed",
+	InvalidPostInit:       "The command was received in the wrong sequence relative to Init and a subsequent Startup",
+	InappropriateSig:      "Signed data cannot include additional DER information",
+	BadKeyProperty:        "The key properties in KEY_PARAMs are not supported by this TPM",
+	BadMigration:          "The migration properties of this key are incorrect",
+	BadScheme:             "The signature or encryption scheme for this key is incorrect or not permitted in this situation",
+	BadDatasize:           "The size of the data (or blob) parameter is bad or inconsistent with the referenced key",
+	BadMode:               "A mode parameter is bad, such as capArea or subCapArea for GetCapability, physicalPresence parameter for PhysicalPresence, or migrationType for CreateMigrationBlob",
+	BadPresence:           "Either the physicalPresence or physicalPresenceLock bits have the wrong value",
+	BadVersion:            "The TPM cannot perform this version of the capability",
+	NoWrapTransport:       "The TPM does not allow for wrapped transport sessions",
+	AuditFailUnsuccessful: "TPM audit construction failed and th eunderlying command was returning a failure code also",
+	AuditFailSuccessful:   "TPM audit construction failed and the underlying command was returning success",
+	NotResetable:          "Attempt to reset a PCR register that does not have the resettable attribute",
+	NotLocal:              "Attempt to reset a PCR register that requires locality and locality modifier not part of command transport",
+	BadType:               "Make identity blob not properly typed",
+	InvalidResource:       "When saving context identified resource type does not match actual resource",
+	NotFIPS:               "The TPM is attempting to execute a command only available when in FIPS mode",
+	InvalidFamily:         "The command is attempting to use an invalid family ID",
+	NoNVPermission:        "The permission to manipulate the NV storage is not available",
+	RequiresSign:          "The operation requires a signed command",
+	KeyNotSupported:       "Wrong operation to load an NV key",
+	AuthConflict:          "NV_LoadKey blob requires both owner and blob authorization",
+	AreaLocked:            "The NV area is locked and not writeable",
+	BadLocality:           "The locality is incorrect for the attempted operation",
+	ReadOnly:              "The NV area is read only and can't be written to",
+	PerNoWrite:            "There is no protection on the write to the NV area",
+	FamilyCount:           "The family count value does not match",
+	WriteLocked:           "The NV area has already been written to",
+	BadAttributes:         "The NV area attributes conflict",
+	InvalidStructure:      "The structure tag and version are invalid or inconsistent",
+	KeyOwnerControl:       "The key is under control of the TPM Owner and can only be evicted by the TPM Owner",
+	BadCounter:            "The counter handle is incorrect",
+	NotFullWrite:          "The write is not a complete write of the area",
+	ContextGap:            "The gap between saved context counts is too large",
+	MaxNVWrites:           "The maximum number of NV writes without an owner has been exceeded",
+	NoOperator:            "No operator AuthData value is set",
+	ResourceMissing:       "The resource pointed to by context is not loaded",
+	DelegateLock:          "The delegate administration is locked",
+	DelegateFamliy:        "Attempt to manage a family other than the delegated family",
+	DelegateAdmin:         "Delegation table management not enabled",
+	TransportNotExclusive: "There was a command executed outside of an exclusive transport session",
+	OwnerControl:          "Attempt to context save a owner evict controlled key",
+	DAAResources:          "The DAA command has no resources available to execute the command",
+	DAAInputData0:         "The consistency check on DAA parameter inputData0 has failed",
+	DAAInputData1:         "The consistency check on DAA parameter inputData1 has failed",
+	DAAIssuerSettings:     "The consistency check on DAA_issuerSettings has failed",
+	DAASettings:           "The consistency check on DAA_tpmSpecific has failed",
+	DAAState:              "The atomic process indicated by the submitted DAA command is not the expected process",
+	DAAIssuerVailidity:    "The issuer's validity check has detected an inconsistency",
+	DAAWrongW:             "The consistency check on w has failed",
+	BadHandle:             "The handle is incorrect",
+	BadDelegate:           "Delegation is not correct",
+	BadContext:            "The context blob is invalid",
+	TooManyContexts:       "Too many contexts held by the TPM",
+	MATicketSignature:     "Migration authority signature validation failure",
+	MADestination:         "Migration destination not authenticated",
+	MASource:              "Migration source incorrect",
+	MAAuthority:           "Incorrect migration authority",
+}
diff --git a/go/src/tpm/tpm_test.go b/go/src/tpm/tpm_test.go
index bd03b7d..fdb8d66 100644
--- a/go/src/tpm/tpm_test.go
+++ b/go/src/tpm/tpm_test.go
@@ -1,55 +1,62 @@
 package tpm
 
 import (
-	"encoding/base64"
+	"encoding/hex"
 	"os"
 	"testing"
 )
 
 func TestEncoding(t *testing.T) {
-	in := []interface{}{&CommandHeader{TagRQUCommand, 0, OrdOIAP}}
+	ch := CommandHeader{tagRQUCommand, 0, ordOIAP}
+	var c uint32 = 137
+	in := []interface{}{c}
 
-	b, err := Pack(in)
+	b, err := Pack(ch, in)
 	if err != nil {
 		t.Fatal("Couldn't pack the bytes:", err)
 	}
 
 	var hdr CommandHeader
-	out := []interface{}{&hdr}
+	var size uint32
+	out := []interface{}{&hdr, &size}
 	if err := Unpack(b, out); err != nil {
 		t.Fatal("Couldn't unpack the packed bytes")
 	}
+
+	if size != 137 {
+		t.Fatal("Got the wrong size back")
+	}
 }
 
 func TestReadPCR(t *testing.T) {
 	// Try to read PCR 18. For this to work, you have to have access to
 	// /dev/tpm0, and there has to be a TPM driver to answer requests.
 	f, err := os.OpenFile("/dev/tpm0", os.O_RDWR, 0600)
 	if err != nil {
 		t.Fatal("Can't open /dev/tpm0 for read/write:", err)
 	}
 
 	res, err := ReadPCR(f, 18)
 	if err != nil {
 		t.Fatal("Couldn't read PCR 18 from the TPM:", err)
 	}
 
-	resStr := base64.StdEncoding.EncodeToString(res)
+	resStr := hex.EncodeToString(res)
 	t.Logf("Got PCR 18 value %s\n", resStr)
 }
 
 func TestGetRandom(t *testing.T) {
 	// Try to get 16 bytes of randomness from the TPM.
 	f, err := os.OpenFile("/dev/tpm0", os.O_RDWR, 0600)
 	if err != nil {
 		t.Fatal("Can't open /dev/tpm0 for read/write:", err)
 	}
 
 	b, err := GetRandom(f, 16)
 	if err != nil {
 		t.Fatal("Couldn't get 16 bytes of randomness from the TPM:", err)
 	}
 
-	s := base64.StdEncoding.EncodeToString(b)
+	s := hex.EncodeToString(b)
 	t.Logf("Got random bytes %s\n", s)
 }
