#* 
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-10-09T11:25:43-0700
#* 
#- Add support for labeled Tao channel types.
#- 
#- This commit adds support for a new shell variable: GOOGLE_HOST_TAO_TYPE. It also
#- adds support for two values for this variable "tpm" and "pipe". These correspond
#- to the two currently support ways for a program to talk to a parent Tao: either
#- it creates a TPMTao and uses, e.g., /dev/tpm0, or it is given a specification of
#- a pair of pipes that should have been added to its file descriptors at fork
#- time, and it uses those pipes for communication.
#- 
#- The next option to be supported will be "unix" for communication over a unix
#- socket, since this will be the easiest way to support Tao channels into docker.
#- 
#- 
#- Add interfaces for hosted programs.
#- 
#- This commit adds an interface for HostedProgram: this generalizes the
#- os/exec.Cmd and the github.com/docker/docker/daemon.Container interfaces to
#- support starting and stopping processes and containers. This also adds an
#- interface for hosted-program factories. This generalizes the LinuxProcessFactory
#- type and will soon be generalized to add support for docker containers.
#- 
#- 
#- Add support for Unix socket Tao channels.
#- 
#- This commit adds support for the "unix" Tao channel type and implements the
#- "-unix" command-line flag in install.sh to add this support.
#- 
#- It updates LinuxProcessFactory to create a Unix socket using a new utility class
#- UnixSingleReadWriteCloser, which manages a single connection on a unix socket.
#- 
#- 
#- Add support for Docker containers.
#- 
#- This commit adds a new factory: the LinuxDockerContainerFactory, and adds
#- support in install.sh for starting hosted programs under Docker containers. The
#- container is based on the empty Docker "scratch" container, so the hash of the
#- tarball that defines the image uniquely defines its contents under Docker. So,
#- the subprincipal for a Docker container is Container([bytes]), where [bytes] is
#- the SHA-256 hash of the tarball.
#- 
#- In install.sh new auth rules for the datalog guard state that if a program hash
#- is trusted, a container hash is trusted, and the container contains the program,
#- then this container can act as a MemberProgram. This hooks containers back into
#- the original rules about member programs and authorization to execute.
#- 
#- Containers get Unix domain sockets hooked in from the host file system and use
#- them for Tao communication with the parent Tao.
#- 
#- 
diff --git a/apps/linux_host/main.go b/apps/linux_host/main.go
index 660a780..0a293c5 100644
--- a/apps/linux_host/main.go
+++ b/apps/linux_host/main.go
@@ -16,44 +16,49 @@ package main
 
 import (
 	"flag"
 	"fmt"
 	"io"
 	"io/ioutil"
 	"log"
 	"net"
 	"os"
 	"os/signal"
 	"path"
 	"syscall"
 
 	"github.com/jlmucb/cloudproxy/tao"
 	"github.com/jlmucb/cloudproxy/tao/auth"
 	"github.com/jlmucb/cloudproxy/util"
 )
 
 var configPath = flag.String("config_path", "tao.config", "Location of tao domain configuration")
 var hostPath = flag.String("path", "linux_tao_host", "Location of linux host configuration")
+var rules = flag.String("rules", "rules", "Name of the rules file for auth")
 var quiet = flag.Bool("quiet", false, "Be more quiet.")
 var root = flag.Bool("root", false, "Run in root mode")
 var stacked = flag.Bool("stacked", false, "Run in stacked mode")
 var pass = flag.String("pass", "", "Password for unlocking keys if running in root mode")
+var channelType = flag.String("channel_type", "pipe", "The type of channel for hosted-program communication ('pipe', or 'unix').")
+var channelSocketPath = flag.String("channel_socket_path", "", "The directory in which to create unix sockets for hosted-program communication")
+var useDocker = flag.Bool("use_docker", false, "Use Docker containers instead of processes")
+var docker = flag.String("docker", "", "The path to a tarball to use to create a docker image")
 
 var create = flag.Bool("create", false, "Create a new LinuxHost service.")
 var show = flag.Bool("show", false, "Show principal name for LinuxHost service.")
 var service = flag.Bool("service", false, "Start the LinuxHost service.")
 var shutdown = flag.Bool("shutdown", false, "Shut down the LinuxHost service.")
 
 var run = flag.Bool("run", false, "Start a hosted program (path and args follow --).")
 var list = flag.Bool("list", false, "List hosted programs.")
 var stop = flag.Bool("stop", false, "Stop a hosted program (names follow --).")
 var kill = flag.Bool("kill", false, "Kill a hosted program (names follow --).")
 var name = flag.Bool("name", false, "Show the principal name of running LinuxHost.")
 
 func countSet(vars ...interface{}) int {
 	var n int
 	for _, v := range vars {
 		switch v := v.(type) {
 		case string:
 			if v != "" {
 				n++
 			}
@@ -88,81 +93,102 @@ func main() {
 	}
 	util.UseEnvFlags("GLOG", "TAO", "TAO_HOST")
 	flag.Parse()
 
 	if *quiet {
 		verbose = ioutil.Discard
 	} else {
 		verbose = os.Stderr
 	}
 
 	if countSet(*create, *show, *service, *shutdown, *run, *stop, *kill, *list, *name) > 1 {
 		log.Fatal("specify at most one of the command options")
 	}
 
 	sockPath := path.Join(*hostPath, "admin_socket")
 
 	if *create || *service || *show {
 		fmt.Fprintf(verbose, "Loading configuration from: %s\n", *configPath)
 		domain, err := tao.LoadDomain(*configPath, nil)
 		fatalIf(err)
+
+		wd, err := os.Getwd()
+		fatalIf(err)
+		rulesPath := path.Join(wd, *rules)
+
+		var childFactory tao.HostedProgramFactory
+		if *useDocker {
+			childFactory = tao.NewLinuxDockerContainerFactory(*channelSocketPath, rulesPath)
+		} else {
+			childFactory = tao.NewLinuxProcessFactory(*channelType, *channelSocketPath)
+		}
+
 		var host *tao.LinuxHost
 		if *root {
 			if len(*pass) == 0 {
 				log.Fatal("password is required")
 			}
-			host, err = tao.NewRootLinuxHost(*hostPath, domain.Guard, []byte(*pass))
+			host, err = tao.NewRootLinuxHost(*hostPath, domain.Guard, []byte(*pass), childFactory)
 		} else if *stacked {
 			if !tao.Hosted() {
 				log.Fatalf("error: no host tao available, check $%s\n", tao.HostTaoEnvVar)
 			}
-			host, err = tao.NewStackedLinuxHost(*hostPath, domain.Guard, tao.Parent())
+			host, err = tao.NewStackedLinuxHost(*hostPath, domain.Guard, tao.Parent(), childFactory)
 		} else {
 			log.Fatal("error: must specify either -root or -stacked")
 		}
 		fatalIf(err)
 		if *create {
 			fmt.Printf("LinuxHost Service: %s\n", host.TaoHostName())
 		} else if *show {
 			fmt.Printf("export GOOGLE_TAO_LINUX='%v'\n", host.TaoHostName())
 		} else /* service */ {
 			sock, err := net.Listen("unix", sockPath)
 			fatalIf(err)
 			defer sock.Close()
 			fmt.Fprintf(verbose, "Linux Tao Service started and waiting for requests\n")
 			fatalIf(err)
 			tao.NewLinuxHostAdminServer(host).Serve(sock)
 		}
 	} else {
 		conn, err := net.Dial("unix", sockPath)
 		fatalIf(err)
 		defer conn.Close()
 		client := tao.NewLinuxHostAdminClient(conn)
 		if *shutdown {
 			log.Fatal("not yet implemented")
 		} else if *run {
 			if flag.NArg() == 0 {
 				log.Fatal("missing program path")
 			}
-			subprin, pid, err := client.StartHostedProgram(flag.Arg(0), flag.Args()...)
-			fatalIf(err)
-			fmt.Printf("%d %v\n", pid, subprin)
+			if *docker == "" {
+				subprin, pid, err := client.StartHostedProgram(flag.Arg(0), flag.Args()...)
+				fatalIf(err)
+				fmt.Printf("%d %v\n", pid, subprin)
+			} else {
+				// flag.Arg(0) is not necessary here, since it
+				// will be pulled off the list by the child
+				// factory when it starts the Docker container.
+				subprin, pid, err := client.StartHostedProgram(*docker, flag.Args()...)
+				fatalIf(err)
+				fmt.Printf("%d %v\n", pid, subprin)
+			}
 		} else if *stop {
 			for _, s := range flag.Args() {
 				var subprin auth.SubPrin
 				_, err := fmt.Sscanf(s, "%v", &subprin)
 				fatalIf(err)
 				err = client.StopHostedProgram(subprin)
 				fatalIf(err)
 			}
 		} else if *kill {
 			for _, s := range flag.Args() {
 				var subprin auth.SubPrin
 				_, err := fmt.Sscanf(s, "%v", &subprin)
 				fatalIf(err)
 				err = client.KillHostedProgram(subprin)
 				fatalIf(err)
 			}
 		} else if *list {
 			name, pid, err := client.ListHostedPrograms()
 			fatalIf(err)
 			for i, p := range pid {
diff --git a/apps/tao_admin/main.go b/apps/tao_admin/main.go
index 7c89844..55fc8ee 100644
--- a/apps/tao_admin/main.go
+++ b/apps/tao_admin/main.go
@@ -38,40 +38,41 @@ var quiet = flag.Bool("quiet", false, "Be more quiet.")
 var show = flag.Bool("show", false, "Show info when done.")
 var host = flag.String("host", "", "The principal name of the host where programs will execute.")
 
 // initializing a new domain
 var create = flag.Bool("create", false, "Create a new domain configuration.")
 var name = flag.String("name", "", "Name for a new configuration.")
 var guard = flag.String("guard", "TrivialLiberalGuard", "Name of guard: ACLs, Datalog, etc.")
 
 // execution policy changes
 var canExecute = flag.String("canexecute", "", "Path of a program to be authorized to execute.")
 var retractCanExecute = flag.String("retractcanexecute", "", "Path of a program to retract authorization to execute.")
 
 // arbitrary policy changes
 var add = flag.String("add", "", "A policy rule to be added.")
 var retract = flag.String("retract", "", "A policy rule to be retracted.")
 var clear = flag.Bool("clear", false, "Clear all policy rules before other changes.")
 var query = flag.String("query", "", "A policy query to be checked.")
 
 // misc. utilities
 var getProgramHash = flag.String("getprogramhash", "", "Path of program to be hashed.")
+var getContainerHash = flag.String("getcontainerhash", "", "Path of container to be hashed.")
 var getPCR = flag.Int("getpcr", -1, "Index of a PCR to return.")
 var tpmPath = flag.String("tpm", "/dev/tpm0", "Path to a TPM device.")
 var aikFile = flag.String("aikblob", "", "A file containing a TPM AIK.")
 
 func main() {
 	help := "Administrative utility for Tao Domain.\n"
 	help += "Usage: %[1]s [options] -create [-name name]\n"
 	help += "%[1]s [options] -(retractcanexecute|canexecute) progpath\n"
 	help += "%[1]s [options] -(add|retract|query) rule\n"
 	help += "%[1]s [options] -clear\n"
 	flag.Usage = func() {
 		fmt.Fprintf(os.Stderr, help, os.Args[0])
 		flag.PrintDefaults()
 	}
 	util.UseEnvFlags("GLOG", "TAO", "TAO_ADMIN")
 	flag.Parse()
 
 	var noise io.Writer
 	if *quiet {
 		noise = ioutil.Discard
@@ -164,40 +165,46 @@ func main() {
 		fatalIf(err)
 		didWork = true
 	}
 	if *query != "" {
 		fmt.Fprintf(noise, "Querying policy guard: %s\n", *query)
 		ok, err := domain.Guard.Query(*query)
 		fatalIf(err)
 		if ok {
 			fmt.Printf("Policy supports query.\n")
 		} else {
 			fmt.Printf("Policy rejects query.\n")
 		}
 		didWork = true
 	}
 	if *getProgramHash != "" {
 		path := *getProgramHash
 		subprin := makeProgramSubPrin(path)
 		fmt.Println(subprin)
 		didWork = true
 	}
+	if *getContainerHash != "" {
+		path := *getContainerHash
+		subprin := makeContainerSubPrin(path)
+		fmt.Println(subprin)
+		didWork = true
+	}
 	if *getPCR > 0 {
 		f, err := os.OpenFile(*tpmPath, os.O_RDWR, 0600)
 		fatalIf(err)
 		defer f.Close()
 		res, err := tpm.ReadPCR(f, uint32(*getPCR))
 		fatalIf(err)
 		fmt.Printf("%x", res)
 		didWork = true
 	}
 	if *aikFile != "" {
 		aikblob, err := ioutil.ReadFile(*aikFile)
 		fatalIf(err)
 		v, err := tpm.UnmarshalRSAPublicKey(aikblob)
 		fatalIf(err)
 		aik, err := x509.MarshalPKIXPublicKey(v)
 		fatalIf(err)
 
 		name := auth.Prin{
 			Type: "tpm",
 			Key:  auth.Bytes(aik),
@@ -222,28 +229,35 @@ func hash(path string) []byte {
 func makeHostPrin(host string) auth.Prin {
 	// Here we rely on there being an env var for the host name. We could also use
 	// a different env var to contact a host and ask its name. That would require
 	// the host to be running, though.
 	if host == "" {
 		host = os.Getenv("GOOGLE_TAO_LINUX")
 	}
 	if host == "" {
 		log.Fatal("No tao host: set $GOOGLE_TAO_LINUX or use -host option")
 	}
 	var prin auth.Prin
 	_, err := fmt.Sscanf(host, "%v", &prin)
 	fatalIf(err)
 	return prin
 }
 
 func makeProgramSubPrin(prog string) auth.SubPrin {
 	// BUG(kwalsh) This assumes no IDs, and it assumes linux hosts.
 	id := uint(0)
 	h := hash(prog)
-	return tao.FormatHostedProgramSubprin(id, h)
+	return tao.FormatSubprin(id, h)
+}
+
+func makeContainerSubPrin(prog string) auth.SubPrin {
+	// TODO(tmroeder): This assumes no IDs
+	id := uint(0)
+	h := hash(prog)
+	return tao.FormatDockerSubprin(id, h)
 }
 
 func fatalIf(err error) {
 	if err != nil {
 		log.Fatal(err)
 	}
 }
diff --git a/install.sh b/install.sh
index c432038..13f4a66 100755
--- a/install.sh
+++ b/install.sh
@@ -13,81 +13,94 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
 # Multi-purpose script for setting up and running tao and cloudproxy tests.
 #
 # This script works with the Go implementation of Tao. It assumes all binaries
 # have been installed in ${GOPATH}/bin (e.g. via `go install`)
 #
 # If you wish to use the TPM, you must have taken ownership of the TPM. For
 # example, see github.com/google/go-tpm/examples/tpm-takeownership.
 
 set -e # quit script on first error
 
 # INSTALL BEGIN
 # Note: This section of code is removed by install.sh
 script_path="install.sh"
 test_dir=""
 test_tpm="no"
 verbose="yes"
 test_guard="AllowAll"
+child_channel_type="pipe"
+tao_channel_type=""
+build_docker="no"
 for arg in "$@"; do
 	case "$arg" in
 		-notpm)
 			test_tpm="no"
 			shift
 			;;
 		-tpm)
 			test_tpm="yes"
+			tao_channel_type="tpm"
 			shift
 			;;
 		-acls)
 			test_guard="ACLs"
 			shift
 			;;
 		-datalog)
 			test_guard="Datalog"
 			shift
 			;;
+		-unix)
+			child_channel_type="unix"
+			shift
+			;;
+		-docker)
+			build_docker="yes"
+			shift
+			;;
 		-q)
 			verbose="no"
 			shift
 			;;
 		-*)
 			echo "Huh? $arg"
 			exit 1
 			;;
 	esac
 done
 if [ $# -eq 1 ]; then
 	test_dir="$1"
 fi
 if [ ! "$test_dir" ]; then
 	echo "Usage: $0 [options] <dir>"
 	echo "  Installs tao testing scripts into <dir>, which will be created"
 	echo "  if it does not yet exist. If neither -acls nor -datalog is"
 	echo "  specified, then the authorization policy is AllowAll."
 	echo "Options:"
 	echo "  -notpm       Use a fake TPM (the default)."
 	echo "  -tpm         Use the TPM."
 	echo "  -acls        Use ACL-based guards for Tao domain policy."
 	echo "  -datalog     Use Datalog-based guards for Tao domain policy."
+	echo "  -unix        Use Unix domain sockets instead of pipes for channels."
 	echo "  -q           Be more quiet."
 	exit 1
 fi
 if [ -e "$test_dir" -a ! -d "$test_dir" ]; then
 	echo "$test_dir: path exists but is not a directory"
 	exit 1
 fi
 mkdir -p "$test_dir"
 # canonicalize
 root_dir=$(readlink -e "$(dirname $0)")
 test_dir=$(readlink -e "$test_dir")
 if [ "$verbose" == "yes" ]; then
 	echo "Installing tao test scripts into: $test_dir"
 fi
 # sanity checks
 if [ ! -d "$GOPATH/bin" ]; then
     echo "install failed: could not find GOPATH bin directory"
     exit 1
 fi
 if [ ! -f "$root_dir/$script_path" -o ! -d "$test_dir" ]; then
@@ -109,76 +122,74 @@ for script in "setup.sh" "start.sh" "restart.sh" "monitor.sh" \
 	ln -s tao.sh $script
 done
 cd "$test_dir"
 rm -f bin
 ln -s ${GOPATH}/bin bin
 mkdir -p logs
 
 if [ "$test_tpm" == "yes" ]; then
 	test_root=false
 	test_stacked=true
 else
 	test_root=true
 	test_stacked=false
 fi
 
 cat <<END > "$test_dir/tao.env"
 # Tao/CloudProxy environment variables"
 export TAO_TEST="$test_dir" # Also hardcoded into $test_dir/scripts/*.sh
 export TAO_ROOTDIR="$root_dir"
 export TAO_USE_TPM="$test_tpm"
+export TAO_CHANNEL_TYPE="$tao_channel_type"
+export TAO_USE_DOCKER="$build_docker"
 
 # Flags for tao programs
 export TAO_config_path="${test_dir}/tao.config"
 export TAO_guard="$test_guard"
 
 # Flags for tao_admin
 export TAO_ADMIN_pass="BogusPass"
 
 # Flags for linux_host
 export TAO_HOST_pass="BogusPass"
 export TAO_HOST_root="$test_root"
 export TAO_HOST_stacked="$test_stacked"
 export TAO_HOST_path="${test_dir}/linux_tao_host"
+export TAO_HOST_channel_type="$child_channel_type"
+export TAO_HOST_channel_socket_path="${test_dir}/linux_tao_host"
 
 # Flags for glog
 export GLOG_v=2
 export GLOG_logtostderr="no"
 export GLOG_alsologtostderr="no"
 export GLOG_stderrthreshold=3 # Only log FATAL to stderr.
 export GLOG_log_dir="\${TAO_TEST}/logs"
 
 # Misc.
 export TAO_HOSTED_PROGRAMS="
 \${TAO_TEST}/bin/demo 
-\${TAO_TEST}/bin/demo_server
-\${TAO_TEST}/bin/client 
-\${TAO_TEST}/bin/server 
-\${TAO_TEST}/bin/fclient 
-\${TAO_TEST}/bin/fserver 
-\${TAO_TEST}/bin/http_echo_server 
-\${TAO_TEST}/bin/https_echo_server 
 "
 
 # BEGIN SETUP VARIABLES
 # These variables come from $test_dir/scripts/setup.sh
 export GOOGLE_HOST_TAO=""
+export GOOGLE_HOST_TAO_TYPE="$tao_channel_type"
 # END SETUP VARIABLES
 END
 
 if [ "$verbose" == "yes" ]; then
 	cat <<END
 Done installing. 
   $test_dir/bin               # Link to ${GOPATH}/bin.
   $test_dir/logs              # Log files.
   $test_dir/scripts           # Useful scripts.
   $test_dir/tao.env           # Environment variables.
 Typical next steps:
   cd $test_dir/
   ./scripts/setup.sh          # Create keys, hashes, ACLs, etc.
   ./scripts/start.sh          # Run Tao CA and Linux Tao server.
   ./scripts/host.sh demo      # Run a client/server demo test.
   ./scripts/stop.sh           # Kill all Tao programs.
   ./scripts/refresh.sh        # Refresh hashes, ACLs, etc.
 Run $test_dir/scripts/help.sh for more info.
 END
 fi
@@ -214,40 +225,41 @@ function extract_pid()
 # e.g. shortname long_binary_filename ==> long_binary_fil
 function shortname()
 {
 	name="$1"
 	echo "\<${name:0:15}\>"
 }
 
 function showenv()
 {
 	cat ${tao_env}
 }
 
 function cleanup()
 {
 	rm -f ${TAO_TEST}/logs/*
 	rm -rf ${TAO_TEST}/{*keys,linux_tao_host,acls,rules,tao.config}
 	sed -i '/^# BEGIN SETUP VARIABLES/,/^# END SETUP VARIABLES/d' ${tao_env}
 	echo "# BEGIN SETUP VARIABLES" >> ${tao_env}
 	echo "# These variables come from ${TAO_TEST}/scripts/setup.sh" >> ${tao_env}
 	echo 'export GOOGLE_HOST_TAO=""' >> ${tao_env}
+	echo 'export GOOGLE_HOST_TAO_TYPE=""' >> ${tao_env}
 	echo "# END SETUP VARIABLES" >> ${tao_env}
 
 	echo "Cleared all Tao configuration data"
 }
 
 function stoptests()
 {
 	echo "Attempting graceful shutdown..."
 	(if linux_host --shutdown; then sleep 1; fi ) 2>/dev/null | grep -v "^Aborted$" || true
 	
 	echo "Checking for remaining Tao services and processes..."
 	# Try to shutdown 
 	killed=0
 	for prog in $all_tao_progs; do
 		if pgrep -lx `shortname "$prog"`; then
 			pkill -x `shortname "$prog"`
 			killed=1
 		fi
 	done
 	if [ $killed -eq 1 ]; then
@@ -256,142 +268,178 @@ function stoptests()
 	else
 		echo "No Tao services or processes remaining"
 	fi
 	rm -f ${TAO_TEST}/linux_tao_host/admin_socket ${TAO_TEST}/*/*_socket
 }
 
 function setup()
 {
 	mkdir -p ${TAO_TEST}/logs
 
 	echo "Creating TaoDomain keys and settings."
 	tao_admin -create -name testing
 
 	# This sets:
 	# $GOOGLE_HOST_TAO # name of underlying host tao, i.e. the TPM (if any)
 	# GOOGLE_TAO_TPM, GOOGLE_TAO_PCRS, # more details about TPM (if any)
 	# and GOOGLE_TAO_LINUX # name of the LinuxHost
 	sed -i '/^# BEGIN SETUP VARIABLES/,/^# END SETUP VARIABLES/d' ${tao_env} 
 	echo "# BEGIN SETUP VARIABLES" >> ${tao_env}
 	echo "# These variables come from ${TAO_TEST}/scripts/setup.sh" >> ${tao_env}
+	echo "export GOOGLE_HOST_TAO_TYPE='${TAO_CHANNEL_TYPE}'" >> ${tao_env}
 
 	if [ "$TAO_USE_TPM" == "yes" ]; then
-        # Don't create a new AIK if one is already present.
-        echo "Checking ${TAO_TEST}/tpm/aikblob"
-        pcr17=`tao_admin -getpcr 17`
-        pcr18=`tao_admin -getpcr 18`
-        if [ ! -f ${TAO_TEST}/tpm/aikblob ]; then
-            echo "Creating TPMTao AIK and settings."
-            rm -rf ${TAO_TEST}/tpm
-            # The genaik program comes from
-            # github.com/google/go-tpm/examples/genaik and must be in
-            # $GOPATH/bin.
-            mkdir -p ${TAO_TEST}/tpm
-            genaik --blob ${TAO_TEST}/tpm/aikblob
-        else
-            echo "Reusing existing TPMTao AIK."
-        fi
-
-        export GOOGLE_HOST_TAO='tao::TPMTao("dir:tpm")'
-        export GOOGLE_TAO_PCRS='PCRs("17,18", "'${pcr17}','${pcr18}'")'
-
-        tprin=`tao_admin -aikblob ${TAO_TEST}/tpm/aikblob`
-        export GOOGLE_TAO_TPM=$tprin
-
-        # TODO(tmroeder): do this correctly in the Go version once we support
-        # AIK creation.
-        echo "export GOOGLE_HOST_TAO='tao::TPMTao(\"dir:tpm\")'" >> ${tao_env}
-        echo "export GOOGLE_TAO_PCRS='PCRs(\"17,18\", \"${pcr17},${pcr18}\")'" >> ${tao_env}
-        echo "export GOOGLE_TAO_TPM='$tprin'" >> ${tao_env}
+		# Don't create a new AIK if one is already present.
+		echo "Checking ${TAO_TEST}/tpm/aikblob"
+		pcr17=`tao_admin -getpcr 17`
+		pcr18=`tao_admin -getpcr 18`
+		if [ ! -f ${TAO_TEST}/tpm/aikblob ]; then
+			echo "Creating TPMTao AIK and settings."
+			rm -rf ${TAO_TEST}/tpm
+			# The genaik program comes from
+			# github.com/google/go-tpm/examples/genaik and must be in
+			# $GOPATH/bin.
+			mkdir -p ${TAO_TEST}/tpm
+			genaik --blob ${TAO_TEST}/tpm/aikblob
+		else
+			echo "Reusing existing TPMTao AIK."
+			export GOOGLE_HOST_TAO="${TAO_TEST}/tpm"
+			export GOOGLE_TAO_PCRS='PCRs("17,18", "'${pcr17}','${pcr18}'")'
+		fi
+
+		export GOOGLE_HOST_TAO=${TAO_TEST}'/tpm'
+		export GOOGLE_TAO_PCRS='PCRs("17,18", "'${pcr17}','${pcr18}'")'
+
+		tprin=`tao_admin -aikblob ${TAO_TEST}/tpm/aikblob`
+		export GOOGLE_TAO_TPM=$tprin
+
+		# TODO(tmroeder): do this in the Go version once we support AIK
+		# creation.
+		echo "export GOOGLE_HOST_TAO='${TAO_TEST}/tpm'" >> ${tao_env}
+		echo "export GOOGLE_TAO_PCRS='PCRs(\"17,18\", \"${pcr17},${pcr18}\")'" >> ${tao_env}
+		echo "export GOOGLE_TAO_TPM='$tprin'" >> ${tao_env}
 	fi
 
 	echo "Creating LinuxHost keys and settings."
 	rm -rf ${TAOHOST_path}
-	linux_host --create --show=false
+	docker_flag=""
+	if [ "${TAO_USE_DOCKER}" == "yes" ]; then
+		docker_flag="--use_docker"
+	fi
+	linux_host --create --show=false ${docker_flag}
 	linux_host --show >> ${tao_env}
 
 	echo "# END SETUP VARIABLES" >> ${tao_env}
 
-    echo "Refreshing"
+	# In Docker mode, set up Docker containers for each hosted program.
+	if [ "${TAO_USE_DOCKER}" == "yes" ]; then
+		for prog in ${TAO_HOSTED_PROGRAMS}; do
+			builddocker $prog
+		done
+	fi
+
+	echo "Refreshing"
 	refresh
+
 }
 
 function refresh()
 {
 	source ${tao_env}
 
 	# Set up default execution policy.
 	tao_admin -clear
 	if [ "${TAO_guard}" == "Datalog" ]; then
 		# Rule for TPM and PCRs combinations that make for a good OS
 		tao_admin -add "(forall S: forall TPM: forall PCRs: TrustedPlatform(TPM) and TrustedKernelPCRs(PCRs) and Subprin(S, TPM, PCRs) implies TrustedOS(S))"
-		# Rule for OS and program hash that make for a good hosted program
+		# Rule for OS and program hash that make for a good hosted
+		# program
 		tao_admin -add "(forall P: forall OS: forall Hash: TrustedOS(OS) and TrustedProgramHash(Hash) and Subprin(P, OS, Hash) implies MemberProgram(P))"
 		# Rule for programs that can execute
 		tao_admin -add "(forall P: MemberProgram(P) implies Authorized(P, \"Execute\"))"
 		# Rule for programs with Args subprincipals
 		tao_admin -add "(forall Y: forall P: forall S: MemberProgram(P) and TrustedArgs(S) and Subprin(Y, P, S) implies Authorized(Y, \"Execute\"))"
+		# Rule for Docker containers: trusted containers can be swapped
+		# in for trusted programs they contain.
+		tao_admin -add "(forall C: forall P: TrustedProgramHash(P) and TrustedContainer(C) and Contains(C, P) implies TrustedProgramHash(C))"
 		# Add the TPM keys, PCRs, and/or LinuxHost keys
 		if [ "$TAO_USE_TPM" == "yes" ]; then
 			tao_admin -add 'TrustedPlatform('${GOOGLE_TAO_TPM}')'
 			# Escape the spaces and quotes in the string so it can be passed as
 			# a single argument to tao_admin
 			trustedpcrs=`echo 'TrustedKernelPCRs(ext.'${GOOGLE_TAO_PCRS}')' | sed 's/ /\\ /g' | sed 's/"/\\"/g'`
 			tao_admin -add "$trustedpcrs"
 		else
 			tao_admin -add 'TrustedOS('${GOOGLE_TAO_LINUX}')'
 		fi
 		# Add the program hashes, assuming LinuxHost and LinuxProcessFactory.
 		for prog in ${TAO_HOSTED_PROGRAMS}; do
 			if [ -f "$prog" ]; then
 				proghash=`tao_admin -quiet -getprogramhash "$prog"`
 				tao_admin -add 'TrustedProgramHash(ext'${proghash}')'
 				tao_admin -add 'TrustedArgs(ext.Args("'$prog'"))'
 				tao_admin -add 'TrustedArgs(ext.Args("'$prog'", "-ca=localhost:8124"))'
+
+				if [ "${TAO_USE_DOCKER}" == "yes" ]; then
+					base_prog=`basename $prog`
+					imghash=`tao_admin -quiet -getcontainerhash "${base_prog}.img.tgz"`
+					tao_admin -add 'TrustedContainer(ext'${imghash}')'
+					tao_admin -add 'Contains(ext'${imghash}', ext'${proghash}')'
+					tao_admin -add 'TrustedArgs(ext.Args("/'${base_prog}'"))'
+				fi
 			fi
 		done
 	else
 		for prog in ${TAO_HOSTED_PROGRAMS}; do
 			if [ -f "$prog" ]; then
 				tao_admin -canexecute "$prog"
 			fi
 		done
 	fi
+
+	# Always have a rules file, even if it's empty.
+	if [ ! -f "${TAO_TEST}/rules" ]; then
+		touch ${TAO_TEST}/rules
+	fi
 	tao_admin -show
 
 	# TODO(kwalsh) set up fserver user ACLs here.
 	#tao_admin -newusers tmroeder,jlm
 	#tao_admin -signacl ${TAO_ROOTDIR}/run/acls.ascii -acl_sig_path user_acls_sig
 	#mkdir -p file_client_files
 	#mkdir -p file_server_files
 	#mkdir -p file_server_meta
 
 	echo "Tao configuration is ready"
 }
 
 function startsvcs()
 {
 	if pgrep -x `shortname linux_host` >/dev/null; then
 		echo "LinuxHost service already running";
 	else
 		rm -f ${TAO_TEST}/linux_tao_host/admin_socket
-		linux_host --service &
+		docker_flag=""
+		if [ "${TAO_USE_DOCKER}" == "yes" ]; then
+			docker_flag="--use_docker"
+		fi
+		linux_host ${docker_flag} --service &
 	fi
 }
 
 function monitor()
 {
 	echo "Monitoring Tao files..."
 	(
 		cd ${TAO_TEST}
 		while true; do
 			inotifywait -e modify -e delete -e attrib $watchfiles >/dev/null 2>&1
 			echo "Files have changed, waiting for quiet..."
 			sleep 1
 			while inotifywait -t 3 -e modify -e delete -e attrib $watchfiles >/dev/null 2>&1; do
 				echo "Still waiting for quiet..."
 				sleep 1
 			done
 			echo "Restarting Tao services..."
 			refresh
 			stoptests
 			startsvcs
@@ -486,46 +534,79 @@ function testpgm()
 			tail -f $GLOG_log_dir/https_echo_server.INFO &
 			tail_pid=$!
 			sleep 1
 			read -p "Press enter to kill https echo server..."
 			echo "Killing cloudproxy https echo server..."
 			kill $server_pid 2>/dev/null
 			sleep 2
 			kill $tail_pid 2>/dev/null
 			;;
 		help|*)
 			echo "Available test programs:"
 			echo "  demo        # a simple demo (run with host.sh)"
 			echo "  server      # cloud client/server test (not ported yet)"
 			echo "  fserver     # file client/server test (not ported yet)"
 			echo "  http        # http echo test (not ported yet)"
 			echo "  https       # https echo test (not ported yet)"
 			;;
 	esac
 }
 
+function builddocker()
+{
+	prog="$1"
+	shift
+	base_prog=`basename $prog`
+	# Build an image for the program.
+	# TODO(tmroeder): this is very specific to our current config.
+	tmpd=`mktemp -d`
+	mkdir -p ${tmpd}/bin
+	cp $prog ${tmpd}/bin/$base_prog
+	mkdir ${tmpd}/policy_keys
+	cp ${TAO_TEST}/policy_keys/cert ${tmpd}/policy_keys/cert
+	cp ${TAO_TEST}/tao.* ${tmpd}
+	cat >${tmpd}/Dockerfile <<EOF
+FROM scratch
+COPY . ${TAO_TEST}
+ENV GOOGLE_HOST_TAO_TYPE unix
+ENV GOOGLE_HOST_TAO /tao
+WORKDIR ${TAO_TEST}
+EOF
+	tar -C $tmpd -czf ${TAO_TEST}/${base_prog}.img.tgz `ls $tmpd`
+	rm -fr $tmpd
+}
+
 function hostpgm()
 {
 	prog="$1"
 	shift
+
+	docker_config=""
+	if [ "$TAO_USE_DOCKER" == "yes" ]; then
+		base_prog=`basename $prog`
+		# In Docker mode, pass the image created at setup time for this
+		# program.
+		docker_config="-docker ${TAO_TEST}/${base_prog}.img.tgz"
+	fi
+
 	echo "Starting hosted program $prog ..."
-	prog_id=`linux_host -run -- "$prog" "$@"`
+	prog_id=`linux_host ${docker_config} -run -- "$prog" "$@"`
 	echo "TaoExtension: $prog_id"
 }
 
 case "$(basename $0)" in
 	setup.sh)
 		stoptests
 		cleanup
 		setup
 		;;
 	start.sh)
 		startsvcs
 		;;
 	restart.sh)
 		stoptests
 		startsvcs
 		;;
 	monitor.sh)
 		monitor
 		;;
 	test.sh)
diff --git a/tao/hosted_program_factory.go b/tao/hosted_program_factory.go
new file mode 100644
index 0000000..2cac63f
--- /dev/null
+++ b/tao/hosted_program_factory.go
@@ -0,0 +1,39 @@
+// Copyright (c) 2014, Google Inc.  All rights reserved.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package tao
+
+import (
+	"io"
+
+	"github.com/jlmucb/cloudproxy/tao/auth"
+)
+
+// A HostedProgram is an abstraction of a process, and it is closely related to
+// os/exec.Cmd and github.com/docker/docker/daemon.Container.
+type HostedProgram interface {
+	Start() error
+	Kill() error
+	Stop() error
+	ID() int
+}
+
+// A HostedProgramFactory manages the creation of hosted programs. For example,
+// on Linux, it might create processes using fork, or it might create processes
+// running on docker containers. It might also start a virtual machine
+// containing a new instance of an operating system.
+type HostedProgramFactory interface {
+	MakeSubprin(uint, string) (auth.SubPrin, string, error)
+	Launch(string, []string) (io.ReadWriteCloser, HostedProgram, error)
+}
diff --git a/tao/linux_docker_container_factory.go b/tao/linux_docker_container_factory.go
new file mode 100644
index 0000000..ed2f9f8
--- /dev/null
+++ b/tao/linux_docker_container_factory.go
@@ -0,0 +1,195 @@
+// Copyright (c) 2014, Google Inc.  All rights reserved.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package tao
+
+import (
+	"crypto/rand"
+	"crypto/sha256"
+	"encoding/hex"
+	"fmt"
+	"io"
+	"io/ioutil"
+	"os"
+	"os/exec"
+	"path"
+
+	"github.com/jlmucb/cloudproxy/tao/auth"
+	"github.com/jlmucb/cloudproxy/util"
+)
+
+// A DockerContainer is a simple wrapper for Docker containers. It uses
+// os/exec.Cmd to send commands to the Docker daemon rather than using the
+// docker client API directly. This is so that this code doesn't depend on the
+// docker code for now.
+type DockerContainer struct {
+	ContainerName string
+	ImageName     string
+	SocketPath    string
+	RulesPath     string
+	Args          []string
+}
+
+// Kill sends a SIGKILL signal to a docker container.
+func (dc *DockerContainer) Kill() error {
+	c := exec.Command("docker", "kill", dc.ContainerName)
+	return c.Run()
+}
+
+// Start starts a docker container using the docker run subcommand.
+func (dc *DockerContainer) Start() error {
+	cmdArgs := []string{"run", "--rm=true",
+		"-v", dc.RulesPath + ":" + dc.RulesPath,
+		"-v", dc.SocketPath + ":/tao",
+		dc.ImageName}
+	cmdArgs = append(cmdArgs, dc.Args...)
+	c := exec.Command("docker", cmdArgs...)
+	c.Stdout = os.Stdout
+	c.Stderr = os.Stderr
+	return c.Start()
+}
+
+// Stop sends a SIGSTOP signal to a docker container.
+func (dc *DockerContainer) Stop() error {
+	c := exec.Command("docker", "kill", "-s", "STOP", dc.ContainerName)
+	return c.Run()
+}
+
+// ID returns a numeric ID for this docker container. For now, this ID is 0.
+func (dc *DockerContainer) ID() int {
+	return 0
+}
+
+// Build uses the provided path to a tar file to build a Docker image.
+func (dc *DockerContainer) Build(tarPath string) error {
+	tarFile, err := os.Open(tarPath)
+	if err != nil {
+		return err
+	}
+	defer tarFile.Close()
+
+	buildCmd := exec.Command("docker", "build", "-t", dc.ImageName, "-q", "-")
+	buildCmd.Stdin = tarFile
+	if err := buildCmd.Run(); err != nil {
+		return err
+	}
+
+	return nil
+}
+
+// A LinuxDockerContainerFactory manages hosted programs started as docker
+// containers over a given docker image.
+type LinuxDockerContainerFactory struct {
+	SocketPath string
+	RulesPath  string
+}
+
+// NewLinuxDockerContainerFactory returns a new HostedProgramFactory that can
+// create docker containers to wrap programs.
+func NewLinuxDockerContainerFactory(sockPath, rulesPath string) HostedProgramFactory {
+	return &LinuxDockerContainerFactory{
+		SocketPath: sockPath,
+		RulesPath:  rulesPath,
+	}
+}
+
+// MakeSubprin computes the hash of a docker container to get a subprincipal for
+func (ldcf *LinuxDockerContainerFactory) MakeSubprin(id uint, image string) (auth.SubPrin, string, error) {
+	var empty auth.SubPrin
+	// To avoid a time-of-check-to-time-of-use error, we copy the file
+	// bytes to a temp file as we read them. This temp-file path is
+	// returned so it can be used to start the docker container.
+	td, err := ioutil.TempDir("/tmp", "cloudproxy_linux_docker_container")
+	if err != nil {
+		return empty, "", err
+	}
+
+	temppath := path.Join(td, "image")
+	tf, err := os.OpenFile(temppath, os.O_CREATE|os.O_RDWR, 0700)
+	defer tf.Close()
+	if err != nil {
+		return empty, "", err
+	}
+
+	inf, err := os.Open(image)
+	defer inf.Close()
+	if err != nil {
+		return empty, "", err
+	}
+
+	// Read from the input file and write to the temp file.
+	tr := io.TeeReader(inf, tf)
+	b, err := ioutil.ReadAll(tr)
+	if err != nil {
+		return empty, "", err
+	}
+
+	h := sha256.Sum256(b)
+	subprin := FormatDockerSubprin(id, h[:])
+	return subprin, temppath, nil
+}
+
+// FormatDockerSubprin produces a string that represents a subprincipal with the
+// given ID and hash.
+func FormatDockerSubprin(id uint, hash []byte) auth.SubPrin {
+	var args []auth.Term
+	if id != 0 {
+		args = append(args, auth.Int(id))
+	}
+	args = append(args, auth.Bytes(hash))
+	return auth.SubPrin{auth.PrinExt{Name: "Container", Arg: args}}
+}
+
+func getRandomFileName(n int) string {
+	// Get a random name for the socket.
+	nameBytes := make([]byte, n)
+	if _, err := rand.Read(nameBytes); err != nil {
+		return ""
+	}
+	return hex.EncodeToString(nameBytes)
+}
+
+var nameLen = 10
+
+// Launch builds a docker container from a tar file and launches it with the
+// given arguments.
+func (ldcf *LinuxDockerContainerFactory) Launch(tarPath string, args []string) (io.ReadWriteCloser, HostedProgram, error) {
+	if len(args) == 0 {
+		return nil, nil, fmt.Errorf("invalid args to Launch docker container")
+	}
+
+	sockName := getRandomFileName(nameLen)
+	sockPath := path.Join(ldcf.SocketPath, sockName)
+
+	// Create a new docker image from the filesystem tarball, and use it to
+	// build a container and launch it.
+	dc := &DockerContainer{
+		ImageName:  getRandomFileName(nameLen),
+		SocketPath: sockPath,
+		RulesPath:  ldcf.RulesPath,
+		Args:       args,
+	}
+	rwc := util.NewUnixSingleReadWriteCloser(sockPath)
+	if err := dc.Build(tarPath); err != nil {
+		rwc.Close()
+		return nil, nil, err
+	}
+
+	if err := dc.Start(); err != nil {
+		rwc.Close()
+		return nil, nil, err
+	}
+
+	return rwc, dc, nil
+}
diff --git a/tao/linux_host.go b/tao/linux_host.go
index 42919cc..2f74fbb 100644
--- a/tao/linux_host.go
+++ b/tao/linux_host.go
@@ -1,115 +1,117 @@
 // Copyright (c) 2014, Google Inc.  All rights reserved.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
 // You may obtain a copy of the License at
 //
 //     http://www.apache.org/licenses/LICENSE-2.0
 //
 // Unless required by applicable law or agreed to in writing, software
 // distributed under the License is distributed on an "AS IS" BASIS,
 // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
 package tao
 
 import (
 	"io"
-	"os/exec"
 	"sync"
-	"syscall"
 
 	"code.google.com/p/goprotobuf/proto"
 
 	"github.com/golang/glog"
 	"github.com/jlmucb/cloudproxy/tao/auth"
 )
 
 // A LinuxHost is a Tao host environment in which hosted programs are Linux
 // processes. A Unix domain socket accepts administrative commands for
 // controlling the host, e.g., for starting hosted processes, stopping hosted
 // processes, or shutting down the host. A LinuxTao can be run in stacked mode
 // (on top of a host Tao) or in root mode (without an underlying host Tao).
 type LinuxHost struct {
 	path           string
 	guard          Guard
 	taoHost        Host
-	childFactory   LinuxProcessFactory
+	childFactory   HostedProgramFactory
 	hostedPrograms []*LinuxHostChild
 	hpm            sync.RWMutex
 	nextChildID    uint
 	idm            sync.Mutex
 }
 
 // NewStackedLinuxHost creates a new LinuxHost as a hosted program of an existing
 // host Tao.
-func NewStackedLinuxHost(path string, guard Guard, hostTao Tao) (*LinuxHost, error) {
+func NewStackedLinuxHost(path string, guard Guard, hostTao Tao, childFactory HostedProgramFactory) (*LinuxHost, error) {
 	lh := &LinuxHost{
-		path:  path,
-		guard: guard,
+		path:         path,
+		guard:        guard,
+		childFactory: childFactory,
 	}
 
 	// TODO(tmroeder): the TPM Tao currently doesn't support name extensions.
 	if _, ok := hostTao.(*TPMTao); !ok {
 		subprin := guard.Subprincipal()
 		if err := hostTao.ExtendTaoName(subprin); err != nil {
 			return nil, err
 		}
 	}
 
 	k, err := NewOnDiskTaoSealedKeys(Signing|Crypting|Deriving, hostTao, path, SealPolicyDefault)
 	if err != nil {
 		return nil, err
 	}
 
 	lh.taoHost, err = NewTaoStackedHostFromKeys(k, hostTao)
 	if err != nil {
 		return nil, err
 	}
 
 	return lh, nil
 }
 
 // NewRootLinuxHost creates a new LinuxHost as a standalone Host that can
 // provide the Tao to hosted Linux processes.
-func NewRootLinuxHost(path string, guard Guard, password []byte) (*LinuxHost, error) {
-	lh := &LinuxHost{guard: guard}
+func NewRootLinuxHost(path string, guard Guard, password []byte, childFactory HostedProgramFactory) (*LinuxHost, error) {
+	lh := &LinuxHost{
+		guard:        guard,
+		childFactory: childFactory,
+	}
 	k, err := NewOnDiskPBEKeys(Signing|Crypting|Deriving, password, path, nil)
 	if err != nil {
 		return nil, err
 	}
 
 	lh.taoHost, err = NewTaoRootHostFromKeys(k)
 	if err != nil {
 		return nil, err
 	}
 
 	return lh, nil
 }
 
 // LinuxHostChild holds state associated with a running child program.
 type LinuxHostChild struct {
 	channel      io.ReadWriteCloser
 	ChildSubprin auth.SubPrin
-	Cmd          *exec.Cmd
+	Cmd          HostedProgram
 }
 
 // GetTaoName returns the Tao name for the child.
 func (lh *LinuxHost) GetTaoName(child *LinuxHostChild) auth.Prin {
 	return lh.taoHost.TaoHostName().MakeSubprincipal(child.ChildSubprin)
 }
 
 // ExtendTaoName irreversibly extends the Tao principal name of the child.
 func (lh *LinuxHost) ExtendTaoName(child *LinuxHostChild, ext auth.SubPrin) error {
 	child.ChildSubprin = append(child.ChildSubprin, ext...)
 	return nil
 }
 
 // GetRandomBytes returns a slice of n random bytes for the child.
 func (lh *LinuxHost) GetRandomBytes(child *LinuxHostChild, n int) ([]byte, error) {
 	return lh.taoHost.GetRandomBytes(child.ChildSubprin, n)
 }
 
 // GetSharedSecret returns a slice of n secret bytes for the child.
 func (lh *LinuxHost) GetSharedSecret(child *LinuxHostChild, n int, policy string) ([]byte, error) {
@@ -203,134 +205,132 @@ func (lh *LinuxHost) Unseal(child *LinuxHostChild, sealed []byte) ([]byte, strin
 
 	return lhsb.Data, policy, nil
 }
 
 // Attest signs a statement on behalf of the child.
 func (lh *LinuxHost) Attest(child *LinuxHostChild, issuer *auth.Prin, time, expiration *int64, stmt auth.Form) (*Attestation, error) {
 	return lh.taoHost.Attest(child.ChildSubprin, issuer, time, expiration, stmt)
 }
 
 // StartHostedProgram starts a new hosted program.
 func (lh *LinuxHost) StartHostedProgram(path string, args []string) (auth.SubPrin, int, error) {
 	lh.idm.Lock()
 	id := lh.nextChildID
 	if lh.nextChildID != 0 {
 		lh.nextChildID++
 	} else {
 		glog.Warning("Running without unique child IDs")
 	}
 	lh.idm.Unlock()
 
-	subprin, temppath, err := lh.childFactory.MakeHostedProgramSubprin(id, path)
+	subprin, temppath, err := lh.childFactory.MakeSubprin(id, path)
 	if err != nil {
 		return auth.SubPrin{}, 0, err
 	}
 
 	// We allow multiple hosted programs with the same subprincipal name,
 	// so we don't check here to make sure that there isn't another program
 	// with the same subprincipal.
 
 	// TODO(tmroeder): do we want to support concurrent updates to policy?
 	// Then we need a lock here, too.
 	hostName := lh.taoHost.TaoHostName()
 	childName := hostName.MakeSubprincipal(subprin)
 	if !lh.guard.IsAuthorized(childName, "Execute", []string{}) {
 		return auth.SubPrin{}, 0, newError("Hosted program %s denied authorization to execute on host %s", subprin, hostName)
 	}
 
-	channel, cmd, err := lh.childFactory.ForkHostedProgram(temppath, args)
+	channel, cmd, err := lh.childFactory.Launch(temppath, args)
 	if err != nil {
 		return auth.SubPrin{}, 0, err
 	}
 	child := &LinuxHostChild{channel, subprin, cmd}
 	go NewLinuxHostTaoServer(lh, child).Serve(channel)
-	pid := child.Cmd.Process.Pid
+	pid := child.Cmd.ID()
 
 	lh.hpm.Lock()
 	lh.hostedPrograms = append(lh.hostedPrograms, child)
 	lh.hpm.Unlock()
 
 	return subprin, pid, nil
 }
 
 // StopHostedProgram stops a running hosted program.
 func (lh *LinuxHost) StopHostedProgram(subprin auth.SubPrin) error {
 	lh.hpm.Lock()
 	defer lh.hpm.Unlock()
 
-	// For Stop, we send SIGTERM
-	sigterm := 15
 	var i int
 	for i < len(lh.hostedPrograms) {
 		lph := lh.hostedPrograms[i]
 		n := len(lh.hostedPrograms)
 		if lph.ChildSubprin.Identical(subprin) {
 			// Close the channel before sending SIGTERM
 			lph.channel.Close()
 
-			if err := syscall.Kill(lph.Cmd.Process.Pid, syscall.Signal(sigterm)); err != nil {
-				glog.Errorf("Couldn't send SIGTERM to process %d, subprincipal %s: %s\n", lph.Cmd.Process.Pid, subprin, err)
+			if err := lph.Cmd.Stop(); err != nil {
+				glog.Errorf("Couldn't stop hosted program %d, subprincipal %s: %s\n", lph.Cmd.ID(), subprin, err)
 			}
 
 			// The order of this array doesn't matter, and we want
 			// to make sure we remove all references to pointers to
 			// LinuxHostServer instances so that they get garbage
 			// collected. So, we implement delete from the slice by
 			// moving elements around.
 			lh.hostedPrograms[i] = lh.hostedPrograms[n-1]
 			lh.hostedPrograms[n-1] = nil
 			lh.hostedPrograms = lh.hostedPrograms[:n-1]
 			i--
 		}
 
 		i++
 	}
 	return nil
 }
 
 // ListHostedPrograms returns a list of running hosted programs.
 func (lh *LinuxHost) ListHostedPrograms() ([]auth.SubPrin, []int, error) {
 	lh.hpm.RLock()
 	subprins := make([]auth.SubPrin, len(lh.hostedPrograms))
 	pids := make([]int, len(lh.hostedPrograms))
 	for i, v := range lh.hostedPrograms {
 		subprins[i] = v.ChildSubprin
-		pids[i] = v.Cmd.Process.Pid
+		pids[i] = v.Cmd.ID()
 	}
 	lh.hpm.RUnlock()
 	return subprins, pids, nil
 }
 
 // KillHostedProgram kills a running hosted program.
 func (lh *LinuxHost) KillHostedProgram(subprin auth.SubPrin) error {
 	lh.hpm.Lock()
 	defer lh.hpm.Unlock()
 	var i int
 	for i < len(lh.hostedPrograms) {
 		lph := lh.hostedPrograms[i]
 		n := len(lh.hostedPrograms)
 		if lph.ChildSubprin.Identical(subprin) {
-			// Close the channel before sending SIGTERM
+			// Close the channel before killing the hosted program.
 			lph.channel.Close()
 
-			if err := lph.Cmd.Process.Kill(); err != nil {
-				glog.Errorf("Couldn't kill process %d, subprincipal %s: %s\n", lph.Cmd.Process.Pid, subprin, err)
+			if err := lph.Cmd.Kill(); err != nil {
+				glog.Errorf("Couldn't kill hosted program %d, subprincipal %s: %s\n", lph.Cmd.ID(), subprin, err)
 			}
 
 			// The order of this array doesn't matter, and we want
 			// to make sure we remove all references to pointers to
 			// LinuxHostServer instances so that they get garbage
 			// collected. So, we implement delete from the slice by
 			// moving elements around.
 			lh.hostedPrograms[i] = lh.hostedPrograms[n-1]
 			lh.hostedPrograms[n-1] = nil
 			lh.hostedPrograms = lh.hostedPrograms[:n-1]
 			i--
 		}
 
 		i++
 	}
 	return nil
 }
 
 // TaoHostName returns the name of the Host used by the LinuxHost.
 func (lh *LinuxHost) TaoHostName() auth.Prin {
diff --git a/tao/linux_host_test.go b/tao/linux_host_test.go
index bd670bb..251cdab 100644
--- a/tao/linux_host_test.go
+++ b/tao/linux_host_test.go
@@ -18,58 +18,58 @@ import (
 	"bytes"
 	"io/ioutil"
 	"os"
 	"testing"
 
 	"github.com/jlmucb/cloudproxy/tao/auth"
 )
 
 func testNewStackedLinuxHost(t *testing.T) (*LinuxHost, string) {
 	tmpdir, err := ioutil.TempDir("/tmp", "test_new_stacked_linux_host")
 	if err != nil {
 		t.Fatal("Couldn't get a temp directory for the new stacked linux host")
 	}
 
 	ft, err := NewFakeTao(auth.NewKeyPrin([]byte("test")), "", nil)
 	if err != nil {
 		t.Fatal("Couldn't create a new fake Tao:", err)
 	}
 
 	tg := LiberalGuard
-	lh, err := NewStackedLinuxHost(tmpdir, &tg, ft)
+	lh, err := NewStackedLinuxHost(tmpdir, &tg, ft, nil)
 	if err != nil {
 		os.RemoveAll(tmpdir)
 		t.Fatal("Couldn't create a new stacked Linux host")
 	}
 
 	return lh, tmpdir
 }
 
 func testNewRootLinuxHost(t *testing.T) (*LinuxHost, string) {
 	tmpdir, err := ioutil.TempDir("/tmp", "test_new_root_linux_host")
 	if err != nil {
 		t.Fatal("Couldn't get a temp directory for the new root linux host")
 	}
 
 	tg := LiberalGuard
 	password := []byte("bad password")
-	lh, err := NewRootLinuxHost(tmpdir, &tg, password)
+	lh, err := NewRootLinuxHost(tmpdir, &tg, password, nil)
 	if err != nil {
 		os.RemoveAll(tmpdir)
 		t.Fatal("Couldn't create a new stacked Linux host")
 	}
 
 	return lh, tmpdir
 }
 
 func TestNewStackedLinuxHost(t *testing.T) {
 	_, td := testNewStackedLinuxHost(t)
 	defer os.RemoveAll(td)
 }
 
 func TestNewRootLinuxHost(t *testing.T) {
 	_, td := testNewRootLinuxHost(t)
 	defer os.RemoveAll(td)
 }
 
 // Test the methods directly instead of testing them across a channel.
 
diff --git a/tao/linux_process_factory.go b/tao/linux_process_factory.go
index 00bbe19..834e8b2 100644
--- a/tao/linux_process_factory.go
+++ b/tao/linux_process_factory.go
@@ -1,136 +1,210 @@
 // Copyright (c) 2014, Google Inc.  All rights reserved.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
 // You may obtain a copy of the License at
 //
 //     http://www.apache.org/licenses/LICENSE-2.0
 //
 // Unless required by applicable law or agreed to in writing, software
 // distributed under the License is distributed on an "AS IS" BASIS,
 // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
 package tao
 
 import (
+	"crypto/rand"
 	"crypto/sha256"
+	"encoding/base64"
+	"fmt"
 	"io"
 	"io/ioutil"
 	"os"
 	"os/exec"
 	"path"
 	"strings"
+	"syscall"
 
 	"github.com/jlmucb/cloudproxy/tao/auth"
 	"github.com/jlmucb/cloudproxy/util"
 )
 
-// In the C++ Tao, these functions are methods on a stateless class. So, in Go,
-// the struct is empty. But we don't make them functions on their own, since we
-// want to support multiple hosted-program factory implementations against an
-// interface in the future.
+// A Process wraps os/exec.Cmd and adds a Kill method to match the HostedProgram
+// interface.
+type Process struct {
+	*exec.Cmd
+}
+
+// Kill kills an os/exec.Cmd process.
+func (p *Process) Kill() error {
+	return p.Process.Kill()
+}
+
+const sigterm = 15
+
+// Stop tries to send SIGTERM to a process.
+func (p *Process) Stop() error {
+	return syscall.Kill(p.Process.Pid, syscall.Signal(sigterm))
+}
+
+// ID returns the PID of the underlying os/exec.Cmd instance.
+func (p *Process) ID() int {
+	return p.Process.Pid
+}
 
 // A LinuxProcessFactory supports methods for creating Linux processes as
-// hosted programs.
-type LinuxProcessFactory struct{}
+// hosted programs. LinuxProcessFactory implements HostedProgramFactory.
+type LinuxProcessFactory struct {
+	channelType string
+	socketPath  string
+}
+
+// NewLinuxProcessFactory creates a LinuxProcessFactory as a
+// HostedProgramFactory.
+func NewLinuxProcessFactory(channelType, socketPath string) HostedProgramFactory {
+	return &LinuxProcessFactory{
+		channelType: channelType,
+		socketPath:  socketPath,
+	}
+}
 
-// FormatHostedProgramSubprin produces a string that represents a subprincipal
-// with the given ID and hash.
-func FormatHostedProgramSubprin(id uint, hash []byte) auth.SubPrin {
+// FormatSubprin produces a string that represents a subprincipal with the given
+// ID and hash.
+func FormatSubprin(id uint, hash []byte) auth.SubPrin {
 	var args []auth.Term
 	if id != 0 {
 		args = append(args, auth.Int(id))
 	}
 	args = append(args, auth.Bytes(hash))
 	return auth.SubPrin{auth.PrinExt{Name: "Program", Arg: args}}
 }
 
-// MakeHostedProgramSubprin computes the hash of a program to get its
-// hosted-program subprincipal. In the process, it copies the program to a
-// temporary file controlled by this code and returns the path to that new
-// binary.
-func (LinuxProcessFactory) MakeHostedProgramSubprin(id uint, prog string) (subprin auth.SubPrin, temppath string, err error) {
+// MakeSubprin computes the hash of a program to get its hosted-program
+// subprincipal. In the process, it copies the program to a temporary file
+// controlled by this code and returns the path to that new binary.
+func (lpf *LinuxProcessFactory) MakeSubprin(id uint, prog string) (subprin auth.SubPrin, temppath string, err error) {
 	// To avoid a time-of-check-to-time-of-use error, we copy the file
 	// bytes to a temp file as we read them. This temp-file path is
 	// returned so it can be used to start the program.
 	td, err := ioutil.TempDir("/tmp", "cloudproxy_linux_host")
 	if err != nil {
 		return
 	}
 
 	temppath = path.Join(td, "hosted_program")
 	tf, err := os.OpenFile(temppath, os.O_CREATE|os.O_RDWR, 0700)
 	defer tf.Close()
 	if err != nil {
 		return
 	}
 
 	inf, err := os.Open(prog)
 	defer inf.Close()
 	if err != nil {
 		return
 	}
 
 	// Read from the input file and write to the temp file.
 	tr := io.TeeReader(inf, tf)
 	b, err := ioutil.ReadAll(tr)
 	if err != nil {
 		return
 	}
 
 	h := sha256.Sum256(b)
-	subprin = FormatHostedProgramSubprin(id, h[:])
+	subprin = FormatSubprin(id, h[:])
 	return
 }
 
-// ForkHostedProgram uses a path and arguments to fork a new process.
-func (LinuxProcessFactory) ForkHostedProgram(prog string, args []string) (io.ReadWriteCloser, *exec.Cmd, error) {
-	// Get a pipe pair for communication with the child.
-	serverRead, clientWrite, err := os.Pipe()
-	if err != nil {
-		return nil, nil, err
-	}
-	defer clientWrite.Close()
+// Use 24 bytes for the socket name.
+const sockNameLen = 24
+
+// Launch uses a path and arguments to fork a new process.
+func (lpf *LinuxProcessFactory) Launch(prog string, args []string) (io.ReadWriteCloser, HostedProgram, error) {
+	var channel io.ReadWriteCloser
+	var extraFiles []*os.File
+	var evar string
+	switch lpf.channelType {
+	case "pipe":
+		// Get a pipe pair for communication with the child.
+		serverRead, clientWrite, err := os.Pipe()
+		if err != nil {
+			return nil, nil, err
+		}
+		defer clientWrite.Close()
 
-	clientRead, serverWrite, err := os.Pipe()
-	if err != nil {
-		serverRead.Close()
-		return nil, nil, err
+		clientRead, serverWrite, err := os.Pipe()
+		if err != nil {
+			serverRead.Close()
+			return nil, nil, err
+		}
+		defer clientRead.Close()
+
+		channel = util.NewPairReadWriteCloser(serverRead, serverWrite)
+		extraFiles = []*os.File{clientRead, clientWrite} // fd 3, fd 4
+
+		// Note: ExtraFiles below ensures readfd=3, writefd=4 in child
+		evar = HostTaoEnvVar + "=tao::TaoRPC+tao::FDMessageChannel(3, 4)"
+	case "unix":
+		// Get a random name for the socket.
+		nameBytes := make([]byte, sockNameLen)
+		if _, err := rand.Read(nameBytes); err != nil {
+			return nil, nil, err
+		}
+		sockName := base64.URLEncoding.EncodeToString(nameBytes)
+		sockPath := path.Join(lpf.socketPath, sockName)
+		channel = util.NewUnixSingleReadWriteCloser(sockPath)
+		if channel == nil {
+			return nil, nil, fmt.Errorf("Couldn't create a new Unix channel\n")
+		}
+		evar = HostTaoEnvVar + "=" + sockPath
+	default:
+		return nil, nil, fmt.Errorf("invalid channel type '%s'\n", lpf.channelType)
 	}
-	defer clientRead.Close()
 
 	env := os.Environ()
-	// Note: ExtraFiles below ensures readfd=3, writefd=4 in child
-	evar := HostTaoEnvVar + "=tao::TaoRPC+tao::FDMessageChannel(3, 4)"
+	// Make sure that the child knows to use the right kind of channel.
+	etvar := HostTaoTypeEnvVar + "=" + lpf.channelType
 	replaced := false
+	replacedType := false
 	for i, pair := range env {
 		if strings.HasPrefix(pair, HostTaoEnvVar+"=") {
 			env[i] = evar
 			replaced = true
 		}
+
+		if strings.HasPrefix(pair, HostTaoTypeEnvVar+"=") {
+			env[i] = etvar
+			replacedType = true
+		}
 	}
 	if !replaced {
 		env = append(env, evar)
 	}
 
-	channel := util.NewPairReadWriteCloser(serverRead, serverWrite)
-	cmd := &exec.Cmd{
-		Path:       prog,
-		Args:       args,
-		Stdin:      os.Stdin,
-		Stdout:     os.Stdout,
-		Stderr:     os.Stderr,
-		Env:        env,
-		ExtraFiles: []*os.File{clientRead, clientWrite}, // fd 3, fd 4
-		// TODO(tmroeder): change the user of the hosted program here.
+	if !replacedType {
+		env = append(env, etvar)
+	}
+
+	cmd := &Process{
+		&exec.Cmd{
+			Path:       prog,
+			Args:       args,
+			Stdin:      os.Stdin,
+			Stdout:     os.Stdout,
+			Stderr:     os.Stderr,
+			Env:        env,
+			ExtraFiles: extraFiles,
+			// TODO(tmroeder): change the user of the hosted program here.
+		},
 	}
 
 	if err := cmd.Start(); err != nil {
 		channel.Close()
 		return nil, nil, err
 	}
 
 	return channel, cmd, nil
 }
diff --git a/tao/tao.go b/tao/tao.go
index 7dd66fc..3167534 100644
--- a/tao/tao.go
+++ b/tao/tao.go
@@ -1,55 +1,57 @@
 // Copyright (c) 2014, Kevin Walsh.  All rights reserved.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
 // You may obtain a copy of the License at
 //
 //     http://www.apache.org/licenses/LICENSE-2.0
 //
 // Unless required by applicable law or agreed to in writing, software
 // distributed under the License is distributed on an "AS IS" BASIS,
 // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
 package tao
 
 import (
+	"fmt"
 	"io"
 	"io/ioutil"
 	"os"
 	"path"
 	"strconv"
 	"strings"
 	"sync"
 
 	"github.com/golang/glog"
 	"github.com/jlmucb/cloudproxy/tao/auth"
 )
 
 // Constants used by the Tao implementations for policy, signing contexts, and
 // environment variables.
 const (
-	HostTaoEnvVar = "GOOGLE_HOST_TAO"
-	TaoTPMEnvVar  = "GOOGLE_TAO_TPM"
-	TaoPCRsEnvVar = "GOOGLE_TAO_PCRS"
+	HostTaoEnvVar     = "GOOGLE_HOST_TAO"
+	HostTaoTypeEnvVar = "GOOGLE_HOST_TAO_TYPE"
+	TaoPCRsEnvVar     = "GOOGLE_TAO_PCRS"
+	TaoTPMEnvVar      = "GOOGLE_TAO_TPM"
 
 	SharedSecretPolicyDefault      = "self"
 	SharedSecretPolicyConservative = "few"
 	SharedSecretPolicyLiberal      = "any"
 
 	SealPolicyDefault      = "self"
 	SealPolicyConservative = "few"
 	SealPolicyLiberal      = "any"
 
 	AttestationSigningContext = "Tao Attestation Signing Context V1"
 )
 
 // Tao is the fundamental Trustworthy Computing interface provided by a host to
 // its hosted programs. Each level of a system can act as a host by exporting
 // the Tao interface and providing Tao services to higher-level hosted programs.
 //
 // In most cases, a hosted program will use a stub Tao that performs RPC over a
 // channel to its host. The details of such RPC depend on the specific
 // implementation of the host: some hosted programs may use pipes to communicate
 // with their host, others may use sockets, etc.
@@ -81,75 +83,86 @@ type Tao interface {
 
 	// Unseal decrypts data that has been sealed by the Seal() operation, but only
 	// if the policy specified during the Seal() operation is satisfied.
 	Unseal(sealed []byte) (data []byte, policy string, err error)
 }
 
 // Cached interface to the host Tao underlying this hosted program.
 var cachedHost Tao
 var cacheOnce sync.Once
 
 // Parent returns the interface to the underlying host Tao. It depends on a
 // specific environment variable being set. On success it memoizes the result
 // before returning it because there should only ever be a single channel to the
 // host. On failure, it logs a message using glog and returns nil.
 // Note: errors are not returned so that, once it is confirmed that Parent
 // returns a non-nil value, callers can use the function result in an
 // expression, e.g.:
 //   name, err := tao.Parent().GetTaoName()
 func Parent() Tao {
 	cacheOnce.Do(func() {
+		hostTypeVar := os.Getenv(HostTaoTypeEnvVar)
 		hostVar := os.Getenv(HostTaoEnvVar)
-		r := strings.TrimPrefix(hostVar, "tao::TPMTao(\"dir:")
-		if r == hostVar {
-			host, err := DeserializeTaoRPC(os.Getenv(HostTaoEnvVar))
-			if err != nil {
-				glog.Error(err)
-				return
-			}
-			cachedHost = host
-		} else {
+		switch hostTypeVar {
+		case "tpm":
 			// TODO(tmroeder): this version assumes that the AIK blob is under
 			// the TPMTao directory as aikblob. This should be specified more
 			// clearly in the environment variables.
-
-			dir := strings.TrimSuffix(r, "\")")
-			aikblob, err := ioutil.ReadFile(path.Join(dir, "aikblob"))
+			aikblob, err := ioutil.ReadFile(path.Join(hostVar, "aikblob"))
 			if err != nil {
+				fmt.Fprintf(os.Stderr, "Couldn't read the aikblob: %s\n", err)
 				glog.Error(err)
 				return
 			}
 
 			taoPCRs := os.Getenv(TaoPCRsEnvVar)
 			pcrStr := strings.TrimPrefix(taoPCRs, "PCRs(\"")
 
 			// This index operation will never panic, since strings.Split always
 			// returns at least one entry in the resulting slice.
 			pcrIntList := strings.Split(pcrStr, "\", \"")[0]
 			pcrInts := strings.Split(pcrIntList, ",")
 			pcrs := make([]int, len(pcrInts))
 			for i, s := range pcrInts {
 				var err error
 				pcrs[i], err = strconv.Atoi(s)
 				if err != nil {
+					fmt.Fprintf(os.Stderr, "Couldn't split the PCRs: %s\n", err)
 					glog.Error(err)
 					return
 				}
 			}
 
 			// TODO(tmroeder): add the tpm device path to the configuration.
 			host, err := NewTPMTao("/dev/tpm0", aikblob, pcrs)
 			if err != nil {
+				fmt.Fprintf(os.Stderr, "Couldn't create a new TPMTao: %s\n", err)
 				glog.Error(err)
 				return
 			}
 
 			cachedHost = host
+		case "pipe":
+			host, err := DeserializeTaoRPC(os.Getenv(HostTaoEnvVar))
+			if err != nil {
+				glog.Error(err)
+				return
+			}
+			cachedHost = host
+		case "unix":
+			host, err := DeserializeUnixSocketTaoRPC(os.Getenv(HostTaoEnvVar))
+			if err != nil {
+				glog.Error(err)
+				return
+			}
+			cachedHost = host
+		default:
+			glog.Errorf("unknown host tao channel type '%s'\n", hostTypeVar)
 		}
 	})
 	return cachedHost
 }
 
 // Hosted returns true iff a host Tao is available via the Parent function.
 func Hosted() bool {
 	return Parent() != nil
 }
diff --git a/tao/tao_rpc.go b/tao/tao_rpc.go
index 543af10..6cfc01f 100644
--- a/tao/tao_rpc.go
+++ b/tao/tao_rpc.go
@@ -38,40 +38,55 @@ type TaoRPC struct {
 }
 
 // DeserializeTaoRPC produces a TaoRPC from a string.
 func DeserializeTaoRPC(s string) (*TaoRPC, error) {
 	if s == "" {
 		return nil, newError("taorpc: missing host Tao spec" +
 			" (ensure $" + HostTaoEnvVar + " is set)")
 	}
 	r := strings.TrimPrefix(s, "tao::TaoRPC+")
 	if r == s {
 		return nil, newError("taorpc: unrecognized $" + HostTaoEnvVar + " string " + s)
 	}
 	ms, err := util.DeserializeFDMessageStream(r)
 	if err != nil {
 		return nil, newError("taorpc: unrecognized $" + HostTaoEnvVar + " string " + s +
 			" (" + err.Error() + ")")
 	}
 	return &TaoRPC{protorpc.NewClient(ms), "Tao"}, nil
 }
 
+// DeserializeUnixSocketTaoRPC produces a TaoRPC from a path string.
+func DeserializeUnixSocketTaoRPC(p string) (*TaoRPC, error) {
+	if p == "" {
+		return nil, newError("taorpc: missing host Tao spec" +
+			" (ensure $" + HostTaoEnvVar + " is set)")
+	}
+
+	ms, err := util.DeserializeUnixSocketMessageStream(p)
+	if err != nil {
+		return nil, err
+	}
+
+	return &TaoRPC{protorpc.NewClient(ms), "Tao"}, nil
+}
+
 // NewTaoRPC constructs a TaoRPC for the default gob encoding rpc client using
 // an io.ReadWriteCloser.
 func NewTaoRPC(rwc io.ReadWriteCloser, serviceName string) (*TaoRPC, error) {
 	return &TaoRPC{rpc.NewClient(rwc), serviceName}, nil
 }
 
 type expectedResponse int
 
 const (
 	wantNothing expectedResponse = 0
 	wantData    expectedResponse = 1 << iota
 	wantPolicy
 )
 
 // An ErrMalformedResponse is returned as an error for an invalid response.
 var ErrMalformedResponse = errors.New("taorpc: malformed response")
 
 // call issues an rpc request, obtains the response, checks the response for
 // errors, and checks that the response contains exactly the expected values.
 func (t *TaoRPC) call(method string, r *TaoRPCRequest, e expectedResponse) (data []byte, policy string, err error) {
diff --git a/util/fdmessagestream.go b/util/fdmessagestream.go
index 3e4b233..eb934fb 100644
--- a/util/fdmessagestream.go
+++ b/util/fdmessagestream.go
@@ -1,41 +1,53 @@
 // Copyright (c) 2014, Kevin Walsh.  All rights reserved.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
 // You may obtain a copy of the License at
 //
 //     http://www.apache.org/licenses/LICENSE-2.0
 //
 // Unless required by applicable law or agreed to in writing, software
 // distributed under the License is distributed on an "AS IS" BASIS,
 // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
 package util
 
 import (
 	"errors"
 	"fmt"
+	"net"
 	"os"
 )
 
 // DeserializeFDMessageStream takes a string description of the form
 // "tao::FDMessageStream(X, Y)" and returns a MessageStream that uses file
 // descriptor X as the reader and file descriptor Y as the writer.
 func DeserializeFDMessageStream(s string) (*MessageStream, error) {
 	var readfd, writefd uintptr
 	_, err := fmt.Sscanf(s, "tao::FDMessageChannel(%d, %d)", &readfd, &writefd)
 	if err != nil {
 		return nil, errors.New("unrecognized channel spec " + s)
 	}
 	if readfd == writefd {
 		rw := os.NewFile(readfd, "read/write pipe")
 		return NewMessageStream(rw), nil
 	} else {
 		r := os.NewFile(readfd, "read pipe")
 		w := os.NewFile(writefd, "write pipe")
 		rw := NewPairReadWriteCloser(r, w)
 		return NewMessageStream(rw), nil
 	}
 }
+
+// DeserializeUnixSocketMessageStream takes a string filename and returns a
+// MessageStream that is based on the Unix socket for this file.
+func DeserializeUnixSocketMessageStream(f string) (*MessageStream, error) {
+	conn, err := net.Dial("unix", f)
+	if err != nil {
+		return nil, err
+	}
+
+	return NewMessageStream(conn), nil
+}
diff --git a/util/unix_single_rwc.go b/util/unix_single_rwc.go
new file mode 100644
index 0000000..f4003eb
--- /dev/null
+++ b/util/unix_single_rwc.go
@@ -0,0 +1,79 @@
+// Copyright (c) 2014, Google Inc.  All rights reserved.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package util
+
+import (
+	"fmt"
+	"io"
+	"net"
+	"os"
+)
+
+// A UnixSingleReadWriteCloser accepts a single connection and reads and writes
+// to this connection
+type UnixSingleReadWriteCloser struct {
+	l net.Listener
+	c net.Conn
+}
+
+// NewUnixSingleReadWriteCloser listens on a given Unix socket path and returns
+// a UnixSingleReadWriteCloser that will accept a single connection on this
+// socket and communicate only with it.
+func NewUnixSingleReadWriteCloser(path string) io.ReadWriteCloser {
+	l, err := net.Listen("unix", path)
+	if err != nil {
+		fmt.Fprintf(os.Stderr, "Failed to listen on the channel: %s\n", err)
+		return nil
+	}
+
+	return &UnixSingleReadWriteCloser{l, nil}
+}
+
+// Read accepts a connection if there isn't one already and reads from the
+// connection.
+func (usrwc *UnixSingleReadWriteCloser) Read(p []byte) (int, error) {
+	var err error
+	if usrwc.c == nil {
+		usrwc.c, err = usrwc.l.Accept()
+		if err != nil {
+			return 0, err
+		}
+	}
+
+	return usrwc.c.Read(p)
+}
+
+// Write accepts a connection if there isn't one already and writes to the
+// connection.
+func (usrwc *UnixSingleReadWriteCloser) Write(p []byte) (int, error) {
+	var err error
+	if usrwc.c == nil {
+		usrwc.c, err = usrwc.l.Accept()
+		if err != nil {
+			return 0, err
+		}
+	}
+
+	return usrwc.c.Write(p)
+}
+
+// Close closes the connection if there is one and closes the listener.
+func (usrwc *UnixSingleReadWriteCloser) Close() error {
+	if usrwc.c != nil {
+		usrwc.c.Close()
+	}
+
+	return usrwc.l.Close()
+}
