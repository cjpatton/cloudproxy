#* 
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-12-12T16:41:16-0800
#* 
#- Add support for labeled Tao channel types.
#- 
#- This commit adds support for a new shell variable: GOOGLE_HOST_TAO_TYPE. It also
#- adds support for two values for this variable "tpm" and "pipe". These correspond
#- to the two currently support ways for a program to talk to a parent Tao: either
#- it creates a TPMTao and uses, e.g., /dev/tpm0, or it is given a specification of
#- a pair of pipes that should have been added to its file descriptors at fork
#- time, and it uses those pipes for communication.
#- 
#- The next option to be supported will be "unix" for communication over a unix
#- socket, since this will be the easiest way to support Tao channels into docker.
#- 
#- 
#- Add interfaces for hosted programs.
#- 
#- This commit adds an interface for HostedProgram: this generalizes the
#- os/exec.Cmd and the github.com/docker/docker/daemon.Container interfaces to
#- support starting and stopping processes and containers. This also adds an
#- interface for hosted-program factories. This generalizes the LinuxProcessFactory
#- type and will soon be generalized to add support for docker containers.
#- 
#- 
#- Add support for Unix socket Tao channels.
#- 
#- This commit adds support for the "unix" Tao channel type and implements the
#- "-unix" command-line flag in install.sh to add this support.
#- 
#- It updates LinuxProcessFactory to create a Unix socket using a new utility class
#- UnixSingleReadWriteCloser, which manages a single connection on a unix socket.
#- 
#- 
#- Add support for Docker containers.
#- 
#- This commit adds a new factory: the LinuxDockerContainerFactory, and adds
#- support in install.sh for starting hosted programs under Docker containers. The
#- container is based on the empty Docker "scratch" container, so the hash of the
#- tarball that defines the image uniquely defines its contents under Docker. So,
#- the subprincipal for a Docker container is Container([bytes]), where [bytes] is
#- the SHA-256 hash of the tarball.
#- 
#- In install.sh new auth rules for the datalog guard state that if a program hash
#- is trusted, a container hash is trusted, and the container contains the program,
#- then this container can act as a MemberProgram. This hooks containers back into
#- the original rules about member programs and authorization to execute.
#- 
#- Containers get Unix domain sockets hooked in from the host file system and use
#- them for Tao communication with the parent Tao.
#- 
#- 
#- Add initial QEMU/KVM CoreOS support.
#- 
#- This commits starts adding support for QEMU/KVM with CoreOS guests. It also
#- removes some superfluous code that slipped in from the jlmucb branch.
#- 
#- 
#- Add initial LinuxHost/CoreOS support.
#- 
#- This commit adds support for running LinuxHost as a privileged Docker container
#- on a CoreOS virtual machine under QEMU/KVM using the KVMCoreOSFactory. It also
#- adds support for channels that act exactly like regular files in the filesystem.
#- This is the kind of channel that is created on the guest in /dev/virtio-ports
#- using virtio-serial under QEMU/KVM.
#- 
#- 
#- Fix the naming and add build support.
#- 
#- This commit changes the name of the new QEMU/KVM CoreOS factory to better follow
#- Go naming standards, and it adds a simple script to build the Go applications
#- statically.
#- 
#- 
#- Split demo and get Docker versions working.
#- 
#- This commit splits the demo_server and demo_client into two applications and
#- gets them to connect between independent Docker containers under the Tao. This
#- requires a connection between the two containers, as follows:
#- 
#- ./scripts/host.sh ./bin/demo_server
#- ./scripts/host.sh ./bin/demo_client --link <demo_server_name>:server
#- 
#- The <demo_server_name> should be the name of the docker container hosting the
#- server.
#- 
#- 
#- Refactor linux_host into a launch and a host.
#- 
#- 
#- Get the process code to work without scripts.
#- 
#- This version works without scripts:
#- 
#- > linux_host &
#- > export DIR=/tmp/linux_host<something output by linux_host>
#- > tao_launch -sock ${DIR}/linux_tao_host/admin_socket -- <path/to/demo_server> -config ${DIR}/tao.config
#- > tao_launch -sock ${DIR}/linux_tao_host/admin_socket -- <path/to/demo_client> -config ${DIR}/tao.config
#- 
#- 
#- Add a README and fix the Docker scripts for demo.
#- 
#- This explains how to run the process and Docker versions of the demo code.
#- 
#- 
diff --git a/apps/demo/README.md b/apps/demo/README.md
new file mode 100644
index 0000000..dffe037
--- /dev/null
+++ b/apps/demo/README.md
@@ -0,0 +1,62 @@
+Linux Process Demo
+------------------
+
+The Linux-process version of the demo requires `demo_server` and `demo_client`
+to have been built, e.g., by
+
+	go install github.com/jlmucb/cloudproxy/...
+
+The following steps set up a Linux-process-based `linux_host` and run the demo
+server and client on it. These commands assume that the cloudproxy binaries are
+in $GOPATH and that $GOPATH is in $PATH.
+
+	linux_host &
+	export DIR=/tmp/linux_host<something output by linux_host>
+	tao_launch -sock ${DIR}/linux_tao_host/admin_socket -- <path/to/demo_server> -config ${DIR}/tao.config
+	tao_launch -sock ${DIR}/linux_tao_host/admin_socket -- <path/to/demo_client> -config ${DIR}/tao.config
+
+Linux Docker Demo
+-----------------
+The first step in setting up the demo application under Docker is building the
+Docker containers for the demo.
+
+First, build `demo_server` and `demo_client` as standalone binaries as follows.
+
+	CGO_ENABLED=0 go install -a -ldflags '-s' github.com/jlmucb/cloudproxy/...
+
+To build `demo_server.img.tgz` and `demo_client.img.tgz`, execute the following
+commands.
+
+	cd <some empty directory>
+	cp ${DEMO_DIR}/demo_server/Dockerfile .
+	mkdir bin
+	cp ${GOPATH}/bin/demo_server bin/demo_server
+	mkdir policy_keys
+	cp <path/to/policy/cert> policy_keys/cert
+
+	echo >tao.config <<EOF
+	# Tao Domain Configuration file
+
+	[Domain]
+	Name = testing
+	PolicyKeysPath = policy_keys
+	GuardType = AllowAll
+
+	[X509Details]
+	CommonName = testing	
+	EOF
+
+	touch rules
+	tar -czf ${DEMO_DIR}/demo_server/demo_server.img.tgz *	
+
+To run this demo under the tao, perform the following steps. Note that you can
+get the name of the container from the output of `docker ps` after starting the
+demo server.
+
+	linux_host --factory_type docker &
+	export DIR=<location of linux_host tmp dir>
+	export DEMO_DIR=<the demo directory>
+	cd $DIR
+	tao_launch -docker_img ${DEMO_DIR}/demo_server/demo_server.img.tgz -- ${DEMO_DIR}/demo_server/demo_server.img.tgz
+	tao_launch -docker_img ${DEMO_DIR}/demo_client/demo_client.img.tgz -- ${DEMO_DIR}/demo_client/demo_client.img.tgz --link <name of container>:server
+
diff --git a/apps/demo/demo.go b/apps/demo/demo.go
deleted file mode 100644
index a260305..0000000
--- a/apps/demo/demo.go
+++ /dev/null
@@ -1,414 +0,0 @@
-// Copyright (c) 2014, Kevin Walsh.  All rights reserved.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package main
-
-import (
-	"bufio"
-	"crypto/tls"
-	"crypto/x509"
-	"crypto/x509/pkix"
-	"errors"
-	"flag"
-	"fmt"
-	"net"
-	"os"
-	"strings"
-
-	"github.com/jlmucb/cloudproxy/tao"
-	"github.com/jlmucb/cloudproxy/tao/auth"
-	taonet "github.com/jlmucb/cloudproxy/tao/net"
-)
-
-var serverHost = flag.String("host", "localhost", "address for client/server")
-var serverPort = flag.String("port", "8123", "port for client/server")
-var serverAddr string // see main()
-var localMode = flag.Bool("local", true, "Run host demo")
-var clientMode = flag.Bool("client", true, "Run demo client")
-var serverMode = flag.Bool("server", true, "Run demo server")
-var pingCount = flag.Int("n", 5, "Number of client/server pings")
-var demoAuth = flag.String("auth", "tao", "\"tcp\", \"tls\", or \"tao\"")
-var configPath = flag.String("config", "tao.config", "The Tao domain config")
-var ca = flag.String("ca", "", "address for Tao CA, if any")
-
-var subprinRule = "(forall P: forall Hash: TrustedProgramHash(Hash) and Subprin(P, %v, Hash) implies MemberProgram(P))"
-var argsRule = "(forall Y: forall P: forall S: MemberProgram(P) and TrustedArgs(S) and Subprin(Y, P, S) implies Authorized(Y, \"Execute\"))"
-var demoRule = "TrustedArgs(ext.Args(%s))"
-
-// client/server driver
-
-func doRequest(guard tao.Guard, domain *tao.Domain, keys *tao.Keys) bool {
-	fmt.Printf("client: connecting to %s using %s authentication.\n", serverAddr, *demoAuth)
-	var conn net.Conn
-	var err error
-	network := "tcp"
-
-	switch *demoAuth {
-	case "tcp":
-		conn, err = net.Dial(network, serverAddr)
-	case "tls":
-		conn, err = taonet.DialTLSWithKeys(network, serverAddr, keys)
-	case "tao":
-		conn, err = taonet.DialWithKeys(network, serverAddr, guard, domain.Keys.VerifyingKey, keys)
-	}
-	if err != nil {
-		fmt.Printf("client: error connecting to %s: %s\n", serverAddr, err.Error())
-		return false
-	}
-	defer conn.Close()
-
-	_, err = fmt.Fprintf(conn, "Hello\n")
-	if err != nil {
-		fmt.Printf("client: can't write: %s\n", err.Error())
-		return false
-	}
-	msg, err := bufio.NewReader(conn).ReadString('\n')
-	if err != nil {
-		fmt.Printf("client can't read: %s\n", err.Error())
-		return false
-	}
-	msg = strings.TrimSpace(msg)
-	fmt.Printf("client: got reply: %s\n", msg)
-	return true
-}
-
-func newTempCAGuard(v *tao.Verifier) (tao.Guard, error) {
-	g := tao.NewTemporaryDatalogGuard()
-	vprin := v.ToPrincipal()
-	rule := fmt.Sprintf(subprinRule, vprin)
-
-	// Add a rule that says that valid args are the ones we were called with.
-	args := ""
-	for i, a := range os.Args {
-		if i > 0 {
-			args += ", "
-		}
-		args += "\"" + a + "\""
-	}
-	authRule := fmt.Sprintf(demoRule, args)
-
-	if err := g.AddRule(rule); err != nil {
-		return nil, err
-	}
-	if err := g.AddRule(argsRule); err != nil {
-		return nil, err
-	}
-	if err := g.AddRule(authRule); err != nil {
-		return nil, err
-	}
-	return g, nil
-}
-
-func doClient(domain *tao.Domain) {
-	network := "tcp"
-	keys, err := tao.NewTemporaryTaoDelegatedKeys(tao.Signing, tao.Parent())
-	if err != nil {
-		fmt.Printf("client: couldn't generate temporary Tao keys: %s\n", err)
-		return
-	}
-
-	// TODO(tmroeder): fix the name
-	cert, err := keys.SigningKey.CreateSelfSignedX509(&pkix.Name{
-		Organization: []string{"Google Tao Demo"}})
-	if err != nil {
-		fmt.Printf("client: couldn't create a self-signed X.509 cert: %s\n", err)
-		return
-	}
-	// TODO(kwalsh) keys should save cert on disk if keys are on disk
-	keys.Cert = cert
-
-	g := domain.Guard
-	if *ca != "" {
-		na, err := taonet.RequestTruncatedAttestation(network, *ca, keys, domain.Keys.VerifyingKey)
-		if err != nil {
-			fmt.Printf("client: couldn't get a truncated attestation from %s: %s\n", *ca, err)
-			return
-		}
-
-		keys.Delegation = na
-
-		// If we're using a CA, then use a custom guard that accepts only
-		// programs that have talked to the CA.
-		g, err = newTempCAGuard(domain.Keys.VerifyingKey)
-		if err != nil {
-			fmt.Printf("client: couldn't set up a new guard: %s\n", err)
-			return
-		}
-	}
-
-	pingGood := 0
-	pingFail := 0
-	for i := 0; i < *pingCount || *pingCount < 0; i++ { // negative means forever
-		if doRequest(g, domain, keys) {
-			pingGood++
-		} else {
-			pingFail++
-		}
-		fmt.Printf("client: made %d connections, finished %d ok, %d bad pings\n",
-			i+1, pingGood, pingFail)
-	}
-}
-
-func doResponse(conn net.Conn, responseOk chan<- bool) {
-	defer conn.Close()
-
-	// Both the TLS and the Tao/TLS connections and listeners handle
-	// authorization during the Accept operation. So, no extra authorization is
-	// needed here.
-	msg, err := bufio.NewReader(conn).ReadString('\n')
-	if err != nil {
-		fmt.Printf("server: can't read: %s\n", err.Error())
-		conn.Close()
-		responseOk <- false
-		return
-	}
-	msg = strings.TrimSpace(msg)
-	fmt.Printf("server: got message: %s\n", msg)
-	responseOk <- true
-	fmt.Fprintf(conn, "echo(%s)\n", msg)
-	conn.Close()
-}
-
-func doServer(stop chan bool, ready, done chan<- bool) {
-	var sock net.Listener
-	var err error
-	var keys *tao.Keys
-	network := "tcp"
-	domain, err := tao.LoadDomain(*configPath, nil)
-	if err != nil {
-		ready <- false
-		done <- true
-		return
-	}
-
-	switch *demoAuth {
-	case "tcp":
-		sock, err = net.Listen(network, serverAddr)
-	case "tls", "tao":
-		keys, err = tao.NewTemporaryTaoDelegatedKeys(tao.Signing, tao.Parent())
-		if err != nil {
-			ready <- false
-			done <- true
-			return
-		}
-		keys.Cert, err = keys.SigningKey.CreateSelfSignedX509(&pkix.Name{
-			Organization: []string{"Google Tao Demo"}})
-		if err != nil {
-			ready <- false
-			done <- true
-			return
-		}
-
-		g := domain.Guard
-		if *ca != "" {
-			na, err := taonet.RequestTruncatedAttestation(network, *ca, keys, domain.Keys.VerifyingKey)
-			if err != nil {
-				ready <- false
-				done <- true
-				return
-			}
-
-			keys.Delegation = na
-			g, err = newTempCAGuard(domain.Keys.VerifyingKey)
-			if err != nil {
-				fmt.Printf("server: couldn't set up a new guard: %s\n", err)
-				return
-			}
-		}
-
-		tlsc, err := taonet.EncodeTLSCert(keys)
-		if err != nil {
-			ready <- false
-			done <- true
-			return
-		}
-		conf := &tls.Config{
-			RootCAs:            x509.NewCertPool(),
-			Certificates:       []tls.Certificate{*tlsc},
-			InsecureSkipVerify: true,
-			ClientAuth:         tls.RequireAnyClientCert,
-		}
-		if *demoAuth == "tao" {
-			sock, err = taonet.Listen(network, serverAddr, conf, g, domain.Keys.VerifyingKey, keys.Delegation)
-		} else {
-			sock, err = tls.Listen(network, serverAddr, conf)
-		}
-	}
-	if err != nil {
-		fmt.Printf("server: can't listen at %s: %s\n", serverAddr, err.Error())
-		ready <- false
-		done <- true
-		return
-	}
-	fmt.Printf("server: listening at %s using %s authentication.\n", serverAddr, *demoAuth)
-	ready <- true
-
-	pings := make(chan bool, 10)
-	connCount := 0
-
-	go func() {
-		for connCount = 0; connCount < *pingCount || *pingCount < 0; connCount++ { // negative means forever
-			conn, err := sock.Accept()
-			if err != nil {
-				fmt.Printf("server: can't accept connection: %s\n", err.Error())
-				stop <- true
-				return
-			}
-			go doResponse(conn, pings)
-		}
-	}()
-
-	pingGood := 0
-	pingFail := 0
-
-loop:
-	for {
-		select {
-		case <-stop:
-			break loop
-		case ok := <-pings:
-			if ok {
-				pingGood++
-			} else {
-				pingFail++
-			}
-		}
-	}
-
-	sock.Close()
-	fmt.Printf("server: handled %d connections, finished %d ok, %d bad pings\n",
-		connCount, pingGood, pingFail)
-
-	done <- true
-}
-
-// Tao Host demo
-
-func hostTaoDemo() error {
-	name, err := tao.Parent().GetTaoName()
-	if err != nil {
-		return err
-	}
-	fmt.Printf("My root name is %s\n", name)
-
-	// TODO(kwalsh) Make a convenience function for this
-	var args []auth.Term
-	for _, arg := range os.Args {
-		args = append(args, auth.Str(arg))
-	}
-	e := auth.PrinExt{Name: "Args", Arg: args}
-	err = tao.Parent().ExtendTaoName(auth.SubPrin{e})
-	if err != nil {
-		return err
-	}
-
-	name, err = tao.Parent().GetTaoName()
-	if err != nil {
-		return err
-	}
-	fmt.Printf("My full name is %s\n", name)
-
-	random, err := tao.Parent().GetRandomBytes(10)
-	if err != nil {
-		return err
-	}
-	fmt.Printf("Random bytes  : % x\n", random)
-
-	n, err := tao.Parent().Rand().Read(random)
-	if err != nil {
-		return err
-	}
-	fmt.Printf("%d more bytes : % x\n", n, random)
-
-	secret, err := tao.Parent().GetSharedSecret(10, tao.SharedSecretPolicyDefault)
-	if err != nil {
-		return err
-	}
-	fmt.Printf("Shared secret : % x\n", secret)
-
-	sealed, err := tao.Parent().Seal(random, tao.SealPolicyDefault)
-	if err != nil {
-		return err
-	}
-	fmt.Printf("Sealed bytes  : % x\n", sealed)
-
-	unsealed, policy, err := tao.Parent().Unseal(sealed)
-	if err != nil {
-		return err
-	}
-	if policy != tao.SealPolicyDefault {
-		return errors.New("unexpected policy on unseal")
-	}
-	fmt.Printf("Unsealed bytes: % x\n", unsealed)
-
-	return nil
-}
-
-func main() {
-	flag.Parse()
-	serverAddr = *serverHost + ":" + *serverPort
-	switch *demoAuth {
-	case "tcp", "tls", "tao":
-	default:
-		fmt.Printf("unrecognized authentication mode: %s\n", *demoAuth)
-		return
-	}
-
-	fmt.Printf("Go Tao Demo\n")
-
-	if !tao.Hosted() {
-		fmt.Printf("can't continue: No host Tao available\n")
-		return
-	}
-
-	if *localMode {
-		err := hostTaoDemo()
-		if err != nil {
-			fmt.Printf("error: %s\n", err.Error())
-			return
-		}
-	}
-
-	serverStop := make(chan bool, 1)
-	serverReady := make(chan bool, 1)
-	serverDone := make(chan bool, 1)
-
-	// TODO(tmroeder): use the Domain and the tao parent to set up the keys and
-	// the guard. Also need to hook the datalog guard into the domain and get
-	// the basic tests working with this guard, especially execution
-	// authorization.
-	if *serverMode {
-		go doServer(serverStop, serverReady, serverDone)
-	} else {
-		serverReady <- true
-		serverDone <- true
-	}
-
-	domain, err := tao.LoadDomain(*configPath, nil)
-	if err != nil {
-		fmt.Printf("error: couldn't load the tao domain from %s\n", *configPath)
-		return
-	}
-
-	if *clientMode {
-		ok := <-serverReady
-		if ok {
-			doClient(domain)
-		}
-		serverStop <- true
-	}
-
-	<-serverDone
-	fmt.Printf("Done\n")
-}
diff --git a/apps/demo/demo_client/Dockerfile b/apps/demo/demo_client/Dockerfile
new file mode 100644
index 0000000..dbaf336
--- /dev/null
+++ b/apps/demo/demo_client/Dockerfile
@@ -0,0 +1,6 @@
+FROM scratch
+ADD tmp /tmp
+ENV GOOGLE_HOST_TAO_TYPE unix
+ENV GOOGLE_HOST_TAO /tao
+WORKDIR .
+ENTRYPOINT ["/bin/demo_client"]
diff --git a/apps/demo/demo_client/demo_client.go b/apps/demo/demo_client/demo_client.go
new file mode 100644
index 0000000..8a65b90
--- /dev/null
+++ b/apps/demo/demo_client/demo_client.go
@@ -0,0 +1,193 @@
+// Copyright (c) 2014, Kevin Walsh.  All rights reserved.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package main
+
+import (
+	"bufio"
+	"crypto/x509/pkix"
+	"flag"
+	"fmt"
+	"net"
+	"os"
+	"strings"
+
+	"github.com/jlmucb/cloudproxy/tao"
+	taonet "github.com/jlmucb/cloudproxy/tao/net"
+)
+
+var serverHost = flag.String("host", "localhost", "address for client/server")
+var serverPort = flag.String("port", "8123", "port for client/server")
+var serverAddr string // see main()
+var pingCount = flag.Int("n", 5, "Number of client/server pings")
+var demoAuth = flag.String("auth", "tao", "\"tcp\", \"tls\", or \"tao\"")
+var configPath = flag.String("config", "tao.config", "The Tao domain config")
+var ca = flag.String("ca", "", "address for Tao CA, if any")
+
+var subprinRule = "(forall P: forall Hash: TrustedProgramHash(Hash) and Subprin(P, %v, Hash) implies MemberProgram(P))"
+var argsRule = "(forall Y: forall P: forall S: MemberProgram(P) and TrustedArgs(S) and Subprin(Y, P, S) implies Authorized(Y, \"Execute\"))"
+var demoRule = "TrustedArgs(ext.Args(%s))"
+
+func doRequest(guard tao.Guard, domain *tao.Domain, keys *tao.Keys) bool {
+	fmt.Printf("client: connecting to %s using %s authentication.\n", serverAddr, *demoAuth)
+	var conn net.Conn
+	var err error
+	network := "tcp"
+
+	switch *demoAuth {
+	case "tcp":
+		conn, err = net.Dial(network, serverAddr)
+	case "tls":
+		conn, err = taonet.DialTLSWithKeys(network, serverAddr, keys)
+	case "tao":
+		conn, err = taonet.DialWithKeys(network, serverAddr, guard, domain.Keys.VerifyingKey, keys)
+	}
+	if err != nil {
+		fmt.Printf("client: error connecting to %s: %s\n", serverAddr, err.Error())
+		return false
+	}
+	defer conn.Close()
+
+	_, err = fmt.Fprintf(conn, "Hello\n")
+	if err != nil {
+		fmt.Printf("client: can't write: %s\n", err.Error())
+		return false
+	}
+	msg, err := bufio.NewReader(conn).ReadString('\n')
+	if err != nil {
+		fmt.Printf("client can't read: %s\n", err.Error())
+		return false
+	}
+	msg = strings.TrimSpace(msg)
+	fmt.Printf("client: got reply: %s\n", msg)
+	return true
+}
+
+func newTempCAGuard(v *tao.Verifier) (tao.Guard, error) {
+	g := tao.NewTemporaryDatalogGuard()
+	vprin := v.ToPrincipal()
+	rule := fmt.Sprintf(subprinRule, vprin)
+
+	// Add a rule that says that valid args are the ones we were called with.
+	args := ""
+	for i, a := range os.Args {
+		if i > 0 {
+			args += ", "
+		}
+		args += "\"" + a + "\""
+	}
+	authRule := fmt.Sprintf(demoRule, args)
+
+	if err := g.AddRule(rule); err != nil {
+		return nil, err
+	}
+	if err := g.AddRule(argsRule); err != nil {
+		return nil, err
+	}
+	if err := g.AddRule(authRule); err != nil {
+		return nil, err
+	}
+	return g, nil
+}
+
+func doClient(domain *tao.Domain) {
+	network := "tcp"
+	keys, err := tao.NewTemporaryTaoDelegatedKeys(tao.Signing, tao.Parent())
+	if err != nil {
+		fmt.Printf("client: couldn't generate temporary Tao keys: %s\n", err)
+		return
+	}
+
+	// TODO(tmroeder): fix the name
+	cert, err := keys.SigningKey.CreateSelfSignedX509(&pkix.Name{
+		Organization: []string{"Google Tao Demo"}})
+	if err != nil {
+		fmt.Printf("client: couldn't create a self-signed X.509 cert: %s\n", err)
+		return
+	}
+	// TODO(kwalsh) keys should save cert on disk if keys are on disk
+	keys.Cert = cert
+
+	g := domain.Guard
+	if *ca != "" {
+		na, err := taonet.RequestTruncatedAttestation(network, *ca, keys, domain.Keys.VerifyingKey)
+		if err != nil {
+			fmt.Printf("client: couldn't get a truncated attestation from %s: %s\n", *ca, err)
+			return
+		}
+
+		keys.Delegation = na
+
+		// If we're using a CA, then use a custom guard that accepts only
+		// programs that have talked to the CA.
+		g, err = newTempCAGuard(domain.Keys.VerifyingKey)
+		if err != nil {
+			fmt.Printf("client: couldn't set up a new guard: %s\n", err)
+			return
+		}
+	}
+
+	pingGood := 0
+	pingFail := 0
+	for i := 0; i < *pingCount || *pingCount < 0; i++ { // negative means forever
+		if doRequest(g, domain, keys) {
+			pingGood++
+		} else {
+			pingFail++
+		}
+		fmt.Printf("client: made %d connections, finished %d ok, %d bad pings\n",
+			i+1, pingGood, pingFail)
+	}
+}
+
+func main() {
+	flag.Parse()
+
+	// Check to see if we are running in Docker mode with linked containers.
+	// If so, then there will be an environment variable SERVER_PORT that
+	// will contain a value of the form tcp://<ip>:<port>
+	serverEnvVar := os.Getenv("SERVER_PORT")
+	if serverEnvVar == "" {
+		serverAddr = net.JoinHostPort(*serverHost, *serverPort)
+	} else {
+		serverAddr = strings.TrimPrefix(serverEnvVar, "tcp://")
+		if serverAddr == serverEnvVar {
+			fmt.Printf("client: invalid SERVER_PORT environment variable value '%s'\n", serverEnvVar)
+			return
+		}
+	}
+
+	switch *demoAuth {
+	case "tcp", "tls", "tao":
+	default:
+		fmt.Printf("unrecognized authentication mode: %s\n", *demoAuth)
+		return
+	}
+
+	fmt.Printf("Go Tao Demo\n")
+
+	if !tao.Hosted() {
+		fmt.Printf("can't continue: No host Tao available\n")
+		return
+	}
+
+	domain, err := tao.LoadDomain(*configPath, nil)
+	if err != nil {
+		fmt.Printf("error: couldn't load the tao domain from %s\n", *configPath)
+		return
+	}
+
+	doClient(domain)
+	fmt.Printf("Client Done\n")
+}
diff --git a/apps/demo/demo_server/Dockerfile b/apps/demo/demo_server/Dockerfile
new file mode 100644
index 0000000..e2c6d75
--- /dev/null
+++ b/apps/demo/demo_server/Dockerfile
@@ -0,0 +1,7 @@
+FROM scratch
+ADD tmp /tmp
+EXPOSE 8123
+ENV GOOGLE_HOST_TAO_TYPE unix
+ENV GOOGLE_HOST_TAO /tao
+WORKDIR .
+ENTRYPOINT ["/bin/demo_server"]
diff --git a/apps/demo/demo_server/demo_server.go b/apps/demo/demo_server/demo_server.go
new file mode 100644
index 0000000..54499c3
--- /dev/null
+++ b/apps/demo/demo_server/demo_server.go
@@ -0,0 +1,220 @@
+// Copyright (c) 2014, Kevin Walsh.  All rights reserved.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package main
+
+import (
+	"bufio"
+	"crypto/tls"
+	"crypto/x509"
+	"crypto/x509/pkix"
+	"flag"
+	"fmt"
+	"log"
+	"net"
+	"os"
+	"strings"
+
+	"github.com/jlmucb/cloudproxy/tao"
+	taonet "github.com/jlmucb/cloudproxy/tao/net"
+)
+
+var serverHost = flag.String("host", "0.0.0.0", "address for client/server")
+var serverPort = flag.String("port", "8123", "port for client/server")
+var serverAddr string // see main()
+var pingCount = flag.Int("n", 5, "Number of client/server pings")
+var demoAuth = flag.String("auth", "tao", "\"tcp\", \"tls\", or \"tao\"")
+var configPath = flag.String("config", "tao.config", "The Tao domain config")
+var ca = flag.String("ca", "", "address for Tao CA, if any")
+
+var subprinRule = "(forall P: forall Hash: TrustedProgramHash(Hash) and Subprin(P, %v, Hash) implies MemberProgram(P))"
+var argsRule = "(forall Y: forall P: forall S: MemberProgram(P) and TrustedArgs(S) and Subprin(Y, P, S) implies Authorized(Y, \"Execute\"))"
+var demoRule = "TrustedArgs(ext.Args(%s))"
+
+func newTempCAGuard(v *tao.Verifier) (tao.Guard, error) {
+	g := tao.NewTemporaryDatalogGuard()
+	vprin := v.ToPrincipal()
+	rule := fmt.Sprintf(subprinRule, vprin)
+
+	// Add a rule that says that valid args are the ones we were called with.
+	args := ""
+	for i, a := range os.Args {
+		if i > 0 {
+			args += ", "
+		}
+		args += "\"" + a + "\""
+	}
+	authRule := fmt.Sprintf(demoRule, args)
+
+	if err := g.AddRule(rule); err != nil {
+		return nil, err
+	}
+	if err := g.AddRule(argsRule); err != nil {
+		return nil, err
+	}
+	if err := g.AddRule(authRule); err != nil {
+		return nil, err
+	}
+	return g, nil
+}
+
+func doResponse(conn net.Conn, responseOk chan<- bool) {
+	defer conn.Close()
+
+	// Both the TLS and the Tao/TLS connections and listeners handle
+	// authorization during the Accept operation. So, no extra authorization is
+	// needed here.
+	msg, err := bufio.NewReader(conn).ReadString('\n')
+	if err != nil {
+		fmt.Printf("server: can't read: %s\n", err.Error())
+		conn.Close()
+		responseOk <- false
+		return
+	}
+	msg = strings.TrimSpace(msg)
+	fmt.Printf("server: got message: %s\n", msg)
+	responseOk <- true
+	fmt.Fprintf(conn, "echo(%s)\n", msg)
+	conn.Close()
+}
+
+func doServer(done chan<- bool) {
+	var sock net.Listener
+	var err error
+	var keys *tao.Keys
+	network := "tcp"
+	domain, err := tao.LoadDomain(*configPath, nil)
+	if err != nil {
+		done <- true
+		return
+	}
+
+	switch *demoAuth {
+	case "tcp":
+		sock, err = net.Listen(network, serverAddr)
+		if err != nil {
+			log.Fatalf("Couldn't listen to the network: %s\n", err)
+		}
+	case "tls", "tao":
+		keys, err = tao.NewTemporaryTaoDelegatedKeys(tao.Signing, tao.Parent())
+		if err != nil {
+			done <- true
+			return
+		}
+		keys.Cert, err = keys.SigningKey.CreateSelfSignedX509(&pkix.Name{
+			Organization: []string{"Google Tao Demo"}})
+		if err != nil {
+			done <- true
+			return
+		}
+
+		g := domain.Guard
+		if *ca != "" {
+			na, err := taonet.RequestTruncatedAttestation(network, *ca, keys, domain.Keys.VerifyingKey)
+			if err != nil {
+				done <- true
+				return
+			}
+
+			keys.Delegation = na
+			g, err = newTempCAGuard(domain.Keys.VerifyingKey)
+			if err != nil {
+				fmt.Printf("server: couldn't set up a new guard: %s\n", err)
+				return
+			}
+		}
+
+		tlsc, err := taonet.EncodeTLSCert(keys)
+		if err != nil {
+			done <- true
+			return
+		}
+		conf := &tls.Config{
+			RootCAs:            x509.NewCertPool(),
+			Certificates:       []tls.Certificate{*tlsc},
+			InsecureSkipVerify: true,
+			ClientAuth:         tls.RequireAnyClientCert,
+		}
+		if *demoAuth == "tao" {
+			sock, err = taonet.Listen(network, serverAddr, conf, g, domain.Keys.VerifyingKey, keys.Delegation)
+			if err != nil {
+				log.Fatalf("Couldn't create a taonet listener: %s\n", err)
+			}
+		} else {
+			sock, err = tls.Listen(network, serverAddr, conf)
+			if err != nil {
+				log.Fatalf("Couldn't create a tls listener: %s\n", err)
+			}
+		}
+	}
+	fmt.Printf("server: listening at %s using %s authentication.\n", serverAddr, *demoAuth)
+
+	pings := make(chan bool, 5)
+	connCount := 0
+
+	go func() {
+		for connCount = 0; connCount < *pingCount || *pingCount < 0; connCount++ { // negative means forever
+			conn, err := sock.Accept()
+			if err != nil {
+				fmt.Printf("server: can't accept connection: %s\n", err.Error())
+				return
+			}
+			go doResponse(conn, pings)
+		}
+	}()
+
+	pingGood := 0
+	pingFail := 0
+
+	for {
+		select {
+		case ok := <-pings:
+			if ok {
+				pingGood++
+			} else {
+				pingFail++
+			}
+		}
+	}
+
+	sock.Close()
+	fmt.Printf("server: handled %d connections, finished %d ok, %d bad pings\n",
+		connCount, pingGood, pingFail)
+
+	done <- true
+}
+
+func main() {
+	flag.Parse()
+	serverAddr = net.JoinHostPort(*serverHost, *serverPort)
+	switch *demoAuth {
+	case "tcp", "tls", "tao":
+	default:
+		fmt.Printf("unrecognized authentication mode: %s\n", *demoAuth)
+		return
+	}
+
+	fmt.Printf("Go Tao Demo Server\n")
+
+	if !tao.Hosted() {
+		fmt.Printf("can't continue: No host Tao available\n")
+		return
+	}
+
+	serverDone := make(chan bool, 1)
+
+	go doServer(serverDone)
+	<-serverDone
+	fmt.Printf("Server Done\n")
+}
diff --git a/apps/linux_host/main.go b/apps/linux_host/main.go
index 660a780..796559e 100644
--- a/apps/linux_host/main.go
+++ b/apps/linux_host/main.go
@@ -5,192 +5,208 @@
 // You may obtain a copy of the License at
 //
 //     http://www.apache.org/licenses/LICENSE-2.0
 //
 // Unless required by applicable law or agreed to in writing, software
 // distributed under the License is distributed on an "AS IS" BASIS,
 // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
 package main
 
 import (
 	"flag"
 	"fmt"
 	"io"
 	"io/ioutil"
 	"log"
 	"net"
 	"os"
-	"os/signal"
 	"path"
-	"syscall"
+	"path/filepath"
 
 	"github.com/jlmucb/cloudproxy/tao"
-	"github.com/jlmucb/cloudproxy/tao/auth"
 	"github.com/jlmucb/cloudproxy/util"
 )
 
-var configPath = flag.String("config_path", "tao.config", "Location of tao domain configuration")
-var hostPath = flag.String("path", "linux_tao_host", "Location of linux host configuration")
-var quiet = flag.Bool("quiet", false, "Be more quiet.")
-var root = flag.Bool("root", false, "Run in root mode")
-var stacked = flag.Bool("stacked", false, "Run in stacked mode")
-var pass = flag.String("pass", "", "Password for unlocking keys if running in root mode")
-
-var create = flag.Bool("create", false, "Create a new LinuxHost service.")
-var show = flag.Bool("show", false, "Show principal name for LinuxHost service.")
-var service = flag.Bool("service", false, "Start the LinuxHost service.")
-var shutdown = flag.Bool("shutdown", false, "Shut down the LinuxHost service.")
-
-var run = flag.Bool("run", false, "Start a hosted program (path and args follow --).")
-var list = flag.Bool("list", false, "List hosted programs.")
-var stop = flag.Bool("stop", false, "Stop a hosted program (names follow --).")
-var kill = flag.Bool("kill", false, "Kill a hosted program (names follow --).")
-var name = flag.Bool("name", false, "Show the principal name of running LinuxHost.")
-
-func countSet(vars ...interface{}) int {
-	var n int
-	for _, v := range vars {
-		switch v := v.(type) {
-		case string:
-			if v != "" {
-				n++
-			}
-		case bool:
-			if v {
-				n++
-			}
-		default:
-			n++
-		}
-	}
-	return n
-}
-
-var verbose io.Writer
-
 func main() {
-	help := "Administrative utility for LinuxHost.\n"
-	help += "Usage:\n"
-	help += "%[1]s [options] -create\n"
-	help += "%[1]s [options] -show\n"
-	help += "%[1]s [options] -service\n"
-	help += "%[1]s [options] -shutdown\n"
-	help += "%[1]s [options] -run -- program args...\n"
-	help += "%[1]s [options] -stop -- subprin...\n"
-	help += "%[1]s [options] -kill -- subprin...\n"
-	help += "%[1]s [options] -list\n"
-	help += "%[1]s [options] -name\n"
-	flag.Usage = func() {
-		fmt.Fprintf(os.Stderr, help, os.Args[0])
-		flag.PrintDefaults()
-	}
+	// General configuration options.
+	configPath := flag.String("config_path", "", "Location of tao domain configuration")
+	hostPath := flag.String("path", "linux_tao_host", "Name of relative path to the location of linux host configuration")
+	rules := flag.String("rules", "rules", "Name of the rules file for auth")
+	quiet := flag.Bool("quiet", false, "Be more quiet.")
+
+	// Absent any flags indicating other options, the default configuration of
+	// linux_host runs in root mode with a fresh key (so with a soft Tao), and with
+	// its configuration stored in a fresh temporary directory, and with a liberal
+	// guard policy. Its default method of creating hosted programs is as processes
+	// with pipe communication.
+	mode := flag.String("mode", "root", "Tao mode to run ('root' or 'stacked').")
+	pass := flag.String("pass", "BogusPass", "Password for unlocking keys if running in root mode")
+	channelType := flag.String("channel_type", "pipe", "The type of channel for hosted-program communication ('pipe', or 'unix').")
+	channelSocketPath := flag.String("channel_socket_path", "linux_tao_host", "The directory in which to create unix sockets for hosted-program communication")
+	factoryType := flag.String("factory_type", "process", "The type of hosted program factory to use ('process', 'docker', or 'coreos')")
+
+	// QEMU/KVM CoreOS configuration with some reasonable defaults.
+	coreOSImage := flag.String("coreos_img", "coreos.img", "The path to a CoreOS image")
+	sshStartPort := flag.Int("coreos_ssh_port", 2222, "The starting port for SSH connections to CoreOS VMs")
+	vmMemory := flag.Int("vm_memory", 1024, "The amount of RAM to give the VM")
+	sshFile := flag.String("ssh_auth_keys", "auth_ssh_coreos", "A path to the authorized keys file for SSH connections to the CoreOS guest")
+	hostImage := flag.String("host_img", "linux_host.img.tgz", "The path to the Docker image for the Linux host to run under CoreOS")
+
+	// An action for the service to take.
+	action := flag.String("action", "start", "The action to take ('init', 'show', 'start', or 'stop')")
 	util.UseEnvFlags("GLOG", "TAO", "TAO_HOST")
 	flag.Parse()
 
+	var verbose io.Writer
 	if *quiet {
 		verbose = ioutil.Discard
 	} else {
 		verbose = os.Stderr
 	}
 
-	if countSet(*create, *show, *service, *shutdown, *run, *stop, *kill, *list, *name) > 1 {
-		log.Fatal("specify at most one of the command options")
+	var dir string
+	var absConfigPath string
+	var err error
+	// If the configPath doesn't exist, then create a temp path for the
+	// configuration. This also handles the case where the config path is
+	// empty.
+	if _, err = os.Stat(*configPath); err != nil {
+		dir, err = ioutil.TempDir("", "linux_host")
+		if err != nil {
+			log.Fatalf("Couldn't create a temporary directory for linux host: %s\n", err)
+		}
+
+		trivialConfig := `
+# Tao Domain Configuration file
+
+[Domain]
+Name = testing
+PolicyKeysPath = policy_keys
+GuardType = AllowAll
+
+[X509Details]
+CommonName = testing`
+		absConfigPath = path.Join(dir, "tao.config")
+		if err = ioutil.WriteFile(absConfigPath, []byte(trivialConfig), 0700); err != nil {
+			log.Fatalf("Couldn't write a trivial Tao config to %s: %s\n", absConfigPath, err)
+		}
+
+		emptyRules := make([]byte, 0)
+		if err = ioutil.WriteFile(path.Join(dir, "rules"), emptyRules, 0700); err != nil {
+			log.Fatalf("Couldn't write an empty rules file: %s\n", err)
+		}
+
+		// If we're creating a temporary directory, then create a set of
+		// fake policy keys as well, using the password provided.
+		if len(*pass) == 0 {
+			log.Fatalf("Must provide a password for temporary keys")
+		}
+
+		fmt.Fprintf(verbose, "Initializing new configuration in: %s\n", absConfigPath)
+		var cfg tao.DomainConfig
+		cfg.Domain.Name = "testing"
+		cfg.X509Details.CommonName = "testing"
+		cfg.Domain.GuardType = "AllowAll"
+
+		_, err = tao.CreateDomain(cfg, absConfigPath, []byte(*pass))
+		fatalIf(err)
+	} else {
+		absConfigPath, err = filepath.Abs(*configPath)
+		if err != nil {
+			log.Fatalf("Couldn't get an absolute version of the config path %s: %s\n", *configPath, err)
+		}
+		fmt.Printf("absConfigPath = %s\n", absConfigPath)
+		dir = path.Dir(absConfigPath)
+		fmt.Printf("dir = %s\n", dir)
 	}
 
-	sockPath := path.Join(*hostPath, "admin_socket")
+	absHostPath := path.Join(dir, *hostPath)
+	sockPath := path.Join(absHostPath, "admin_socket")
+	fmt.Fprintf(verbose, "Admin socket: %s\n", sockPath)
+
+	absChannelSocketPath := path.Join(dir, *channelSocketPath)
 
-	if *create || *service || *show {
-		fmt.Fprintf(verbose, "Loading configuration from: %s\n", *configPath)
-		domain, err := tao.LoadDomain(*configPath, nil)
+	switch *action {
+	case "init", "show", "start":
+		fmt.Fprintf(verbose, "Loading configuration from: %s\n", absConfigPath)
+		domain, err := tao.LoadDomain(absConfigPath, nil)
 		fatalIf(err)
+
+		rulesPath := path.Join(dir, *rules)
+
+		var childFactory tao.HostedProgramFactory
+		switch *factoryType {
+		case "process":
+			childFactory = tao.NewLinuxProcessFactory(*channelType, absChannelSocketPath)
+		case "docker":
+			childFactory = tao.NewLinuxDockerContainerFactory(absChannelSocketPath, rulesPath)
+		case "coreos":
+			if *sshFile == "" {
+				log.Fatal("Must specify an SSH authorized_key file for CoreOS")
+			}
+			sshKeysCfg, err := tao.CloudConfigFromSSHKeys(*sshFile)
+			if err != nil {
+				log.Fatalf("Couldn't load the ssh files file '%s': %s\n", *sshFile, err)
+			}
+
+			if *coreOSImage == "" {
+				log.Fatal("Must specify a CoreOS image file for the CoreOS hosted-program factory")
+			}
+
+			// Construct the CoreOS configuration from the flags.
+			cfg := &tao.CoreOSConfig{
+				ImageFile:  *coreOSImage,
+				SSHPort:    *sshStartPort,
+				Memory:     *vmMemory,
+				RulesPath:  rulesPath,
+				SSHKeysCfg: sshKeysCfg,
+			}
+			childFactory = tao.NewLinuxKVMCoreOSFactory(absChannelSocketPath, *hostImage, cfg)
+		default:
+			log.Fatalf("Unknown hosted-program factory '%s'\n", *factoryType)
+		}
+
 		var host *tao.LinuxHost
-		if *root {
+		switch *mode {
+		case "root":
 			if len(*pass) == 0 {
 				log.Fatal("password is required")
 			}
-			host, err = tao.NewRootLinuxHost(*hostPath, domain.Guard, []byte(*pass))
-		} else if *stacked {
+			host, err = tao.NewRootLinuxHost(absHostPath, domain.Guard, []byte(*pass), childFactory)
+			fatalIf(err)
+		case "stacked":
 			if !tao.Hosted() {
 				log.Fatalf("error: no host tao available, check $%s\n", tao.HostTaoEnvVar)
 			}
-			host, err = tao.NewStackedLinuxHost(*hostPath, domain.Guard, tao.Parent())
-		} else {
+			host, err = tao.NewStackedLinuxHost(absHostPath, domain.Guard, tao.Parent(), childFactory)
+			fatalIf(err)
+		default:
 			log.Fatal("error: must specify either -root or -stacked")
 		}
-		fatalIf(err)
-		if *create {
+
+		switch *action {
+		case "create":
 			fmt.Printf("LinuxHost Service: %s\n", host.TaoHostName())
-		} else if *show {
+		case "show":
 			fmt.Printf("export GOOGLE_TAO_LINUX='%v'\n", host.TaoHostName())
-		} else /* service */ {
+		case "start":
 			sock, err := net.Listen("unix", sockPath)
 			fatalIf(err)
 			defer sock.Close()
-			fmt.Fprintf(verbose, "Linux Tao Service started and waiting for requests\n")
+			fmt.Fprintf(verbose, "Linux Tao Service (%s) started and waiting for requests\n", host.TaoHostName())
 			fatalIf(err)
 			tao.NewLinuxHostAdminServer(host).Serve(sock)
 		}
-	} else {
-		conn, err := net.Dial("unix", sockPath)
-		fatalIf(err)
-		defer conn.Close()
-		client := tao.NewLinuxHostAdminClient(conn)
-		if *shutdown {
-			log.Fatal("not yet implemented")
-		} else if *run {
-			if flag.NArg() == 0 {
-				log.Fatal("missing program path")
-			}
-			subprin, pid, err := client.StartHostedProgram(flag.Arg(0), flag.Args()...)
-			fatalIf(err)
-			fmt.Printf("%d %v\n", pid, subprin)
-		} else if *stop {
-			for _, s := range flag.Args() {
-				var subprin auth.SubPrin
-				_, err := fmt.Sscanf(s, "%v", &subprin)
-				fatalIf(err)
-				err = client.StopHostedProgram(subprin)
-				fatalIf(err)
-			}
-		} else if *kill {
-			for _, s := range flag.Args() {
-				var subprin auth.SubPrin
-				_, err := fmt.Sscanf(s, "%v", &subprin)
-				fatalIf(err)
-				err = client.KillHostedProgram(subprin)
-				fatalIf(err)
-			}
-		} else if *list {
-			name, pid, err := client.ListHostedPrograms()
-			fatalIf(err)
-			for i, p := range pid {
-				fmt.Printf("pid=%d %v\n", p, name[i])
-			}
-			fmt.Printf("%d processes\n", len(pid))
-		} else if *name {
-			name, err := client.TaoHostName()
-			fatalIf(err)
-			fmt.Printf("LinuxHost: %v\n", name)
-		} else {
-			name, err := client.TaoHostName()
-			fatalIf(err)
-			fmt.Printf("LinuxHost: %s\n", name)
-		}
+	case "shutdown":
+		log.Fatal("not yet implemented")
+	default:
 	}
 }
 
 func fatalIf(err error) {
 	if err != nil {
 		log.Fatal(err)
 	}
 }
-
-func panicOnHup() {
-	c := make(chan os.Signal, 1)
-	signal.Notify(c, syscall.SIGQUIT)
-
-	s := <-c
-	panic(s)
-}
diff --git a/apps/tao_admin/main.go b/apps/tao_admin/main.go
index 7c89844..55fc8ee 100644
--- a/apps/tao_admin/main.go
+++ b/apps/tao_admin/main.go
@@ -38,40 +38,41 @@ var quiet = flag.Bool("quiet", false, "Be more quiet.")
 var show = flag.Bool("show", false, "Show info when done.")
 var host = flag.String("host", "", "The principal name of the host where programs will execute.")
 
 // initializing a new domain
 var create = flag.Bool("create", false, "Create a new domain configuration.")
 var name = flag.String("name", "", "Name for a new configuration.")
 var guard = flag.String("guard", "TrivialLiberalGuard", "Name of guard: ACLs, Datalog, etc.")
 
 // execution policy changes
 var canExecute = flag.String("canexecute", "", "Path of a program to be authorized to execute.")
 var retractCanExecute = flag.String("retractcanexecute", "", "Path of a program to retract authorization to execute.")
 
 // arbitrary policy changes
 var add = flag.String("add", "", "A policy rule to be added.")
 var retract = flag.String("retract", "", "A policy rule to be retracted.")
 var clear = flag.Bool("clear", false, "Clear all policy rules before other changes.")
 var query = flag.String("query", "", "A policy query to be checked.")
 
 // misc. utilities
 var getProgramHash = flag.String("getprogramhash", "", "Path of program to be hashed.")
+var getContainerHash = flag.String("getcontainerhash", "", "Path of container to be hashed.")
 var getPCR = flag.Int("getpcr", -1, "Index of a PCR to return.")
 var tpmPath = flag.String("tpm", "/dev/tpm0", "Path to a TPM device.")
 var aikFile = flag.String("aikblob", "", "A file containing a TPM AIK.")
 
 func main() {
 	help := "Administrative utility for Tao Domain.\n"
 	help += "Usage: %[1]s [options] -create [-name name]\n"
 	help += "%[1]s [options] -(retractcanexecute|canexecute) progpath\n"
 	help += "%[1]s [options] -(add|retract|query) rule\n"
 	help += "%[1]s [options] -clear\n"
 	flag.Usage = func() {
 		fmt.Fprintf(os.Stderr, help, os.Args[0])
 		flag.PrintDefaults()
 	}
 	util.UseEnvFlags("GLOG", "TAO", "TAO_ADMIN")
 	flag.Parse()
 
 	var noise io.Writer
 	if *quiet {
 		noise = ioutil.Discard
@@ -164,40 +165,46 @@ func main() {
 		fatalIf(err)
 		didWork = true
 	}
 	if *query != "" {
 		fmt.Fprintf(noise, "Querying policy guard: %s\n", *query)
 		ok, err := domain.Guard.Query(*query)
 		fatalIf(err)
 		if ok {
 			fmt.Printf("Policy supports query.\n")
 		} else {
 			fmt.Printf("Policy rejects query.\n")
 		}
 		didWork = true
 	}
 	if *getProgramHash != "" {
 		path := *getProgramHash
 		subprin := makeProgramSubPrin(path)
 		fmt.Println(subprin)
 		didWork = true
 	}
+	if *getContainerHash != "" {
+		path := *getContainerHash
+		subprin := makeContainerSubPrin(path)
+		fmt.Println(subprin)
+		didWork = true
+	}
 	if *getPCR > 0 {
 		f, err := os.OpenFile(*tpmPath, os.O_RDWR, 0600)
 		fatalIf(err)
 		defer f.Close()
 		res, err := tpm.ReadPCR(f, uint32(*getPCR))
 		fatalIf(err)
 		fmt.Printf("%x", res)
 		didWork = true
 	}
 	if *aikFile != "" {
 		aikblob, err := ioutil.ReadFile(*aikFile)
 		fatalIf(err)
 		v, err := tpm.UnmarshalRSAPublicKey(aikblob)
 		fatalIf(err)
 		aik, err := x509.MarshalPKIXPublicKey(v)
 		fatalIf(err)
 
 		name := auth.Prin{
 			Type: "tpm",
 			Key:  auth.Bytes(aik),
@@ -222,28 +229,35 @@ func hash(path string) []byte {
 func makeHostPrin(host string) auth.Prin {
 	// Here we rely on there being an env var for the host name. We could also use
 	// a different env var to contact a host and ask its name. That would require
 	// the host to be running, though.
 	if host == "" {
 		host = os.Getenv("GOOGLE_TAO_LINUX")
 	}
 	if host == "" {
 		log.Fatal("No tao host: set $GOOGLE_TAO_LINUX or use -host option")
 	}
 	var prin auth.Prin
 	_, err := fmt.Sscanf(host, "%v", &prin)
 	fatalIf(err)
 	return prin
 }
 
 func makeProgramSubPrin(prog string) auth.SubPrin {
 	// BUG(kwalsh) This assumes no IDs, and it assumes linux hosts.
 	id := uint(0)
 	h := hash(prog)
-	return tao.FormatHostedProgramSubprin(id, h)
+	return tao.FormatSubprin(id, h)
+}
+
+func makeContainerSubPrin(prog string) auth.SubPrin {
+	// TODO(tmroeder): This assumes no IDs
+	id := uint(0)
+	h := hash(prog)
+	return tao.FormatDockerSubprin(id, h)
 }
 
 func fatalIf(err error) {
 	if err != nil {
 		log.Fatal(err)
 	}
 }
diff --git a/apps/tao_launch/tao_launch.go b/apps/tao_launch/tao_launch.go
new file mode 100644
index 0000000..88673ad
--- /dev/null
+++ b/apps/tao_launch/tao_launch.go
@@ -0,0 +1,112 @@
+// Copyright (c) 2014, Google, Inc.  All rights reserved.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package main
+
+import (
+	"flag"
+	"fmt"
+	"log"
+	"net"
+
+	"github.com/jlmucb/cloudproxy/tao"
+	"github.com/jlmucb/cloudproxy/tao/auth"
+)
+
+func main() {
+	operation := flag.String("operation", "run", "The operation to perform ('run', 'stop', 'kill', 'list', or 'name').")
+	sockPath := flag.String("sock", "linux_tao_host/admin_socket", "The path to the socket for the linux_host")
+	docker := flag.String("docker_img", "", "The path to a tarball to use to create a docker image")
+
+	if *sockPath == "" {
+		log.Fatalf("Must supply a socket patch for the linux host")
+	}
+
+	flag.Parse()
+
+	conn, err := net.Dial("unix", *sockPath)
+	if err != nil {
+		log.Fatal(err)
+	}
+	defer conn.Close()
+	client := tao.NewLinuxHostAdminClient(conn)
+	switch *operation {
+	case "run":
+		if flag.NArg() == 0 {
+			log.Fatal("missing program path")
+		}
+		if *docker == "" {
+			subprin, pid, err := client.StartHostedProgram(flag.Arg(0), flag.Args()...)
+			if err != nil {
+				log.Fatal(err)
+			}
+			fmt.Printf("%d %v\n", pid, subprin)
+		} else {
+			// Drop the first arg for Docker, since it will
+			// be handled by the Dockerfile directly.
+			if flag.NArg() == 1 {
+				subprin, pid, err := client.StartHostedProgram(*docker)
+				if err != nil {
+					log.Fatal(err)
+				}
+				fmt.Printf("%d %v\n", pid, subprin)
+			} else {
+				subprin, pid, err := client.StartHostedProgram(*docker, flag.Args()[1:]...)
+				if err != nil {
+					log.Fatal(err)
+				}
+				fmt.Printf("%d %v\n", pid, subprin)
+			}
+		}
+	case "stop":
+		for _, s := range flag.Args() {
+			var subprin auth.SubPrin
+			if _, err := fmt.Sscanf(s, "%v", &subprin); err != nil {
+				log.Fatal(err)
+			}
+			if err = client.StopHostedProgram(subprin); err != nil {
+				log.Fatal(err)
+			}
+		}
+	case "kill":
+		for _, s := range flag.Args() {
+			var subprin auth.SubPrin
+			if _, err := fmt.Sscanf(s, "%v", &subprin); err != nil {
+				log.Fatal(err)
+			}
+			if err = client.KillHostedProgram(subprin); err != nil {
+				log.Fatal(err)
+			}
+		}
+	case "list":
+		name, pid, err := client.ListHostedPrograms()
+		if err != nil {
+			log.Fatal(err)
+		}
+		for i, p := range pid {
+			fmt.Printf("pid=%d %v\n", p, name[i])
+		}
+		fmt.Printf("%d processes\n", len(pid))
+	case "name":
+		name, err := client.TaoHostName()
+		if err != nil {
+			log.Fatal(err)
+		}
+		fmt.Printf("LinuxHost: %v\n", name)
+	default:
+		log.Fatalf("Unknown operation '%s'", *operation)
+	}
+
+	return
+}
diff --git a/build.sh b/build.sh
new file mode 100755
index 0000000..c0e7a15
--- /dev/null
+++ b/build.sh
@@ -0,0 +1,29 @@
+#!/bin/sh
+# Copyright (c) 2014, Google, Inc. All rights reserved.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+
+# There are two separate builds to run here: one is the Go build for all the Go
+# code currently in the repo, including apps and libraries. The other is the
+# CMake build that provides support for building C++ applications that can talk
+# to the a Go Tao using protobuf RPC.
+
+# This assumes the GOPATH is properly set up to include the current directory as
+# github.com/jlmucb/cloudproxy. We need to build in this mode to support running
+# in Docker containers built over the scratch container: these don't have
+# anything in them at all.
+echo "Building Go libaries and applications"
+CGO_ENABLED=0 go install -a -ldflags '-s' github.com/jlmucb/cloudproxy/...
+
+echo "To build the C++ support, change directories to src and follow the instructions in the README.md"
diff --git a/install.sh b/install.sh
index c432038..beae81e 100755
--- a/install.sh
+++ b/install.sh
@@ -13,172 +13,215 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
 # Multi-purpose script for setting up and running tao and cloudproxy tests.
 #
 # This script works with the Go implementation of Tao. It assumes all binaries
 # have been installed in ${GOPATH}/bin (e.g. via `go install`)
 #
 # If you wish to use the TPM, you must have taken ownership of the TPM. For
 # example, see github.com/google/go-tpm/examples/tpm-takeownership.
 
 set -e # quit script on first error
 
 # INSTALL BEGIN
 # Note: This section of code is removed by install.sh
 script_path="install.sh"
 test_dir=""
 test_tpm="no"
 verbose="yes"
 test_guard="AllowAll"
+child_channel_type="pipe"
+tao_channel_type=""
+tao_factory_type="process"
+coreos_img=""
+ssh_keys=""
 for arg in "$@"; do
 	case "$arg" in
 		-notpm)
 			test_tpm="no"
 			shift
 			;;
 		-tpm)
 			test_tpm="yes"
+			tao_channel_type="tpm"
 			shift
 			;;
 		-acls)
 			test_guard="ACLs"
 			shift
 			;;
 		-datalog)
 			test_guard="Datalog"
 			shift
 			;;
+		-unix)
+			child_channel_type="unix"
+			shift
+			;;
+		-docker)
+			tao_factory_type="docker"
+			child_channel_type="unix"
+			shift
+			;;
+		-coreos)
+			tao_factory_type="coreos"
+			child_channel_type="unix"
+			shift
+			;;
+		-coreos_img)
+			coreos_img=$2
+			shift
+			shift
+			;;
+		-ssh_keys)
+			ssh_keys=$2
+			shift
+			shift
+			;;
 		-q)
 			verbose="no"
 			shift
 			;;
 		-*)
 			echo "Huh? $arg"
 			exit 1
 			;;
 	esac
 done
 if [ $# -eq 1 ]; then
 	test_dir="$1"
 fi
 if [ ! "$test_dir" ]; then
 	echo "Usage: $0 [options] <dir>"
 	echo "  Installs tao testing scripts into <dir>, which will be created"
 	echo "  if it does not yet exist. If neither -acls nor -datalog is"
 	echo "  specified, then the authorization policy is AllowAll."
 	echo "Options:"
 	echo "  -notpm       Use a fake TPM (the default)."
 	echo "  -tpm         Use the TPM."
 	echo "  -acls        Use ACL-based guards for Tao domain policy."
 	echo "  -datalog     Use Datalog-based guards for Tao domain policy."
+	echo "  -unix        Use Unix domain sockets instead of pipes for channels."
+	echo "  -docker      Use Docker containers for hosted programs."
+	echo "  -coreos      Use QEMU/KVM-hosted CoreOS for hosted programs."
 	echo "  -q           Be more quiet."
 	exit 1
 fi
 if [ -e "$test_dir" -a ! -d "$test_dir" ]; then
 	echo "$test_dir: path exists but is not a directory"
 	exit 1
 fi
 mkdir -p "$test_dir"
 # canonicalize
 root_dir=$(readlink -e "$(dirname $0)")
 test_dir=$(readlink -e "$test_dir")
 if [ "$verbose" == "yes" ]; then
 	echo "Installing tao test scripts into: $test_dir"
 fi
 # sanity checks
 if [ ! -d "$GOPATH/bin" ]; then
     echo "install failed: could not find GOPATH bin directory"
     exit 1
 fi
 if [ ! -f "$root_dir/$script_path" -o ! -d "$test_dir" ]; then
 	echo "install failed: could not canonicalize paths"
 	exit 1
 fi
+if [ "${tao_factory_type}" == "coreos" -a ! -f "${coreos_img}" ]; then
+	echo "install failed: must supply a valid image file for CoreOS"
+	exit 1
+fi
+if [ "${tao_factory_type}" == "coreos" -a ! -f "${ssh_keys}" ]; then
+	echo "install failed: must supply a valid SSH keys file for CoreOS"
+	exit 1
+fi
 mkdir -p "$test_dir/scripts"
 rm -f "$test_dir/scripts/tao.sh"
 sed '/^# INSTALL BEGIN/,/^# INSTALL END/ s/^/## /' "$root_dir/$script_path" \
 			>"$test_dir/scripts/tao.sh"
 chmod +x "$test_dir/scripts/tao.sh"
 	
 cd "$test_dir/scripts/"
 perl -p -i -e "s|^export TAO_TEST=undef .*\$|export TAO_TEST="\""$test_dir"\""|" tao.sh
 for script in "setup.sh" "start.sh" "restart.sh" "monitor.sh" \
 	"test.sh" "refresh.sh" "stop.sh" "clean.sh" "hash.sh" "help.sh" \
 	"host.sh" "base64w-encode.sh" "base64w-decode.sh"; do
 	rm -f $script
 	ln -s tao.sh $script
 done
 cd "$test_dir"
 rm -f bin
 ln -s ${GOPATH}/bin bin
 mkdir -p logs
 
 if [ "$test_tpm" == "yes" ]; then
 	test_root=false
 	test_stacked=true
 else
 	test_root=true
 	test_stacked=false
 fi
 
 cat <<END > "$test_dir/tao.env"
 # Tao/CloudProxy environment variables"
 export TAO_TEST="$test_dir" # Also hardcoded into $test_dir/scripts/*.sh
 export TAO_ROOTDIR="$root_dir"
 export TAO_USE_TPM="$test_tpm"
+export TAO_CHANNEL_TYPE="$tao_channel_type"
+export TAO_FACTORY_TYPE="$tao_factory_type"
+export TAO_COREOS_IMAGE="$coreos_img"
+export TAO_SSH_KEYS="$ssh_keys"
 
 # Flags for tao programs
 export TAO_config_path="${test_dir}/tao.config"
 export TAO_guard="$test_guard"
 
 # Flags for tao_admin
 export TAO_ADMIN_pass="BogusPass"
 
 # Flags for linux_host
 export TAO_HOST_pass="BogusPass"
 export TAO_HOST_root="$test_root"
 export TAO_HOST_stacked="$test_stacked"
 export TAO_HOST_path="${test_dir}/linux_tao_host"
+export TAO_HOST_channel_type="$child_channel_type"
+export TAO_HOST_channel_socket_path="${test_dir}/linux_tao_host"
 
 # Flags for glog
 export GLOG_v=2
 export GLOG_logtostderr="no"
 export GLOG_alsologtostderr="no"
 export GLOG_stderrthreshold=3 # Only log FATAL to stderr.
 export GLOG_log_dir="\${TAO_TEST}/logs"
 
 # Misc.
 export TAO_HOSTED_PROGRAMS="
-\${TAO_TEST}/bin/demo 
+\${TAO_TEST}/bin/demo_client
 \${TAO_TEST}/bin/demo_server
-\${TAO_TEST}/bin/client 
-\${TAO_TEST}/bin/server 
-\${TAO_TEST}/bin/fclient 
-\${TAO_TEST}/bin/fserver 
-\${TAO_TEST}/bin/http_echo_server 
-\${TAO_TEST}/bin/https_echo_server 
+\${TAO_TEST}/bin/linux_host
 "
 
 # BEGIN SETUP VARIABLES
 # These variables come from $test_dir/scripts/setup.sh
 export GOOGLE_HOST_TAO=""
+export GOOGLE_HOST_TAO_TYPE="$tao_channel_type"
 # END SETUP VARIABLES
 END
 
 if [ "$verbose" == "yes" ]; then
 	cat <<END
 Done installing. 
   $test_dir/bin               # Link to ${GOPATH}/bin.
   $test_dir/logs              # Log files.
   $test_dir/scripts           # Useful scripts.
   $test_dir/tao.env           # Environment variables.
 Typical next steps:
   cd $test_dir/
   ./scripts/setup.sh          # Create keys, hashes, ACLs, etc.
   ./scripts/start.sh          # Run Tao CA and Linux Tao server.
   ./scripts/host.sh demo      # Run a client/server demo test.
   ./scripts/stop.sh           # Kill all Tao programs.
   ./scripts/refresh.sh        # Refresh hashes, ACLs, etc.
 Run $test_dir/scripts/help.sh for more info.
 END
 fi
@@ -214,40 +257,41 @@ function extract_pid()
 # e.g. shortname long_binary_filename ==> long_binary_fil
 function shortname()
 {
 	name="$1"
 	echo "\<${name:0:15}\>"
 }
 
 function showenv()
 {
 	cat ${tao_env}
 }
 
 function cleanup()
 {
 	rm -f ${TAO_TEST}/logs/*
 	rm -rf ${TAO_TEST}/{*keys,linux_tao_host,acls,rules,tao.config}
 	sed -i '/^# BEGIN SETUP VARIABLES/,/^# END SETUP VARIABLES/d' ${tao_env}
 	echo "# BEGIN SETUP VARIABLES" >> ${tao_env}
 	echo "# These variables come from ${TAO_TEST}/scripts/setup.sh" >> ${tao_env}
 	echo 'export GOOGLE_HOST_TAO=""' >> ${tao_env}
+	echo 'export GOOGLE_HOST_TAO_TYPE=""' >> ${tao_env}
 	echo "# END SETUP VARIABLES" >> ${tao_env}
 
 	echo "Cleared all Tao configuration data"
 }
 
 function stoptests()
 {
 	echo "Attempting graceful shutdown..."
 	(if linux_host --shutdown; then sleep 1; fi ) 2>/dev/null | grep -v "^Aborted$" || true
 	
 	echo "Checking for remaining Tao services and processes..."
 	# Try to shutdown 
 	killed=0
 	for prog in $all_tao_progs; do
 		if pgrep -lx `shortname "$prog"`; then
 			pkill -x `shortname "$prog"`
 			killed=1
 		fi
 	done
 	if [ $killed -eq 1 ]; then
@@ -256,142 +300,184 @@ function stoptests()
 	else
 		echo "No Tao services or processes remaining"
 	fi
 	rm -f ${TAO_TEST}/linux_tao_host/admin_socket ${TAO_TEST}/*/*_socket
 }
 
 function setup()
 {
 	mkdir -p ${TAO_TEST}/logs
 
 	echo "Creating TaoDomain keys and settings."
 	tao_admin -create -name testing
 
 	# This sets:
 	# $GOOGLE_HOST_TAO # name of underlying host tao, i.e. the TPM (if any)
 	# GOOGLE_TAO_TPM, GOOGLE_TAO_PCRS, # more details about TPM (if any)
 	# and GOOGLE_TAO_LINUX # name of the LinuxHost
 	sed -i '/^# BEGIN SETUP VARIABLES/,/^# END SETUP VARIABLES/d' ${tao_env} 
 	echo "# BEGIN SETUP VARIABLES" >> ${tao_env}
 	echo "# These variables come from ${TAO_TEST}/scripts/setup.sh" >> ${tao_env}
+	echo "export GOOGLE_HOST_TAO_TYPE='${TAO_CHANNEL_TYPE}'" >> ${tao_env}
 
 	if [ "$TAO_USE_TPM" == "yes" ]; then
-        # Don't create a new AIK if one is already present.
-        echo "Checking ${TAO_TEST}/tpm/aikblob"
-        pcr17=`tao_admin -getpcr 17`
-        pcr18=`tao_admin -getpcr 18`
-        if [ ! -f ${TAO_TEST}/tpm/aikblob ]; then
-            echo "Creating TPMTao AIK and settings."
-            rm -rf ${TAO_TEST}/tpm
-            # The genaik program comes from
-            # github.com/google/go-tpm/examples/genaik and must be in
-            # $GOPATH/bin.
-            mkdir -p ${TAO_TEST}/tpm
-            genaik --blob ${TAO_TEST}/tpm/aikblob
-        else
-            echo "Reusing existing TPMTao AIK."
-        fi
-
-        export GOOGLE_HOST_TAO='tao::TPMTao("dir:tpm")'
-        export GOOGLE_TAO_PCRS='PCRs("17,18", "'${pcr17}','${pcr18}'")'
-
-        tprin=`tao_admin -aikblob ${TAO_TEST}/tpm/aikblob`
-        export GOOGLE_TAO_TPM=$tprin
-
-        # TODO(tmroeder): do this correctly in the Go version once we support
-        # AIK creation.
-        echo "export GOOGLE_HOST_TAO='tao::TPMTao(\"dir:tpm\")'" >> ${tao_env}
-        echo "export GOOGLE_TAO_PCRS='PCRs(\"17,18\", \"${pcr17},${pcr18}\")'" >> ${tao_env}
-        echo "export GOOGLE_TAO_TPM='$tprin'" >> ${tao_env}
+		# Don't create a new AIK if one is already present.
+		echo "Checking ${TAO_TEST}/tpm/aikblob"
+		pcr17=`tao_admin -getpcr 17`
+		pcr18=`tao_admin -getpcr 18`
+		if [ ! -f ${TAO_TEST}/tpm/aikblob ]; then
+			echo "Creating TPMTao AIK and settings."
+			rm -rf ${TAO_TEST}/tpm
+			# The genaik program comes from
+			# github.com/google/go-tpm/examples/genaik and must be in
+			# $GOPATH/bin.
+			mkdir -p ${TAO_TEST}/tpm
+			genaik --blob ${TAO_TEST}/tpm/aikblob
+		else
+			echo "Reusing existing TPMTao AIK."
+			export GOOGLE_HOST_TAO="${TAO_TEST}/tpm"
+			export GOOGLE_TAO_PCRS='PCRs("17,18", "'${pcr17}','${pcr18}'")'
+		fi
+
+		export GOOGLE_HOST_TAO=${TAO_TEST}'/tpm'
+		export GOOGLE_TAO_PCRS='PCRs("17,18", "'${pcr17}','${pcr18}'")'
+
+		tprin=`tao_admin -aikblob ${TAO_TEST}/tpm/aikblob`
+		export GOOGLE_TAO_TPM=$tprin
+
+		# TODO(tmroeder): do this in the Go version once we support AIK
+		# creation.
+		echo "export GOOGLE_HOST_TAO='${TAO_TEST}/tpm'" >> ${tao_env}
+		echo "export GOOGLE_TAO_PCRS='PCRs(\"17,18\", \"${pcr17},${pcr18}\")'" >> ${tao_env}
+		echo "export GOOGLE_TAO_TPM='$tprin'" >> ${tao_env}
 	fi
 
 	echo "Creating LinuxHost keys and settings."
 	rm -rf ${TAOHOST_path}
-	linux_host --create --show=false
+
+	# Set up the CoreOS image and the SSH keys, if any.
+	echo "factory ${TAO_FACTORY_TYPE}"
+	if [ "${TAO_FACTORY_TYPE}" == "coreos" ]; then
+		echo "Copying values '${TAO_COREOS_IMAGE}' and '${TAO_SSH_KEYS}'"
+		cp ${TAO_COREOS_IMAGE} ${TAO_TEST}/coreos.img
+		cp ${TAO_SSH_KEYS} ${TAO_TEST}/auth_ssh_coreos
+	fi
+
+	linux_host --create --show=false --factory_type=${TAO_FACTORY_TYPE}
 	linux_host --show >> ${tao_env}
 
 	echo "# END SETUP VARIABLES" >> ${tao_env}
 
-    echo "Refreshing"
+
+	# In Docker mode, set up Docker containers for each hosted program.
+	if [ "${TAO_FACTORY_TYPE}" != "process" ]; then
+		for prog in ${TAO_HOSTED_PROGRAMS}; do
+			if [ "$prog" == "${TAO_TEST}/bin/linux_host" -a "${TAO_FACTORY_TYPE}" == "coreos" ]; then
+				builddocker $prog file
+			else
+				builddocker $prog unix
+			fi
+		done
+	fi
+
+	echo "Refreshing"
 	refresh
+
 }
 
 function refresh()
 {
 	source ${tao_env}
 
 	# Set up default execution policy.
 	tao_admin -clear
 	if [ "${TAO_guard}" == "Datalog" ]; then
 		# Rule for TPM and PCRs combinations that make for a good OS
 		tao_admin -add "(forall S: forall TPM: forall PCRs: TrustedPlatform(TPM) and TrustedKernelPCRs(PCRs) and Subprin(S, TPM, PCRs) implies TrustedOS(S))"
-		# Rule for OS and program hash that make for a good hosted program
+		# Rule for OS and program hash that make for a good hosted
+		# program
 		tao_admin -add "(forall P: forall OS: forall Hash: TrustedOS(OS) and TrustedProgramHash(Hash) and Subprin(P, OS, Hash) implies MemberProgram(P))"
 		# Rule for programs that can execute
 		tao_admin -add "(forall P: MemberProgram(P) implies Authorized(P, \"Execute\"))"
 		# Rule for programs with Args subprincipals
 		tao_admin -add "(forall Y: forall P: forall S: MemberProgram(P) and TrustedArgs(S) and Subprin(Y, P, S) implies Authorized(Y, \"Execute\"))"
+		# Rule for Docker containers: trusted containers can be swapped
+		# in for trusted programs they contain.
+		tao_admin -add "(forall C: forall P: TrustedProgramHash(P) and TrustedContainer(C) and Contains(C, P) implies TrustedProgramHash(C))"
 		# Add the TPM keys, PCRs, and/or LinuxHost keys
 		if [ "$TAO_USE_TPM" == "yes" ]; then
 			tao_admin -add 'TrustedPlatform('${GOOGLE_TAO_TPM}')'
 			# Escape the spaces and quotes in the string so it can be passed as
 			# a single argument to tao_admin
 			trustedpcrs=`echo 'TrustedKernelPCRs(ext.'${GOOGLE_TAO_PCRS}')' | sed 's/ /\\ /g' | sed 's/"/\\"/g'`
 			tao_admin -add "$trustedpcrs"
 		else
 			tao_admin -add 'TrustedOS('${GOOGLE_TAO_LINUX}')'
 		fi
 		# Add the program hashes, assuming LinuxHost and LinuxProcessFactory.
 		for prog in ${TAO_HOSTED_PROGRAMS}; do
 			if [ -f "$prog" ]; then
 				proghash=`tao_admin -quiet -getprogramhash "$prog"`
 				tao_admin -add 'TrustedProgramHash(ext'${proghash}')'
 				tao_admin -add 'TrustedArgs(ext.Args("'$prog'"))'
 				tao_admin -add 'TrustedArgs(ext.Args("'$prog'", "-ca=localhost:8124"))'
+
+				if [ "${TAO_USE_DOCKER}" == "yes" ]; then
+					base_prog=`basename $prog`
+					imghash=`tao_admin -quiet -getcontainerhash "${base_prog}.img.tgz"`
+					tao_admin -add 'TrustedContainer(ext'${imghash}')'
+					tao_admin -add 'Contains(ext'${imghash}', ext'${proghash}')'
+					tao_admin -add 'TrustedArgs(ext.Args("/'${base_prog}'"))'
+				fi
 			fi
 		done
 	else
 		for prog in ${TAO_HOSTED_PROGRAMS}; do
 			if [ -f "$prog" ]; then
 				tao_admin -canexecute "$prog"
 			fi
 		done
 	fi
+
+	# Always have a rules file, even if it's empty.
+	if [ ! -f "${TAO_TEST}/rules" ]; then
+		touch ${TAO_TEST}/rules
+	fi
 	tao_admin -show
 
 	# TODO(kwalsh) set up fserver user ACLs here.
 	#tao_admin -newusers tmroeder,jlm
 	#tao_admin -signacl ${TAO_ROOTDIR}/run/acls.ascii -acl_sig_path user_acls_sig
 	#mkdir -p file_client_files
 	#mkdir -p file_server_files
 	#mkdir -p file_server_meta
 
 	echo "Tao configuration is ready"
 }
 
 function startsvcs()
 {
 	if pgrep -x `shortname linux_host` >/dev/null; then
 		echo "LinuxHost service already running";
 	else
 		rm -f ${TAO_TEST}/linux_tao_host/admin_socket
-		linux_host --service &
+		linux_host --factory_type=${TAO_FACTORY_TYPE} --service &
 	fi
 }
 
 function monitor()
 {
 	echo "Monitoring Tao files..."
 	(
 		cd ${TAO_TEST}
 		while true; do
 			inotifywait -e modify -e delete -e attrib $watchfiles >/dev/null 2>&1
 			echo "Files have changed, waiting for quiet..."
 			sleep 1
 			while inotifywait -t 3 -e modify -e delete -e attrib $watchfiles >/dev/null 2>&1; do
 				echo "Still waiting for quiet..."
 				sleep 1
 			done
 			echo "Restarting Tao services..."
 			refresh
 			stoptests
 			startsvcs
@@ -486,46 +572,94 @@ function testpgm()
 			tail -f $GLOG_log_dir/https_echo_server.INFO &
 			tail_pid=$!
 			sleep 1
 			read -p "Press enter to kill https echo server..."
 			echo "Killing cloudproxy https echo server..."
 			kill $server_pid 2>/dev/null
 			sleep 2
 			kill $tail_pid 2>/dev/null
 			;;
 		help|*)
 			echo "Available test programs:"
 			echo "  demo        # a simple demo (run with host.sh)"
 			echo "  server      # cloud client/server test (not ported yet)"
 			echo "  fserver     # file client/server test (not ported yet)"
 			echo "  http        # http echo test (not ported yet)"
 			echo "  https       # https echo test (not ported yet)"
 			;;
 	esac
 }
 
+function builddocker()
+{
+	prog="$1"
+	channel_type="$2"
+	shift
+	base_prog=`basename $prog`
+	channel_name="/tao"
+	if [ "$channel_type" == "file" ]; then
+		channel_name="tao::TaoRPC+tao::FileMessageChannel(/tao)"
+	fi
+
+	# Build an image for the program.
+	# TODO(tmroeder): this is very specific to our current config.
+	tmpd=`mktemp -d`
+	mkdir -p ${tmpd}/bin
+	cp $prog ${tmpd}/bin/$base_prog
+	mkdir ${tmpd}/policy_keys
+	mkdir ${tmpd}/tmp
+	cp ${TAO_TEST}/policy_keys/cert ${tmpd}/policy_keys/cert
+	cp ${TAO_TEST}/tao.* ${tmpd}
+	# If there is already a Dockerfile for this application, then use it.
+	# Otherwise, generate a basic Dockerfile that sets up the necessary
+	# files.
+	if [ -f "${prog}.Dockerfile" ]; then
+		cp ${prog}.Dockerfile ${tmpd}/Dockerfile
+	else
+		cat >${tmpd}/Dockerfile <<EOF
+FROM scratch
+COPY . ${TAO_TEST}
+ADD tmp /tmp
+ENV GOOGLE_HOST_TAO_TYPE $channel_type
+ENV GOOGLE_HOST_TAO $channel_name
+WORKDIR ${TAO_TEST}
+EOF
+	fi
+	tar -C $tmpd -czf ${TAO_TEST}/${base_prog}.img.tgz `ls $tmpd`
+	rm -fr $tmpd
+}
+
 function hostpgm()
 {
 	prog="$1"
 	shift
+
+	config=""
+	if [ "$TAO_FACTORY_TYPE" == "docker" ]; then
+		base_prog=`basename $prog`
+		# In Docker mode, pass the image created at setup time for this
+		# program.
+		config="-docker_img ${TAO_TEST}/${base_prog}.img.tgz"
+	fi
+
 	echo "Starting hosted program $prog ..."
-	prog_id=`linux_host -run -- "$prog" "$@"`
+	prog_id=`linux_host ${config} -run -- "$prog" "$@"`
 	echo "TaoExtension: $prog_id"
 }
 
 case "$(basename $0)" in
 	setup.sh)
 		stoptests
 		cleanup
 		setup
 		;;
 	start.sh)
 		startsvcs
 		;;
 	restart.sh)
 		stoptests
 		startsvcs
 		;;
 	monitor.sh)
 		monitor
 		;;
 	test.sh)
diff --git a/tao/hosted_program_factory.go b/tao/hosted_program_factory.go
new file mode 100644
index 0000000..2cac63f
--- /dev/null
+++ b/tao/hosted_program_factory.go
@@ -0,0 +1,39 @@
+// Copyright (c) 2014, Google Inc.  All rights reserved.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package tao
+
+import (
+	"io"
+
+	"github.com/jlmucb/cloudproxy/tao/auth"
+)
+
+// A HostedProgram is an abstraction of a process, and it is closely related to
+// os/exec.Cmd and github.com/docker/docker/daemon.Container.
+type HostedProgram interface {
+	Start() error
+	Kill() error
+	Stop() error
+	ID() int
+}
+
+// A HostedProgramFactory manages the creation of hosted programs. For example,
+// on Linux, it might create processes using fork, or it might create processes
+// running on docker containers. It might also start a virtual machine
+// containing a new instance of an operating system.
+type HostedProgramFactory interface {
+	MakeSubprin(uint, string) (auth.SubPrin, string, error)
+	Launch(string, []string) (io.ReadWriteCloser, HostedProgram, error)
+}
diff --git a/tao/kvm_coreos_factory.go b/tao/kvm_coreos_factory.go
new file mode 100644
index 0000000..4d38c57
--- /dev/null
+++ b/tao/kvm_coreos_factory.go
@@ -0,0 +1,387 @@
+// Copyright (c) 2014, Google Inc.  All rights reserved.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package tao
+
+import (
+	"bufio"
+	"crypto/rand"
+	"crypto/sha256"
+	"encoding/hex"
+	"fmt"
+	"io"
+	"io/ioutil"
+	"log"
+	"net"
+	"os"
+	"os/exec"
+	"path"
+	"strconv"
+	"sync"
+	"syscall"
+	"time"
+
+	"code.google.com/p/go.crypto/ssh"
+	"code.google.com/p/go.crypto/ssh/agent"
+
+	"github.com/jlmucb/cloudproxy/tao/auth"
+	"github.com/jlmucb/cloudproxy/util"
+)
+
+// A CoreOSConfig contains the details needed to start a new CoreOS VM.
+type CoreOSConfig struct {
+	Name       string
+	ImageFile  string
+	SSHPort    int
+	Memory     int
+	RulesPath  string
+	SSHKeysCfg string
+	SocketPath string
+}
+
+// A KVMCoreOSContainer is a simple wrapper for CoreOS running on KVM. It uses
+// os/exec.Cmd to send commands to QEMU/KVM to start CoreOS then uses SSH to
+// connect to CoreOS to start the LinuxHost there with a virtio-serial
+// connection for its communication with the Tao running on Linux in the guest.
+// This use of os/exec is to avoid having to rewrite or hook into libvirt for
+// now.
+type KvmCoreOSContainer struct {
+	Cfg            *CoreOSConfig
+	DockerHostFile string
+	Args           []string
+	QCmd           *exec.Cmd
+}
+
+// Kill sends a SIGKILL signal to a QEMU instance.
+func (kcc *KvmCoreOSContainer) Kill() error {
+	// Kill the qemu command directly.
+	// TODO(tmroeder): rewrite this using qemu's communication/management
+	// system; sending SIGKILL is definitely not the right way to do this.
+	return kcc.QCmd.Process.Kill()
+}
+
+// Start starts a QEMU/KVM CoreOS container using the command line.
+func (kcc *KvmCoreOSContainer) Start() error {
+	// Create a temporary directory for the config drive.
+	td, err := ioutil.TempDir("", "coreos")
+	if err != nil {
+		return err
+	}
+	// TODO(tmroeder): save this path and remove it on Stop/Kill.
+	// defer os.RemoveAll(td)
+
+	// Create a temporary directory for the LinuxHost Docker image.
+	td_docker, err := ioutil.TempDir("", "coreos_docker")
+	if err != nil {
+		return err
+	}
+	// TODO(tmroeder): save this path and remove it on Stop/Kill.
+	// defer os.RemoveAll(td_docker)
+	linuxHostImage, err := ioutil.ReadFile(kcc.DockerHostFile)
+	if err != nil {
+		return err
+	}
+	linuxHostPath := path.Join(td_docker, "img")
+	if err := ioutil.WriteFile(linuxHostPath, linuxHostImage, 0700); err != nil {
+		return err
+	}
+
+	latestDir := path.Join(td, "openstack/latest")
+	if err := os.MkdirAll(latestDir, 0700); err != nil {
+		return err
+	}
+
+	cfg := kcc.Cfg
+	userData := path.Join(latestDir, "user_data")
+	if err := ioutil.WriteFile(userData, []byte(cfg.SSHKeysCfg), 0700); err != nil {
+		return err
+	}
+
+	// Copy the rules into the mirrored filesystem for use by the Linux host
+	// on CoreOS.
+	rules, err := ioutil.ReadFile(cfg.RulesPath)
+	if err != nil {
+		return err
+	}
+	rulesFile := path.Join(latestDir, "rules")
+	if err := ioutil.WriteFile(rulesFile, []byte(rules), 0700); err != nil {
+		return err
+	}
+
+	qemuProg := "qemu-system-x86_64"
+	qemuArgs := []string{"-name", cfg.Name,
+		"-m", strconv.Itoa(cfg.Memory),
+		"-machine", "accel=kvm:tcg",
+		// Networking.
+		"-net", "nic,vlan=0,model=virtio",
+		"-net", "user,vlan=0,hostfwd=tcp::" + strconv.Itoa(cfg.SSHPort) + "-:22,hostname=" + cfg.Name,
+		// Tao communications through virtio-serial. With this
+		// configuration, QEMU waits for a server on cfg.SocketPath,
+		// then connects to it.
+		"-chardev", "socket,path=" + cfg.SocketPath + ",id=port0-char",
+		"-device", "virtio-serial",
+		"-device", "virtserialport,id=port1,name=tao,chardev=port0-char",
+		// The CoreOS image to boot from.
+		"-drive", "if=virtio,file=" + cfg.ImageFile,
+		// A Plan9P filesystem for SSH configuration (and our rules).
+		"-fsdev", "local,id=conf,security_model=none,readonly,path=" + td,
+		"-device", "virtio-9p-pci,fsdev=conf,mount_tag=config-2",
+		// Another Plan9P filesystem for the Docker files.
+		"-fsdev", "local,id=tao,security_model=none,readonly,path=" + td_docker,
+		"-device", "virtio-9p-pci,fsdev=tao,mount_tag=tao",
+		// Machine config.
+		"-cpu", "host",
+		"-smp", "4",
+		"-nographic"} // for now, we add -nographic explicitly.
+	// TODO(tmroeder): append args later.
+	//qemuArgs = append(qemuArgs, kcc.Args...)
+
+	qemuCmd := exec.Command(qemuProg, qemuArgs...)
+	// Don't connect QEMU/KVM to any of the current input/output channels,
+	// since we'll connect over SSH.
+	//qemuCmd.Stdin = os.Stdin
+	//qemuCmd.Stdout = os.Stdout
+	//qemuCmd.Stderr = os.Stderr
+	kcc.QCmd = qemuCmd
+	return kcc.QCmd.Start()
+}
+
+// Stop sends a SIGSTOP signal to a docker container.
+func (kcc *KvmCoreOSContainer) Stop() error {
+	// Stop the QEMU/KVM process with SIGSTOP.
+	// TODO(tmroeder): rewrite this using qemu's communication/management
+	// system; sending SIGSTOP is definitely not the right way to do this.
+	return kcc.QCmd.Process.Signal(syscall.SIGSTOP)
+}
+
+// ID returns a numeric ID for this container. For now, this ID is 0.
+func (kcc *KvmCoreOSContainer) ID() int {
+	return 0
+}
+
+// A LinuxKVMCoreOSFactory manages hosted programs started as QEMU/KVM
+// instances over a given CoreOS image.
+type LinuxKVMCoreOSFactory struct {
+	Cfg            *CoreOSConfig
+	SocketPath     string
+	DockerHostFile string
+	NextSSHPort    int
+	Mutex          sync.Mutex
+}
+
+// NewLinuxKVMCoreOSFactory returns a new HostedProgramFactory that can
+// create docker containers to wrap programs.
+func NewLinuxKVMCoreOSFactory(sockPath, dockerPath string, cfg *CoreOSConfig) HostedProgramFactory {
+	return &LinuxKVMCoreOSFactory{
+		Cfg:            cfg,
+		SocketPath:     sockPath,
+		DockerHostFile: dockerPath,
+		// The first SSH port is the port from the incoming config.
+		NextSSHPort: cfg.SSHPort,
+	}
+}
+
+// CloudConfigFromSSHKeys converts an ssh authorized-keys file into a format
+// that can be used by CoreOS to authorize incoming SSH connections over the
+// Plan9P-mounted filesystem it uses.
+func CloudConfigFromSSHKeys(keysFile string) (string, error) {
+	sshKeys := "#cloud-config\nssh_authorized_keys:"
+	sshFile, err := os.Open(keysFile)
+	if err != nil {
+		return "", err
+	}
+	scanner := bufio.NewScanner(sshFile)
+	for scanner.Scan() {
+		sshKeys += "\n - " + scanner.Text()
+	}
+
+	return sshKeys, nil
+}
+
+// MakeSubprin computes the hash of a QEMU/KVM CoreOS image to get a
+// subprincipal for authorization purposes.
+func (ldcf *LinuxKVMCoreOSFactory) MakeSubprin(id uint, image string) (auth.SubPrin, string, error) {
+	var empty auth.SubPrin
+	// TODO(tmroeder): the combination of TeeReader and ReadAll doesn't seem
+	// to copy the entire image, so we're going to hash in place for now.
+	// This needs to be fixed to copy the image so we can avoid a TOCTTOU
+	// attack.
+	b, err := ioutil.ReadFile(image)
+	if err != nil {
+		return empty, "", err
+	}
+
+	h := sha256.Sum256(b)
+	subprin := FormatCoreOSSubprin(id, h[:])
+	return subprin, image, nil
+}
+
+// FormatCoreOSSubprin produces a string that represents a subprincipal with the
+// given ID and hash.
+func FormatCoreOSSubprin(id uint, hash []byte) auth.SubPrin {
+	var args []auth.Term
+	if id != 0 {
+		args = append(args, auth.Int(id))
+	}
+	args = append(args, auth.Bytes(hash))
+	return auth.SubPrin{auth.PrinExt{Name: "CoreOS", Arg: args}}
+}
+
+func getRandomFileName(n int) string {
+	// Get a random name for the socket.
+	nameBytes := make([]byte, n)
+	if _, err := rand.Read(nameBytes); err != nil {
+		return ""
+	}
+	return hex.EncodeToString(nameBytes)
+}
+
+var nameLen = 10
+
+// Launch launches a QEMU/KVM CoreOS instance, connects to it with SSH to start
+// the LinuxHost on it, and returns the socket connection to that host.
+func (lkcf *LinuxKVMCoreOSFactory) Launch(imagePath string, args []string) (io.ReadWriteCloser, HostedProgram, error) {
+	// Build the new Config and start it. Make sure it has a random name so
+	// it doesn't conflict with other virtual machines. Note that we need to
+	// assign fresh local SSH ports for each new virtual machine, hence the
+	// mutex and increment operation.
+	sockName := getRandomFileName(nameLen)
+	sockPath := path.Join(lkcf.SocketPath, sockName)
+
+	lkcf.Mutex.Lock()
+	sshPort := lkcf.NextSSHPort
+	lkcf.NextSSHPort += 1
+	lkcf.Mutex.Unlock()
+
+	cfg := &CoreOSConfig{
+		Name:       getRandomFileName(nameLen),
+		ImageFile:  imagePath,
+		SSHPort:    sshPort,
+		Memory:     lkcf.Cfg.Memory,
+		RulesPath:  lkcf.Cfg.RulesPath,
+		SSHKeysCfg: lkcf.Cfg.SSHKeysCfg,
+		SocketPath: sockPath,
+	}
+
+	// Create a new docker image from the filesystem tarball, and use it to
+	// build a container and launch it.
+	kcc := &KvmCoreOSContainer{
+		Cfg:            cfg,
+		DockerHostFile: lkcf.DockerHostFile,
+		Args:           args,
+	}
+
+	// Create the listening server before starting the connection. This lets
+	// QEMU start right away. See the comments in Start, above, for why this
+	// is.
+	rwc := util.NewUnixSingleReadWriteCloser(cfg.SocketPath)
+	if err := kcc.Start(); err != nil {
+		return nil, nil, err
+	}
+
+	// We need some way to wait for the socket to open before we can connect
+	// to it and return the ReadWriteCloser for communication. Also we need
+	// to connect by SSH to the instance once it comes up properly. For now,
+	// we just wait for a timeout before trying to connect and listen.
+	tc := time.After(10 * time.Second)
+
+	// TODO(tmroeder): for now, this program expects to find SSH_AUTH_SOCK
+	// in its environment so it can connect to the local ssh-agent for ssh
+	// keys. In the future, this will need to be configured better.
+	agentPath := os.ExpandEnv("$SSH_AUTH_SOCK")
+	if agentPath == "" {
+		return nil, nil, fmt.Errorf("couldn't find agent socket in the environment.\n")
+	}
+
+	// TODO(tmroeder): the right way to do this is to first set up a docker
+	// container for LinuxHost so it can run directly on CoreOS. Then add it
+	// to the config directory and make it part of the name. Then start it
+	// with a docker command and hook up /dev/tao directly to it. For
+	// initial testing, though, we'll try to set up the virtual machine and
+	// run a simple command on it, then fail.
+	log.Printf("Found agent socket path '%s'\n", agentPath)
+	agentSock, err := net.Dial("unix", agentPath)
+	if err != nil {
+		return nil, nil, fmt.Errorf("Couldn't connect to agent socket '%s': %s\n", agentPath, err)
+	}
+	ag := agent.NewClient(agentSock)
+
+	// Set up an ssh client config to use to connect to CoreOS.
+	conf := &ssh.ClientConfig{
+		// The CoreOS user for the SSH keys is currently always 'core'.
+		User: "core",
+		Auth: []ssh.AuthMethod{ssh.PublicKeysCallback(ag.Signers)},
+	}
+
+	log.Println("Waiting for at most 10 seconds before trying to connect")
+	<-tc
+
+	hostPort := net.JoinHostPort("localhost", strconv.Itoa(sshPort))
+	client, err := ssh.Dial("tcp", hostPort, conf)
+	if err != nil {
+		return nil, nil, fmt.Errorf("couldn't dial '%s'\n", hostPort)
+	}
+
+	// We need to run a set of commands to set up the LinuxHost as a docker
+	// container on the remote system.
+	// Mount the filesystem.
+	mount, err := client.NewSession()
+	mount.Stdout = os.Stdout
+	mount.Stderr = os.Stderr
+	if err != nil {
+		return nil, nil, fmt.Errorf("couldn't establish a mount session on SSH: %s\n", err)
+	}
+	if err := mount.Run("sudo mkdir /media/tao && sudo mount -t 9p -o trans=virtio,version=9p2000.L tao /media/tao"); err != nil {
+		return nil, nil, fmt.Errorf("couldn't mount the tao filesystem on the guest: %s\n", err)
+	}
+	mount.Close()
+
+	// Build the container.
+	build, err := client.NewSession()
+	build.Stdout = os.Stdout
+	build.Stderr = os.Stderr
+	if err != nil {
+		return nil, nil, fmt.Errorf("couldn't establish a build session on SSH: %s\n", err)
+	}
+	if err := build.Run("sudo cat /media/tao/img | sudo docker build -t tao -"); err != nil {
+		return nil, nil, fmt.Errorf("couldn't build the tao linux_host docker image on the guest: %s\n", err)
+	}
+	build.Close()
+
+	// Create the linux_host on the container.
+	//	create, err := client.NewSession()
+	//	create.Stdout = os.Stdout
+	//	create.Stderr = os.Stderr
+	//	if err != nil {
+	//		return nil, nil, fmt.Errorf("couldn't establish a create session on SSH: %s\n", err)
+	//	}
+	//	if err := create.Run("sudo docker run --privileged=true -v /dev/virtio-ports/tao:/tao -v /media/configvirtfs/openstack/latest/rules:/home/tmroeder/src/github.com/jlmucb/cloudproxy/test/rules tao ./bin/linux_host --create --stacked"); err != nil {
+	//		return nil, nil, fmt.Errorf("couldn't start linux_host on the guest: %s\n", err)
+	//	}
+	//	create.Close()
+
+	// Start the linux_host on the container.
+	start, err := client.NewSession()
+	start.Stdout = os.Stdout
+	start.Stderr = os.Stderr
+	if err != nil {
+		return nil, nil, fmt.Errorf("couldn't establish a start session on SSH: %s\n", err)
+	}
+	if err := start.Run("sudo docker run -d --name=\"linux_host\" --privileged=true -v /dev/virtio-ports/tao:/tao -v /media/configvirtfs/openstack/latest/rules:/home/tmroeder/src/github.com/jlmucb/cloudproxy/test/rules tao ./bin/linux_host --service --stacked"); err != nil {
+		return nil, nil, fmt.Errorf("couldn't start linux_host on the guest: %s\n", err)
+	}
+	start.Close()
+
+	return rwc, kcc, nil
+}
diff --git a/tao/linux_docker_container_factory.go b/tao/linux_docker_container_factory.go
new file mode 100644
index 0000000..5eed0f8
--- /dev/null
+++ b/tao/linux_docker_container_factory.go
@@ -0,0 +1,184 @@
+// Copyright (c) 2014, Google Inc.  All rights reserved.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package tao
+
+import (
+	"crypto/sha256"
+	"io"
+	"io/ioutil"
+	"log"
+	"os"
+	"os/exec"
+	"path"
+
+	"github.com/jlmucb/cloudproxy/tao/auth"
+	"github.com/jlmucb/cloudproxy/util"
+)
+
+// A DockerContainer is a simple wrapper for Docker containers. It uses
+// os/exec.Cmd to send commands to the Docker daemon rather than using the
+// docker client API directly. This is so that this code doesn't depend on the
+// docker code for now.
+type DockerContainer struct {
+	ContainerName string
+	ImageName     string
+	SocketPath    string
+	RulesPath     string
+	Args          []string
+}
+
+// Kill sends a SIGKILL signal to a docker container.
+func (dc *DockerContainer) Kill() error {
+	c := exec.Command("docker", "kill", dc.ContainerName)
+	return c.Run()
+}
+
+// Start starts a docker container using the docker run subcommand.
+func (dc *DockerContainer) Start() error {
+	cmdArgs := []string{"run", "--rm=true",
+		"-v", dc.RulesPath + ":" + dc.RulesPath,
+		"-v", dc.SocketPath + ":/tao"}
+	// The arguments for Docker are arguments directly to Docker. To add
+	// arguments to an application, set up a Dockerfile for this
+	// application.
+	cmdArgs = append(cmdArgs, dc.Args...)
+	cmdArgs = append(cmdArgs, dc.ImageName)
+	c := exec.Command("docker", cmdArgs...)
+	c.Stdout = os.Stdout
+	c.Stderr = os.Stderr
+	return c.Start()
+}
+
+// Stop sends a SIGSTOP signal to a docker container.
+func (dc *DockerContainer) Stop() error {
+	c := exec.Command("docker", "kill", "-s", "STOP", dc.ContainerName)
+	return c.Run()
+}
+
+// ID returns a numeric ID for this docker container. For now, this ID is 0.
+func (dc *DockerContainer) ID() int {
+	return 0
+}
+
+// Build uses the provided path to a tar file to build a Docker image.
+func (dc *DockerContainer) Build(tarPath string) error {
+	tarFile, err := os.Open(tarPath)
+	if err != nil {
+		return err
+	}
+	defer tarFile.Close()
+
+	buildCmd := exec.Command("docker", "build", "-t", dc.ImageName, "-q", "-")
+	buildCmd.Stdin = tarFile
+	if err := buildCmd.Run(); err != nil {
+		return err
+	}
+
+	return nil
+}
+
+// A LinuxDockerContainerFactory manages hosted programs started as docker
+// containers over a given docker image.
+type LinuxDockerContainerFactory struct {
+	SocketPath string
+	RulesPath  string
+}
+
+// NewLinuxDockerContainerFactory returns a new HostedProgramFactory that can
+// create docker containers to wrap programs.
+func NewLinuxDockerContainerFactory(sockPath, rulesPath string) HostedProgramFactory {
+	return &LinuxDockerContainerFactory{
+		SocketPath: sockPath,
+		RulesPath:  rulesPath,
+	}
+}
+
+// MakeSubprin computes the hash of a docker container to get a subprincipal for
+func (ldcf *LinuxDockerContainerFactory) MakeSubprin(id uint, image string) (auth.SubPrin, string, error) {
+	var empty auth.SubPrin
+	// To avoid a time-of-check-to-time-of-use error, we copy the file
+	// bytes to a temp file as we read them. This temp-file path is
+	// returned so it can be used to start the docker container.
+	td, err := ioutil.TempDir("/tmp", "cloudproxy_linux_docker_container")
+	if err != nil {
+		return empty, "", err
+	}
+
+	temppath := path.Join(td, "image")
+	tf, err := os.OpenFile(temppath, os.O_CREATE|os.O_RDWR, 0700)
+	defer tf.Close()
+	if err != nil {
+		return empty, "", err
+	}
+
+	inf, err := os.Open(image)
+	defer inf.Close()
+	if err != nil {
+		return empty, "", err
+	}
+
+	// Read from the input file and write to the temp file.
+	tr := io.TeeReader(inf, tf)
+	b, err := ioutil.ReadAll(tr)
+	if err != nil {
+		return empty, "", err
+	}
+
+	h := sha256.Sum256(b)
+	subprin := FormatDockerSubprin(id, h[:])
+	return subprin, temppath, nil
+}
+
+// FormatDockerSubprin produces a string that represents a subprincipal with the
+// given ID and hash.
+func FormatDockerSubprin(id uint, hash []byte) auth.SubPrin {
+	var args []auth.Term
+	if id != 0 {
+		args = append(args, auth.Int(id))
+	}
+	args = append(args, auth.Bytes(hash))
+	return auth.SubPrin{auth.PrinExt{Name: "Container", Arg: args}}
+}
+
+// Launch builds a docker container from a tar file and launches it with the
+// given arguments.
+func (ldcf *LinuxDockerContainerFactory) Launch(tarPath string, args []string) (io.ReadWriteCloser, HostedProgram, error) {
+	sockName := getRandomFileName(nameLen)
+	sockPath := path.Join(ldcf.SocketPath, sockName)
+
+	// Create a new docker image from the filesystem tarball, and use it to
+	// build a container and launch it.
+	dc := &DockerContainer{
+		ImageName:  getRandomFileName(nameLen),
+		SocketPath: sockPath,
+		RulesPath:  ldcf.RulesPath,
+		Args:       args,
+	}
+	rwc := util.NewUnixSingleReadWriteCloser(sockPath)
+	log.Printf("Building image from path %s\n", tarPath)
+	if err := dc.Build(tarPath); err != nil {
+		rwc.Close()
+		return nil, nil, err
+	}
+
+	log.Printf("Starting docker container\n")
+	if err := dc.Start(); err != nil {
+		rwc.Close()
+		return nil, nil, err
+	}
+	log.Println("Succeeded!")
+
+	return rwc, dc, nil
+}
diff --git a/tao/linux_host.go b/tao/linux_host.go
index 42919cc..270cb94 100644
--- a/tao/linux_host.go
+++ b/tao/linux_host.go
@@ -1,130 +1,134 @@
 // Copyright (c) 2014, Google Inc.  All rights reserved.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
 // You may obtain a copy of the License at
 //
 //     http://www.apache.org/licenses/LICENSE-2.0
 //
 // Unless required by applicable law or agreed to in writing, software
 // distributed under the License is distributed on an "AS IS" BASIS,
 // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
 package tao
 
 import (
 	"io"
-	"os/exec"
+	"log"
 	"sync"
-	"syscall"
 
 	"code.google.com/p/goprotobuf/proto"
 
 	"github.com/golang/glog"
 	"github.com/jlmucb/cloudproxy/tao/auth"
 )
 
 // A LinuxHost is a Tao host environment in which hosted programs are Linux
 // processes. A Unix domain socket accepts administrative commands for
 // controlling the host, e.g., for starting hosted processes, stopping hosted
 // processes, or shutting down the host. A LinuxTao can be run in stacked mode
 // (on top of a host Tao) or in root mode (without an underlying host Tao).
 type LinuxHost struct {
 	path           string
 	guard          Guard
 	taoHost        Host
-	childFactory   LinuxProcessFactory
+	childFactory   HostedProgramFactory
 	hostedPrograms []*LinuxHostChild
 	hpm            sync.RWMutex
 	nextChildID    uint
 	idm            sync.Mutex
 }
 
 // NewStackedLinuxHost creates a new LinuxHost as a hosted program of an existing
 // host Tao.
-func NewStackedLinuxHost(path string, guard Guard, hostTao Tao) (*LinuxHost, error) {
+func NewStackedLinuxHost(path string, guard Guard, hostTao Tao, childFactory HostedProgramFactory) (*LinuxHost, error) {
 	lh := &LinuxHost{
-		path:  path,
-		guard: guard,
+		path:         path,
+		guard:        guard,
+		childFactory: childFactory,
 	}
 
 	// TODO(tmroeder): the TPM Tao currently doesn't support name extensions.
 	if _, ok := hostTao.(*TPMTao); !ok {
 		subprin := guard.Subprincipal()
 		if err := hostTao.ExtendTaoName(subprin); err != nil {
 			return nil, err
 		}
 	}
 
 	k, err := NewOnDiskTaoSealedKeys(Signing|Crypting|Deriving, hostTao, path, SealPolicyDefault)
 	if err != nil {
 		return nil, err
 	}
 
 	lh.taoHost, err = NewTaoStackedHostFromKeys(k, hostTao)
 	if err != nil {
 		return nil, err
 	}
 
 	return lh, nil
 }
 
 // NewRootLinuxHost creates a new LinuxHost as a standalone Host that can
 // provide the Tao to hosted Linux processes.
-func NewRootLinuxHost(path string, guard Guard, password []byte) (*LinuxHost, error) {
-	lh := &LinuxHost{guard: guard}
+func NewRootLinuxHost(path string, guard Guard, password []byte, childFactory HostedProgramFactory) (*LinuxHost, error) {
+	lh := &LinuxHost{
+		guard:        guard,
+		childFactory: childFactory,
+	}
 	k, err := NewOnDiskPBEKeys(Signing|Crypting|Deriving, password, path, nil)
 	if err != nil {
 		return nil, err
 	}
 
 	lh.taoHost, err = NewTaoRootHostFromKeys(k)
 	if err != nil {
 		return nil, err
 	}
 
 	return lh, nil
 }
 
 // LinuxHostChild holds state associated with a running child program.
 type LinuxHostChild struct {
 	channel      io.ReadWriteCloser
 	ChildSubprin auth.SubPrin
-	Cmd          *exec.Cmd
+	Cmd          HostedProgram
 }
 
 // GetTaoName returns the Tao name for the child.
 func (lh *LinuxHost) GetTaoName(child *LinuxHostChild) auth.Prin {
 	return lh.taoHost.TaoHostName().MakeSubprincipal(child.ChildSubprin)
 }
 
 // ExtendTaoName irreversibly extends the Tao principal name of the child.
 func (lh *LinuxHost) ExtendTaoName(child *LinuxHostChild, ext auth.SubPrin) error {
 	child.ChildSubprin = append(child.ChildSubprin, ext...)
 	return nil
 }
 
 // GetRandomBytes returns a slice of n random bytes for the child.
 func (lh *LinuxHost) GetRandomBytes(child *LinuxHostChild, n int) ([]byte, error) {
+	log.Print("Getting random bytes in the linux host")
 	return lh.taoHost.GetRandomBytes(child.ChildSubprin, n)
 }
 
 // GetSharedSecret returns a slice of n secret bytes for the child.
 func (lh *LinuxHost) GetSharedSecret(child *LinuxHostChild, n int, policy string) ([]byte, error) {
 	// Compute a tag based on the policy identifier and the child's subprin.
 	var tag string
 	switch policy {
 	case SharedSecretPolicyDefault:
 	case SharedSecretPolicyConservative:
 		// We are using a master key-deriving key shared among all
 		// similar LinuxHost instances. For LinuxHost, the default
 		// and conservative policies means any process running the same
 		// program binary as the caller hosted on a similar
 		// LinuxHost.
 		// TODO(kwalsh) conservative policy could include PID or other
 		// child info.
 		tag = policy + "|" + child.ChildSubprin.String()
 	case SharedSecretPolicyLiberal:
 		// The most liberal we can do is allow any hosted process
@@ -203,134 +207,132 @@ func (lh *LinuxHost) Unseal(child *LinuxHostChild, sealed []byte) ([]byte, strin
 
 	return lhsb.Data, policy, nil
 }
 
 // Attest signs a statement on behalf of the child.
 func (lh *LinuxHost) Attest(child *LinuxHostChild, issuer *auth.Prin, time, expiration *int64, stmt auth.Form) (*Attestation, error) {
 	return lh.taoHost.Attest(child.ChildSubprin, issuer, time, expiration, stmt)
 }
 
 // StartHostedProgram starts a new hosted program.
 func (lh *LinuxHost) StartHostedProgram(path string, args []string) (auth.SubPrin, int, error) {
 	lh.idm.Lock()
 	id := lh.nextChildID
 	if lh.nextChildID != 0 {
 		lh.nextChildID++
 	} else {
 		glog.Warning("Running without unique child IDs")
 	}
 	lh.idm.Unlock()
 
-	subprin, temppath, err := lh.childFactory.MakeHostedProgramSubprin(id, path)
+	subprin, temppath, err := lh.childFactory.MakeSubprin(id, path)
 	if err != nil {
 		return auth.SubPrin{}, 0, err
 	}
 
 	// We allow multiple hosted programs with the same subprincipal name,
 	// so we don't check here to make sure that there isn't another program
 	// with the same subprincipal.
 
 	// TODO(tmroeder): do we want to support concurrent updates to policy?
 	// Then we need a lock here, too.
 	hostName := lh.taoHost.TaoHostName()
 	childName := hostName.MakeSubprincipal(subprin)
 	if !lh.guard.IsAuthorized(childName, "Execute", []string{}) {
 		return auth.SubPrin{}, 0, newError("Hosted program %s denied authorization to execute on host %s", subprin, hostName)
 	}
 
-	channel, cmd, err := lh.childFactory.ForkHostedProgram(temppath, args)
+	channel, cmd, err := lh.childFactory.Launch(temppath, args)
 	if err != nil {
 		return auth.SubPrin{}, 0, err
 	}
 	child := &LinuxHostChild{channel, subprin, cmd}
 	go NewLinuxHostTaoServer(lh, child).Serve(channel)
-	pid := child.Cmd.Process.Pid
+	pid := child.Cmd.ID()
 
 	lh.hpm.Lock()
 	lh.hostedPrograms = append(lh.hostedPrograms, child)
 	lh.hpm.Unlock()
 
 	return subprin, pid, nil
 }
 
 // StopHostedProgram stops a running hosted program.
 func (lh *LinuxHost) StopHostedProgram(subprin auth.SubPrin) error {
 	lh.hpm.Lock()
 	defer lh.hpm.Unlock()
 
-	// For Stop, we send SIGTERM
-	sigterm := 15
 	var i int
 	for i < len(lh.hostedPrograms) {
 		lph := lh.hostedPrograms[i]
 		n := len(lh.hostedPrograms)
 		if lph.ChildSubprin.Identical(subprin) {
 			// Close the channel before sending SIGTERM
 			lph.channel.Close()
 
-			if err := syscall.Kill(lph.Cmd.Process.Pid, syscall.Signal(sigterm)); err != nil {
-				glog.Errorf("Couldn't send SIGTERM to process %d, subprincipal %s: %s\n", lph.Cmd.Process.Pid, subprin, err)
+			if err := lph.Cmd.Stop(); err != nil {
+				glog.Errorf("Couldn't stop hosted program %d, subprincipal %s: %s\n", lph.Cmd.ID(), subprin, err)
 			}
 
 			// The order of this array doesn't matter, and we want
 			// to make sure we remove all references to pointers to
 			// LinuxHostServer instances so that they get garbage
 			// collected. So, we implement delete from the slice by
 			// moving elements around.
 			lh.hostedPrograms[i] = lh.hostedPrograms[n-1]
 			lh.hostedPrograms[n-1] = nil
 			lh.hostedPrograms = lh.hostedPrograms[:n-1]
 			i--
 		}
 
 		i++
 	}
 	return nil
 }
 
 // ListHostedPrograms returns a list of running hosted programs.
 func (lh *LinuxHost) ListHostedPrograms() ([]auth.SubPrin, []int, error) {
 	lh.hpm.RLock()
 	subprins := make([]auth.SubPrin, len(lh.hostedPrograms))
 	pids := make([]int, len(lh.hostedPrograms))
 	for i, v := range lh.hostedPrograms {
 		subprins[i] = v.ChildSubprin
-		pids[i] = v.Cmd.Process.Pid
+		pids[i] = v.Cmd.ID()
 	}
 	lh.hpm.RUnlock()
 	return subprins, pids, nil
 }
 
 // KillHostedProgram kills a running hosted program.
 func (lh *LinuxHost) KillHostedProgram(subprin auth.SubPrin) error {
 	lh.hpm.Lock()
 	defer lh.hpm.Unlock()
 	var i int
 	for i < len(lh.hostedPrograms) {
 		lph := lh.hostedPrograms[i]
 		n := len(lh.hostedPrograms)
 		if lph.ChildSubprin.Identical(subprin) {
-			// Close the channel before sending SIGTERM
+			// Close the channel before killing the hosted program.
 			lph.channel.Close()
 
-			if err := lph.Cmd.Process.Kill(); err != nil {
-				glog.Errorf("Couldn't kill process %d, subprincipal %s: %s\n", lph.Cmd.Process.Pid, subprin, err)
+			if err := lph.Cmd.Kill(); err != nil {
+				glog.Errorf("Couldn't kill hosted program %d, subprincipal %s: %s\n", lph.Cmd.ID(), subprin, err)
 			}
 
 			// The order of this array doesn't matter, and we want
 			// to make sure we remove all references to pointers to
 			// LinuxHostServer instances so that they get garbage
 			// collected. So, we implement delete from the slice by
 			// moving elements around.
 			lh.hostedPrograms[i] = lh.hostedPrograms[n-1]
 			lh.hostedPrograms[n-1] = nil
 			lh.hostedPrograms = lh.hostedPrograms[:n-1]
 			i--
 		}
 
 		i++
 	}
 	return nil
 }
 
 // TaoHostName returns the name of the Host used by the LinuxHost.
 func (lh *LinuxHost) TaoHostName() auth.Prin {
diff --git a/tao/linux_host_test.go b/tao/linux_host_test.go
index bd670bb..251cdab 100644
--- a/tao/linux_host_test.go
+++ b/tao/linux_host_test.go
@@ -18,58 +18,58 @@ import (
 	"bytes"
 	"io/ioutil"
 	"os"
 	"testing"
 
 	"github.com/jlmucb/cloudproxy/tao/auth"
 )
 
 func testNewStackedLinuxHost(t *testing.T) (*LinuxHost, string) {
 	tmpdir, err := ioutil.TempDir("/tmp", "test_new_stacked_linux_host")
 	if err != nil {
 		t.Fatal("Couldn't get a temp directory for the new stacked linux host")
 	}
 
 	ft, err := NewFakeTao(auth.NewKeyPrin([]byte("test")), "", nil)
 	if err != nil {
 		t.Fatal("Couldn't create a new fake Tao:", err)
 	}
 
 	tg := LiberalGuard
-	lh, err := NewStackedLinuxHost(tmpdir, &tg, ft)
+	lh, err := NewStackedLinuxHost(tmpdir, &tg, ft, nil)
 	if err != nil {
 		os.RemoveAll(tmpdir)
 		t.Fatal("Couldn't create a new stacked Linux host")
 	}
 
 	return lh, tmpdir
 }
 
 func testNewRootLinuxHost(t *testing.T) (*LinuxHost, string) {
 	tmpdir, err := ioutil.TempDir("/tmp", "test_new_root_linux_host")
 	if err != nil {
 		t.Fatal("Couldn't get a temp directory for the new root linux host")
 	}
 
 	tg := LiberalGuard
 	password := []byte("bad password")
-	lh, err := NewRootLinuxHost(tmpdir, &tg, password)
+	lh, err := NewRootLinuxHost(tmpdir, &tg, password, nil)
 	if err != nil {
 		os.RemoveAll(tmpdir)
 		t.Fatal("Couldn't create a new stacked Linux host")
 	}
 
 	return lh, tmpdir
 }
 
 func TestNewStackedLinuxHost(t *testing.T) {
 	_, td := testNewStackedLinuxHost(t)
 	defer os.RemoveAll(td)
 }
 
 func TestNewRootLinuxHost(t *testing.T) {
 	_, td := testNewRootLinuxHost(t)
 	defer os.RemoveAll(td)
 }
 
 // Test the methods directly instead of testing them across a channel.
 
diff --git a/tao/linux_process_factory.go b/tao/linux_process_factory.go
index 00bbe19..834e8b2 100644
--- a/tao/linux_process_factory.go
+++ b/tao/linux_process_factory.go
@@ -1,136 +1,210 @@
 // Copyright (c) 2014, Google Inc.  All rights reserved.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
 // You may obtain a copy of the License at
 //
 //     http://www.apache.org/licenses/LICENSE-2.0
 //
 // Unless required by applicable law or agreed to in writing, software
 // distributed under the License is distributed on an "AS IS" BASIS,
 // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
 package tao
 
 import (
+	"crypto/rand"
 	"crypto/sha256"
+	"encoding/base64"
+	"fmt"
 	"io"
 	"io/ioutil"
 	"os"
 	"os/exec"
 	"path"
 	"strings"
+	"syscall"
 
 	"github.com/jlmucb/cloudproxy/tao/auth"
 	"github.com/jlmucb/cloudproxy/util"
 )
 
-// In the C++ Tao, these functions are methods on a stateless class. So, in Go,
-// the struct is empty. But we don't make them functions on their own, since we
-// want to support multiple hosted-program factory implementations against an
-// interface in the future.
+// A Process wraps os/exec.Cmd and adds a Kill method to match the HostedProgram
+// interface.
+type Process struct {
+	*exec.Cmd
+}
+
+// Kill kills an os/exec.Cmd process.
+func (p *Process) Kill() error {
+	return p.Process.Kill()
+}
+
+const sigterm = 15
+
+// Stop tries to send SIGTERM to a process.
+func (p *Process) Stop() error {
+	return syscall.Kill(p.Process.Pid, syscall.Signal(sigterm))
+}
+
+// ID returns the PID of the underlying os/exec.Cmd instance.
+func (p *Process) ID() int {
+	return p.Process.Pid
+}
 
 // A LinuxProcessFactory supports methods for creating Linux processes as
-// hosted programs.
-type LinuxProcessFactory struct{}
+// hosted programs. LinuxProcessFactory implements HostedProgramFactory.
+type LinuxProcessFactory struct {
+	channelType string
+	socketPath  string
+}
+
+// NewLinuxProcessFactory creates a LinuxProcessFactory as a
+// HostedProgramFactory.
+func NewLinuxProcessFactory(channelType, socketPath string) HostedProgramFactory {
+	return &LinuxProcessFactory{
+		channelType: channelType,
+		socketPath:  socketPath,
+	}
+}
 
-// FormatHostedProgramSubprin produces a string that represents a subprincipal
-// with the given ID and hash.
-func FormatHostedProgramSubprin(id uint, hash []byte) auth.SubPrin {
+// FormatSubprin produces a string that represents a subprincipal with the given
+// ID and hash.
+func FormatSubprin(id uint, hash []byte) auth.SubPrin {
 	var args []auth.Term
 	if id != 0 {
 		args = append(args, auth.Int(id))
 	}
 	args = append(args, auth.Bytes(hash))
 	return auth.SubPrin{auth.PrinExt{Name: "Program", Arg: args}}
 }
 
-// MakeHostedProgramSubprin computes the hash of a program to get its
-// hosted-program subprincipal. In the process, it copies the program to a
-// temporary file controlled by this code and returns the path to that new
-// binary.
-func (LinuxProcessFactory) MakeHostedProgramSubprin(id uint, prog string) (subprin auth.SubPrin, temppath string, err error) {
+// MakeSubprin computes the hash of a program to get its hosted-program
+// subprincipal. In the process, it copies the program to a temporary file
+// controlled by this code and returns the path to that new binary.
+func (lpf *LinuxProcessFactory) MakeSubprin(id uint, prog string) (subprin auth.SubPrin, temppath string, err error) {
 	// To avoid a time-of-check-to-time-of-use error, we copy the file
 	// bytes to a temp file as we read them. This temp-file path is
 	// returned so it can be used to start the program.
 	td, err := ioutil.TempDir("/tmp", "cloudproxy_linux_host")
 	if err != nil {
 		return
 	}
 
 	temppath = path.Join(td, "hosted_program")
 	tf, err := os.OpenFile(temppath, os.O_CREATE|os.O_RDWR, 0700)
 	defer tf.Close()
 	if err != nil {
 		return
 	}
 
 	inf, err := os.Open(prog)
 	defer inf.Close()
 	if err != nil {
 		return
 	}
 
 	// Read from the input file and write to the temp file.
 	tr := io.TeeReader(inf, tf)
 	b, err := ioutil.ReadAll(tr)
 	if err != nil {
 		return
 	}
 
 	h := sha256.Sum256(b)
-	subprin = FormatHostedProgramSubprin(id, h[:])
+	subprin = FormatSubprin(id, h[:])
 	return
 }
 
-// ForkHostedProgram uses a path and arguments to fork a new process.
-func (LinuxProcessFactory) ForkHostedProgram(prog string, args []string) (io.ReadWriteCloser, *exec.Cmd, error) {
-	// Get a pipe pair for communication with the child.
-	serverRead, clientWrite, err := os.Pipe()
-	if err != nil {
-		return nil, nil, err
-	}
-	defer clientWrite.Close()
+// Use 24 bytes for the socket name.
+const sockNameLen = 24
+
+// Launch uses a path and arguments to fork a new process.
+func (lpf *LinuxProcessFactory) Launch(prog string, args []string) (io.ReadWriteCloser, HostedProgram, error) {
+	var channel io.ReadWriteCloser
+	var extraFiles []*os.File
+	var evar string
+	switch lpf.channelType {
+	case "pipe":
+		// Get a pipe pair for communication with the child.
+		serverRead, clientWrite, err := os.Pipe()
+		if err != nil {
+			return nil, nil, err
+		}
+		defer clientWrite.Close()
 
-	clientRead, serverWrite, err := os.Pipe()
-	if err != nil {
-		serverRead.Close()
-		return nil, nil, err
+		clientRead, serverWrite, err := os.Pipe()
+		if err != nil {
+			serverRead.Close()
+			return nil, nil, err
+		}
+		defer clientRead.Close()
+
+		channel = util.NewPairReadWriteCloser(serverRead, serverWrite)
+		extraFiles = []*os.File{clientRead, clientWrite} // fd 3, fd 4
+
+		// Note: ExtraFiles below ensures readfd=3, writefd=4 in child
+		evar = HostTaoEnvVar + "=tao::TaoRPC+tao::FDMessageChannel(3, 4)"
+	case "unix":
+		// Get a random name for the socket.
+		nameBytes := make([]byte, sockNameLen)
+		if _, err := rand.Read(nameBytes); err != nil {
+			return nil, nil, err
+		}
+		sockName := base64.URLEncoding.EncodeToString(nameBytes)
+		sockPath := path.Join(lpf.socketPath, sockName)
+		channel = util.NewUnixSingleReadWriteCloser(sockPath)
+		if channel == nil {
+			return nil, nil, fmt.Errorf("Couldn't create a new Unix channel\n")
+		}
+		evar = HostTaoEnvVar + "=" + sockPath
+	default:
+		return nil, nil, fmt.Errorf("invalid channel type '%s'\n", lpf.channelType)
 	}
-	defer clientRead.Close()
 
 	env := os.Environ()
-	// Note: ExtraFiles below ensures readfd=3, writefd=4 in child
-	evar := HostTaoEnvVar + "=tao::TaoRPC+tao::FDMessageChannel(3, 4)"
+	// Make sure that the child knows to use the right kind of channel.
+	etvar := HostTaoTypeEnvVar + "=" + lpf.channelType
 	replaced := false
+	replacedType := false
 	for i, pair := range env {
 		if strings.HasPrefix(pair, HostTaoEnvVar+"=") {
 			env[i] = evar
 			replaced = true
 		}
+
+		if strings.HasPrefix(pair, HostTaoTypeEnvVar+"=") {
+			env[i] = etvar
+			replacedType = true
+		}
 	}
 	if !replaced {
 		env = append(env, evar)
 	}
 
-	channel := util.NewPairReadWriteCloser(serverRead, serverWrite)
-	cmd := &exec.Cmd{
-		Path:       prog,
-		Args:       args,
-		Stdin:      os.Stdin,
-		Stdout:     os.Stdout,
-		Stderr:     os.Stderr,
-		Env:        env,
-		ExtraFiles: []*os.File{clientRead, clientWrite}, // fd 3, fd 4
-		// TODO(tmroeder): change the user of the hosted program here.
+	if !replacedType {
+		env = append(env, etvar)
+	}
+
+	cmd := &Process{
+		&exec.Cmd{
+			Path:       prog,
+			Args:       args,
+			Stdin:      os.Stdin,
+			Stdout:     os.Stdout,
+			Stderr:     os.Stderr,
+			Env:        env,
+			ExtraFiles: extraFiles,
+			// TODO(tmroeder): change the user of the hosted program here.
+		},
 	}
 
 	if err := cmd.Start(); err != nil {
 		channel.Close()
 		return nil, nil, err
 	}
 
 	return channel, cmd, nil
 }
diff --git a/tao/net/listener.go b/tao/net/listener.go
index d508b7c..a928b89 100644
--- a/tao/net/listener.go
+++ b/tao/net/listener.go
@@ -29,40 +29,41 @@ import (
 // a connection, it exchanges Tao attestation chains and checks the attestation
 // for the certificate of the client against its tao.Guard. The guard in this
 // case should be the guard of the Tao domain. This listener allows connections
 // from any program that is authorized under the Tao to execute.
 type listener struct {
 	gl         net.Listener
 	guard      tao.Guard
 	verifier   *tao.Verifier
 	delegation *tao.Attestation
 }
 
 // NewTaoListener returns a new Tao-based net.Listener that uses the underlying
 // crypto/tls net.Listener and a tao.Guard to check whether or not connections
 // are authorized.
 func Listen(network, laddr string, config *tls.Config, g tao.Guard, v *tao.Verifier, del *tao.Attestation) (net.Listener, error) {
 	config.ClientAuth = tls.RequireAnyClientCert
 	inner, err := tls.Listen(network, laddr, config)
 	if err != nil {
 		return nil, err
 	}
+
 	return &listener{inner, g, v, del}, nil
 }
 
 // ValidatePeerAttestation checks a tao.Attestation for a given Listener against
 // an X.509 certificate from a TLS channel.
 func ValidatePeerAttestation(a *tao.Attestation, cert *x509.Certificate, guard tao.Guard) error {
 	stmt, err := a.Validate()
 	if err != nil {
 		return err
 	}
 
 	// Insist that the message of the statement be a SpeaksFor and that the
 	// initial term be an auth.Prin of type key. Note that Validate has already
 	// checked the expirations and the times and the general well-formedness of
 	// the attestation.
 	sf, ok := stmt.Message.(auth.Speaksfor)
 	if !ok {
 		return errors.New("a peer attestation must have an auth.Speaksfor as a message")
 	}
 
diff --git a/tao/tao.go b/tao/tao.go
index 7dd66fc..1d43643 100644
--- a/tao/tao.go
+++ b/tao/tao.go
@@ -1,55 +1,57 @@
 // Copyright (c) 2014, Kevin Walsh.  All rights reserved.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
 // You may obtain a copy of the License at
 //
 //     http://www.apache.org/licenses/LICENSE-2.0
 //
 // Unless required by applicable law or agreed to in writing, software
 // distributed under the License is distributed on an "AS IS" BASIS,
 // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
 package tao
 
 import (
+	"fmt"
 	"io"
 	"io/ioutil"
 	"os"
 	"path"
 	"strconv"
 	"strings"
 	"sync"
 
 	"github.com/golang/glog"
 	"github.com/jlmucb/cloudproxy/tao/auth"
 )
 
 // Constants used by the Tao implementations for policy, signing contexts, and
 // environment variables.
 const (
-	HostTaoEnvVar = "GOOGLE_HOST_TAO"
-	TaoTPMEnvVar  = "GOOGLE_TAO_TPM"
-	TaoPCRsEnvVar = "GOOGLE_TAO_PCRS"
+	HostTaoEnvVar     = "GOOGLE_HOST_TAO"
+	HostTaoTypeEnvVar = "GOOGLE_HOST_TAO_TYPE"
+	TaoPCRsEnvVar     = "GOOGLE_TAO_PCRS"
+	TaoTPMEnvVar      = "GOOGLE_TAO_TPM"
 
 	SharedSecretPolicyDefault      = "self"
 	SharedSecretPolicyConservative = "few"
 	SharedSecretPolicyLiberal      = "any"
 
 	SealPolicyDefault      = "self"
 	SealPolicyConservative = "few"
 	SealPolicyLiberal      = "any"
 
 	AttestationSigningContext = "Tao Attestation Signing Context V1"
 )
 
 // Tao is the fundamental Trustworthy Computing interface provided by a host to
 // its hosted programs. Each level of a system can act as a host by exporting
 // the Tao interface and providing Tao services to higher-level hosted programs.
 //
 // In most cases, a hosted program will use a stub Tao that performs RPC over a
 // channel to its host. The details of such RPC depend on the specific
 // implementation of the host: some hosted programs may use pipes to communicate
 // with their host, others may use sockets, etc.
@@ -81,75 +83,93 @@ type Tao interface {
 
 	// Unseal decrypts data that has been sealed by the Seal() operation, but only
 	// if the policy specified during the Seal() operation is satisfied.
 	Unseal(sealed []byte) (data []byte, policy string, err error)
 }
 
 // Cached interface to the host Tao underlying this hosted program.
 var cachedHost Tao
 var cacheOnce sync.Once
 
 // Parent returns the interface to the underlying host Tao. It depends on a
 // specific environment variable being set. On success it memoizes the result
 // before returning it because there should only ever be a single channel to the
 // host. On failure, it logs a message using glog and returns nil.
 // Note: errors are not returned so that, once it is confirmed that Parent
 // returns a non-nil value, callers can use the function result in an
 // expression, e.g.:
 //   name, err := tao.Parent().GetTaoName()
 func Parent() Tao {
 	cacheOnce.Do(func() {
+		hostTypeVar := os.Getenv(HostTaoTypeEnvVar)
 		hostVar := os.Getenv(HostTaoEnvVar)
-		r := strings.TrimPrefix(hostVar, "tao::TPMTao(\"dir:")
-		if r == hostVar {
-			host, err := DeserializeTaoRPC(os.Getenv(HostTaoEnvVar))
-			if err != nil {
-				glog.Error(err)
-				return
-			}
-			cachedHost = host
-		} else {
+		switch hostTypeVar {
+		case "tpm":
 			// TODO(tmroeder): this version assumes that the AIK blob is under
 			// the TPMTao directory as aikblob. This should be specified more
 			// clearly in the environment variables.
-
-			dir := strings.TrimSuffix(r, "\")")
-			aikblob, err := ioutil.ReadFile(path.Join(dir, "aikblob"))
+			aikblob, err := ioutil.ReadFile(path.Join(hostVar, "aikblob"))
 			if err != nil {
+				fmt.Fprintf(os.Stderr, "Couldn't read the aikblob: %s\n", err)
 				glog.Error(err)
 				return
 			}
 
 			taoPCRs := os.Getenv(TaoPCRsEnvVar)
 			pcrStr := strings.TrimPrefix(taoPCRs, "PCRs(\"")
 
 			// This index operation will never panic, since strings.Split always
 			// returns at least one entry in the resulting slice.
 			pcrIntList := strings.Split(pcrStr, "\", \"")[0]
 			pcrInts := strings.Split(pcrIntList, ",")
 			pcrs := make([]int, len(pcrInts))
 			for i, s := range pcrInts {
 				var err error
 				pcrs[i], err = strconv.Atoi(s)
 				if err != nil {
+					fmt.Fprintf(os.Stderr, "Couldn't split the PCRs: %s\n", err)
 					glog.Error(err)
 					return
 				}
 			}
 
 			// TODO(tmroeder): add the tpm device path to the configuration.
 			host, err := NewTPMTao("/dev/tpm0", aikblob, pcrs)
 			if err != nil {
+				fmt.Fprintf(os.Stderr, "Couldn't create a new TPMTao: %s\n", err)
 				glog.Error(err)
 				return
 			}
 
 			cachedHost = host
+		case "pipe":
+			host, err := DeserializeTaoRPC(os.Getenv(HostTaoEnvVar))
+			if err != nil {
+				glog.Error(err)
+				return
+			}
+			cachedHost = host
+		case "file":
+			host, err := DeserializeFileTaoRPC(os.Getenv(HostTaoEnvVar))
+			if err != nil {
+				glog.Error(err)
+				return
+			}
+			cachedHost = host
+		case "unix":
+			host, err := DeserializeUnixSocketTaoRPC(os.Getenv(HostTaoEnvVar))
+			if err != nil {
+				glog.Error(err)
+				return
+			}
+			cachedHost = host
+		default:
+			glog.Errorf("unknown host tao channel type '%s'\n", hostTypeVar)
 		}
 	})
 	return cachedHost
 }
 
 // Hosted returns true iff a host Tao is available via the Parent function.
 func Hosted() bool {
 	return Parent() != nil
 }
diff --git a/tao/tao_rpc.go b/tao/tao_rpc.go
index 543af10..bd72aac 100644
--- a/tao/tao_rpc.go
+++ b/tao/tao_rpc.go
@@ -38,40 +38,73 @@ type TaoRPC struct {
 }
 
 // DeserializeTaoRPC produces a TaoRPC from a string.
 func DeserializeTaoRPC(s string) (*TaoRPC, error) {
 	if s == "" {
 		return nil, newError("taorpc: missing host Tao spec" +
 			" (ensure $" + HostTaoEnvVar + " is set)")
 	}
 	r := strings.TrimPrefix(s, "tao::TaoRPC+")
 	if r == s {
 		return nil, newError("taorpc: unrecognized $" + HostTaoEnvVar + " string " + s)
 	}
 	ms, err := util.DeserializeFDMessageStream(r)
 	if err != nil {
 		return nil, newError("taorpc: unrecognized $" + HostTaoEnvVar + " string " + s +
 			" (" + err.Error() + ")")
 	}
 	return &TaoRPC{protorpc.NewClient(ms), "Tao"}, nil
 }
 
+// DeserializeFileTaoRPC produces a TaoRPC from a string representing a file.
+func DeserializeFileTaoRPC(s string) (*TaoRPC, error) {
+	if s == "" {
+		return nil, newError("taorpc: missing host Tao spec" +
+			" (ensure $" + HostTaoEnvVar + " is set)")
+	}
+	r := strings.TrimPrefix(s, "tao::TaoRPC+")
+	if r == s {
+		return nil, newError("taorpc: unrecognized $" + HostTaoEnvVar + " string " + s)
+	}
+	ms, err := util.DeserializeFileMessageStream(r)
+	if err != nil {
+		return nil, newError("taorpc: unrecognized $" + HostTaoEnvVar + " string " + s +
+			" (" + err.Error() + ")")
+	}
+	return &TaoRPC{protorpc.NewClient(ms), "Tao"}, nil
+}
+
+// DeserializeUnixSocketTaoRPC produces a TaoRPC from a path string.
+func DeserializeUnixSocketTaoRPC(p string) (*TaoRPC, error) {
+	if p == "" {
+		return nil, newError("taorpc: missing host Tao spec" +
+			" (ensure $" + HostTaoEnvVar + " is set)")
+	}
+
+	ms, err := util.DeserializeUnixSocketMessageStream(p)
+	if err != nil {
+		return nil, err
+	}
+
+	return &TaoRPC{protorpc.NewClient(ms), "Tao"}, nil
+}
+
 // NewTaoRPC constructs a TaoRPC for the default gob encoding rpc client using
 // an io.ReadWriteCloser.
 func NewTaoRPC(rwc io.ReadWriteCloser, serviceName string) (*TaoRPC, error) {
 	return &TaoRPC{rpc.NewClient(rwc), serviceName}, nil
 }
 
 type expectedResponse int
 
 const (
 	wantNothing expectedResponse = 0
 	wantData    expectedResponse = 1 << iota
 	wantPolicy
 )
 
 // An ErrMalformedResponse is returned as an error for an invalid response.
 var ErrMalformedResponse = errors.New("taorpc: malformed response")
 
 // call issues an rpc request, obtains the response, checks the response for
 // errors, and checks that the response contains exactly the expected values.
 func (t *TaoRPC) call(method string, r *TaoRPCRequest, e expectedResponse) (data []byte, policy string, err error) {
diff --git a/util/fdmessagestream.go b/util/fdmessagestream.go
index 3e4b233..aae0690 100644
--- a/util/fdmessagestream.go
+++ b/util/fdmessagestream.go
@@ -1,41 +1,74 @@
 // Copyright (c) 2014, Kevin Walsh.  All rights reserved.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
 // You may obtain a copy of the License at
 //
 //     http://www.apache.org/licenses/LICENSE-2.0
 //
 // Unless required by applicable law or agreed to in writing, software
 // distributed under the License is distributed on an "AS IS" BASIS,
 // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
 package util
 
 import (
 	"errors"
 	"fmt"
+	"net"
 	"os"
+	"strings"
 )
 
+// DeserializeFileMessageStream takes a string description of the form
+// "tao::FileMessageChannel(X)" and returns a MessageStream that uses file
+// X to communicate.
+func DeserializeFileMessageStream(s string) (*MessageStream, error) {
+	r := strings.TrimPrefix(s, "tao::FileMessageChannel(")
+	if r == s {
+		return nil, errors.New("unrecognized channel spec " + s)
+	}
+	filename := strings.TrimSuffix(r, ")")
+	if filename == r {
+		return nil, errors.New("unrecognized channel spec " + s)
+	}
+
+	rw, err := os.OpenFile(filename, os.O_RDWR, 0700)
+	if err != nil {
+		return nil, err
+	}
+	return NewMessageStream(rw), nil
+}
+
 // DeserializeFDMessageStream takes a string description of the form
 // "tao::FDMessageStream(X, Y)" and returns a MessageStream that uses file
 // descriptor X as the reader and file descriptor Y as the writer.
 func DeserializeFDMessageStream(s string) (*MessageStream, error) {
 	var readfd, writefd uintptr
 	_, err := fmt.Sscanf(s, "tao::FDMessageChannel(%d, %d)", &readfd, &writefd)
 	if err != nil {
 		return nil, errors.New("unrecognized channel spec " + s)
 	}
 	if readfd == writefd {
 		rw := os.NewFile(readfd, "read/write pipe")
 		return NewMessageStream(rw), nil
 	} else {
 		r := os.NewFile(readfd, "read pipe")
 		w := os.NewFile(writefd, "write pipe")
 		rw := NewPairReadWriteCloser(r, w)
 		return NewMessageStream(rw), nil
 	}
 }
+
+// DeserializeUnixSocketMessageStream takes a string filename and returns a
+// MessageStream that is based on the Unix socket for this file.
+func DeserializeUnixSocketMessageStream(f string) (*MessageStream, error) {
+	conn, err := net.Dial("unix", f)
+	if err != nil {
+		return nil, err
+	}
+
+	return NewMessageStream(conn), nil
+}
diff --git a/util/messagestream.go b/util/messagestream.go
index 07868c9..b8a8d72 100644
--- a/util/messagestream.go
+++ b/util/messagestream.go
@@ -25,88 +25,88 @@ import (
 )
 
 // A MessageStream is an io.ReadWriteCloser that can also read and write strings
 // and protobuf messages. Boundaries are preserved for strings and protobuf
 // messages using a 32-bit (network byte order) length prefix before the
 // contents of the string or marshalled protobuf message. MessageStream can also
 // enforce an upper-limit on the size of received messages.
 type MessageStream struct {
 	MaxMessageSize int // Negative means unlimited
 	io.ReadWriteCloser
 }
 
 const DefaultMaxMessageSize = 20 * 1024 * 1024
 
 var ErrMessageTooLarge = errors.New("messagestream: message is too large")
 
 // WriteString writes a 32-bit length followed by the string.
 func (ms *MessageStream) WriteString(s string) (int, error) {
 	n := len(s)
 	if n > math.MaxUint32 {
-		return 0, Logged(ErrMessageTooLarge)
+		return 0, ErrMessageTooLarge
 	}
 	var sizebytes [4]byte
 	binary.BigEndian.PutUint32(sizebytes[:], uint32(n))
 	n, err := ms.Write(sizebytes[:])
 	if err != nil {
 		return n, Logged(err)
 	}
 	m, err := ms.Write([]byte(s))
 	return n + m, Logged(err)
 }
 
 // ReadString reads a 32-bit length followed by a string.
 func (ms *MessageStream) ReadString() (string, error) {
 	var sizebytes [4]byte
 	_, err := io.ReadFull(ms, sizebytes[:])
 	if err != nil {
-		return "", Logged(err)
+		return "", err
 	}
 	n := binary.BigEndian.Uint32(sizebytes[:])
 	max := ms.MaxMessageSize
 	// We also check for int(n) to overflow so allocation below doesn't fail.
 	if int(n) < 0 || (max > 0 && int(n) > max) {
 		glog.Errorf("String on wire is too large: %d bytes\n", n)
 		return "", Logged(ErrMessageTooLarge)
 	}
 	strbytes := make([]byte, int(n))
 	_, err = io.ReadFull(ms, strbytes)
 	if err != nil {
 		return "", Logged(err)
 	}
 	return string(strbytes), nil
 }
 
 // WriteMessage writes 32-bit length followed by a protobuf message. If m is
 // nil, a blank message is written instead.
 func (ms *MessageStream) WriteMessage(m proto.Message) (int, error) {
 	if m == nil {
 		return ms.WriteString("")
 	}
 	bytes, err := proto.Marshal(m)
 	if err != nil {
 		return 0, Logged(err)
 	}
 	return ms.WriteString(string(bytes))
 }
 
 // ReadMessage reads a 32-bit length followed by a protobuf message. If m is
 // nil, the incoming message is discarded.
 func (ms *MessageStream) ReadMessage(m proto.Message) error {
 	s, err := ms.ReadString()
 	if err != nil {
-		return Logged(err)
+		return err
 	}
 	if m != nil {
 		err = proto.Unmarshal([]byte(s), m)
 		if err != nil {
 			return Logged(err)
 		}
 	}
 	return nil
 }
 
 // NewMessageStream creates a MessageStream for the given pipe with a reception
 // limit of DefaultMaxMessageSize.
 func NewMessageStream(pipe io.ReadWriteCloser) *MessageStream {
 	return &MessageStream{DefaultMaxMessageSize, pipe}
 }
diff --git a/util/protorpc/protorpc.go b/util/protorpc/protorpc.go
index a083da1..4e042f6 100644
--- a/util/protorpc/protorpc.go
+++ b/util/protorpc/protorpc.go
@@ -132,41 +132,44 @@ type serverCodec struct {
 	m       *util.MessageStream
 	sending sync.Mutex
 }
 
 // NewServerCodec returns a new rpc.ServerCodec using protobuf messages on conn.
 func NewServerCodec(conn io.ReadWriteCloser) rpc.ServerCodec {
 	m, ok := conn.(*util.MessageStream)
 	if !ok {
 		// The given conn lacks framing, so add some.
 		m = util.NewMessageStream(conn)
 	}
 	return &serverCodec{m, sync.Mutex{}}
 }
 
 // ReadRequestHeader receives and decodes a net/rpc request header r.
 func (c *serverCodec) ReadRequestHeader(r *rpc.Request) error {
 	// This is almost identical to ReadResponseHeader(), above.
 	var err error
 	var hdr ProtoRPCRequestHeader
 	if err = c.m.ReadMessage(&hdr); err != nil {
-		return util.Logged(err)
+		// Don't log an error here, since this is where normal EOF
+		// happens over net/rpc channels, e.g., if a client finishes and
+		// disconnects.
+		return err
 	}
 	r.Seq = *hdr.Seq
 	r.ServiceMethod = *hdr.Op
 	return nil
 }
 
 // ReadRequestBody receives and decodes a net/rpc request body x.
 func (c *serverCodec) ReadRequestBody(x interface{}) error {
 	// This is almost identical to ReadResponseBody(), above.
 	if x == nil {
 		// rpc.Server is telling us to read and discard the request, perhaps because
 		// response header was read successfully but contained an unexpected service
 		// method string. The client would have encoded an actual message body.
 		_, err := c.m.ReadString()
 		return util.Logged(err)
 	}
 	body, ok := x.(proto.Message)
 	if !ok || body == nil {
 		// TODO(kwalsh) Not clear if this is legal, but I think not.
 		// Read and discard the request body.
diff --git a/util/unix_single_rwc.go b/util/unix_single_rwc.go
new file mode 100644
index 0000000..f4003eb
--- /dev/null
+++ b/util/unix_single_rwc.go
@@ -0,0 +1,79 @@
+// Copyright (c) 2014, Google Inc.  All rights reserved.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package util
+
+import (
+	"fmt"
+	"io"
+	"net"
+	"os"
+)
+
+// A UnixSingleReadWriteCloser accepts a single connection and reads and writes
+// to this connection
+type UnixSingleReadWriteCloser struct {
+	l net.Listener
+	c net.Conn
+}
+
+// NewUnixSingleReadWriteCloser listens on a given Unix socket path and returns
+// a UnixSingleReadWriteCloser that will accept a single connection on this
+// socket and communicate only with it.
+func NewUnixSingleReadWriteCloser(path string) io.ReadWriteCloser {
+	l, err := net.Listen("unix", path)
+	if err != nil {
+		fmt.Fprintf(os.Stderr, "Failed to listen on the channel: %s\n", err)
+		return nil
+	}
+
+	return &UnixSingleReadWriteCloser{l, nil}
+}
+
+// Read accepts a connection if there isn't one already and reads from the
+// connection.
+func (usrwc *UnixSingleReadWriteCloser) Read(p []byte) (int, error) {
+	var err error
+	if usrwc.c == nil {
+		usrwc.c, err = usrwc.l.Accept()
+		if err != nil {
+			return 0, err
+		}
+	}
+
+	return usrwc.c.Read(p)
+}
+
+// Write accepts a connection if there isn't one already and writes to the
+// connection.
+func (usrwc *UnixSingleReadWriteCloser) Write(p []byte) (int, error) {
+	var err error
+	if usrwc.c == nil {
+		usrwc.c, err = usrwc.l.Accept()
+		if err != nil {
+			return 0, err
+		}
+	}
+
+	return usrwc.c.Write(p)
+}
+
+// Close closes the connection if there is one and closes the listener.
+func (usrwc *UnixSingleReadWriteCloser) Close() error {
+	if usrwc.c != nil {
+		usrwc.c.Close()
+	}
+
+	return usrwc.l.Close()
+}
