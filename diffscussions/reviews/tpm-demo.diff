#* 
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-08-26T16:04:21-0700
#* 
#- Add hybrid sealed data and fix the install script to support TPM.
#- 
#- This commit adds support for TPM-based tests using install.sh -tpm.
#- It adds a new hybrid sealing scheme in TPMTao to overcome a limit in the number
#- of bytes that can be sealed in the hardware TPM; to do this, it creates a new
#- key (using Crypter in keys.go), encrypts the data using this key, and seals the
#- serialized key structure as the sealed data. Unseal reverses the operation.
#- 
#- This version also changes the host to not try to extend the name of the Tao in
#- the Stacked LinuxHost when the Tao is TPMTao. This is OK because TPMTao already
#- extends its name with the PCR values, which characterize the Linux OS in
#- question (or at least, they do if we boot from initrd).
#- 
#- 
diff --git a/go/install.sh b/go/install.sh
index cd981ee..709df0d 100755
--- a/go/install.sh
+++ b/go/install.sh
@@ -119,41 +119,41 @@ fi
 cat <<END > "$test_dir/tao.env"
 # Tao/CloudProxy environment variables"
 export TAO_TEST="$test_dir" # Also hardcoded into $test_dir/scripts/*.sh
 export TAO_ROOTDIR="$root_dir"
 export TAO_USE_TPM="$test_tpm"
 
 # Flags for tao programs
 export TAO_config_path="${test_dir}/tao.config"
 export TAO_guard="$test_guard"
 
 # Flags for tao_admin
 export TAO_ADMIN_pass="BogusPass"
 
 # Flags for linux_host
 export TAO_HOST_pass="BogusPass"
 export TAO_HOST_root="$test_root"
 export TAO_HOST_stacked="$test_stacked"
 export TAO_HOST_path="${test_dir}/linux_tao_host"
 
 # Flags for tpm_tao
-export TAO_TPM_path="${test_dir}/tpm "
+export TAO_TPM_path="${test_dir}/tpm"
 export TAO_TPM_pcrs="17, 18"
 
 # Flags for glog
 export GLOG_v=2
 export GLOG_logtostderr="no"
 export GLOG_alsologtostderr="no"
 export GLOG_stderrthreshold=3 # Only log FATAL to stderr.
 export GLOG_log_dir="\${TAO_TEST}/logs"
 
 # Misc.
 export TAO_HOSTED_PROGRAMS="
 \${TAO_TEST}/bin/demo 
 \${TAO_TEST}/bin/demo_server
 \${TAO_TEST}/bin/client 
 \${TAO_TEST}/bin/server 
 \${TAO_TEST}/bin/fclient 
 \${TAO_TEST}/bin/fserver 
 \${TAO_TEST}/bin/http_echo_server 
 \${TAO_TEST}/bin/https_echo_server 
 "
@@ -208,41 +208,41 @@ function extract_pid()
 	echo "$pid"
 }
 
 # return at most the first 15 chars of argument
 # suitable for pgrep -x or pkill -x
 # e.g. shortname long_binary_filename ==> long_binary_fil
 function shortname()
 {
 	name="$1"
 	echo "\<${name:0:15}\>"
 }
 
 function showenv()
 {
 	cat ${tao_env}
 }
 
 function cleanup()
 {
 	rm -f ${TAO_TEST}/logs/*
-	rm -rf ${TAO_TEST}/{*keys,tpm,linux_tao_host,domain_acls,domain_rules,tao.config,user_acls_sig}
+	rm -rf ${TAO_TEST}/{*keys,linux_tao_host,domain_acls,domain_rules,tao.config,user_acls_sig}
 	sed -i '/^# BEGIN SETUP VARIABLES/,/^# END SETUP VARIABLES/d' ${tao_env}
 	echo "# BEGIN SETUP VARIABLES" >> ${tao_env}
 	echo "# These variables come from ${TAO_TEST}/scripts/setup.sh" >> ${tao_env}
 	echo 'export GOOGLE_HOST_TAO=""' >> ${tao_env}
 	echo "# END SETUP VARIABLES" >> ${tao_env}
 
 	echo "Cleared all Tao configuration data"
 }
 
 function stoptests()
 {
 	echo "Attempting graceful shutdown..."
 	(if linux_host --shutdown; then sleep 1; fi ) 2>/dev/null | grep -v "^Aborted$" || true
 	
 	echo "Checking for remaining Tao services and processes..."
 	# Try to shutdown 
 	killed=0
 	for prog in $all_tao_progs; do
 		if pgrep -lx `shortname "$prog"`; then
 			pkill -x `shortname "$prog"`
@@ -257,44 +257,56 @@ function stoptests()
 	fi
 	rm -f ${TAO_TEST}/linux_tao_host/admin_socket ${TAO_TEST}/*/*_socket
 }
 
 function setup()
 {
 	mkdir -p ${TAO_TEST}/logs
 
 	echo "Creating TaoDomain keys and settings."
 	tao_admin -create -name testing
 
 	# This sets:
 	# $GOOGLE_HOST_TAO # name of underlying host tao, i.e. the TPM (if any)
 	# GOOGLE_TAO_TPM, GOOGLE_TAO_PCRS, # more details about TPM (if any)
 	# and GOOGLE_TAO_LINUX # name of the LinuxHost
 	sed -i '/^# BEGIN SETUP VARIABLES/,/^# END SETUP VARIABLES/d' ${tao_env} 
 	echo "# BEGIN SETUP VARIABLES" >> ${tao_env}
 	echo "# These variables come from ${TAO_TEST}/scripts/setup.sh" >> ${tao_env}
 
 	if [ "$TAO_USE_TPM" == "yes" ]; then
-		echo "Creating TPMTao AIK and settings."
-		rm -rf ${TAOTPM_path}
-		tpm_tao --create --show=false
-		tpm_tao --show >> ${tao_env}
+        # Don't create a new AIK if one is already present.
+        echo "Checking ${TAO_TEST}/tpm/aikblob"
+        if [ ! -f ${TAO_TEST}/tpm/aikblob ]; then
+            echo "Creating TPMTao AIK and settings."
+            rm -rf ${TAO_TEST}/tpm
+            tpm_tao --create --show=false
+        else
+            echo "Reusing existing TPMTao AIK."
+            export GOOGLE_HOST_TAO='tao::TPMTao("dir:tpm")'
+            export GOOGLE_TAO_PCRS='PCRs("17, 18", "0, 0")'
+        fi
+
+        # TODO(tmroeder): do this correctly in the Go version once we support
+        # AIK creation.
+        echo "export GOOGLE_HOST_TAO='tao::TPMTao(\"dir:tpm\")'" >> ${tao_env}
+        echo "export GOOGLE_TAO_PCRS='PCRs(\"17, 18\", \"0, 0\")'" >> ${tao_env}
 	fi
 
 	echo "Creating LinuxHost keys and settings."
 	rm -rf ${TAOHOST_path}
 	linux_host --create --show=false
 	linux_host --show >> ${tao_env}
 
 	echo "# END SETUP VARIABLES" >> ${tao_env}
 
 	refresh
 }
 
 function refresh()
 {
 	source ${tao_env}
 
 	# Set up default execution policy.
 	tao_admin -clear
 	if [ "${TAO_GUARD}" == "datalog" ]; then
 		# Rule for TPM and PCRs combinations that make for a good OS
diff --git a/go/src/cloudproxy/linux_host/main.go b/go/src/cloudproxy/linux_host/main.go
index 2d77a9d..79f8003 100644
--- a/go/src/cloudproxy/linux_host/main.go
+++ b/go/src/cloudproxy/linux_host/main.go
@@ -75,62 +75,62 @@ func main() {
 	help += "Usage:\n"
 	help += "%[1]s [options] -create\n"
 	help += "%[1]s [options] -show\n"
 	help += "%[1]s [options] -service\n"
 	help += "%[1]s [options] -shutdown\n"
 	help += "%[1]s [options] -run -- program args...\n"
 	help += "%[1]s [options] -stop -- subprin...\n"
 	help += "%[1]s [options] -kill -- subprin...\n"
 	help += "%[1]s [options] -list\n"
 	help += "%[1]s [options] -name\n"
 	flag.Usage = func() {
 		fmt.Fprintf(os.Stderr, help, os.Args[0])
 		flag.PrintDefaults()
 	}
 	util.UseEnvFlags("GLOG", "TAO", "TAO_HOST")
 	flag.Parse()
 
 	if *quiet {
 		verbose = ioutil.Discard
 	} else {
-		verbose = os.Stdout
+		verbose = os.Stderr
 	}
 
 	if countSet(*create, *show, *service, *shutdown, *run, *stop, *kill, *list, *name) > 1 {
 		log.Fatal("specify at most one of the command options")
 	}
 
 	sockPath := path.Join(*hostPath, "admin_socket")
 
 	if *create || *service || *show {
 		fmt.Fprintf(verbose, "Loading configuration from: %s\n", *configPath)
 		domain, err := tao.LoadDomain(*configPath, nil)
 		fatalIf(err)
 		var host *tao.LinuxHost
 		if *root {
 			if len(*pass) == 0 {
 				log.Fatal("password is required")
 			}
 			host, err = tao.NewRootLinuxHost(*hostPath, domain.Guard, []byte(*pass))
 		} else if *stacked {
 			if !tao.Hosted() {
-				log.Fatal("error: no host tao available, check $%s\n", tao.HostTaoEnvVar)
+				log.Fatalf("error: no host tao available, check $%s\n", tao.HostTaoEnvVar)
 			}
 			host, err = tao.NewStackedLinuxHost(*hostPath, domain.Guard, tao.Parent())
 		} else {
 			log.Fatal("error: must specify either -root or -stacked")
 		}
 		fatalIf(err)
 		if *create {
 			fmt.Printf("LinuxHost Service: %s\n", host.TaoHostName())
 		} else if *show {
 			fmt.Printf("export GOOGLE_TAO_LINUX='%v'\n", host.TaoHostName())
 		} else /* service */ {
 			sock, err := net.Listen("unix", sockPath)
 			fatalIf(err)
 			defer sock.Close()
 			fmt.Fprintf(verbose, "Linux Tao Service started and waiting for requests\n")
 			fatalIf(err)
 			tao.NewLinuxHostAdminServer(host).Serve(sock)
 		}
 	} else {
 		conn, err := net.Dial("unix", sockPath)
diff --git a/go/src/cloudproxy/tao/acl_guard.pb.go b/go/src/cloudproxy/tao/acl_guard.pb.go
index 9830ea6..bbdb966 100644
--- a/go/src/cloudproxy/tao/acl_guard.pb.go
+++ b/go/src/cloudproxy/tao/acl_guard.pb.go
@@ -1,34 +1,35 @@
 // Code generated by protoc-gen-go.
 // source: acl_guard.proto
 // DO NOT EDIT!
 
 /*
 Package tao is a generated protocol buffer package.
 
 It is generated from these files:
 	acl_guard.proto
 	attestation.proto
 	keys.proto
 	linux_host_admin_rpc.proto
 	linux_host.proto
 	tao_rpc.proto
+	tpm_tao.proto
 
 It has these top-level messages:
 	ACLSet
 	SignedACLSet
 */
 package tao
 
 import proto "code.google.com/p/goprotobuf/proto"
 import math "math"
 
 // Reference imports to suppress errors if they are not otherwise used.
 var _ = proto.Marshal
 var _ = math.Inf
 
 // A set of ACL entries.
 type ACLSet struct {
 	Entries          []string `protobuf:"bytes,1,rep,name=entries" json:"entries,omitempty"`
 	XXX_unrecognized []byte   `json:"-"`
 }
 
diff --git a/go/src/cloudproxy/tao/linux_host.go b/go/src/cloudproxy/tao/linux_host.go
index cf420f9..f27364b 100644
--- a/go/src/cloudproxy/tao/linux_host.go
+++ b/go/src/cloudproxy/tao/linux_host.go
@@ -33,47 +33,46 @@ import (
 // (on top of a host Tao) or in root mode (without an underlying host Tao).
 type LinuxHost struct {
 	path           string
 	guard          Guard
 	taoHost        Host
 	childFactory   LinuxProcessFactory
 	hostedPrograms []*LinuxHostChild
 	hpm            sync.RWMutex
 	nextChildID    uint
 	idm            sync.Mutex
 }
 
 // NewStackedLinuxHost creates a new LinuxHost as a hosted program of an existing
 // host Tao.
 func NewStackedLinuxHost(path string, guard Guard, hostTao Tao) (*LinuxHost, error) {
 	lh := &LinuxHost{
 		path:  path,
 		guard: guard,
 	}
 
-	subprin := guard.Subprincipal()
-	if err := hostTao.ExtendTaoName(subprin); err != nil {
-		return nil, err
-	}
-
-	if err := hostTao.ExtendTaoName(subprin); err != nil {
-		return nil, err
+	// TODO(tmroeder): the TPM Tao currently doesn't support name extensions.
+	if _, ok := hostTao.(*TPMTao); !ok {
+		subprin := guard.Subprincipal()
+		if err := hostTao.ExtendTaoName(subprin); err != nil {
+			return nil, err
+		}
 	}
 
 	k, err := NewOnDiskTaoSealedKeys(Signing|Crypting|Deriving, hostTao, path, SealPolicyDefault)
 	if err != nil {
 		return nil, err
 	}
 
 	lh.taoHost, err = NewTaoStackedHostFromKeys(k, hostTao)
 	if err != nil {
 		return nil, err
 	}
 
 	return lh, nil
 }
 
 // NewRootLinuxHost creates a new LinuxHost as a standalone Host that can
 // provide the Tao to hosted Linux processes.
 func NewRootLinuxHost(path string, guard Guard, password []byte) (*LinuxHost, error) {
 	lh := &LinuxHost{guard: guard}
 	k, err := NewOnDiskPBEKeys(Signing|Crypting|Deriving, password, path, nil)
diff --git a/go/src/cloudproxy/tao/tao.go b/go/src/cloudproxy/tao/tao.go
index 6271ccf..414adf1 100644
--- a/go/src/cloudproxy/tao/tao.go
+++ b/go/src/cloudproxy/tao/tao.go
@@ -1,50 +1,56 @@
 // Copyright (c) 2014, Kevin Walsh.  All rights reserved.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
 // You may obtain a copy of the License at
 //
 //     http://www.apache.org/licenses/LICENSE-2.0
 //
 // Unless required by applicable law or agreed to in writing, software
 // distributed under the License is distributed on an "AS IS" BASIS,
 // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
 package tao
 
 import (
 	"io"
+	"io/ioutil"
 	"os"
+	"path"
+	"strconv"
+	"strings"
 	"sync"
 
 	"github.com/golang/glog"
 
 	"cloudproxy/tao/auth"
 )
 
 // Constants used by the Tao implementations for policy, signing contexts, and
 // environment variables.
 const (
 	HostTaoEnvVar = "GOOGLE_HOST_TAO"
+	TaoTPMEnvVar  = "GOOGLE_TAO_TPM"
+	TaoPCRsEnvVar = "GOOGLE_TAO_PCRS"
 
 	SharedSecretPolicyDefault      = "self"
 	SharedSecretPolicyConservative = "few"
 	SharedSecretPolicyLiberal      = "any"
 
 	SealPolicyDefault      = "self"
 	SealPolicyConservative = "few"
 	SealPolicyLiberal      = "any"
 
 	AttestationSigningContext = "Tao Attestation Signing Context V1"
 )
 
 // Tao is the fundamental Trustworthy Computing interface provided by a host to
 // its hosted programs. Each level of a system can act as a host by exporting
 // the Tao interface and providing Tao services to higher-level hosted programs.
 //
 // In most cases, a hosted program will use a stub Tao that performs RPC over a
 // channel to its host. The details of such RPC depend on the specific
 // implementation of the host: some hosted programs may use pipes to communicate
 // with their host, others may use sockets, etc.
@@ -76,34 +82,75 @@ type Tao interface {
 
 	// Unseal decrypts data that has been sealed by the Seal() operation, but only
 	// if the policy specified during the Seal() operation is satisfied.
 	Unseal(sealed []byte) (data []byte, policy string, err error)
 }
 
 // Cached interface to the host Tao underlying this hosted program.
 var cachedHost Tao
 var cacheOnce sync.Once
 
 // Parent returns the interface to the underlying host Tao. It depends on a
 // specific environment variable being set. On success it memoizes the result
 // before returning it because there should only ever be a single channel to the
 // host. On failure, it logs a message using glog and returns nil.
 // Note: errors are not returned so that, once it is confirmed that Parent
 // returns a non-nil value, callers can use the function result in an
 // expression, e.g.:
 //   name, err := tao.Parent().GetTaoName()
 func Parent() Tao {
 	cacheOnce.Do(func() {
-		host, err := DeserializeTaoRPC(os.Getenv(HostTaoEnvVar))
-		if err != nil {
-			glog.Error(err)
-			return
+		hostVar := os.Getenv(HostTaoEnvVar)
+		r := strings.TrimPrefix(hostVar, "tao::TPMTao(\"dir:")
+		if r == hostVar {
+			host, err := DeserializeTaoRPC(os.Getenv(HostTaoEnvVar))
+			if err != nil {
+				glog.Error(err)
+				return
+			}
+			cachedHost = host
+		} else {
+			// TODO(tmroeder): this version assumes that the AIK blob is under
+			// the TPMTao directory as aikblob. This should be specified more
+			// clearly in the environment variables.
+
+			dir := strings.TrimSuffix(r, "\")")
+			aikblob, err := ioutil.ReadFile(path.Join(dir, "aikblob"))
+			if err != nil {
+				glog.Error(err)
+				return
+			}
+
+			taoPCRs := os.Getenv(TaoPCRsEnvVar)
+			pcrStr := strings.TrimPrefix(taoPCRs, "PCRs(\"")
+
+			// This index operation will never panic, since strings.Split always
+			// returns at least one entry in the resulting slice.
+			pcrIntList := strings.Split(pcrStr, "\", \"")[0]
+			pcrInts := strings.Split(pcrIntList, ", ")
+			pcrs := make([]int, len(pcrInts))
+			for i, s := range pcrInts {
+				var err error
+				pcrs[i], err = strconv.Atoi(s)
+				if err != nil {
+					glog.Error(err)
+					return
+				}
+			}
+
+			// TODO(tmroeder): add the tpm device path to the configuration.
+			host, err := NewTPMTao("/dev/tpm0", aikblob, pcrs)
+			if err != nil {
+				glog.Error(err)
+				return
+			}
+
+			cachedHost = host
 		}
-		cachedHost = host
 	})
 	return cachedHost
 }
 
 // Hosted returns true iff a host Tao is available via the Parent function.
 func Hosted() bool {
 	return Parent() != nil
 }
diff --git a/go/src/cloudproxy/tao/tpm_tao.go b/go/src/cloudproxy/tao/tpm_tao.go
index eec1308..bcf7ddf 100644
--- a/go/src/cloudproxy/tao/tpm_tao.go
+++ b/go/src/cloudproxy/tao/tpm_tao.go
@@ -11,40 +11,42 @@
 // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
 package tao
 
 import (
 	"crypto/rsa"
 	"crypto/x509"
 	"encoding/hex"
 	"errors"
 	"io"
 	"os"
 	"runtime"
 	"strconv"
 	"strings"
 	"time"
 
 	"cloudproxy/tao/auth"
 
+	"code.google.com/p/goprotobuf/proto"
+
 	"github.com/google/go-tpm/tpm"
 )
 
 // A TPMTao implements the Tao using a hardware TPM device.
 type TPMTao struct {
 	// tpmfile is the file through which TPMTao communicates with the TPM. E.g.,
 	// on Linux, this is usually /dev/tpm0.
 	tpmfile *os.File
 
 	// srkAuth is the authenticator for the SRK. In most simple cases, it's 20
 	// bytes of zeros. That value is called the "well-known authentictor"
 	srkAuth [20]byte
 
 	// aikHandle is an integer handle for an AIK held by the TPM. This key is
 	// used for creating Quote values from the TPM.
 	aikHandle tpm.Handle
 
 	// verifier is a representation of the AIK that can be used to verify Quote
 	// and Quote2 attestations.
 	verifier *rsa.PublicKey
@@ -223,58 +225,121 @@ func (tt *TPMTao) Attest(issuer *auth.Prin, start, expiration *int64, message au
 	// clearing the PCRs.
 	sig, _, err := tpm.Quote(tt.tpmfile, tt.aikHandle, ser, tt.pcrNums, tt.srkAuth[:])
 	if err != nil {
 		return nil, err
 	}
 
 	// Pull off the extensions from the name to get the bare TPM key for the
 	// signer.
 	signer := auth.Prin{
 		Type: tt.name.Type,
 		Key:  tt.name.Key,
 	}
 	a := &Attestation{
 		SerializedStatement: ser,
 		Signature:           sig,
 		Signer:              auth.Marshal(signer),
 	}
 	return a, nil
 }
 
-// Seal encrypts data so only certain hosted programs can unseal it.
+// Seal encrypts data so only certain hosted programs can unseal it. Note that
+// at least some TPMs can only seal up to 149 bytes of data. So, we employ a
+// hybrid encryption scheme that seals a key and uses the key to encrypt the
+// data separately. We use the keys infrastructure to perform secure and
+// flexible encryption.
 func (tt *TPMTao) Seal(data []byte, policy string) (sealed []byte, err error) {
 	if policy != SealPolicyDefault {
 		return nil, errors.New("tpm-specific policies are not yet implemented")
 	}
 
-	return tpm.Seal(tt.tpmfile, tt.locality, tt.pcrNums, data, tt.srkAuth[:])
+	crypter, err := GenerateCrypter()
+	if err != nil {
+		return nil, err
+	}
+	defer zeroBytes(crypter.aesKey)
+	defer zeroBytes(crypter.hmacKey)
+
+	c, err := crypter.Encrypt(data)
+	if err != nil {
+		return nil, err
+	}
+
+	ck, err := MarshalCrypterProto(crypter)
+	if err != nil {
+		return nil, err
+	}
+	defer zeroBytes(ck.Key)
+
+	ckb, err := proto.Marshal(ck)
+	if err != nil {
+		return nil, err
+	}
+	defer zeroBytes(ckb)
+
+	s, err := tpm.Seal(tt.tpmfile, tt.locality, tt.pcrNums, ckb, tt.srkAuth[:])
+	if err != nil {
+		return nil, err
+	}
+
+	h := &HybridSealedData{
+		SealedKey:     s,
+		EncryptedData: c,
+	}
+
+	return proto.Marshal(h)
 }
 
 // Unseal decrypts data that has been sealed by the Seal() operation, but only
 // if the policy specified during the Seal() operation is satisfied.
 func (tt *TPMTao) Unseal(sealed []byte) (data []byte, policy string, err error) {
-	unsealed, err := tpm.Unseal(tt.tpmfile, sealed, tt.srkAuth[:])
+	// The sealed data is a HybridSealedData.
+	var h HybridSealedData
+	if err := proto.Unmarshal(sealed, &h); err != nil {
+		return nil, "", err
+	}
+
+	unsealed, err := tpm.Unseal(tt.tpmfile, h.SealedKey, tt.srkAuth[:])
+	if err != nil {
+		return nil, "", err
+	}
+	defer zeroBytes(unsealed)
+
+	var ck CryptoKey
+	if err := proto.Unmarshal(unsealed, &ck); err != nil {
+		return nil, "", err
+	}
+	defer zeroBytes(ck.Key)
+
+	crypter, err := UnmarshalCrypterProto(&ck)
+	if err != nil {
+		return nil, "", err
+	}
+	defer zeroBytes(crypter.aesKey)
+	defer zeroBytes(crypter.hmacKey)
+
+	m, err := crypter.Decrypt(h.EncryptedData)
 	if err != nil {
 		return nil, "", err
 	}
 
-	return unsealed, SealPolicyDefault, nil
+	return m, SealPolicyDefault, nil
 }
 
 // extractPCRs gets the PCRs from a tpm principal.
 func extractPCRs(p auth.Prin) ([]int, []byte, error) {
 	if p.Type != "tpm" {
 		return nil, nil, errors.New("can only extract PCRs from a TPM principal")
 	}
 
 	// The PCRs are stored as the first subprincipal value, with name "PCRs".
 	if len(p.Ext) == 0 {
 		return nil, nil, errors.New("no subprincipals available for PCR extraction")
 	}
 
 	if p.Ext[0].Name != "PCRs" {
 		return nil, nil, errors.New("the first subprincipal must have Name 'PCRs' for PCR extraction to work")
 	}
 
 	sp := p.Ext[0]
 	if len(sp.Arg) != 2 {
 		return nil, nil, errors.New("the PCRs subprincipal must have exactly two arguments")
diff --git a/go/src/cloudproxy/tao/tpm_tao.pb.go b/go/src/cloudproxy/tao/tpm_tao.pb.go
new file mode 100644
index 0000000..9604645
--- /dev/null
+++ b/go/src/cloudproxy/tao/tpm_tao.pb.go
@@ -0,0 +1,39 @@
+// Code generated by protoc-gen-go.
+// source: tpm_tao.proto
+// DO NOT EDIT!
+
+package tao
+
+import proto "code.google.com/p/goprotobuf/proto"
+import math "math"
+
+// Reference imports to suppress errors if they are not otherwise used.
+var _ = proto.Marshal
+var _ = math.Inf
+
+type HybridSealedData struct {
+	SealedKey        []byte `protobuf:"bytes,1,req" json:"SealedKey,omitempty"`
+	EncryptedData    []byte `protobuf:"bytes,2,req" json:"EncryptedData,omitempty"`
+	XXX_unrecognized []byte `json:"-"`
+}
+
+func (m *HybridSealedData) Reset()         { *m = HybridSealedData{} }
+func (m *HybridSealedData) String() string { return proto.CompactTextString(m) }
+func (*HybridSealedData) ProtoMessage()    {}
+
+func (m *HybridSealedData) GetSealedKey() []byte {
+	if m != nil {
+		return m.SealedKey
+	}
+	return nil
+}
+
+func (m *HybridSealedData) GetEncryptedData() []byte {
+	if m != nil {
+		return m.EncryptedData
+	}
+	return nil
+}
+
+func init() {
+}
diff --git a/go/src/cloudproxy/tao/tpm_tao.proto b/go/src/cloudproxy/tao/tpm_tao.proto
new file mode 100644
index 0000000..1772335
--- /dev/null
+++ b/go/src/cloudproxy/tao/tpm_tao.proto
@@ -0,0 +1,20 @@
+//  Copyright (c) 2014, Google Inc.  All rights reserved.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package tao;
+
+message HybridSealedData {
+  required bytes SealedKey = 1;
+  required bytes EncryptedData = 2;
+} 
diff --git a/go/src/cloudproxy/tao/tpm_tao_test.go b/go/src/cloudproxy/tao/tpm_tao_test.go
index 9bb1b0a..7453805 100644
--- a/go/src/cloudproxy/tao/tpm_tao_test.go
+++ b/go/src/cloudproxy/tao/tpm_tao_test.go
@@ -72,40 +72,77 @@ func TestTPMTaoSeal(t *testing.T) {
 	sealed, err := tpmtao.Seal(data, SealPolicyDefault)
 	if err != nil {
 		t.Fatal("Couldn't seal data in the TPM Tao:", err)
 	}
 
 	unsealed, policy, err := tpmtao.Unseal(sealed)
 	if err != nil {
 		t.Fatal("Couldn't unseal data sealed by the TPM Tao:", err)
 	}
 
 	if policy != SealPolicyDefault {
 		t.Fatal("Got the wrong policy back from TPMTao.Unseal")
 	}
 
 	if !bytes.Equal(unsealed, data) {
 		t.Fatal("The data returned from TPMTao.Unseal didn't match the original data")
 	}
 
 }
 
+func TestTPMTaoLargeSeal(t *testing.T) {
+	aikblob, err := ioutil.ReadFile("./aikblob")
+	if err != nil {
+		t.Skip("Skipping tests, since there's no ./aikblob file")
+	}
+
+	tpmtao, err := NewTPMTao("/dev/tpm0", aikblob, []int{17, 18})
+	if err != nil {
+		t.Fatal("Couldn't create a new TPM Tao:", err)
+	}
+	tt, ok := tpmtao.(*TPMTao)
+	if !ok {
+		t.Fatal("Failed to create the right kind of Tao object from NewTPMTao")
+	}
+	defer cleanUpTPMTao(tt)
+
+	data := make([]byte, 10000)
+	sealed, err := tpmtao.Seal(data, SealPolicyDefault)
+	if err != nil {
+		t.Fatal("Couldn't seal data in the TPM Tao:", err)
+	}
+
+	unsealed, policy, err := tpmtao.Unseal(sealed)
+	if err != nil {
+		t.Fatal("Couldn't unseal data sealed by the TPM Tao:", err)
+	}
+
+	if policy != SealPolicyDefault {
+		t.Fatal("Got the wrong policy back from TPMTao.Unseal")
+	}
+
+	if !bytes.Equal(unsealed, data) {
+		t.Fatal("The data returned from TPMTao.Unseal didn't match the original data")
+	}
+
+}
+
 func TestTPMTaoAttest(t *testing.T) {
 	aikblob, err := ioutil.ReadFile("./aikblob")
 	if err != nil {
 		t.Skip("Skipping tests, since there's no ./aikblob file")
 	}
 
 	tpmtao, err := NewTPMTao("/dev/tpm0", aikblob, []int{17, 18})
 	if err != nil {
 		t.Fatal("Couldn't create a new TPM Tao:", err)
 	}
 	tt, ok := tpmtao.(*TPMTao)
 	if !ok {
 		t.Fatal("Failed to create the right kind of Tao object from NewTPMTao")
 	}
 	defer cleanUpTPMTao(tt)
 
 	// Set up a fake key delegation.
 	taoname, err := tpmtao.GetTaoName()
 	if err != nil {
 		t.Fatal("Couldn't get the name of the tao:", err)
