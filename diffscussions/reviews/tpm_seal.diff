# 
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-07-31T16:25:35-0700
#* 
#- This diff adds support for Seal/Unseal low-level operations as well as
#- high-level functions that call them. For the moment, this only seals against
#- PCR 17, but that's easy to fix, given the PCRMask type and the generality of
#- the underlying functions. This version currently also only supports the
#- well-known SRK auth value of all 0s, but that should be easy to fix as well.
#- 
#- Added support for PCR composites and for the low-level Seal command
#- 
#- 
#- Added tests and entity types and values
#- 
#- 
#- rewrote the resizeable slice encoding to use the header size information rather than a specialized value
#- 
#- 
#- Got rid of SliceSize and added tests for the new style of Pack/Unpack
#- 
#- 
#- Unexported most of the existing types and fixed submitTPMRequest to always try to read the max amount from /dev/tpm, so we don't depend on unknown variable-length data
#- 
#- 
#- Got Seal to work with /dev/tpm0. Unseal not yet tested.
#- 
#- 
#- Added Unseal and got it to work with the TPM
#- 
#- 
#- Added random Odd nonces instead of empty Odd nonces
#- 
#- 
#- Fixed a minor typo in the error text
#- 
#- 
#- Removed constants that are not currently used by the tpm package
#- 
#- 
#**
#** author: Kevin Walsh
#** email: kwalsh@holycross.edu
#** date: 2014-08-01T16:34:01-0400
#**
#-- Might it be a good idea to make this a standalone package as done for datalog?
#--
#-- The below comments are extremely nitpicky and verbose. Sorry for that. Feel
#-- free to completely disregard them, of course. Also, my comments are almost
#-- entirely about non-exported code, so if you want to push this to master, it
#-- is fine by me.
diff --git a/go/src/tpm/tpm.go b/go/src/tpm/tpm.go
index f4a3bb4..acd9622 100644
--- a/go/src/tpm/tpm.go
+++ b/go/src/tpm/tpm.go
@@ -1,260 +1,911 @@
+// Copyright (c) 2014, Google Inc. All rights reserved.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
 // Package tpm supports direct communication with a tpm device under Linux.
 package tpm
 
 import (
 	"bytes"
+	"crypto/hmac"
+	"crypto/rand"
+	"crypto/sha1"
 	"encoding/binary"
 	"errors"
+	"fmt"
 	"os"
+	"strconv"
+
+	"github.com/golang/glog"
 )
 
 // Supported TPM commands.
 const (
-	tagRQUCommand uint16 = 0x00C1
-	tagRSPCommand uint16 = 0x00C4
+	tagPCRInfoLong     uint16 = 0x06
+	tagRQUCommand      uint16 = 0x00C1
+	tagRQUAuth1Command uint16 = 0x00C2
+	tagRQUAuth2Command uint16 = 0x00C3
+	tagRSPCommand      uint16 = 0x00C4
+	tagRSPAuth1Command uint16 = 0x00C5
+	tagRSPAuth2Command uint16 = 0x00C6
 )
 
 // Supported TPM operations.
 const (
-	ordOSAP      uint32 = 0x0000000B
 	ordOIAP      uint32 = 0x0000000A
-	ordPCRExtend uint32 = 0x00000014
+	ordOSAP      uint32 = 0x0000000B
 	ordPCRRead   uint32 = 0x00000015
+	ordSeal      uint32 = 0x00000017
+	ordUnseal    uint32 = 0x00000018
 	ordGetRandom uint32 = 0x00000046
 )
 
+// Entity types
+const (
+	etSRK uint16 = 0x0004
+)
+
+// A tpmHandle is a 32-bit unsigned integer.
+type tpmHandle uint32
+
+// Entity values
+const (
+	khSRK tpmHandle = 0x40000000
+)
+
 // Each PCR has a fixed size of 20 bytes.
 const PCRSize int = 20
 
-// A CommandHeader is the header for a TPM command.
-type CommandHeader struct {
+// A commandHeader is the header for a TPM command.
+type commandHeader struct {
 	Tag  uint16
 	Size uint32
 	Cmd  uint32
 }
#*
#* author: Kevin Walsh
#* email: kwalsh@holycross.edu
#* date: 2014-08-01T16:50:13-0400
#*
#- These fields can probably be made unexported. If you ever plan on returning
#- an (unexported) commandHeader from an exported function, then it might make
#- sense to keep the fields exported since in that case, as far as I can tell,
#- things outside this package can still use exported fields from the unexported
#- type.
#-
 
-// PackedSize computes the size of a sequence of types that can be passed to
+// String prints a string version of a commandHeader
#*
#* author: Kevin Walsh
#* email: kwalsh@holycross.edu
#* date: 2014-08-01T16:37:43-0400
#*
#- "returns" not "prints"
#-
+func (ch commandHeader) String() string {
+	return fmt.Sprintf("commandHeader{Tag: %x, Size: %x, Cmd: %x}", ch.Tag, ch.Size, ch.Cmd)
+}
+
+// packedSize computes the size of a sequence of types that can be passed to
 // binary.Read or binary.Write.
-func PackedSize(elts []interface{}) int {
+func packedSize(elts []interface{}) int {
 	// Add the total size to the header.
 	var size int
 	for i := range elts {
 		s := binary.Size(elts[i])
 		if s == -1 {
 			return -1
 		}
 
 		size += s
 	}
 
 	return size
 }
 
-// Pack takes a sequence of elements that are either of fixed length or slices
+// pack takes a sequence of elements that are either of fixed length or slices
 // of fixed-length types and packs them into a single byte array using
 // binary.Write.
-func Pack(ch CommandHeader, cmd []interface{}) ([]byte, error) {
-	hdrSize := binary.Size(ch)
-	bodySize := PackedSize(cmd)
-	if bodySize <= 0 {
-		return nil, errors.New("can't compute the size of the command")
+func pack(elts []interface{}) ([]byte, error) {
+	size := packedSize(elts)
+	if size <= 0 {
+		return nil, errors.New("can't compute the size of the elements")
 	}
 
-	size := hdrSize + bodySize
-	ch.Size = uint32(size)
 	buf := bytes.NewBuffer(make([]byte, 0, size))
 
-	// The header goes first, unsurprisingly.
-	if err := binary.Write(buf, binary.BigEndian, ch); err != nil {
-		return nil, err
-	}
-
-	for _, c := range cmd {
-		if err := binary.Write(buf, binary.BigEndian, c); err != nil {
+	for _, e := range elts {
+		if err := binary.Write(buf, binary.BigEndian, e); err != nil {
 			return nil, err
 		}
 	}
 
 	return buf.Bytes(), nil
 }
 
-// A ResponseHeader is a header for TPM responses.
-type ResponseHeader struct {
+// packWithHeader takes a header and a sequence of elements that are either of
+// fixed length or slices of fixed-length types and packs them into a single
+// byte array using binary.Write. It updates the CommandHeader to have the right
+// length.
+func packWithHeader(ch commandHeader, cmd []interface{}) ([]byte, error) {
+	hdrSize := binary.Size(ch)
+	bodySize := packedSize(cmd)
+	if bodySize < 0 {
+		return nil, errors.New("couldn't compute packed size for message body")
+	}
+
+	ch.Size = uint32(hdrSize + bodySize)
+
+	in := []interface{}{ch}
+	in = append(in, cmd...)
+	return pack(in)
+}
+
+// A responseHeader is a header for TPM responses.
+type responseHeader struct {
 	Tag  uint16
 	Size uint32
 	Res  uint32
 }
 
-// A SliceSize is used to detect incoming variable-sized array responses. Note
-// that any time there is a SliceSize followed by a slice in a respones, this
-// slice must be resized to match its preceeding SliceSize after
-// submitTPMRequest, since the Unpack code doesn't resize the underlying slice.
-type SliceSize uint32
+// String writes out a string representation of a responseHeader.
+func (rh responseHeader) String() string {
+	return fmt.Sprintf("responseHeader{Tag: %x, Size: %x, Res: %x", rh.Tag, rh.Size, rh.Res)
+}
+
+// A resizeableSlice is a pointer to a slice so this slice can be resized
+// dynamically. This is critical for cases like Seal, where we don't know
+// beforehand exactly how many bytes the TPM might produce.
+type resizeableSlice *[]byte
+
+// SimpleUnpack calls Unpack with a nil header and rest as 0. This is used when
+// there is no resizeable slice.
+func simpleUnpack(b []byte, resp []interface{}) error {
+	return unpack(b, resp, nil, 0)
+}
#*
#* author: Kevin Walsh
#* email: kwalsh@holycross.edu
#* date: 2014-08-01T17:16:17-0400
#*
#- "unpack" not "Unpack"
#-
#- Also, I don't like the name simpleUnpack -- could mean anything. How about
#- unpackWithoutHeader? Or make it unpack and the other one unpackWithHeader?
#- Better yet, see below for 3rd option.
#-
 
-// Unpack decodes from a byte array a sequence of elements that are either
+// unpack decodes from a byte array a sequence of elements that are either
 // pointers to fixed length types or slices of fixed-length types. It uses
-// binary.Read to do the decoding.
-func Unpack(b []byte, resp []interface{}) error {
+// binary.Read to do the decoding. If rh is not nil, then the size is used to
+// resize a ResizeableSlice. The size of the byte array is taken to be rh.Size -
+// rest.
+func unpack(b []byte, resp []interface{}, rh *responseHeader, rest uint) error {
 	buf := bytes.NewBuffer(b)
-	var nextSliceSize SliceSize
-	var resizeNext bool
+	var resized bool
 	for _, r := range resp {
-		if resizeNext {
-			// This must be a byte slice to resize.
-			bs, ok := r.([]byte)
-			if !ok {
-				return errors.New("a *SliceSize must be followed by a []byte")
+		bs, ok := r.(resizeableSlice)
+		if ok {
+			if rh == nil {
+				return errors.New("found a resizeableSlice but no header")
 			}
 
-			if int(nextSliceSize) > len(b) {
-				return errors.New("the TPM returned more bytes than can fit in the supplied slice")
+			if resized {
+				return errors.New("can't resize two arrays in a single response")
 			}
 
-			// Resize the slice to match the number of bytes the TPM says it
-			// returned for this value.
-			r = bs[:nextSliceSize]
-			nextSliceSize = 0
-			resizeNext = false
+			size := uint(rh.Size) - rest
+			l := uint(len(*bs))
+			if size > l {
+				*bs = append(*bs, make([]byte, size-l)...)
+			} else if size < l {
+				*bs = (*bs)[:size]
+			}
+
+			resized = true
 		}
 
 		// Note that this only makes sense if the elements of resp are either
 		// pointers or slices, since otherwise the decoded values just get
 		// thrown away.
 		if err := binary.Read(buf, binary.BigEndian, r); err != nil {
 			return err
 		}
-
-		if ss, ok := r.(*SliceSize); ok {
-			nextSliceSize = *ss
-			resizeNext = true
-		}
 	}
 
 	if buf.Len() > 0 {
 		return errors.New("unread bytes in the TPM response")
 	}
 
 	return nil
 }
#*
#* author: Kevin Walsh
#* email: kwalsh@holycross.edu
#* date: 2014-08-01T17:36:32-0400
#*
#- I'm not keen on this organization at all. Why is responseHeader being passed
#- in as a pointer to a struct, when only rh.Size is needed. Why are rest and
#- rh.Size being passed in separately, when really only l=(rh.Size - rest) is
#- needed? And why are we passing in lengths anyway, since slices carry size
#- information? Specifically, I'm pretty sure your l=(rh.Size - rest) value
#- would be identical to len(b) - unpackSize(resp), if unpackSize() does the
#- same thing as packedSize but ignores variable-size byteslice output
#- parameters. And for cases like GetRandom where there is an explicit size
#- encoded, who is responsible for calculating the size during packing or
#- checking during unpacking that the encoded size matches what is expected?
#- Alternatively, does anyone check that the entire buffer is filled at the end
#- of packing or consumed at the end of unpacking? Lastly, having the sizes
#- managed by the caller means there is boring size-calculating code and
#- size-variables scattered in lots of places.
#-
#- Looking at the tpm specs, and specifically the commentary in the main part,
#- it is pretty clear that there are three cases:
#- (1) fixed-size byte or int32 arrays, e.g. 20-byte digests. These are encoded as just
#-     the bytes. This is the same path used for non-array non-slice primitive
#-     objects like int, byte, etc.
#- (2) variable-sized opaque byte or int32 arrays. In the spec, these are
#-     labeled as size "<>" and type "BYTE[]". In every case I could find in the
#-     spec, these are always encoded as a UINT32 length followed by the bytes,
#-     both for incoming and outgoing buffers.
#- (3) other variable-sized structures, like TPM_KEY and TPM_STORED_DATA. 
#-     These have internal structure, and by looking inside you can recursively
#-     figure out the actual size.
#-
#- I think you currently handle (1) using these using arrays, not slices, and I
#- like that. But your handling of (2) and (3) is not ideal.
#-
#- I think you currently handle (2) using slices plus a separate uint32 for a
#- length. I think it should instead just be a slice -- the semantics seem to
#- match up just about perfectly. When packing a byteslice, pack it as 4+n
#- bytes: a 4-byte length, followed by the contents. When unpacking a
#- pointer-to-byteslice, unpack the 4-byte length first, then alloocate (or
#- resize) and fill the pointed-to byteslice.
#-
#- I think you handle (3) using slices without a separate length, and this is
#- where the trouble is caused.  In the case of seal, just define the proper
#- struct:
#-    type tpmStoredData struct {
#-      ver uint32
#-      sealInfo []byte
#-      encData []byte
#-    }
#- There is a similiar case for TPM_KEY and TPM_KEY12, and a few other tpm
#- structures. It's fine if we continue to return these as opaque byte slices if
#- we want to hide the internal structure from callers.
#-
#- When packing a tpmStoredData, the size is computed exactly as
#- packedSize() would compute it: case 1 for ver, case 2 for the other two
#- fields. When unpacking, you'd unpack ver first using case 1, then unpack
#- sealInfo using case 2, then encData using case 2.
#-
#- This could all be done with reflection and recursion in the same way that
#- binary.Write(), binary.Read(), etc., do it, passing most cases off to the
#- binary package but handling byte slices specially. I suspect this would be
#- nearly a 1-liner, able to handle embedded tpmStoredData structs and all other
#- similar tpm structs. Or you could make a "packable" interface and check for
#- that at the top level of pack, unpack, etc., and hand-code functions with the
#- recursive calls for each of those structs.
#-
#- Actually, here is I think a nearly complete pack() solution along those
#- lines:
#-
#- // pack encodes a slice of tpm structures into a byte array.
#- func pack(elts []interface{}) ([]byte, error) {
#- 	buf := new(bytes.Buffer)
#- 	if err := packWriter(buf, elts); err != nil {
#- 		return nil, err
#- 	}
#- 	return buf.Bytes(), nil
#- }
#-
#- // packWriter encodes a slice of tpm structures. A tpm structure is either:
#- // (1) a fixed-size integer type, or an array of them
#- // (2) a slice of fixed-size integer types
#- // (3) a struct of tpm structures
#- func packWriter(buf io.Writer, elts []interface{}) (err error) {
#- 	for _, e := range elts {
#- 		v := reflect.ValueOf(e)
#- 		switch v.Kind() {
#- 		case reflect.Struct:
#- 			fmt.Printf("packing %s (struct)\n", v.Type())
#- 			for i := 0; i < v.NumField() && err == nil; i++ {
#- 				err = packWriter(buf, []interface{}{v.Field(i).Interface()})
#- 			}
#- 		case reflect.Slice:
#- 			fmt.Printf("packing %s (variable length)\n", v.Type())
#- 			elemSize, err := sizeof(v.Type().Elem())
#- 			if err == nil {
#-				err = binary.Write(buf, binary.BigEndian, uint32(v.Len() * elemSize))
#-			}
#- 			if err == nil {
#- 				err = binary.Write(buf, binary.BigEndian, e)
#- 			}
#- 		default:
#- 			fmt.Printf("packing %s (fixed length)\n", v.Type())
#- 			err = binary.Write(buf, binary.BigEndian, e)
#- 		}
#- 		if err != nil {
#- 			return
#- 		}
#- 	}
#- 	return
#- }
#-
#- Of course it would be trivial to handle slices of tpm structures by
#- just recursing instead of calling binary.Write() in the second case, but I'm
#- don't think that ever happens. And the "default" could be made more strict
#- for more strict error checking, if desired. The once case I see that isn't
#- handled here is TPM_PCR_INFO_LONG, which is wierd. It's a struct, so should
#- have an implicit length like TPM_STORED_DATA or TPM_KEY. But it's also
#- (sometimes?) optional, so they use an explicit pcrInfoSize that can be 0 to
#- for that case. But there is an old v1 TPM_PCR_INFO struct which is missing a
#- versioning tag, so they also seem to use pcrInfoSize to help work around that
#- oversight. In the code above, I'd probably either (a) handle pcrInfoLong
#- specially, (b) handle any pointer to a tpm structure during packing as an
#- "optional" field to be preceded by an explicit length, or (c) generalize the
#- slice handling so you can pass in a slice of zero or one pcrInfoLong
#- structures.
#-
#- I think the unpack code would just be the mirror image of the above, but
#- having everything be pointers.
+// maxTPMResponse is the largest possible response from the TPM. We need to know
+// this because we don't always know the length of the TPM response, and
+// /dev/tpm insists on giving it all back in a single value rather than
+// returning a header and a body in separate responses.
+const maxTPMResponse = 4096
+
 // submitTPMRequest sends a structure to the TPM device file and gets results
 // back, interpreting them as a new provided structure.
 func submitTPMRequest(f *os.File, tag uint16, ord uint32, in []interface{}, out []interface{}) error {
-	ch := CommandHeader{tag, 0, ord}
-	inb, err := Pack(ch, in)
+	ch := commandHeader{tag, 0, ord}
+	inb, err := packWithHeader(ch, in)
 	if err != nil {
 		return err
 	}
 
+	if glog.V(2) {
+		glog.Infof("TPM request:\n%x\n", inb)
+	}
 	if _, err := f.Write(inb); err != nil {
 		return err
 	}
 
 	// Try to read the whole thing, but handle the case where it's just a
 	// ResponseHeader and not the body, since that's what happens in the error
 	// case.
-	var rh ResponseHeader
-	outSize := PackedSize(out)
+	var rh responseHeader
+	outSize := packedSize(out)
#*
#* author: Kevin Walsh
#* email: kwalsh@holycross.edu
#* date: 2014-08-01T19:33:24-0400
#*
#- Other than the error checking here, this value is never used. Implicitly, you
#- are really just checking to make sure this is "unpackable", you don't care
#- about the size at all. This check should be moved down to the place where the
#- check is needed, below.
#-
 	if outSize < 0 {
 		return errors.New("invalid out arguments")
 	}
 
 	rhSize := binary.Size(rh)
-	outb := make([]byte, rhSize+outSize)
-	if _, err := f.Read(outb); err != nil {
+	outb := make([]byte, maxTPMResponse)
+	outlen, err := f.Read(outb)
+	if err != nil {
 		return err
 	}
 
-	if err := Unpack(outb[:rhSize], []interface{}{&rh}); err != nil {
-		return err
+	// Resize the buffer to match the amount read from the TPM.
+	outb = outb[:outlen]
+	if glog.V(2) {
+		glog.Infof("TPM response:\n%x\n", outb)
 	}
 
-	// Check success before trying to read the rest of the result.
-	if rh.Tag != tagRSPCommand {
-		return errors.New("inconsistent tag returned by TPM")
+	if err := simpleUnpack(outb[:rhSize], []interface{}{&rh}); err != nil {
+		return err
 	}
 
+	// Check success before trying to read the rest of the result.
+	// Note that the command tag and its associated response tag differ by 3,
+	// e.g., tagRQUCommand == 0x00C1, and tagRSPCommand == 0x00C4.
 	if rh.Res != 0 {
 		return tpmError(rh.Res)
 	}
 
+	if rh.Tag != ch.Tag+3 {
+		return errors.New("inconsistent tag returned by TPM. Expected " + strconv.Itoa(int(ch.Tag+3)) + " but got " + strconv.Itoa(int(rh.Tag)))
+	}
+
 	if rh.Size > uint32(rhSize) {
-		if err := Unpack(outb[rhSize:], out); err != nil {
+		// Calculate the size of the rest of the structures (the ones that
+		// aren't ResizeableSlice). This cast is safe, since we already know
+		// that the encoding/binary package can compute the size of the response
+		// header, so its return value will be nonnegative.
#*
#* author: Kevin Walsh
#* email: kwalsh@holycross.edu
#* date: 2014-08-01T19:35:54-0400
#*
#- This is where the above outSize < 0 check should have been.
#-
+		rest := uint(binary.Size(&rh))
+		for _, r := range out {
+			if _, ok := r.(resizeableSlice); !ok {
+				rest += uint(binary.Size(r))
+			}
+		}
+
+		if err := unpack(outb[rhSize:], out, &rh, rest); err != nil {
#*
#* author: Kevin Walsh
#* email: kwalsh@holycross.edu
#* date: 2014-08-01T19:35:08-0400
#*
#- I view this code as a symptom of the problem outlined above. This is just a
#- hacked-up version of packedSize() all over again.
#-
 			return err
 		}
 	}
 
 	return nil
 }
 
 // ReadPCR reads a PCR value from the TPM.
 func ReadPCR(f *os.File, pcr uint32) ([]byte, error) {
 	in := []interface{}{pcr}
 	v := make([]byte, PCRSize)
 	out := []interface{}{v}
 	if err := submitTPMRequest(f, tagRQUCommand, ordPCRRead, in, out); err != nil {
 		return nil, err
 	}
 
 	return v, nil
 }
 
-// An OIAPResponse is a response to an OIAPCommand.
-type OIAPResponse struct {
-	Auth      uint32
-	NonceEven [20]byte
+// A PCRMask represents a set of PCR choices, one bit per PCR out of the 24
+// possible PCR values.
+type PCRMask [3]byte
#*
#* author: Kevin Walsh
#* email: kwalsh@holycross.edu
#* date: 2014-08-01T19:40:25-0400
#*
#- Technically, there are n>=24 pcrs, and the pcrmask can be 3+ bytes. And
#- apparently sometimes the tpm passes back 4, 5, or even 6 bytes even though it
#- knows only the first 24 bits can be filled.
#-
#- Internally the limitation in the code doesn't matter for now, but maybe the
#- fixed 3-byte limitation shouldn't be exported. Or maybe use big.Int
#- internally to handle the bit-level manipulations, and call big.Int.Bytes()
#- before putting a mask into a pcrSelection struct.
+
+// SetPCR sets a PCR value as selected in a given mask.
+func (pm *PCRMask) SetPCR(i int) error {
+	if i >= 24 || i < 0 {
+		return errors.New("can't set PCR " + strconv.Itoa(i))
+	}
+
+	(*pm)[i/8] |= 1 << uint(i%8)
+	return nil
+}
#*
#* author: Kevin Walsh
#* email: kwalsh@holycross.edu
#* date: 2014-08-01T19:45:40-0400
#*
#- Maybe add a ClearPCR() for completeness? Use go's &^ "bit clear" operator for
#- that.
#-
+
+// IsPCRSet checks to see if a given PCR is included in this mask.
+func (pm PCRMask) IsPCRSet(i int) (bool, error) {
+	if i >= 24 || i < 0 {
+		return false, errors.New("can't check PCR " + strconv.Itoa(i))
+	}
+
+	n := byte(1 << uint(i%8))
+	return pm[i/8]&n == n, nil
+}
+
+// FetchPCRValues gets a sequence of PCR values based on a mask.
+func FetchPCRValues(f *os.File, mask PCRMask) ([]byte, error) {
+	var pcrs []byte
+	// There are a fixed 24 possible PCR indices.
+	for i := 0; i < 24; i++ {
+		set, err := mask.IsPCRSet(i)
+		if err != nil {
+			return nil, err
+		}
+
+		if set {
+			pcr, err := ReadPCR(f, uint32(i))
+			if err != nil {
+				return nil, err
+			}
+
+			pcrs = append(pcrs, pcr...)
+		}
+	}
+
+	return pcrs, nil
+}
+
+// A pcrSelection is the first element in the input a PCR composition, which is
+// A pcrSelection, followed by the combined length of the PCR values,
+// followed by the PCR values, all hashed under SHA-1.
+type pcrSelection struct {
+	Size uint16
+	Mask PCRMask
+}
#*
#* author: Kevin Walsh
#* email: kwalsh@holycross.edu
#* date: 2014-08-01T19:47:36-0400
#*
#- Under my suggestion above, and if PCRMask were a slice (since it may be 3+
#- bytes), this would be:
#-  type PCRMask []byte
#-  type pcrSelection struct {
#-    Mask PCRMask
#-  }
#- And encoding or decoding a pcrSelection would just mean doing Mask,
#- which of course is just a case (2) variable-length byteslice encoded as 4+n
#- bytes with length then contents.
#-
+
+// String writes out a string representation of a pcrSelection
+func (p pcrSelection) String() string {
+	return fmt.Sprintf("pcrSelection{Size: %x, Mask: % x}", p.Size, p.Mask)
+}
+
+// createPCRComposite composes a set of PCRs by prepending a pcrSelection and a
+// length, then computing the SHA1 hash and returning its output.
+func createPCRComposite(mask PCRMask, pcrs []byte) ([]byte, error) {
+	if len(pcrs)%PCRSize != 0 {
+		return nil, errors.New("pcrs must be a multiple of " + strconv.Itoa(PCRSize))
+	}
+
+	in := []interface{}{pcrSelection{3, mask}, uint32(len(pcrs)), pcrs}
#*
#* author: Kevin Walsh
#* email: kwalsh@holycross.edu
#* date: 2014-08-01T19:52:55-0400
#*
#- Under my suggestion, this would just be
#-   in := []interface{}{pcrSelection{mask}, pcrs}
#- since pcrs is a case (2) variable-size byteslice.
+	b, err := pack(in)
+	if err != nil {
+		return nil, err
+	}
+	if glog.V(2) {
+		glog.Infof("composite buffer for mask %s is % x\n", mask, b)
+	}
+
+	h := sha1.Sum(b)
+	if glog.V(2) {
+		glog.Infof("SHA1 hash of composite buffer is % x\n", h)
+	}
+
+	return h[:], nil
+}
+
+// A nonce is a 20-byte value.
+type nonce [20]byte
+
+const nonceSize uint32 = 20
#*
#* author: Kevin Walsh
#* email: kwalsh@holycross.edu
#* date: 2014-08-01T19:57:07-0400
#*
#- I like type nonce. You can't eliminate one of those 20's in go, can you?
#-
+
+// An oiapResponse is a response to an OIAP command.
+type oiapResponse struct {
+	AuthHandle tpmHandle
+	NonceEven  nonce
 }
 
-// OIAP sends an OIAP command to the TPM and gets back an auth value and a
+// String writes out a string representation of an oiapResponse.
+func (opr oiapResponse) String() string {
+	return fmt.Sprintf("oiapResponse{AuthHandle: %x, NonceEven: % x}", opr.AuthHandle, opr.NonceEven)
+}
+
+// oiap sends an OIAP command to the TPM and gets back an auth value and a
 // nonce.
-func OIAP(f *os.File) (*OIAPResponse, error) {
-	var resp OIAPResponse
+func oiap(f *os.File) (*oiapResponse, error) {
+	var resp oiapResponse
 	out := []interface{}{&resp}
 	if err := submitTPMRequest(f, tagRQUCommand, ordOIAP, nil, out); err != nil {
 		return nil, err
 	}
 
 	return &resp, nil
 }
 
 // GetRandom gets random bytes from the TPM.
 func GetRandom(f *os.File, size uint32) ([]byte, error) {
 	in := []interface{}{size}
 
-	var outSize SliceSize
-	b := make([]byte, int(size))
-	out := []interface{}{&outSize, b}
+	var outSize uint32
+	var b []byte
+	out := []interface{}{&outSize, resizeableSlice(&b)}
#*
#* author: Kevin Walsh
#* email: kwalsh@holycross.edu
#* date: 2014-08-01T19:54:35-0400
#*
#- Under my suggestion, this would be
#-   out := []interface{}{&b}, and unpack would resize b, make sure the entire
#-   response message size matches up with the explicit size in the response,
#-   etc.
#-
 
 	if err := submitTPMRequest(f, tagRQUCommand, ordGetRandom, in, out); err != nil {
 		return nil, err
 	}
 
-	return b[:outSize], nil
+	return b, nil
 }
 
-// An OSAPCommand is a command sent for OSAP authentication.
-type OSAPCommand struct {
+// An osapCommand is a command sent for OSAP authentication.
+type osapCommand struct {
 	EntityType  uint16
-	EntityValue uint32
-	OddOSAP     [20]byte
+	EntityValue tpmHandle
+	OddOSAP     nonce
 }
 
-// An OSAPResponse is a TPM reply to an OSAPCommand.
-type OSAPResponse struct {
-	Auth      uint32
-	NonceEven [20]byte
-	EvenOSAP  [20]byte
+// String writes out a string representation of an osapCommand.
+func (opc osapCommand) String() string {
+	return fmt.Sprintf("osapCommand{EntityType: %x, EntityValue: %x, OddOSAP: % x}", opc.EntityType, opc.EntityValue, opc.OddOSAP)
 }
 
-// OSAP sends an OSAPCommand to the TPM and gets back authentication
+// An osapResponse is a TPM reply to an osapCommand.
+type osapResponse struct {
+	AuthHandle tpmHandle
+	NonceEven  nonce
+	EvenOSAP   nonce
+}
+
+// String returns a string representation of an osapResponse.
+func (opr osapResponse) String() string {
+	return fmt.Sprintf("osapResponse{AuthHandle: %x, NonceEven: % x, EvenOSAP: % x}", opr.AuthHandle, opr.NonceEven, opr.EvenOSAP)
+}
+
+// osap sends an OSAPCommand to the TPM and gets back authentication
 // information in an OSAPResponse.
-func OSAP(f *os.File, entityType uint16, entityValue uint32, oddOSAP [20]byte) (*OSAPResponse, error) {
-	in := []interface{}{OSAPCommand{entityType, entityValue, oddOSAP}}
-	var resp OSAPResponse
+func osap(f *os.File, osap osapCommand) (*osapResponse, error) {
+	in := []interface{}{osap}
+	var resp osapResponse
 	out := []interface{}{&resp}
 	if err := submitTPMRequest(f, tagRQUCommand, ordOSAP, in, out); err != nil {
 		return nil, err
 	}
 
 	return &resp, nil
 }
+
+// A Digest is a 20-byte SHA1 value.
+type digest [20]byte
+
+const digestSize uint32 = 20
+
+// An AuthValue is a 20-byte value used for authentication.
+type authValue [20]byte
+
+const authSize uint32 = 20
+
+// pcrInfoLong stores detailed information about PCRs.
+type pcrInfoLong struct {
+	Tag              uint16
+	LocAtCreation    byte
+	LocAtRelease     byte
+	PCRsAtCreation   pcrSelection
+	PCRsAtRelease    pcrSelection
+	DigestAtCreation digest
+	DigestAtRelease  digest
+}
+
+// String returns a string representation of a pcrInfoLong.
+func (pcri pcrInfoLong) String() string {
+	return fmt.Sprintf("pcrInfoLong{Tag: %x, LocAtCreation: %x, LocAtRelease: %x, PCRsAtCreation: %s, PCRsAtRelease: %s, DigestAtCreation: % x, DigestAtRelease: % x}", pcri.Tag, pcri.LocAtCreation, pcri.LocAtRelease, pcri.PCRsAtCreation, pcri.PCRsAtRelease, pcri.DigestAtCreation, pcri.DigestAtRelease)
+}
+
+// createPCRInfo creates a pcrInfoLong structure from a mask and some PCR
+// values that match this mask, along with a TPM locality.
+func createPCRInfo(loc byte, mask PCRMask, pcrVals []byte) (*pcrInfoLong, error) {
+	d, err := createPCRComposite(mask, pcrVals)
+	if err != nil {
+		return nil, err
+	}
+
+	locVal := byte(1 << loc)
+	pcri := &pcrInfoLong{
+		Tag:            tagPCRInfoLong,
+		LocAtCreation:  locVal,
+		LocAtRelease:   locVal,
+		PCRsAtCreation: pcrSelection{3, mask},
+		PCRsAtRelease:  pcrSelection{3, mask},
+	}
+
+	copy(pcri.DigestAtRelease[:], d)
+	copy(pcri.DigestAtCreation[:], d)
+
+	if glog.V(2) {
+		glog.Info("Created pcrInfoLong with serialized form %s\n", pcri)
+	}
+
+	return pcri, nil
+}
+
+// A sealCommand is the command sent to the TPM to seal data.
+type sealCommand struct {
+	KeyHandle tpmHandle
+	EncAuth   authValue
+}
+
+// String returns a string representation of a sealCommand.
+func (sc sealCommand) String() string {
+	return fmt.Sprintf("sealCommand{KeyHandle: %x, EncAuth: % x}", sc.KeyHandle, sc.EncAuth)
+}
+
+// sealCommandAuth stores the auth information sent with a SealCommand.
+type sealCommandAuth struct {
+	AuthHandle  tpmHandle
+	NonceOdd    nonce
+	ContSession byte
+	PubAuth     authValue
+}
+
+// String returns a string representation of a sealCommandAuth.
+func (sca sealCommandAuth) String() string {
+	return fmt.Sprintf("sealCommandAuth{AuthHandle: %x, NonceOdd: % x, ContSession: %x, PubAuth: % x}", sca.AuthHandle, sca.NonceOdd, sca.ContSession, sca.PubAuth)
+}
+
+// sealResponse contains the auth information returned from a sealCommand.
+type sealResponse struct {
+	NonceEven   nonce
+	ContSession byte
+	PubAuth     authValue
+}
+
+// String returns a string representation of a sealResponse.
+func (sr sealResponse) String() string {
+	return fmt.Sprintf("sealResponse{NonceEven: % x, ContSession: %x, PubAuth: % x}", sr.NonceEven, sr.ContSession, sr.PubAuth)
+}
+
+// seal performs a seal operation on the TPM.
+func seal(f *os.File, sc *sealCommand, pcrs *pcrInfoLong, data []byte, sca *sealCommandAuth) ([]byte, *sealResponse, error) {
+	datasize := uint32(len(data))
+	pcrsize := binary.Size(pcrs)
+	if pcrsize < 0 {
+		return nil, nil, errors.New("Couldn't compute the size of a pcrInfoLong")
+	}
+
+	in := []interface{}{sc, uint32(pcrsize), pcrs, datasize, data, sca}
#*
#* author: Kevin Walsh
#* email: kwalsh@holycross.edu
#* date: 2014-08-02T00:38:10-0400
#*
#- Under my suggestion, all the above would reduce to:
#-   in := []interface{sc, pcrs, data, sca}
#- without any of the size calculations.
+
+	// The slice will be resized by Unpack to the size of the sealed value.
+	var b []byte
+	var resp sealResponse
+	out := []interface{}{resizeableSlice(&b), &resp}
+	if err := submitTPMRequest(f, tagRQUAuth1Command, ordSeal, in, out); err != nil {
+		return nil, nil, err
+	}
#*
#* author: Kevin Walsh
#* email: kwalsh@holycross.edu
#* date: 2014-08-02T00:41:40-0400
#*
#- Under my suggestion, this would be
#-   var b tpmStoredData
#-   out := []interface{}(&b, &resp)
#- Or just put the tpmStoredData as a field inside resp.
+
+	return b, &resp, nil
+}
+
+// unsealResponse contains the auth information returned from an unsealCommand.
+type unsealResponse struct {
+	NonceEven   nonce
+	ContSession byte
+	ResultAuth  authValue
+}
+
+// String returns a string representation of an unsealResponse.
+func (ur unsealResponse) String() string {
+	return fmt.Sprintf("unsealResponse{NonceEven: % x, ContSession: %x, ResultAuth: % x}", ur.NonceEven, ur.ContSession, ur.ResultAuth)
+}
+
+// unseal data sealed by the TPM.
+func unseal(f *os.File, keyHandle tpmHandle, sealed []byte, auth1 *sealCommandAuth, auth2 *sealCommandAuth) ([]byte, *unsealResponse, *unsealResponse, error) {
+	in := []interface{}{keyHandle, sealed, auth1, auth2}
+	var outb []byte
+	var size uint32
+	var outAuth1 unsealResponse
+	var outAuth2 unsealResponse
+	out := []interface{}{&size, resizeableSlice(&outb), &outAuth1, &outAuth2}
#*
#* author: Kevin Walsh
#* email: kwalsh@holycross.edu
#* date: 2014-08-02T00:44:02-0400
#*
#- More size calculations that could be eliminated.
#-
+	if err := submitTPMRequest(f, tagRQUAuth2Command, ordUnseal, in, out); err != nil {
+		return nil, nil, nil, err
+	}
+
+	return outb, &outAuth1, &outAuth2, nil
+}
+
+// Seal encrypts data under PCR 17 and returns the sealed data.
+func Seal(f *os.File, data []byte) ([]byte, error) {
+	var mask PCRMask
+	if err := mask.SetPCR(17); err != nil {
+		return nil, err
+	}
+
+	if glog.V(2) {
+		glog.Infof("mask is % x\n", mask)
+	}
+
+	pcrVals, err := FetchPCRValues(f, mask)
+	if err != nil {
+		return nil, err
+	}
+
+	if glog.V(2) {
+		glog.Infof("pcrVals is % x\n", pcrVals)
+	}
+
+	// Locality is apparently always set to 0 in vTCIDirect.
+	var locality byte
+	pcrInfo, err := createPCRInfo(locality, mask, pcrVals)
+	if err != nil {
+		return nil, err
+	}
+
+	if glog.V(2) {
+		glog.Infof("pcrInfo is %s\n", pcrInfo)
+	}
+
+	// Try to run OSAP for the SRK, reading a random OddOSAP for our initial
+	// command.
+	osapc := osapCommand{
+		EntityType:  etSRK,
+		EntityValue: khSRK,
+	}
+
+	if _, err := rand.Read(osapc.OddOSAP[:]); err != nil {
+		return nil, err
+	}
+
+	if glog.V(2) {
+		glog.Infof("osapCommand is %s\n", osapc)
+	}
+
+	osapr, err := osap(f, osapc)
+	if err != nil {
+		return nil, err
+	}
+
+	if glog.V(2) {
+		glog.Infof("osapResponse is %s\n", osapr)
+	}
+
+	// A shared secret is computed as
+	//
+	// sharedSecret = HMAC-SHA1(srkAuth, evenosap||oddosap)
+	//
+	// where srkAuth is the hash of the SRK authentication (which hash is all 0s
+	// for the well-known SRK auth value, which is what we're using right now),
+	// and even and odd OSAP are the values from the OSAP protocol.
+	osapData, err := pack([]interface{}{osapr.EvenOSAP, osapc.OddOSAP})
+	if err != nil {
+		return nil, err
+	}
+
+	if glog.V(2) {
+		glog.Infof("osapData is % x\n", osapData)
+	}
+
+	// TODO(tmroeder): test this with secrets other than the well-known secret.
+	// Note that this will require setting up the TPM differently.
+	wellKnownAuth := make([]byte, authSize)
#*
#* author: Kevin Walsh
#* email: kwalsh@holycross.edu
#* date: 2014-08-02T00:45:27-0400
#*
#- Use authValue type here.
#-   wellKnownAuth := new(AuthValue)
#- Then below you can use
#-   wellKnownAuth[:]
#- if you need a slice.
#-
+	if glog.V(2) {
+		glog.Infof("wellKnownAuth is % x\n", wellKnownAuth)
+	}
+
+	hm := hmac.New(sha1.New, wellKnownAuth)
+	hm.Write(osapData)
+	sharedSecret := hm.Sum(nil)
+
+	if glog.V(2) {
+		glog.Infof("hmac size is %d\n", hm.Size())
+		glog.Infof("sharedSecret is % x\n", sharedSecret)
+		glog.Infof("length of shared secret is %d\n", len(sharedSecret))
+	}
+
+	// EncAuth is computed as
+	//
+	// encAuth = XOR(srkAuth, SHA1(sharedSecret || <lastEvenNonce>))
+	//
+	// In this case, the last even nonce is NonceEven from OSAP.
+	xorData, err := pack([]interface{}{sharedSecret, osapr.NonceEven})
+	if err != nil {
+		return nil, err
+	}
+
+	if glog.V(2) {
+		glog.Infof("xorData is % x\n", xorData)
+	}
+
+	encAuthData := sha1.Sum(xorData)
+
+	if glog.V(2) {
+		glog.Infof("encAuthData is % x\n", encAuthData)
+	}
+
+	// Zero out the xorData, since it contains the sharedSecret.
+	//    for i := range xorData {
+	//        xorData[i] = 0
+	//    }
+
+	sc := &sealCommand{KeyHandle: khSRK}
+
+	for i := range sc.EncAuth {
+		sc.EncAuth[i] = wellKnownAuth[i] ^ encAuthData[i]
+	}
+
+	if glog.V(2) {
+		glog.Infof("sealCommand is %s\n", sc)
+	}
+
+	// The digest input to pubauth is
+	//
+	// digest = SHA1(ordSeal || encAuth || binary.Size(pcrInfo) || pcrInfo ||
+	//               len(data) || data)
+	//
+	// and the PubAuth value is then
+	//
+	// PubAuth = HMAC-SHA1(sharedSecret, digest || NonceEven || NonceOdd ||
+	//                     ContSession)
+	//
+	// where ContSession is the value chosen for sealCommandAuth
+	digestBytes, err := pack([]interface{}{ordSeal, sc.EncAuth, uint32(binary.Size(pcrInfo)), pcrInfo, uint32(len(data)), data})
+	if err != nil {
+		return nil, err
+	}
#*
#* author: Kevin Walsh
#* email: kwalsh@holycross.edu
#* date: 2014-08-02T00:47:51-0400
#*
#- A few more size calculations to eliminate.
+
+	if glog.V(2) {
+		glog.Infof("digestBytes is % x\n", digestBytes)
+	}
+
+	digest := sha1.Sum(digestBytes)
+
+	if glog.V(2) {
+		glog.Infof("digest is % x\n", digest)
+	}
+
+	// Except for the auth handle from OSAP, all the values of the
+	// sealCommandAuth start at 0, including ContSession and NonceOdd. We then
+	// fill NonceOdd with strong random bytes and compute PubAuth according to
+	// the standard TPM algorithm.
+	sca := &sealCommandAuth{
+		AuthHandle: osapr.AuthHandle,
+	}
+	if _, err := rand.Read(sca.NonceOdd[:]); err != nil {
+		return nil, err
+	}
+
+	if glog.V(2) {
+		glog.Infof("sealCommandAuth is %s\n", sca)
+	}
+
+	pubAuthBytes, err := pack([]interface{}{digest, osapr.NonceEven, sca.NonceOdd, sca.ContSession})
+	if err != nil {
+		return nil, err
+	}
+
+	if glog.V(2) {
+		glog.Infof("pubAuthBytes is % x\n", pubAuthBytes)
+	}
+
+	hm2 := hmac.New(sha1.New, sharedSecret)
+	hm2.Write(pubAuthBytes)
+	pubAuth := hm2.Sum(nil)
+	copy(sca.PubAuth[:], pubAuth[:])
+
+	if glog.V(2) {
+		glog.Infof("sealCommandAuth now is %s\n", sca)
+	}
+
+	sealed, _, err := seal(f, sc, pcrInfo, data, sca)
+	if err != nil {
+		return nil, err
+	}
+
+	return sealed, nil
+}
+
+// Unseal decrypts data encrypted by the TPM for PCR 17.
+func Unseal(f *os.File, sealed []byte) ([]byte, error) {
+	// Try to run OSAP for the SRK, reading a random OddOSAP for our initial
+	// command.
+	osapc := osapCommand{
+		EntityType:  etSRK,
+		EntityValue: khSRK,
+	}
+
+	if _, err := rand.Read(osapc.OddOSAP[:]); err != nil {
+		return nil, err
+	}
+
+	if glog.V(2) {
+		glog.Infof("osapCommand is %s\n", osapc)
+	}
+
+	osapr, err := osap(f, osapc)
+	if err != nil {
+		return nil, err
+	}
+
+	if glog.V(2) {
+		glog.Infof("osapResponse is %s\n", osapr)
+	}
+
+	// A shared secret is computed as
+	//
+	// sharedSecret = HMAC-SHA1(srkAuth, evenosap||oddosap)
+	//
+	// where srkAuth is the hash of the SRK authentication (which hash is all 0s
+	// for the well-known SRK auth value, which is what we're using right now),
+	// and even and odd OSAP are the values from the OSAP protocol.
+	osapData, err := pack([]interface{}{osapr.EvenOSAP, osapc.OddOSAP})
+	if err != nil {
+		return nil, err
+	}
+
+	if glog.V(2) {
+		glog.Infof("osapData is % x\n", osapData)
+	}
+
+	// TODO(tmroeder): test this with secrets other than the well-known secret.
+	// Note that this will require setting up the TPM differently.
+	wellKnownAuth := make([]byte, authSize)
+	if glog.V(2) {
+		glog.Infof("wellKnownAuth is % x\n", wellKnownAuth)
+	}
+
+	hm := hmac.New(sha1.New, wellKnownAuth)
+	hm.Write(osapData)
+	sharedSecret := hm.Sum(nil)
+
+	if glog.V(2) {
+		glog.Infof("hmac size is %d\n", hm.Size())
+		glog.Infof("sharedSecret is % x\n", sharedSecret)
+		glog.Infof("length of shared secret is %d\n", len(sharedSecret))
+	}
+
+	// The unseal command needs an OIAP session in addition to the OSAP session.
+	oiapr, err := oiap(f)
+	if err != nil {
+		return nil, err
+	}
+
+	// The digest for the unseal command is computed as
+	//
+	// digest = SHA1(ordUnseal || sealed)
+	digestInput, err := pack([]interface{}{ordUnseal, sealed})
+	if err != nil {
+		return nil, err
+	}
+
+	digest := sha1.Sum(digestInput)
+
+	// The first PubAuth value for unseal is computed as
+	//
+	// PubAuth = HMAC-SHA1(sharedSecret, digest || NonceEven || NonceOdd ||
+	//                     ContSession)
+	sca := &sealCommandAuth{
+		AuthHandle: osapr.AuthHandle,
+	}
+
+	if _, err := rand.Read(sca.NonceOdd[:]); err != nil {
+		return nil, err
+	}
+
+	pubAuthInput, err := pack([]interface{}{digest, osapr.NonceEven, sca.NonceOdd, sca.ContSession})
+	if err != nil {
+		return nil, err
+	}
+
+	h := hmac.New(sha1.New, sharedSecret)
+	h.Write(pubAuthInput)
+	pa := h.Sum(nil)
+	copy(sca.PubAuth[:], pa[:])
+
+	// The second PubAuth value for unseal is computed as
+	//
+	// PubAuth2 = HMAC-SHA1(srkAuth, digest || NonceEven2 || NonceOdd2 ||
+	//                      ContSession2)
+	sca2 := &sealCommandAuth{
+		AuthHandle: oiapr.AuthHandle,
+	}
+
+	if _, err := rand.Read(sca2.NonceOdd[:]); err != nil {
+		return nil, err
+	}
+
+	pubAuthInput2, err := pack([]interface{}{digest, oiapr.NonceEven, sca2.NonceOdd, sca2.ContSession})
+	if err != nil {
+		return nil, err
+	}
+
+	h2 := hmac.New(sha1.New, wellKnownAuth)
+	h2.Write(pubAuthInput2)
+	pa2 := h2.Sum(nil)
+	copy(sca2.PubAuth[:], pa2[:])
+
+	unsealed, _, _, err := unseal(f, khSRK, sealed, sca, sca2)
+	if err != nil {
+		return nil, err
+	}
+
+	return unsealed, nil
+}
diff --git a/go/src/tpm/tpm_errors.go b/go/src/tpm/tpm_errors.go
index 91ff267..c758c71 100644
--- a/go/src/tpm/tpm_errors.go
+++ b/go/src/tpm/tpm_errors.go
@@ -1,20 +1,34 @@
+// Copyright (c) 2014, Google Inc. All rights reserved.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
 package tpm
 
 import (
 	"strconv"
 )
 
 // A tpmError is an error value from the TPM.
 type tpmError uint32
 
 // Error produces a string for the given TPM Error code
 func (o tpmError) Error() string {
 	if s, ok := tpmErrMsgs[o]; ok {
 		return "tpm: " + s
 	}
 
 	return "tpm: unknown error code " + strconv.Itoa(int(o))
 }
 
 // These are the TPM error codes from the spec.
 const (
@@ -148,41 +162,41 @@ var tpmErrMsgs = map[tpmError]string{
 	ErrFailedSelfTest:        "self-test has failed and the TPM has shutdown",
 	ErrAuth2Fail:             "the authorization for the second key in a 2 key function failed authorization",
 	ErrBadTag:                "the tag value sent to for a command is invalid",
 	ErrIOError:               "an IO error occurred transmitting information to the TPM",
 	ErrEncryptError:          "the encryption process had a problem",
 	ErrDecryptError:          "the decryption process had a problem",
 	ErrInvalidAuthHandle:     "an invalid handle was used",
 	ErrNoEndorsement:         "the TPM does not have an EK installed",
 	ErrInvalidKeyUsage:       "the usage of a key is not allowed",
 	ErrWrongEntityType:       "the submitted entity type is not allowed",
 	ErrInvalidPostInit:       "the command was received in the wrong sequence relative to Init and a subsequent Startup",
 	ErrInappropriateSig:      "signed data cannot include additional DER information",
 	ErrBadKeyProperty:        "the key properties in KEY_PARAMs are not supported by this TPM",
 	ErrBadMigration:          "the migration properties of this key are incorrect",
 	ErrBadScheme:             "the signature or encryption scheme for this key is incorrect or not permitted in this situation",
 	ErrBadDatasize:           "the size of the data (or blob) parameter is bad or inconsistent with the referenced key",
 	ErrBadMode:               "a mode parameter is bad, such as capArea or subCapArea for GetCapability, physicalPresence parameter for PhysicalPresence, or migrationType for CreateMigrationBlob",
 	ErrBadPresence:           "either the physicalPresence or physicalPresenceLock bits have the wrong value",
 	ErrBadVersion:            "the TPM cannot perform this version of the capability",
 	ErrNoWrapTransport:       "the TPM does not allow for wrapped transport sessions",
-	ErrAuditFailUnsuccessful: "TPM audit construction failed and th eunderlying command was returning a failure code also",
+	ErrAuditFailUnsuccessful: "TPM audit construction failed and the underlying command was returning a failure code also",
 	ErrAuditFailSuccessful:   "TPM audit construction failed and the underlying command was returning success",
 	ErrNotResetable:          "attempt to reset a PCR register that does not have the resettable attribute",
 	ErrNotLocal:              "attempt to reset a PCR register that requires locality and locality modifier not part of command transport",
 	ErrBadType:               "make identity blob not properly typed",
 	ErrInvalidResource:       "when saving context identified resource type does not match actual resource",
 	ErrNotFIPS:               "the TPM is attempting to execute a command only available when in FIPS mode",
 	ErrInvalidFamily:         "the command is attempting to use an invalid family ID",
 	ErrNoNVPermission:        "the permission to manipulate the NV storage is not available",
 	ErrRequiresSign:          "the operation requires a signed command",
 	ErrKeyNotSupported:       "wrong operation to load an NV key",
 	ErrAuthConflict:          "NV_LoadKey blob requires both owner and blob authorization",
 	ErrAreaLocked:            "the NV area is locked and not writeable",
 	ErrBadLocality:           "the locality is incorrect for the attempted operation",
 	ErrReadOnly:              "the NV area is read only and can't be written to",
 	ErrPerNoWrite:            "there is no protection on the write to the NV area",
 	ErrFamilyCount:           "the family count value does not match",
 	ErrWriteLocked:           "the NV area has already been written to",
 	ErrBadAttributes:         "the NV area attributes conflict",
 	ErrInvalidStructure:      "the structure tag and version are invalid or inconsistent",
 	ErrKeyOwnerControl:       "the key is under control of the TPM Owner and can only be evicted by the TPM Owner",
diff --git a/go/src/tpm/tpm_test.go b/go/src/tpm/tpm_test.go
index 9b9fffd..0b889ff 100644
--- a/go/src/tpm/tpm_test.go
+++ b/go/src/tpm/tpm_test.go
@@ -1,59 +1,274 @@
+// Copyright (c) 2014, Google Inc. All rights reserved.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
 package tpm
 
 import (
+	"bytes"
+	"crypto/rand"
+	"encoding/binary"
 	"os"
 	"testing"
 )
 
 func TestEncoding(t *testing.T) {
-	ch := CommandHeader{tagRQUCommand, 0, ordOIAP}
+	ch := commandHeader{tagRQUCommand, 0, ordOIAP}
 	var c uint32 = 137
 	in := []interface{}{c}
 
-	b, err := Pack(ch, in)
+	b, err := packWithHeader(ch, in)
 	if err != nil {
 		t.Fatal("Couldn't pack the bytes:", err)
 	}
 
-	var hdr CommandHeader
+	var hdr commandHeader
 	var size uint32
 	out := []interface{}{&hdr, &size}
-	if err := Unpack(b, out); err != nil {
+	if err := simpleUnpack(b, out); err != nil {
 		t.Fatal("Couldn't unpack the packed bytes")
 	}
 
 	if size != 137 {
 		t.Fatal("Got the wrong size back")
 	}
 }
 
 func TestReadPCR(t *testing.T) {
 	// Try to read PCR 18. For this to work, you have to have access to
 	// /dev/tpm0, and there has to be a TPM driver to answer requests.
 	f, err := os.OpenFile("/dev/tpm0", os.O_RDWR, 0600)
+	defer f.Close()
 	if err != nil {
 		t.Fatal("Can't open /dev/tpm0 for read/write:", err)
 	}
 
 	res, err := ReadPCR(f, 18)
 	if err != nil {
 		t.Fatal("Couldn't read PCR 18 from the TPM:", err)
 	}
 
 	t.Logf("Got PCR 18 value % x\n", res)
 }
 
+func TestPCRMask(t *testing.T) {
+	var mask PCRMask
+	if err := mask.SetPCR(-1); err == nil {
+		t.Fatal("Incorrectly allowed non-existent PCR -1 to be set")
+	}
+
+	if err := mask.SetPCR(24); err == nil {
+		t.Fatal("Incorrectly allowed non-existent PCR 24 to be set")
+	}
+
+	if err := mask.SetPCR(0); err != nil {
+		t.Fatal("Couldn't set PCR 0 in the mask:", err)
+	}
+
+	set, err := mask.IsPCRSet(0)
+	if err != nil {
+		t.Fatal("Couldn't check to see if PCR 0 was set:", err)
+	}
+
+	if !set {
+		t.Fatal("Incorrectly said PCR wasn't set when it should have been")
+	}
+
+	if err := mask.SetPCR(18); err != nil {
+		t.Fatal("Couldn't set PCR 18 in the mask:", err)
+	}
+
+	set, err = mask.IsPCRSet(18)
+	if err != nil {
+		t.Fatal("Couldn't check to see if PCR 18 was set:", err)
+	}
+
+	if !set {
+		t.Fatal("Incorrectly said PCR wasn't set when it should have been")
+	}
+}
+
+func TestFetchPCRValues(t *testing.T) {
+	// Try to get 16 bytes of randomness from the TPM.
+	f, err := os.OpenFile("/dev/tpm0", os.O_RDWR, 0600)
+	defer f.Close()
+	if err != nil {
+		t.Fatal("Can't open /dev/tpm0 for read/write:", err)
+	}
+
+	var mask PCRMask
+	if err := mask.SetPCR(17); err != nil {
+		t.Fatal("Couldn't set PCR 17:", err)
+	}
+
+	pcrs, err := FetchPCRValues(f, mask)
+	if err != nil {
+		t.Fatal("Couldn't get PCRs 17 and 18:", err)
+	}
+
+	comp, err := createPCRComposite(mask, pcrs)
+	if err != nil {
+		t.Fatal("Couldn't create PCR composite")
+	}
+
+	if len(comp) != int(digestSize) {
+		t.Fatal("Invalid PCR composite")
+	}
+
+	// Locality is apparently always set to 0 in vTCIDirect.
+	var locality byte
+	_, err = createPCRInfo(locality, mask, pcrs)
+	if err != nil {
+		t.Fatal("Couldn't create a pcrInfoLong structure for these PCRs")
+	}
+}
+
 func TestGetRandom(t *testing.T) {
 	// Try to get 16 bytes of randomness from the TPM.
 	f, err := os.OpenFile("/dev/tpm0", os.O_RDWR, 0600)
+	defer f.Close()
 	if err != nil {
 		t.Fatal("Can't open /dev/tpm0 for read/write:", err)
 	}
 
 	b, err := GetRandom(f, 16)
 	if err != nil {
 		t.Fatal("Couldn't get 16 bytes of randomness from the TPM:", err)
 	}
 
 	t.Logf("Got random bytes % x\n", b)
 }
+
+func TestOIAP(t *testing.T) {
+	f, err := os.OpenFile("/dev/tpm0", os.O_RDWR, 0600)
+	defer f.Close()
+	if err != nil {
+		t.Fatal("Can't open /dev/tpm0 for read/write:", err)
+	}
+
+	// Get auth info from OIAP.
+	resp, err := oiap(f)
+	if err != nil {
+		t.Fatal("Couldn't run OIAP:", err)
+	}
+
+	t.Logf("From OIAP, got AuthHandle %d and NonceEven % x\n", resp.AuthHandle, resp.NonceEven)
+}
+
+func TestOSAP(t *testing.T) {
+	f, err := os.OpenFile("/dev/tpm0", os.O_RDWR, 0600)
+	defer f.Close()
+	if err != nil {
+		t.Fatal("Can't open /dev/tpm0 for read/write:", err)
+	}
+
+	// Try to run OSAP for the SRK.
+	osapc := osapCommand{
+		EntityType:  etSRK,
+		EntityValue: khSRK,
+	}
+
+	if _, err := rand.Read(osapc.OddOSAP[:]); err != nil {
+		t.Fatal("Couldn't get a random odd OSAP nonce")
+	}
+
+	resp, err := osap(f, osapc)
+	if err != nil {
+		t.Fatal("Couldn't run OSAP:", err)
+	}
+
+	t.Logf("From OSAP, go AuthHandle %d and NonceEven % x and EvenOSAP % x\n", resp.AuthHandle, resp.NonceEven, resp.EvenOSAP)
+}
+
+func TestResizeableSliceNoHeader(t *testing.T) {
+	var b []byte
+	var outb []byte
+	out := []interface{}{resizeableSlice(&outb)}
+	if err := unpack(b, out, nil, 0); err == nil {
+		t.Fatal("Incorrectly unpacked a resizeableSlice without using a header")
+	}
+}
+
+func TestResizeableSlice(t *testing.T) {
+	// Set up an encoded slice with a byte array.
+	sr := &sealResponse{
+		NonceEven:   [20]byte{},
+		ContSession: 1,
+		PubAuth:     [20]byte{},
+	}
+
+	b := make([]byte, 322)
+	if _, err := rand.Read(b); err != nil {
+		t.Fatal("Couldn't read random bytes into the byte array")
+	}
+
+	rh := &responseHeader{
+		Tag:  tagRSPAuth1Command,
+		Size: 0,
+		Res:  0,
+	}
+
+	rh.Size = uint32(binary.Size(rh) + binary.Size(sr) + binary.Size(b))
+
+	in := []interface{}{rh, sr, b}
+	bb, err := pack(in)
+	if err != nil {
+		t.Fatal("Couldn't pack the bytes:", err)
+	}
+
+	rest := uint(binary.Size(rh) + binary.Size(sr))
+	var rh2 responseHeader
+	var sr2 sealResponse
+	b2 := make([]byte, 20)
+
+	// Normally, the response header is read separately. But this time, we
+	// happen to already have one handy, so we use it instead to simplify the
+	// test.
+	out := []interface{}{&rh2, &sr2, resizeableSlice(&b2)}
+	if err := unpack(bb, out, rh, rest); err != nil {
+		t.Fatal("Couldn't unpack the resizeable values:", err)
+	}
+
+	if !bytes.Equal(b2, b) {
+		t.Fatal("ResizeableSlice was not resized or copied correctly")
+	}
+}
+
+func TestSeal(t *testing.T) {
+	f, err := os.OpenFile("/dev/tpm0", os.O_RDWR, 0600)
+	defer f.Close()
+	if err != nil {
+		t.Fatal("Can't open /dev/tpm0 for read/write:", err)
+	}
+
+	// Seal the same data as vTCIDirect so we can check the output as exactly as
+	// possible.
+	data := make([]byte, 64)
+	data[0] = 1
+	data[1] = 27
+	data[2] = 52
+
+	sealed, err := Seal(f, data)
+	if err != nil {
+		t.Fatal("Couldn't seal the data:", err)
+	}
+
+	data2, err := Unseal(f, sealed)
+	if err != nil {
+		t.Fatal("Couldn't unseal the data:", err)
+	}
+
+	if !bytes.Equal(data2, data) {
+		t.Fatal("Unsealed data doesn't match original data")
+	}
+}
