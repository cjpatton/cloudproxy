#* 
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-08-19T10:35:14-0700
#* 
#- Add ACLGuard and tests for ACLGuard
#- 
#- This commit adds a new, simple ACLGuard that stores strings and checks queries
#- by checking string equality. This commit also adds tests for ACLGuard. Other
#- than Save and Load, coverage is 100% for the functions in ACLGuard.
#- 
#- 
#**
#** author: Kevin Walsh
#** email: kwalsh@holycross.edu
#** date: 2014-08-19T14:17:32-0400
#**
#-- This is all fine. Comments below are just fyi, no changes needed. You will
#-- need a little more code in domain.go to fully integrate this... just search
#-- for "acl" and replace my pseudo-code comments with actual code.
#--
diff --git a/go/src/cloudproxy/tao/acl_guard.go b/go/src/cloudproxy/tao/acl_guard.go
new file mode 100644
index 0000000..337b872
--- /dev/null
+++ b/go/src/cloudproxy/tao/acl_guard.go
@@ -0,0 +1,224 @@
+// Copyright (c) 2014, Google Inc.  All rights reserved.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package tao
+
+import (
+	"errors"
+	"io/ioutil"
+	"os"
+	"strings"
+
+	"cloudproxy/tao/auth"
+)
+
+// ACLGuardConfig stores the configuration for an ACLGuard.
+// TODO(tmroeder): these two paths should really be a single file that contains
+// the list and the signed data, either gob-encoded or protobuf-encoded.
+type ACLGuardConfig struct {
+	SignedACLsPath string
+	SignaturePath  string
+}
+
+// An ACLGuard is an implementation of tao.Guard that uses an ACL to make
+// authorization decisions. All rules are immediately converted to strings when
+// they are added, and they are never converted back to auth.ast form. Any
+// policy that requires more than string comparison should use DatalogGuard.
+type ACLGuard struct {
+	Config ACLGuardConfig
+	ACL    []string
+}
+
+// ACLGuardSigningContext is the context used for ACL-file signatures.
+const ACLGuardSigningContext = "tao.ACLGuard Version 1"
+const aclGuardFileMode os.FileMode = 0600
+
+// NewACLGuard produces a Guard implementation that implements ACLGuard.
+func NewACLGuard(config ACLGuardConfig) Guard {
+	return &ACLGuard{Config: config}
+}
+
+// Subprincipal returns a unique subprincipal for this policy.
+func (a *ACLGuard) Subprincipal() auth.SubPrin {
+	pe := auth.PrinExt{Name: "ACLGuard"}
+	for _, p := range a.ACL {
+		pe.Arg = append(pe.Arg, auth.Str(p))
+	}
+	return []auth.PrinExt{pe}
+}
#*
#* author: Kevin Walsh
#* email: kwalsh@holycross.edu
#* date: 2014-08-19T14:06:18-0400
#*
#- For now, ACLGuard(path, path) is fine. But really it should probably be
#- ACLGuard(key) since, aside from the actual list of rules, the key is the only
#- important distinguishing feature of this guard. I have this in datalog guard
#- already, and when I merge I will fix both.
#-
+
+// Save writes all presistent policy data to disk, signed by key.
+func (a *ACLGuard) Save(key *Signer) error {
+	rules := strings.Join(a.ACL, "\n")
+	sig, err := key.Sign([]byte(rules), ACLGuardSigningContext)
+	if err != nil {
+		return err
+	}
+
+	if err := ioutil.WriteFile(a.Config.SignaturePath, sig, aclGuardFileMode); err != nil {
+		return err
+	}
+	if err := ioutil.WriteFile(a.Config.SignedACLsPath, []byte(rules), aclGuardFileMode); err != nil {
+		return err
+	}
+
+	return nil
+}
+
+// Load restores a set of rules saved with Save. It replaces any rules in the
+// ACLGuard with the rules it loaded. In the process, it also checks the
+// signature created during the Save process.
+func LoadACLGuard(key *Verifier, config ACLGuardConfig) (Guard, error) {
+	rules, err := ioutil.ReadFile(config.SignedACLsPath)
+	if err != nil {
+		return nil, err
+	}
+
+	sig, err := ioutil.ReadFile(config.SignaturePath)
+	if err != nil {
+		return nil, err
+	}
+
+	ok, err := key.Verify(rules, ACLGuardSigningContext, sig)
+	if err != nil {
+		return nil, err
+	}
+
+	if !ok {
+		return nil, errors.New("the signature on the file didn't pass verification")
+	}
+
+	a := &ACLGuard{Config: config}
+	a.ACL = strings.Split(string(rules), "\n")
+	return a, nil
+}
+
+func createPredicateString(name auth.Prin, op string, args []string) string {
+	p := auth.Pred{
+		Name: "Authorized",
+		Arg:  make([]auth.Term, len(args)+2),
+	}
+	p.Arg[0] = name
+	p.Arg[1] = auth.Str(op)
+	for i, s := range args {
+		p.Arg[i+2] = auth.Str(s)
+	}
+
+	return p.String()
+}
#*
#* author: Kevin Walsh
#* email: kwalsh@holycross.edu
#* date: 2014-08-19T14:09:55-0400
#*
#- I have a patch elsewhere that will turn the above function into just:
#- auth.MakePredicate("Authorized", name, args...).String()
#- I'll fix this when I merge. Also, it is fortunate here though somewhat
#- accidental that String() is actually canonical.
#-
+
+// Authorize adds an authorization for a principal to perform an
+// operation.
+func (a *ACLGuard) Authorize(name auth.Prin, op string, args []string) error {
+	a.ACL = append(a.ACL, createPredicateString(name, op, args))
+	return nil
+}
+
+// Retract removes an authorization for a principal to perform an
+// operation, essentially reversing the effect of an Authorize() call
+// with identical name, op, and args. Note: this reverses the effect of
+// an Authorize() call with identical parameters of the equivalent
+// AddRule() call. However, particularly when expressive policies are
+// supported (e.g., an "authorize all" rule), other rules may still be
+// in place authorizing the principal to perform the operation.
+func (a *ACLGuard) Retract(name auth.Prin, op string, args []string) error {
+	ps := createPredicateString(name, op, args)
+	i := 0
+	for i < len(a.ACL) {
+		if ps == a.ACL[i] {
+			a.ACL[i], a.ACL, i = a.ACL[len(a.ACL)-1], a.ACL[:len(a.ACL)-1], i-1
+		}
+
+		i++
+	}
+	return nil
+}
+
+// IsAuthorized checks whether a principal is authorized to perform an
+// operation.
+func (a *ACLGuard) IsAuthorized(name auth.Prin, op string, args []string) bool {
+	ps := createPredicateString(name, op, args)
+	for _, s := range a.ACL {
+		if s == ps {
+			return true
+		}
+	}
+	return false
+}
+
+// AddRule adds a policy rule. Subclasses should support at least rules
+// of the form: Authorized(P, op, args...). This is equivalent to
+// calling Authorize(P, op, args...) with each of the arguments
+// converted to either a string or integer.
+func (a *ACLGuard) AddRule(rule string) error {
+	a.ACL = append(a.ACL, rule)
+	return nil
+}
+
+// RetractRule removes a rule previously added via AddRule() or the
+// equivalent Authorize() call.
+func (a *ACLGuard) RetractRule(rule string) error {
+	i := 0
+	for i < len(a.ACL) {
+		if rule == a.ACL[i] {
+			a.ACL[i], a.ACL, i = a.ACL[len(a.ACL)-1], a.ACL[:len(a.ACL)-1], i-1
+		}
+
+		i++
+	}
+	return nil
+}
+
+// Clear removes all rules.
+func (a *ACLGuard) Clear() error {
+	a.ACL = make([]string, 0)
+	return nil
+}
+
+// Query the policy. Implementations of this interface should support
+// at least queries of the form: Authorized(P, op, args...).
+func (a *ACLGuard) Query(query string) (bool, error) {
+	for _, s := range a.ACL {
+		if query == s {
+			return true, nil
+		}
+	}
+
+	return false, nil
+}
+
+// RuleCount returns a count of the total number of rules.
+func (a *ACLGuard) RuleCount() int {
+	return len(a.ACL)
+}
+
+// GetRule returns the ith policy rule, if it exists.
+func (a *ACLGuard) GetRule(i int) string {
+	if i >= len(a.ACL) || i < 0 {
+		return ""
+	}
+	return a.ACL[i]
+}
+
+// RuleDebugString returns a debug string for the ith policy rule, if
+// it exists.
+func (a *ACLGuard) RuleDebugString(i int) string {
+	return a.GetRule(i)
+}
+
+// String returns a string suitable for showing users authorization
+// info.
+func (a *ACLGuard) String() string {
+	return "ACLGuard{\n" + strings.Join(a.ACL, "\n") + "\n}"
+}
diff --git a/go/src/cloudproxy/tao/acl_guard_test.go b/go/src/cloudproxy/tao/acl_guard_test.go
new file mode 100644
index 0000000..8a954fb
--- /dev/null
+++ b/go/src/cloudproxy/tao/acl_guard_test.go
@@ -0,0 +1,308 @@
+// Copyright (c) 2014, Google Inc.  All rights reserved.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package tao
+
+import (
+	"io/ioutil"
+	"os"
+	"path"
+	"strconv"
+	"testing"
+
+	"cloudproxy/tao/auth"
+)
+
+func testNewACLGuard(t *testing.T) (Guard, string) {
+	tmpdir, err := ioutil.TempDir("/tmp", "acl_guard_test")
+	if err != nil {
+		t.Fatal("Couldn't get a temp directory for the new ACL guard:", err)
+	}
+
+	aclsPath := path.Join(tmpdir, "acls")
+	sigPath := path.Join(tmpdir, "sig")
+	config := ACLGuardConfig{
+		SignedACLsPath: aclsPath,
+		SignaturePath:  sigPath,
+	}
+	tg := NewACLGuard(config)
+	return tg, tmpdir
+}
+
+func TestACLGuardSaveACLs(t *testing.T) {
+	s, err := GenerateSigner()
+	if err != nil {
+		t.Fatal("Couldn't generate a signer")
+	}
+
+	tg, tmpdir := testNewACLGuard(t)
+	defer os.RemoveAll(tmpdir)
+
+	p := auth.Prin{
+		Type: "key",
+		Key:  []byte(`Fake key`),
+	}
+	if err := tg.Authorize(p, "Write", []string{"filename"}); err != nil {
+		t.Fatal("Couldn't authorize a simple operation:", err)
+	}
+
+	if err := tg.Save(s); err != nil {
+		t.Fatal("Couldn't save the file")
+	}
+
+	aclsPath := path.Join(tmpdir, "acls")
+	sigPath := path.Join(tmpdir, "sig")
+	config := ACLGuardConfig{
+		SignedACLsPath: aclsPath,
+		SignaturePath:  sigPath,
+	}
+
+	v := s.GetVerifier()
+	aclg, err := LoadACLGuard(v, config)
+	if err != nil {
+		t.Fatal("Couldn't load the ACLs:", err)
+	}
+
+	if aclg.RuleCount() != tg.RuleCount() {
+		t.Fatal("Wrong number of rules in loaded ACLGuard")
+	}
+
+	if aclg.String() != tg.String() {
+		t.Fatal("Wrong string representation of loaded ACLGuard")
+	}
+}
+
+func TestACLGuardAuthorize(t *testing.T) {
+	tg, tmpdir := testNewACLGuard(t)
+	defer os.RemoveAll(tmpdir)
+
+	p := auth.Prin{
+		Type: "key",
+		Key:  []byte(`Fake key`),
+	}
+	if err := tg.Authorize(p, "Write", []string{"filename"}); err != nil {
+		t.Fatal("Couldn't authorize a simple operation:", err)
+	}
+
+	if !tg.IsAuthorized(p, "Write", []string{"filename"}) {
+		t.Fatal("A rule that was added to the ACL was not present")
+	}
+
+	if tg.IsAuthorized(p, "Write", []string{"file"}) {
+		t.Fatal("A rule was authorized even though it has the wrong file name")
+	}
+
+	if tg.IsAuthorized(p, "Read", []string{"filename"}) {
+		t.Fatal("A rule was authorized even though it has the wrong op")
+	}
+
+	if tg.IsAuthorized(auth.Prin{}, "Write", []string{"filename"}) {
+		t.Fatal("A rule was authorized even though it has the wrong principal")
+	}
+
+	if err := tg.Retract(p, "Write", []string{"filename"}); err != nil {
+		t.Fatal("Couldn't retract an existing rule:", err)
+	}
+
+	if tg.IsAuthorized(p, "Write", []string{"filename"}) {
+		t.Fatal("A rule was still authorized after it was retracted")
+	}
+}
+
+func TestACLGuardDoubleAuthorize(t *testing.T) {
+	tg, tmpdir := testNewACLGuard(t)
+	defer os.RemoveAll(tmpdir)
+
+	p := auth.Prin{
+		Type: "key",
+		Key:  []byte(`Fake key`),
+	}
+	if err := tg.Authorize(p, "Write", []string{"filename"}); err != nil {
+		t.Fatal("Couldn't authorize a simple operation:", err)
+	}
+
+	// So nice, we authorize it twice.
+	if err := tg.Authorize(p, "Write", []string{"filename"}); err != nil {
+		t.Fatal("Couldn't authorize a simple operation:", err)
+	}
+
+	if !tg.IsAuthorized(p, "Write", []string{"filename"}) {
+		t.Fatal("A rule that was added to the ACL was not present")
+	}
+
+	if err := tg.Retract(p, "Write", []string{"filename"}); err != nil {
+		t.Fatal("Couldn't retract an existing double-added rule:", err)
+	}
+
+	if tg.IsAuthorized(p, "Write", []string{"filename"}) {
+		t.Fatal("A rule was still authorized after it was retracted")
+	}
+}
+
+func TestACLGuardAddRule(t *testing.T) {
+	tg, tmpdir := testNewACLGuard(t)
+	defer os.RemoveAll(tmpdir)
+
+	if err := tg.AddRule("Fake rule"); err != nil {
+		t.Fatal("Couldn't add a fake rule to the ACL")
+	}
+
+	ret, err := tg.Query("Fake rule")
+	if err != nil {
+		t.Fatal("Couldn't query a fake rule from the ACLGuard:", err)
+	}
+
+	if !ret {
+		t.Fatal("ACLGuard.Query did not return true for a rule that was added by AddRule")
+	}
+
+	if err := tg.Clear(); err != nil {
+		t.Fatal("Couldn't clear the ACLGuard:", err)
+	}
+
+	ret, err = tg.Query("Fake rule")
+	if err != nil {
+		t.Fatal("Couldn't query a fake rule after clearing the ACLGuard:", err)
+	}
+
+	if ret {
+		t.Fatal("ACLGuard.Query returned true for a rule after clearing the ACLGuard")
+	}
+}
+
+func TestACLGuardRetractRule(t *testing.T) {
+	tg, tmpdir := testNewACLGuard(t)
+	defer os.RemoveAll(tmpdir)
+
+	if err := tg.AddRule("Fake rule"); err != nil {
+		t.Fatal("Couldn't add a fake rule to the ACL")
+	}
+
+	ret, err := tg.Query("Fake rule")
+	if err != nil {
+		t.Fatal("Couldn't query a fake rule from the ACLGuard:", err)
+	}
+
+	if !ret {
+		t.Fatal("ACLGuard.Query did not return true for a rule that was added by AddRule")
+	}
+
+	if err := tg.RetractRule("Fake rule"); err != nil {
+		t.Fatal("Couldn't clear the ACLGuard:", err)
+	}
+
+	ret, err = tg.Query("Fake rule")
+	if err != nil {
+		t.Fatal("Couldn't query a fake rule after clearing the ACLGuard:", err)
+	}
+
+	if ret {
+		t.Fatal("ACLGuard.Query returned true for a rule after retracting the rule")
+	}
+}
+
+func TestACLGuardRuleCount(t *testing.T) {
+	tg, tmpdir := testNewACLGuard(t)
+	defer os.RemoveAll(tmpdir)
+
+	count := 20
+	for i := 0; i < count; i++ {
+		if err := tg.AddRule(strconv.Itoa(i)); err != nil {
+			t.Fatal("Couldn't add a rule that was a single integer as a string:", err)
+		}
+	}
+
+	if tg.RuleCount() != count {
+		t.Fatal("Wrong rule count after adding 20 rules")
+	}
+
+	// add the same rule again and make sure the RuleCount goes up.
+	if err := tg.AddRule("0"); err != nil {
+		t.Fatal("Couldn't add the same rule twice to the list:", err)
+	}
+
+	if tg.RuleCount() != count+1 {
+		t.Fatal("Wrong rule count after adding a rule twice")
+	}
+
+	if err := tg.RetractRule("0"); err != nil {
+		t.Fatal("Couldn't retract a rule that had been added twice:", err)
+	}
+
+	if tg.RuleCount() != count-1 {
+		t.Fatal("Wrong rule count after removing a rule that had been added twice")
+	}
+}
+
+func TestACLGuardGetRule(t *testing.T) {
+	tg, tmpdir := testNewACLGuard(t)
+	defer os.RemoveAll(tmpdir)
+
+	count := 20
+	for i := 0; i < count; i++ {
+		if err := tg.AddRule(strconv.Itoa(i)); err != nil {
+			t.Fatal("Couldn't add a rule that was a single integer as a string:", err)
+		}
+	}
+
+	if tg.GetRule(0) != "0" {
+		t.Fatal("Got the wrong rule from GetRule")
+	}
+
+	if tg.GetRule(200) != "" {
+		t.Fatal("Got a non-empty rule string for a non-existent rule")
+	}
+
+	if tg.GetRule(-1) != "" {
+		t.Fatal("Got a non-empty rule string for a negative rule index")
+	}
+}
+
+func TestACLGuardRuleDebugString(t *testing.T) {
+	tg, tmpdir := testNewACLGuard(t)
+	defer os.RemoveAll(tmpdir)
+
+	count := 20
+	for i := 0; i < count; i++ {
+		if err := tg.AddRule(strconv.Itoa(i)); err != nil {
+			t.Fatal("Couldn't add a rule that was a single integer as a string:", err)
+		}
+	}
+
+	if tg.RuleDebugString(0) != "0" {
+		t.Fatal("Got the wrong rule from GetRule")
+	}
+
+	if tg.RuleDebugString(200) != "" {
+		t.Fatal("Got a non-empty rule string for a non-existent rule")
+	}
+
+	if tg.RuleDebugString(-1) != "" {
+		t.Fatal("Got a non-empty rule string for a negative rule index")
+	}
+}
+
+func TestACLGuardString(t *testing.T) {
+	tg, tmpdir := testNewACLGuard(t)
+	defer os.RemoveAll(tmpdir)
+
+	if err := tg.AddRule("0"); err != nil {
+		t.Fatal("Couldn't add a rule that was a single integer as a string:", err)
+	}
+
+	s := "ACLGuard{\n0\n}"
+	if tg.String() != s {
+		t.Fatal("Got the wrong string representation of the ACLGuard")
+	}
+}
diff --git a/go/src/cloudproxy/tao/domain.go b/go/src/cloudproxy/tao/domain.go
index 8b22401..8406b72 100644
--- a/go/src/cloudproxy/tao/domain.go
+++ b/go/src/cloudproxy/tao/domain.go
@@ -26,45 +26,40 @@ import (
 )
 
 // Domain manages domain-wide authorization policies and configuration for a
 // single Tao administrative domain. Configuration includes a name, domain guard
 // type, ACLs or other guard-specific policy data, and a key pair for signing
 // policy data.
 //
 // Except for a password used to encrypt the policy private key, top-level
 // configuration data for Domain is stored in a text file, typically named
 // "tao.config". This configuration file contains the locations of all other
 // files and directories, e.g. configuration files for the domain guard. File
 // and directory paths within the tao.config file are relative to the location
 // of the tao.config file itself.
 type Domain struct {
 	Config     DomainConfig
 	ConfigPath string
 	Keys       *Keys
 	Guard      Guard
 }
 
-// TODO(kwalsh) Move to acl_guard.go when that file exists.
-type ACLGuardConfig struct {
-	SignedACLsPath string
-}
-
 // TODO(kwalsh) Move to datalog_guard.go when that file exists.
 type DatalogGuard struct {
 	SignedRulesPath string
 }
 
 // DomainConfig holds the presistent configuration data for a domain.
 type DomainConfig struct {
 	// Policy-agnostic configuration
 	Domain struct {
 		// Name of the domain
 		Name string
 		// Path to the password-protected signing key
 		PolicyKeysPath string
 		// Type of guard to use for domain-wide policy decisions
 		GuardType string
 	}
 	// Details used for the domain signing key x509 certificate
 	X509Details X509Details
 	// Policy-specific configuration (optional)
 	// ACLGuard ACLGuardConfig
