#* 
#* author: John Manferdelli
#* email: jlmucbmath@gmail.com
#* date: 2014-11-10T12:13:19-0800
#* 
#- changes
#- 
#- 
#- updated fileclient
#- 
#- 
#- channels
#- 
#- 
#- fixed certs and signing
#- 
#- 
#- new fileclient and fileproxy library
#- 
#- 
#- fileclient keys
#- 
#- 
#- fileclient send fiel flow
#- 
#- 
#- add encryption keys
#- 
#- 
#- moved common code to fileserver
#- 
#- 
#- fileserver initial draft
#- 
#- 
#- filehandler
#- 
#- 
#- more of the resource handler
#- 
#- 
#- messages and decoding
#- 
#- 
#- more fileproxy
#- 
#- 
#- service loop
#- 
#- 
#- yet more error handler
#- 
#- 
#- fixed syntax errors in filehandler
#- 
#- 
#- a few more fixes
#- 
#- 
#- fileserver compiles
#- 
#- 
#- keynegoserver, new cert
#- 
#- 
#- request loop and test scripts
#- 
#- 
#- test loop
#- 
#- 
#- error messages
#- 
#- 
#- bug fixes, new test scripts
#- 
#- 
#- debugging code
#- 
#- 
#- checkin for tom
#- 
#- 
#- got CryptoKey rather than der in delegatee
#- 
#- 
#- keynegoserver issues cert
#- 
#- 
#- some fixes
#- 
#- 
#- moved policy key to attestation role
#- 
#- 
#- saved correct cert
#- 
#- 
#- fileserver keys adn bug fixes
#- 
#- 
#- key retrieval bug fixes
#- 
#- 
#- Established channel
#- 
#- 
#- encoded createfile
#- 
#- 
#- createrequest
#- 
#- 
#- bug fix in GetResponse
#- 
#- 
#- fixes in resource management
#- 
#- 
#- filehandling
#- 
#- 
#- bug fixes
#- 
#- 
#- fileprotocol works
#- 
#- 
#- secure channel nego done
#- 
#- 
#- fixed unsealing bug
#- 
#- 
#- generate user keys
#- 
#- 
#- initial fileguard
#- 
#- 
#- initial Authenticate principal protocols
#- 
#- 
#- challenge response channel
#- 
#- 
#- challenge-response works
#- 
#- 
#- checked everything but read/write guard
#- 
#- 
#- fileguard on read and write
#- 
#- 
#- get policy key from domain
#- 
#- 
#- subjects and owners are now certs instead of strings
#- 
#- 
#- sendRule and check name
#- 
#- 
#- most of the file save and restore stuff
#- 
#- 
#- cert chain for challenge verified
#- 
#- 
#- Auth working again
#- 
#- 
#- finished addrule, started rollback
#- 
#- 
#- first batch of changes from code review
#- 
#- 
#- second batch of fixes from code review
#- 
#- 
#- mover rules to MasterInfo
#- 
#- 
#- got rid of global program variables
#- 
#- 
#- rearranged code, rollback started
#- 
#- 
#- got rid of EncodeMessage and DecodeMessage in fileproxy.go
#- 
#- 
#- got rid of encodemessage everywhere
#- 
#- 
#- more rollback
#- 
#- 
#- got rid of globals
#- 
#- 
#- rollback service loop
#- 
#- 
#- more of rollback checked in
#- 
#- 
#- more rollback
#- 
#- 
#- everything but client name
#- 
#- 
#- client name works, cleaned up allocations, etc
#- 
#- 
#- extended name with hash of policy cert
#- 
#- 
#- fixed reallocation and hex names
#- 
#- 
#- got rid of file size limitation
#- 
#- 
#- encryption stub for files
#- 
#- 
#- file encryption works, still have to hmac
#- 
#- 
#- hmac working
#- 
#- 
#**
#** author: Tom Roeder
#** email: tmroeder@google.com
#** date: 2014-11-10T12:44:23-0800
#**
#-- In general, this is already looking much more like Go, though there are
#-- still a bunch of changes that need to be made before it can roll over.
#-- Fortunately, it's close enough that I can probably make those changes myself
#-- pretty easily.
#--
diff --git a/Doc/Go-cloudproxy.pdf b/Doc/Go-cloudproxy.pdf
new file mode 100644
index 0000000..59c2218
Binary files /dev/null and b/Doc/Go-cloudproxy.pdf differ
diff --git a/apps/fileproxy/Go-cloudproxy.pdf b/apps/fileproxy/Go-cloudproxy.pdf
deleted file mode 100644
index 59c2218..0000000
Binary files a/apps/fileproxy/Go-cloudproxy.pdf and /dev/null differ
diff --git a/apps/fileproxy/fileclient/fileclient.go b/apps/fileproxy/fileclient/fileclient.go
index 821cf46..c491772 100644
--- a/apps/fileproxy/fileclient/fileclient.go
+++ b/apps/fileproxy/fileclient/fileclient.go
@@ -1,208 +1,363 @@
-// Copyright (c) 2014, Kevin Walsh.  All rights reserved.
+// Copyright (c) 2014, Google Corporation.  All rights reserved.
#*
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-11-10T12:13:36-0800
#*
#- There's no such thing as "Google Corporation". It's "Google, Inc.".
#-
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
 // You may obtain a copy of the License at
-//
 //     http://www.apache.org/licenses/LICENSE-2.0
-//
 // Unless required by applicable law or agreed to in writing, software
 // distributed under the License is distributed on an "AS IS" BASIS,
 // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 // See the License for the specific language governing permissions and
 // limitations under the License.
+//
+// File: fileclient.go
 
 package main
 
 import (
-	"bufio"
+	"crypto/sha256"
 	"crypto/tls"
 	"crypto/x509"
-	"crypto/x509/pkix"
-	"errors"
+	"encoding/binary"
+	"encoding/hex"
 	"flag"
-	"fmt"
-	"net"
-	"os"
-	"strings"
+	"io/ioutil"
+	"log"
 
-	"github.com/jlmucb/cloudproxy/tao"
+	"code.google.com/p/goprotobuf/proto"
+
+	"github.com/jlmucb/cloudproxy/apps/fileproxy"
+	tao "github.com/jlmucb/cloudproxy/tao"
 	"github.com/jlmucb/cloudproxy/tao/auth"
 	taonet "github.com/jlmucb/cloudproxy/tao/net"
+	"github.com/jlmucb/cloudproxy/util"
 )
 
+var hostcfg = flag.String("../hostdomain/tao.config", "../hostdomain/tao.config", "path to host tao configuration")
#*
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-11-10T12:14:30-0800
#*
#- Most of these are good now, but this "hostcfg" variable has a relative path
#- that needs to be removed.
#-
 var serverHost = flag.String("host", "localhost", "address for client/server")
 var serverPort = flag.String("port", "8123", "port for client/server")
-var serverAddr string // see main()
-var localMode = flag.Bool("local", true, "Run fileclient")
-var clientMode = flag.Bool("client", true, "Run fileclient")
-var serverMode = flag.Bool("server", true, "Run demo server")
-var pingCount = flag.Int("n", 5, "Number of client/server pings")
-var demoAuth = flag.String("auth", "tao", "\"tcp\", \"tls\", or \"tao\"")
-var configPath = flag.String("config", "tao.config", "The Tao domain config")
-var ca = flag.String("ca", "", "address for Tao CA, if any")
+var rollbackserverHost = flag.String("rollbackhost", "localhost", "address for rollback client/server")
+var rollbackserverPort = flag.String("rollbackport", "8129", "port for client/server")
+var fileclientPath = flag.String("fileclient_files/", "fileclient_files/", "fileclient directory")
#*
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-11-10T12:15:15-0800
#*
#- Do you need the "/"? If you use path.Join, then it will be added correctly
#- automatically when needed.
#-
#- Also, this means that there's a slash in the flag name, which seems odd in
#- terms of standard Unix flag naming.
#-
+var serverAddr string
+var rollbackserverAddr string
+var fileclientFilePath = flag.String("fileclient_files/stored_files/", "fileclient_files/stored_files/",
#*
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-11-10T12:18:03-0800
#*
#- I don't know if this is going to work well, since this means that there's a
#- slash in the flag name. That's probably not the right choice. Maybe just
#- stored_files?
#-
#- Also, this should be "fileClientFilePath" to match standard Go naming
#- conventions.
#-
+	"fileclient file directory")
+var testFile = flag.String("originalTestFile", "originalTestFile", "test file")
+var fileclientKeyPath = flag.String("usercreds/", "usercreds/", "user keys and certs")
+
+func main() {
 
-var subprinRule = "(forall P: forall Hash: TrustedProgramHash(Hash) and Subprin(P, %v, Hash) implies MemberProgram(P))"
-var argsRule = "(forall Y: forall P: forall S: MemberProgram(P) and TrustedArgs(S) and Subprin(Y, P, S) implies Authorized(Y, \"Execute\"))"
-var demoRule = "TrustedArgs(ext.Args(%s))"
+	var fileClientProgramObject fileproxy.ProgramPolicy
+	var FileClientProgramObject *fileproxy.ProgramPolicy
#*
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-11-10T12:16:09-0800
#*
#- It's confusing to me to have two similarly named variables like this. Also,
#- this violates the naming conventions, since a variable shouldn't start with a
#- capital letter like this. You might try running "go vet" and "golint" on your
#- code and following their advice as well.
#-
 
+	flag.Parse()
+	serverAddr = *serverHost + ":" + *serverPort
#*
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-11-10T12:19:35-0800
#*
#- Use net.JoinHostPort for generality. You might think that this is trivial,
#- but there are cases where the host can contain characters (colon or
#- percent) that require "[host]:port" rather than "host:port".
#-
+
+	hostDomain, err := tao.LoadDomain(*hostcfg, nil)
+	if err != nil {
+		return
#*
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-11-10T12:25:25-0800
#*
#- Log all errors, especially those that halt the program. In main, one easy way
#- to do this is to use log.Fatal{f}, since that does Print followed by os.Exit.
#-
+	}
+	var derPolicyCert []byte
+	if hostDomain.Keys.Cert != nil {
+		derPolicyCert = hostDomain.Keys.Cert.Raw
+	}
+	if derPolicyCert == nil {
+		log.Printf("fileclient: can't retrieve policy cert\n")
+		return
+	}
#*
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-11-10T12:28:17-0800
#*
#- In general, early termination is easier to read, and many projects (e.g.,
#- LLVM) strongly recommend it as a matter of style. So, in this case:
#-
#- if hostDomain.Keys.Cert == nil {
#- 	log.Fatalln("fileclient: can't retrieve policy cert")
#- }
#- derPolicyCert := hostDomain.Keys.Cert.Raw
#-
#- It's shorter, and it uses fewer conditionals, but it has exactly the same
#- effect.
#-
 
-func doClient(domain *tao.Domain) {
-	network := "tcp"
-	keys, err := tao.NewTemporaryTaoDelegatedKeys(tao.Signing, tao.Parent())
+	/*
+	 Replace with: hostDomai.ExtendTaoDomain(tao)
+	*/
+	sha256Hash := sha256.New()
+	sha256Hash.Write(derPolicyCert)
+	policyCertHash := sha256Hash.Sum(nil)
+	hexCertHash := hex.EncodeToString(policyCertHash)
+	e := auth.PrinExt{Name: hexCertHash}
+	err = tao.Parent().ExtendTaoName(auth.SubPrin{e})
 	if err != nil {
-		fmt.Printf("client: couldn't generate temporary Tao keys: %s\n", err)
 		return
 	}
 
-	// TODO(tmroeder): fix the name
-	cert, err := keys.SigningKey.CreateSelfSignedX509(&pkix.Name{
-		Organization: []string{"Google Tao Demo"}})
+	e = auth.PrinExt{Name: "fileclient_version_1"}
+	err = tao.Parent().ExtendTaoName(auth.SubPrin{e})
 	if err != nil {
-		fmt.Printf("client: couldn't create a self-signed X.509 cert: %s\n", err)
 		return
 	}
-	// TODO(kwalsh) keys should save cert on disk if keys are on disk
-	keys.Cert = cert
 
-	g := domain.Guard
-	if *ca != "" {
-		na, err := taonet.RequestTruncatedAttestation(network, *ca, keys, domain.Keys.VerifyingKey)
-		if err != nil {
-			fmt.Printf("client: couldn't get a truncated attestation from %s: %s\n", *ca, err)
-			return
-		}
+	taoName, err := tao.Parent().GetTaoName()
+	if err != nil {
+		log.Printf("fileserver: cant get tao name\n")
+		return
+	}
+	log.Printf("fileclient: my name is %s\n", taoName)
 
-		keys.Delegation = na
+	sealedSymmetricKey, sealedSigningKey, programCert, delegation, err := fileproxy.LoadProgramKeys(*fileclientPath)
+	if err != nil {
+		log.Printf("fileclient: cant retrieve key material\n")
+	}
+	if sealedSymmetricKey == nil || sealedSigningKey == nil || delegation == nil || programCert == nil {
+		log.Printf("fileclient: No key material present\n")
+	}
+	log.Printf("Finished fileproxy.LoadProgramKeys\n")
 
-		// If we're using a CA, then use a custom guard that accepts only
-		// programs that have talked to the CA.
-		g, err = newTempCAGuard(domain.Keys.VerifyingKey)
+	var symKeys []byte
+	if sealedSymmetricKey != nil {
+		symKeys, policy, err := tao.Parent().Unseal(sealedSymmetricKey)
 		if err != nil {
-			fmt.Printf("client: couldn't set up a new guard: %s\n", err)
 			return
 		}
+		if policy != tao.SealPolicyDefault {
+			log.Printf("fileclient: unexpected policy on unseal\n")
+		}
+		log.Printf("fileclient: Unsealed symKeys: % x\n", symKeys)
+	} else {
+		symKeys, err := fileproxy.InitializeSealedSymmetricKeys(*fileclientPath, tao.Parent(), fileproxy.SizeofSymmetricKeys)
+		if err != nil {
+			log.Printf("fileclient: InitializeSealedSymmetricKeys error: %s\n", err)
+		}
+		log.Printf("fileclient: InitilizedsymKeys: % x\n", symKeys)
 	}
+	defer fileproxy.ZeroBytes(symKeys)
 
-	pingGood := 0
-	pingFail := 0
-	for i := 0; i < *pingCount || *pingCount < 0; i++ { // negative means forever
-		if doRequest(g, domain, keys) {
-			pingGood++
-		} else {
-			pingFail++
+	var signingKey *tao.Keys
+	if sealedSigningKey != nil {
+		signingKey, err = fileproxy.SigningKeyFromBlob(tao.Parent(),
+			sealedSigningKey, programCert, delegation)
+		if err != nil {
+			log.Printf("fileclient: SigningKeyFromBlob error: %s\n", err)
 		}
-		fmt.Printf("client: made %d connections, finished %d ok, %d bad pings\n",
-			i+1, pingGood, pingFail)
+		log.Printf("fileclient: Retrieved Signing key: % x\n", *signingKey)
+	} else {
+		signingKey, err = fileproxy.InitializeSealedSigningKey(*fileclientPath,
+			tao.Parent(), *hostDomain)
+		if err != nil {
+			log.Printf("fileclient: InitializeSealedSigningKey error: %s\n", err)
+		}
+		log.Printf("fileclient: Initilized signingKey\n")
 	}
-}
 
+	FileClientProgramObject = &fileClientProgramObject
+	_ = FileClientProgramObject.InitProgramPolicy(derPolicyCert, taoName.String(), *signingKey, symKeys, programCert)
#*
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-11-10T12:33:59-0800
#*
#- Why the reference here?
#-
 
-// Tao Host demo
-
-func hostTaoDemo() error {
-	name, err := tao.Parent().GetTaoName()
+	policyCert, err := x509.ParseCertificate(derPolicyCert)
 	if err != nil {
-		return err
+		log.Printf("fileclient:cant ParseCertificate\n")
+		return
 	}
-	fmt.Printf("My root name is %s\n", name)
+	log.Printf("fileclient: place 0\n")
+	pool := x509.NewCertPool()
+	pool.AddCert(policyCert)
 
-	// TODO(kwalsh) Make a convenience function for this
-	var args []auth.Term
-	for _, arg := range os.Args {
-		args = append(args, auth.Str(arg))
+	tlsc, err := taonet.EncodeTLSCert(signingKey)
+	if err != nil {
+		log.Printf("fileclient, encode error: ", err)
+		log.Printf("\n")
+		return
 	}
-	e := auth.PrinExt{Name: "Args", Arg: args}
-	err = tao.Parent().ExtendTaoName(auth.SubPrin{e})
+	conn, err := tls.Dial("tcp", serverAddr, &tls.Config{
+		RootCAs:            pool,
+		Certificates:       []tls.Certificate{*tlsc},
+		InsecureSkipVerify: false,
+	})
 	if err != nil {
-		return err
+		log.Printf("fileclient: cant establish channel\n", err)
+		log.Printf("\n")
+		return
 	}
+	ms := util.NewMessageStream(conn)
+	log.Printf("fileclient: Established channel\n")
 
-	name, err = tao.Parent().GetTaoName()
+	// Authenticate user principal(s).
+	userCert, err := ioutil.ReadFile(*fileclientPath + *fileclientKeyPath + "cert")
 	if err != nil {
-		return err
+		log.Printf("fileclient: cant read cert %s\n", *fileclientPath+*fileclientKeyPath+"cert")
+		return
 	}
-	fmt.Printf("My full name is %s\n", name)
-
-	random, err := tao.Parent().GetRandomBytes(10)
+	log.Printf("fileclient: read cert\n")
+	if userCert == nil {
+		log.Printf("fileclient: nil user cert\n")
+	}
+	pks, err := ioutil.ReadFile(*fileclientPath + *fileclientKeyPath + "keys")
 	if err != nil {
-		return err
+		log.Printf("fileclient: cant read key blob\n")
+		return
 	}
-	fmt.Printf("Random bytes  : % x\n", random)
-
-	n, err := tao.Parent().Rand().Read(random)
+	if pks == nil {
+		log.Printf("fileclient: nil pks\n")
+	}
+	log.Printf("fileclient: read key blob\n")
+	var cks tao.CryptoKeyset
+	err = proto.Unmarshal(pks, &cks)
 	if err != nil {
-		return err
+		log.Printf("fileclient: cant proto unmarshal key set\n")
+		return
 	}
-	fmt.Printf("%d more bytes : % x\n", n, random)
-
-	secret, err := tao.Parent().GetSharedSecret(10, tao.SharedSecretPolicyDefault)
+	if pks == nil {
+		log.Printf("fileclient: cant proto unmarshaled is nil \n")
+		return
+	}
+	log.Printf("fileclient: unmarshaled proto key\n")
+	userKey, err := tao.UnmarshalKeyset(&cks)
 	if err != nil {
-		return err
+		log.Printf("fileclient: cant unmarshal key set\n")
+		return
+	}
+	log.Printf("fileclient: unmarshaled key\n")
+	log.Printf("user key: ", userKey)
+	log.Printf("\n")
+	ok := fileproxy.AuthenticatePrincipalRequest(ms, userKey, userCert)
+	if !ok {
+		log.Printf("fileclient: cant authenticate principal\n")
+		return
 	}
-	fmt.Printf("Shared secret : % x\n", secret)
+	log.Printf("fileclient: AuthenticatedPrincipalRequest\n")
 
-	sealed, err := tao.Parent().Seal(random, tao.SealPolicyDefault)
+	// Send a rule.
+	rule := "Delegate(\"jlm\", \"tom\", \"getfile\",\"myfile\")"
+	log.Printf("fileclient, sending rule: %s\n", rule)
+	err = fileproxy.SendRule(ms, rule, userCert)
 	if err != nil {
-		return err
+		log.Printf("fileclient: cant create file\n")
+		return
 	}
-	fmt.Printf("Sealed bytes  : % x\n", sealed)
-
-	unsealed, policy, err := tao.Parent().Unseal(sealed)
+	status, message, size, err := fileproxy.GetResponse(ms)
 	if err != nil {
-		return err
+		log.Printf("fileclient: Error in response to SendCreate\n")
+		return
 	}
-	if policy != tao.SealPolicyDefault {
-		return errors.New("unexpected policy on unseal")
+	log.Printf("Response to SendCreate\n")
+	fileproxy.PrintResponse(status, message, size)
+	if *status != "succeeded" {
+		return
 	}
-	fmt.Printf("Unsealed bytes: % x\n", unsealed)
 
-	return nil
-}
+	// Create a file.
+	sentFileName := *testFile
+	log.Printf("fileclient, Creating: %s\n", sentFileName)
+	err = fileproxy.SendCreateFile(ms, userCert, sentFileName)
+	if err != nil {
+		log.Printf("fileclient: cant create file\n")
+		return
+	}
+	status, message, size, err = fileproxy.GetResponse(ms)
+	if err != nil {
+		log.Printf("fileclient: Error in response to SendCreate\n")
+		return
+	}
+	log.Printf("fileclient: Response to SendCreate\n")
+	fileproxy.PrintResponse(status, message, size)
+	if *status != "succeeded" {
+		return
+	}
 
-func main() {
-	flag.Parse()
-	serverAddr = *serverHost + ":" + *serverPort
-	switch *demoAuth {
-	case "tcp", "tls", "tao":
-	default:
-		fmt.Printf("unrecognized authentication mode: %s\n", *demoAuth)
+	// Send File.
+	log.Printf("\nfileclient sending file %s\n", sentFileName)
+	err = fileproxy.SendSendFile(ms, userCert, sentFileName)
+	if err != nil {
+		log.Printf("fileclient: SendSendFile has error\n")
 		return
 	}
 
-	fmt.Printf("Go Tao Demo\n")
+	status, message, size, err = fileproxy.GetResponse(ms)
+	if err != nil {
+		log.Printf("fileclient: Error in response to SendSend\n")
+		return
+	}
+	log.Printf("fileclient: Response to SendSend\n")
+	fileproxy.PrintResponse(status, message, size)
+	if *status != "succeeded" {
+		return
+	}
 
-	if !tao.Hosted() {
-		fmt.Printf("can't continue: No host Tao available\n")
+	err = fileproxy.SendFile(ms, *fileclientFilePath, sentFileName, nil)
+	if err != nil {
+		log.Printf("fileclient: Error in response to SendFile ", err)
+		log.Printf("\n")
 		return
 	}
 
-	if *localMode {
-		err := hostTaoDemo()
-		if err != nil {
-			fmt.Printf("error: %s\n", err.Error())
-			return
-		}
+	// Get file
+	log.Printf("\nfileclient getting file %s\n", sentFileName)
+	err = fileproxy.SendGetFile(ms, userCert, sentFileName)
+	if err != nil {
+		log.Printf("fileclient: SendGetFile has error\n")
+		return
 	}
 
-	// TODO(tmroeder): use the Domain and the tao parent to set up the keys and
-	// the guard. Also need to hook the datalog guard into the domain and get
-	// the basic tests working with this guard, especially execution
-	// authorization.
-	serverReady <- true
-	serverDone <- true
+	status, message, size, err = fileproxy.GetResponse(ms)
+	if err != nil {
+		log.Printf("fileclient: Error in response to GetFile\n")
+		return
+	}
+	log.Printf("fileclient: Response to SendGet\n")
+	fileproxy.PrintResponse(status, message, size)
+	if *status != "succeeded" {
+		return
+	}
 
-	domain, err := tao.LoadDomain(*configPath, nil)
+	err = fileproxy.GetFile(ms, *fileclientFilePath, sentFileName+".received", nil)
 	if err != nil {
-		fmt.Printf("error: couldn't load the tao domain from %s\n", *configPath)
+		log.Printf("fileclient: cant get file ", err)
+		log.Printf("\n")
 		return
 	}
 
-	ok := <-serverReady
-	if ok {
-		doClient(domain)
+	// rollback test
+	rollbackserverAddr = *serverHost + ":" + *rollbackserverPort
+	rbconn, err := tls.Dial("tcp", rollbackserverAddr, &tls.Config{
+		RootCAs:            pool,
+		Certificates:       []tls.Certificate{*tlsc},
+		InsecureSkipVerify: false,
+	})
+	if err != nil {
+		log.Printf("fileclient: cant establish rollback channel\n", err)
+		log.Printf("\n")
+		return
+	}
+	newms := util.NewMessageStream(rbconn)
+	if newms == nil {
+		log.Printf("cant get newms\n")
+	}
+	log.Printf("fileclient: Established rollback channel\n")
+	// set hash
+	hash := make([]byte, 128)
#*
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-11-10T12:36:12-0800
#*
#- This should probably be a constant in the rollback library that can be
#- accessed by clients.
#-
+	for i := 0; i < 32; i++ {
+		hash[i] = byte(i)
+	}
+	clientProgramName := taoName.String()
+	ok2 := fileproxy.ClientSetResourceHashRequest(newms, clientProgramName, "test_resource", []byte(hash))
+	if !ok2 {
+		log.Printf("fileclient: fileproxy.ClientSetResourceHashRequest failed")
+		return
+	}
+	log.Printf("fileclient: set fileproxy.ClientSetResourceHashRequest succeeded\n")
+	// set counter
+	fileproxy.ClientSetRollbackCounter(newms, int64(10))
+	log.Printf("fileclient: set fileproxy.ClientSetRollbackCounter\n")
+	// get counter
+	ok2, counter := fileproxy.ClientGetRollbackCounter(newms, clientProgramName)
+	if !ok2 {
+		log.Printf("fileclient: fileproxy.ClientGetRollbackCounter failed")
+		return
 	}
-	serverStop <- true
-	<-serverDone
-	fmt.Printf("Done\n")
+	log.Printf("counter is %d\n", counter)
+	// get verify
+	ok2, newhash := fileproxy.ClientGetRollbackHashedVerifierRequest(newms, clientProgramName, "test_resource")
+	if !ok2 {
+		log.Printf("fileclient: fileproxy.ClientGetRollbackHashedVerifierRequest failed")
+		return
+	}
+	log.Printf("fileclient: newhash is %x\n", newhash)
+	sha256HashCtr := sha256.New()
+	bc := make([]byte, 8)
+	binary.PutVarint(bc, counter)
+	sha256HashCtr.Write(bc)
+	sha256HashCtr.Write(hash)
+	sha256HashCtr.Write(bc)
+	computed_hash := sha256HashCtr.Sum(nil)
+	log.Printf("fileclient: computed_hash is %x\n", computed_hash)
+
+	log.Printf("fileclient: Done\n")
 }
diff --git a/apps/fileproxy/fileclient/rebuild b/apps/fileproxy/fileclient/rebuild
new file mode 100755
index 0000000..5e3c928
--- /dev/null
+++ b/apps/fileproxy/fileclient/rebuild
@@ -0,0 +1,7 @@
+#
+echo "rebuilding fileproxy"
+cd ..
+go build ...
+cd fileclient
+go build fileclient.go
+echo "done"
diff --git a/apps/fileproxy/filehandler.go b/apps/fileproxy/filehandler.go
new file mode 100644
index 0000000..313a062
--- /dev/null
+++ b/apps/fileproxy/filehandler.go
@@ -0,0 +1,809 @@
+// Copyright (c) 2014, Google Corporation.  All rights reserved.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//     http://www.apache.org/licenses/LICENSE-2.0
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// File: filehandler.go
+
+package fileproxy
+
+import (
+	"bytes"
+	"crypto/rand"
+	"crypto/x509"
+	"errors"
+	"io/ioutil"
+	"log"
+	"os"
+
+	"code.google.com/p/goprotobuf/proto"
+
+	tao "github.com/jlmucb/cloudproxy/tao"
+	"github.com/jlmucb/cloudproxy/util"
+)
+
+const SizeofNonce = 32
+const ChallengeContext = "fileproxy-challenge"
+
+// Resource types: files, channels
+type ResourceInfo struct {
+	ResourceName      string
+	ResourceType      string
+	ResourceStatus    string
+	ResourceLocation  string
+	ResourceSize      int
+	ResourceOwner     string
+	DateCreated       string
+	DateModified      string
+	AuthenticatorType string
+	Authenticator     [][]byte
+}
+
+type PrincipalInfo struct {
+	Name   string
+	Der    []byte
+	Status string
+}
+
+type ResourceMaster struct {
+	ProgramName      string
+	Guard            tao.Guard
+	BaseDirectory    string
+	NumResources     int
+	ResourceArray    []ResourceInfo
+	NumPrincipals    int
+	PrincipalArray   []PrincipalInfo
+	Policy           []string
+	AdditionalPolicy []string
+}
+
+// Policy for managing files in the fileserver.
+var policy = []string{
+	// Fileserver owns everything.
+	"forall FS: forall R: FileServer(FS) and Resource(R) implies Owner(FS, R)",
+	// Creators are owners.
+	"forall C: forall R: Creator(C, R) implies Owner(C, R)",
+	// Owners can perform all actions and make all delegations.
+	"forall O: forall A: forall R: Owner(O, R) and Resource(R) and Action(A) implies Authorized(O, \"delegate\", A, R)",
+	"forall O: forall A: forall R: Owner(O, R) and Resource(R) and Action(A) implies Authorized(O, A, R)",
+	// Principals have namespaces where they can create things.
+	// The guard needs to understand that Authorized(P, "create-subdir",
+	// path) means that P can create a path with its name underneath (or
+	// something like the hash of its name).
+	"forall P: Authorized(P, \"execute\") implies Authorized(P, \"create-subdir\", \"/principals\")",
+	// Basic Delegation.
+	"forall U1: forall U2: forall R: forall A: Authorized(U1, \"delegate\", A, R) and Delegate(U1, U2, A, R) implies Authorized(U2, A, R)",
+	// Redelegation.
+	"forall U1: forall U2: forall R: forall A: Authorized(U1, \"delegate\", A, R) and Delegate(U1, U2, \"delegate\", A, R) implies Authorized(U2, \"delegate\", A, R)",
+}
+
+// Some fake additional statements for the purpose of testing the guard.
+var additional_policy = []string{
+	"FileServer(\"fileserver\")",
+	"Action(\"create\")",
+	"Action(\"getfile\")",
+	"Action(\"sendfile\")",
+	"Action(\"delete\")",
+}
+
+func delegateResource(owner, delegate, op, res string, g tao.Guard) {
+	if err := g.AddRule("Delegate(\"" + owner + "\", \"" + delegate + "\", \"" + op + "\", \"" + res + "\")"); err != nil {
+		log.Printf("Couldn't delegate operation '%s' on '%s' from '%s' to '%s': %s\n", op, res, owner, delegate, err)
+	}
+}
+
+func redelegateResource(owner, delegate, op, res string, g tao.Guard) {
+	if err := g.AddRule("Delegate(\"" + owner + "\", \"" + delegate + "\", \"delegate\", \"" + op + "\", \"" + res + "\")"); err != nil {
+		log.Printf("Couldn't redelegate operation '%s' on '%s' from '%s' to '%s': %s\n", op, res, owner, delegate, err)
+	}
+}
+
+func addResource(creator, resource string, g tao.Guard) error {
+	if err := g.AddRule("Resource(\"" + resource + "\")"); err != nil {
+		return errors.New("Can't add resource in rules\n")
+	}
+	if err := g.AddRule("Creator(\"" + creator + "\", \"" + resource + "\")"); err != nil {
+		return errors.New("Can't add creator in rules\n")
+	}
+	return nil
+}
+
+func makeQuery(subject string, action string, resource string) *string {
+	var out string
+	if action == "create" {
+		out = "Authorized(\"" + subject + "\", \"" + action + "\",  \"" + resource + "\")"
+	} else if action == "getfile" {
+		out = "Authorized(\"" + subject + "\", \"" + action + "\", \"" + resource + "\")"
+	} else if action == "sendfile" {
+		out = "Authorized(\"" + subject + "\", \"" + action + "\", \"" + resource + "\")"
+	} else {
+		log.Printf("makeQuery: unknown action\n")
+		return nil
+	}
+	log.Printf("makeQuery: %s\n", out)
+	return &out
+}
+
+func (m *ResourceMaster) Query(query string) bool {
+	b, err := m.Guard.Query(query)
+	if err != nil {
+		log.Printf("Query: %s generates error %s\n", query, err)
+		return false
+	}
+	if b {
+		log.Printf("%s succeeds\n", query)
+	} else {
+		log.Printf("%s failed\n", query)
+	}
+	return b
+}
+
+func (m *ResourceMaster) FindResource(resourcename string) (*ResourceInfo, error) {
+	for i := range m.ResourceArray {
+		if m.ResourceArray[i].ResourceName == resourcename {
+			return &m.ResourceArray[i], nil
+		}
+	}
+	return nil, nil
+}
+
+func (m *ResourceMaster) InsertResource(path string, resourcename string, owner string) (*ResourceInfo, error) {
+	found, err := m.FindResource(resourcename)
+	if err != nil {
+		return nil, err
+	}
+	if found != nil {
+		return found, nil
+	}
+	if len(m.ResourceArray) >= cap(m.ResourceArray) {
+		t := make([]ResourceInfo, 2*cap(m.ResourceArray))
+		copy(t, m.ResourceArray)
+		m.ResourceArray = t
+	}
+	m.ResourceArray = m.ResourceArray[0 : len(m.ResourceArray)+1]
+	n := len(m.ResourceArray) - 1
+	m.ResourceArray[n].ResourceName = resourcename
+	m.ResourceArray[n].ResourceType = "file"
+	m.ResourceArray[n].ResourceStatus = "created"
+	m.ResourceArray[n].ResourceLocation = path + resourcename
+	m.ResourceArray[n].ResourceOwner = owner
+	return &m.ResourceArray[n], nil
+}
+
+func (m *ResourceMaster) FindPrincipal(name string) (*PrincipalInfo, error) {
+	for i := range m.PrincipalArray {
+		if m.PrincipalArray[i].Name == name {
+			return &m.PrincipalArray[i], nil
+		}
+	}
+	return nil, nil
+}
+
+func (m *ResourceMaster) InsertPrincipal(name string, cert []byte, authStatus string) (*PrincipalInfo, error) {
+	found, err := m.FindPrincipal(name)
+	if err != nil {
+		return nil, err
+	}
+	if found != nil {
+		return found, nil
+	}
+	if len(m.PrincipalArray) >= cap(m.PrincipalArray) {
+		t := make([]PrincipalInfo, 2*cap(m.PrincipalArray))
+		copy(t, m.PrincipalArray)
+		m.PrincipalArray = t
+	}
+	m.PrincipalArray = m.PrincipalArray[0 : len(m.PrincipalArray)+1]
+	n := len(m.PrincipalArray) - 1
#*
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-11-10T12:37:57-0800
#*
#- There's an easier way than this: check out the built-in function append().
#-
+	m.PrincipalArray[n].Name = name
+	m.PrincipalArray[n].Der = cert
+	m.PrincipalArray[n].Status = authStatus
+	return &m.PrincipalArray[n], nil
+}
+
+func (m *ResourceMaster) Delete(resourceName string) error {
+	return nil // not implemented
#*
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-11-13T08:23:44-0800
#*
#- return errors.New("not implemented")
#-
#- By convention, the nil error means that it has been implemented and that
#- there's no error
#-
+}
+
+func (m *ResourceMaster) EncodeMaster() ([]byte, error) {
+	log.Printf("filehandler: encodeMaster\n")
+	protoMessage := new(FPResourceMaster)
+	protoMessage.PrinName = proto.String(m.ProgramName)
+	protoMessage.BaseDirectoryName = proto.String(m.BaseDirectory)
+	protoMessage.NumFileinfos = proto.Int(len(m.ResourceArray))
#*
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-11-13T10:15:13-0800
#*
#- Even more idiomatic Go would be:
#-
#- p := &FPResourceMaster{
#- 	PrinName: proto.String(m.ProgramName),
#- 	BaseDirectoryName: proto.String(m.BaseDirectory),
#- 	NumFileInfos: proto.Int(len(m.ResourceArray)),
#- }
#- return proto.Marshal(p)
#-
+	return proto.Marshal(protoMessage)
+}
+
+func (m *ResourceMaster) DecodeMaster(in []byte) (*int, error) {
+	log.Printf("filehandler: DecodeMaster\n")
+	rMessage := new(FPResourceMaster)
+	err := proto.Unmarshal(in, rMessage)
+	if err != nil {
+		return nil, err
+	}
#*
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-11-13T10:17:16-0800
#*
#- More idiomatic Go:
#-
#- var m FPResourceMaster
#- if err := proto.Unmarshal(in, &m); err != nil {
#- 	return nil, err
#- }
#-
#-
+	m.ProgramName = *rMessage.PrinName
+	m.BaseDirectory = *rMessage.BaseDirectoryName
+	size := *rMessage.NumFileinfos
+	isize := int(size) //TODO: Fix
+	return &isize, nil
#*
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-11-13T10:19:48-0800
#*
#- As the TODO notes, this is unnecessary
#-
+}
+
+func (m *ResourceMaster) PrintMaster(printResources bool) {
+	log.Printf("Program principal: %s\n", m.ProgramName)
+	log.Printf("Base Directory: %s\n", m.BaseDirectory)
+	log.Printf("%d resources\n", len(m.ResourceArray))
+	if printResources {
+		for i := range m.ResourceArray {
+			m.ResourceArray[i].PrintResourceInfo()
+		}
+	}
+}
+
+func (r *ResourceInfo) EncodeResourceInfo() ([]byte, error) {
+	log.Printf("filehandler: encodeResourceInfo\n")
+	protoMessage := new(FPResourceInfo)
+	protoMessage.ResourceName = proto.String(r.ResourceName)
+	protoMessage.ResourceType = proto.String(r.ResourceType)
+	protoMessage.ResourceStatus = proto.String(r.ResourceStatus)
+	protoMessage.ResourceLocation = proto.String(r.ResourceLocation)
+	protoMessage.ResourceSize = proto.Int(r.ResourceSize)
+	//Fix: protoMessage.ResourceOwner= proto.Bytes(r.ResourceOwner);
+	out, err := proto.Marshal(protoMessage)
+	return out, err
#*
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-11-13T10:20:15-0800
#*
#- Fold these two lines into a single return statement
#-
+}
+
+func (r *ResourceInfo) DecodeResourceInfo(in []byte) error {
+	log.Printf("filehandler: DecodeResourceInfo\n")
+	rMessage := new(FPResourceInfo)
+	_ = proto.Unmarshal(in, rMessage)
+	r.ResourceName = *rMessage.ResourceName
+	r.ResourceType = *rMessage.ResourceType
+	r.ResourceLocation = *rMessage.ResourceLocation
+	r.ResourceSize = int(*rMessage.ResourceSize)
+	r.ResourceOwner = *rMessage.ResourceOwner
+	return nil
+}
+
+func (r *ResourceInfo) PrintResourceInfo() {
+	log.Printf("Resource name: %s\n", r.ResourceName)
+	log.Printf("Resource type: %s\n", r.ResourceType)
+	log.Printf("Resource status: %s\n", r.ResourceStatus)
+	log.Printf("Resource location: %s\n", r.ResourceLocation)
+	log.Printf("Resource size: %d\n", r.ResourceSize)
+	log.Printf("Resource creation date: %s\n", r.DateCreated)
+	log.Printf("Resource modified date: %s\n", r.DateModified)
+	log.Printf("\n")
+}
#*
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-11-13T10:20:45-0800
#*
#- In Go, the way this is normally done is to give objects a String() method,
#- since then they implement fmt.Stringer and can be passed directly to
#- formatting statements like so:
#-
#- var ri ResourceInfo
#- // ... set up ri ...
#- log.Println(ri)
#-
+
+func (p *PrincipalInfo) EncodePrincipal() ([]byte, error) {
+	log.Printf("filehandler: encodePrincipalInfo\n")
+	protoMessage := new(FPPrincipalInfo)
+	protoMessage.PrincipalName = proto.String(p.Name)
+	protoMessage.PrincipalStatus = proto.String(p.Status)
+	protoMessage.PrincipalCert = proto.String(string(p.Der))
+	out, err := proto.Marshal(protoMessage)
+	return out, err
+}
+
+func (p *PrincipalInfo) DecodePrincipal(in []byte) error {
+	log.Printf("filehandler: DecodePrincipalInfo\n")
+	rMessage := new(FPPrincipalInfo)
+	_ = proto.Unmarshal(in, rMessage)
+	p.Name = *rMessage.PrincipalName
+	p.Status = *rMessage.PrincipalStatus
+	p.Der = []byte(*rMessage.PrincipalCert)
+	return nil
+}
+
+func (p *PrincipalInfo) PrintPrincipal() {
+	log.Printf("Principal name: %s\n", p.Name)
+	log.Printf("Principal status: %s\n", p.Status)
+	log.Printf("Principal cert: %s\n", p.Der)
+	log.Printf("\n")
+}
+
+func (m *ResourceMaster) PrintAllPolicy() {
+	for i := range m.Policy {
+		log.Printf("Rule: %s\n", m.Policy[i])
+	}
+	for i := range m.AdditionalPolicy {
+		log.Printf("Rule: %s\n", m.AdditionalPolicy[i])
+	}
+}
+
+func (m *ResourceMaster) InitGuard(rulefile string) error {
+	log.Printf("filehandler: InitGuard\n")
+	m.Guard = tao.NewTemporaryDatalogGuard()
+	for i := range m.Policy {
+		if err := m.Guard.AddRule(m.Policy[i]); err != nil {
+			return errors.New("Couldn't add rule in InitGuard")
+		}
+	}
+
+	for i := range m.AdditionalPolicy {
+		if err := m.Guard.AddRule(m.AdditionalPolicy[i]); err != nil {
+			return errors.New("Couldn't add rule in InitGuard")
+		}
+	}
+	return nil
+}
+
+func (m *ResourceMaster) ReadRules(rulefile string) error {
+	log.Printf("filehandler: ReadRules\n")
+	// no need for rules
#*
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-11-13T10:22:30-0800
#*
#- I'm not sure what this comment means. Can you be more explicit?
#-
+	return nil
+}
+
+func (m *ResourceMaster) SaveRules(rulefile string) error {
+	log.Printf("filehandler: SaveRules\n")
+	// no need for rules
+	return nil
+}
+
+func (m *ResourceMaster) GetResourceData(masterFile string, resourceFile string, principalFile string, ruleFile string) error {
#*
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-11-13T10:23:23-0800
#*
#- This function needs error handling added throughout.
#-
+	log.Printf("filehandler: GetResourceData\n")
+	// TODO: decrypt the files
+	// Read master
+	masterRecord, _ := ioutil.ReadFile(masterFile)
+	_, _ = m.DecodeMaster([]byte(masterRecord))
+	log.Printf("masterRecord size: %d\n", len(masterRecord))
+
+	// Save resources
+	fo, _ := os.Open(resourceFile)
+	rs := util.NewMessageStream(fo)
+	for i := range m.ResourceArray {
+		resourceRecord, _ := rs.ReadString()
+		_ = m.ResourceArray[i].DecodeResourceInfo([]byte(resourceRecord))
+		log.Printf("resourceRecord size: %d\n", len(resourceRecord))
+	}
+	fo.Close()
+
+	// Read principals
+	fo, _ = os.Open(principalFile)
+	ps := util.NewMessageStream(fo)
+	for i := range m.PrincipalArray {
+		principalRecord, _ := ps.ReadString()
+		_ = m.PrincipalArray[i].DecodePrincipal([]byte(principalRecord))
+		log.Printf("principalRecord size: %d\n", len(principalRecord))
+	}
+	fo.Close()
+
+	// Read rules
+	_ = m.ReadRules(ruleFile)
+	return nil
+}
+
+func (m *ResourceMaster) SaveResourceData(masterFile string, resourceFile string, principalFile string, ruleFile string) error {
+	log.Printf("filehandler: SaveResourceData\n")
+	// TODO: encrypt the files
+	// Save master
+	masterRecord, _ := m.EncodeMaster()
+	log.Printf("masterRecord size: %d\n", len(masterRecord))
+	ioutil.WriteFile(masterFile, masterRecord, os.ModePerm)
+	// Save resources
+	fo, _ := os.Create(resourceFile)
+	rs := util.NewMessageStream(fo)
+	for i := range m.ResourceArray {
+		resourceRecord, _ := m.ResourceArray[i].EncodeResourceInfo()
+		log.Printf("resourceRecord size: %d\n", len(resourceRecord))
+		_, _ = rs.WriteString(string(resourceRecord))
+	}
+	fo.Close()
+	// Save principals
+	fo, _ = os.Create(principalFile)
+	ps := util.NewMessageStream(fo)
+	for i := range m.PrincipalArray {
+		principalRecord, _ := m.PrincipalArray[i].EncodePrincipal()
+		log.Printf("principalRecord size: %d\n", len(principalRecord))
+		_, _ = ps.WriteString(string(principalRecord))
+	}
+	fo.Close()
+
+	// Save rules
+	_ = m.SaveRules(ruleFile)
+	return nil
+}
+
+func AuthenticatePrincipal(m *ResourceMaster, ms *util.MessageStream, programPolicyObject *ProgramPolicy) (bool, []byte) {
+	log.Printf("AuthenticatePrincipal\n")
+	offeredCert, err := GetProtocolMessage(ms)
+	if err != nil {
+		log.Printf("cant GetProtocolMessage in AuthenticatePrincipal % x\n", offeredCert)
+	}
+	nonce := make([]byte, SizeofNonce)
+	_, err = rand.Read(nonce)
+	if err != nil {
+		log.Printf("Rand error in AuthenticatePrincipal\n")
+	}
+	SendProtocolMessage(ms, len(nonce), nonce)
+	signedRand, err := GetProtocolMessage(ms)
+	if err != nil {
+		log.Printf("cant GetProtocolMessage in AuthenticatePrincipal\n")
+	}
+	log.Printf("AuthenticatePrincipal: got signed nonce % x\n", signedRand)
+	// Decrypt nonce
+	cert, err := x509.ParseCertificate(offeredCert)
+	if err != nil {
+		log.Printf("cant Parse Certificate in AuthenticatePrincipal\n")
+	}
+	v, err := tao.FromX509(cert)
+	if err != nil {
+		log.Printf("cant get verifier from x509 AuthenticatePrincipal\n")
+	}
+	ok, err := v.Verify(nonce, ChallengeContext, signedRand)
+	if err != nil {
+		return false, nil
+	}
+	if ok {
+		var opts x509.VerifyOptions
+		roots := x509.NewCertPool()
+		if !programPolicyObject.Initialized {
+			log.Printf("MyProgramPolicy not initialized")
+			return false, nil
+		}
+		policyCert, err := x509.ParseCertificate(programPolicyObject.ThePolicyCert)
+		if err != nil || policyCert == nil {
+			log.Printf("Can't parse policy cert")
+			return false, nil
+		}
+		roots.AddCert(policyCert)
+		opts.Roots = roots
+		// Now check cert chain
+		chains, err := cert.Verify(opts)
+		if chains == nil || err != nil {
+			log.Printf("Can't validate cert chain to policy")
+			return false, nil
+		}
+		log.Printf("Cert chain for challenge verified\n")
+	}
+	if ok {
+		log.Printf("nonce verified\n")
+	} else {
+		log.Printf("nonce did not verified\n")
+	}
+	var status string
+	if ok {
+		status = "succeeded"
+	} else {
+		status = "failed"
+	}
+	msg := ""
+	SendResponse(ms, status, msg, 0)
+	return ok, offeredCert
+}
+
+func AuthenticatePrincipalRequest(ms *util.MessageStream, key *tao.Keys, derCert []byte) bool {
+	log.Printf("AuthenticatePrincipalRequest\n")
+	// Format request
+	subject := string(derCert)
+	action := "authenticateprincipal"
+	err := SendRequest(ms, &subject, &action, &subject, nil)
+	if err != nil {
+		log.Printf("AuthenticatePrincipalRequest: couldn't send request\n")
+	}
+	SendProtocolMessage(ms, len(derCert), derCert)
+	nonce, err := GetProtocolMessage(ms)
+	if err != nil {
+		log.Printf("cant GetProtocolMessage in AuthenticatePrincipalRequest\n")
+		return false
+	}
+	log.Printf("AuthenticatePrincipalRequest: got nonce\n")
+	// Encrypt nonce
+	signedBlob, err := key.SigningKey.Sign(nonce, "fileproxy-challenge")
+	if err != nil {
+		log.Printf("AuthenticatePrincipalRequest: cant sign\n")
+	}
+	SendProtocolMessage(ms, len(signedBlob), signedBlob)
+	log.Printf("AuthenticatePrincipalRequest: sent signed\n")
+	status, _, _, err := GetResponse(ms)
+	if err != nil {
+		log.Printf("cant GetResponse in AuthenticatePrincipalRequest\n")
+		return false
+	}
+	log.Printf("AuthenticatePrincipalRequest: status of response: %s\n", *status)
+	return true
+}
+
+func readRequest(m *ResourceMaster, ms *util.MessageStream, resourcename string, symKey []byte) error {
+	log.Printf("filehandler: readRequest\n")
+	rInfo, _ := m.FindResource(resourcename)
+	if rInfo == nil {
+		SendResponse(ms, "failed", "resource does not exist", 0)
+		return nil
+	}
+	status := "succeeded"
+	SendResponse(ms, status, "", 0)
+	return SendFile(ms, m.BaseDirectory, resourcename, symKey)
+}
+
+func writeRequest(m *ResourceMaster, ms *util.MessageStream, resourcename string, symKey []byte) error {
+	log.Printf("filehandler: writeRequest\n")
+	rInfo, _ := m.FindResource(resourcename)
+	if rInfo == nil {
+		SendResponse(ms, "failed", "resource does not exist", 0)
+		return nil
+	}
+	status := "succeeded"
+	SendResponse(ms, status, "", 0)
+	return GetFile(ms, m.BaseDirectory, resourcename, symKey)
+}
+
+func createRequest(m *ResourceMaster, ms *util.MessageStream,
+	resourcename string, owner string) error {
+	log.Printf("filehandler: createRequest\n")
+	rInfo, _ := m.FindResource(resourcename)
+	if rInfo != nil {
+		SendResponse(ms, "failed", "resource exists", 0)
+		return nil
+	}
+	rInfo, _ = m.InsertResource(m.BaseDirectory, resourcename, owner)
+	if rInfo == nil {
+		SendResponse(ms, "failed", "cant insert resource", 0)
+		return nil
+	}
+	rInfo.PrintResourceInfo()
+	status := "succeeded"
+	SendResponse(ms, status, "", 0)
+	return nil
+}
+
+func newruleRequest(m *ResourceMaster, ms *util.MessageStream,
+	rule string, signerCert []byte) error {
+
+	log.Printf("filehandler, newruleRequest, rule: %s\n", rule)
+	signerName := PrincipalNameFromDERCert(signerCert)
+	if signerName == nil {
+		log.Printf("filehandler, newruleRequest: cant get name from cert\n")
+		return nil
+	}
+	prin, err := m.FindPrincipal(*signerName)
+	if prin != nil {
+		log.Printf("filehandler, newRuleRequest: found principal, %s %s\n", prin.Name, prin.Status)
+	}
+	if err != nil || prin == nil || !bytes.Equal(prin.Der, signerCert) {
+		SendResponse(ms, "failed", "cert doesn't match", 0)
+		return nil
+	}
+	// Check a signature?
+	m.Guard.AddRule(rule)
+	SendResponse(ms, "succeeded", "", 0)
+	return nil
+}
+
+func deleteRequest(m *ResourceMaster, ms *util.MessageStream, resourcename string) error {
+	return errors.New("deleteRequest not implemented")
+}
+
+func addRuleRequest(m *ResourceMaster, ms *util.MessageStream, resourcename string) error {
+	return errors.New("addRuleRequest not implemented")
+}
+
+func addOwnerRequest(m *ResourceMaster, ms *util.MessageStream, resourcename string) error {
+	return errors.New("addOwnerRequest not implemented")
+}
+
+func deleteOwnerRequest(m *ResourceMaster, ms *util.MessageStream, resourcename string) error {
+	return errors.New("deleteOwnerRequest not implemented")
+}
+
+func (m *ResourceMaster) certToAuthenticatedName(subjectCert []byte) *string {
+	if subjectCert == nil {
+		return nil
+	}
+	var subjectName *string
+	subjectName = nil
+	subjectName = PrincipalNameFromDERCert([]byte(subjectCert))
+	if subjectName == nil {
+		log.Printf("filehandler, certToAuthenticatedName: cant get name from cert\n")
+		return nil
+	}
+	prin, err := m.FindPrincipal(*subjectName)
+	if prin != nil {
+		log.Printf("filehandler, certToAuthenticatedName: found principal, %s %s\n", prin.Name, prin.Status)
+	}
+	if err != nil || prin == nil || bytes.Equal(prin.Der, []byte(*subjectName)) {
+		return nil
+	}
+	return subjectName
+}
+
+// First return value is terminate flag
+func (m *ResourceMaster) HandleServiceRequest(ms *util.MessageStream, programPolicyObject *ProgramPolicy, clientProgramName string, request []byte) (bool, error) {
+	log.Printf("filehandler: HandleServiceRequest\n")
+
+	fpMessage := new(FPMessage)
+	err := proto.Unmarshal(request, fpMessage)
+	if err != nil {
+		return false, errors.New("HandleService can't unmarshal request")
+	}
+	if fpMessage.MessageType == nil {
+		return false, errors.New("HandleService: no message type")
+	}
+	switch MessageType(*fpMessage.MessageType) {
+	default:
+		return false, errors.New("HandleService does not get MessageType_REQUEST")
+	case MessageType_REQUEST:
+	}
+	action := fpMessage.ActionName
+	if action == nil {
+		SendResponse(ms, "failed", "", 0)
+		return false, errors.New("no action")
+	}
+	subject := fpMessage.SubjectName
+	resourceName := fpMessage.ResourceName
+	owner := fpMessage.ResourceOwner
+
+	log.Printf("HandleServiceRequest %s\n", *action)
+
+	switch *action {
+	case "authenticateprincipal":
+		ok, ownerCert := AuthenticatePrincipal(m, ms, programPolicyObject)
+		if ok {
+			ownerName := PrincipalNameFromDERCert([]byte(ownerCert))
+			if ownerName == nil {
+				log.Printf("can't get ownername after AuthenticatePrincipal\n")
+				return false, nil
+			}
+			log.Printf("filehandler inserting %s %s\n", *ownerName, "authenticated")
+			_, err = m.InsertPrincipal(*ownerName, []byte(ownerCert), "authenticated")
+			if err != nil {
+				log.Printf("cant insert principal name in file\n")
+				return false, errors.New("cant insert principal name in file")
+			}
+			log.Printf("HandleServiceRequest: Added %s to Principal table\n", *ownerName)
+			return false, nil
+		} else {
+			return false, errors.New("AuthenticatePrincipal failed")
+		}
+	case "sendrule":
+		log.Printf("filehandler sendrule %s\n", *resourceName)
+		if resourceName == nil || owner == nil {
+			SendResponse(ms, "failed", "no ownername or resourcename", 0)
+			return false, nil
+		}
+		err = newruleRequest(m, ms, *resourceName /* rule */, []byte(*owner))
+		if err != nil {
+			return false, errors.New("Can't construct newrulequest")
+		}
+		return false, nil
+	default:
+	}
+
+	// Replace owner and subject with name
+	var ownerName *string
+	ownerName = nil
+	if owner != nil {
+		ownerName = m.certToAuthenticatedName([]byte(*owner))
+		if ownerName == nil {
+			status := "failed"
+			message := "unknown owner specified"
+			SendResponse(ms, status, message, 0)
+			return false, errors.New("unauthenticated principal")
+		}
+	}
+	var subjectName *string
+	subjectName = nil
+	if subject != nil {
+		subjectName = m.certToAuthenticatedName([]byte(*subject))
+		if subjectName == nil {
+			status := "failed"
+			message := "unknown owner specified"
+			SendResponse(ms, status, message, 0)
+			return false, errors.New("unauthenticated principal")
+		}
+	}
+	if subjectName != nil {
+		log.Printf("filehandler, HandleRequest, Subjectname: %s\n", *subjectName)
+	}
+	if ownerName != nil {
+		log.Printf("filehandler, HandleRequest, Ownername: %s\n", *ownerName)
+	}
+
+	// Is it authorized?
+	var ok bool
+	switch *action {
+	case "create":
+		if ownerName == nil {
+			SendResponse(ms, "failed", "no owner name", 0)
+			return false, nil
+		}
+		addResource(*ownerName, *resourceName, m.Guard)
+		fileserverSubject := "fileserver"
+		query := makeQuery(fileserverSubject, *action, *resourceName)
+		if query == nil {
+			log.Printf("bad query")
+		}
+		ok = m.Query(*query)
+
+	case "getfile":
+		if subjectName == nil || resourceName == nil {
+			SendResponse(ms, "failed", "no subjectname or resourcename", 0)
+			return false, nil
+		}
+		query := makeQuery(*subjectName, *action, *resourceName)
+		if query == nil {
+			log.Printf("bad query")
+		}
+		ok = m.Query(*query)
+	case "sendfile":
+		if subjectName == nil || resourceName == nil {
+			SendResponse(ms, "failed", "no subjectname or resourcename", 0)
+			return false, nil
+		}
+		query := makeQuery(*subjectName, *action, *resourceName)
+		if query == nil {
+			log.Printf("bad query")
+		}
+		ok = m.Query(*query)
+	default:
+		ok = false
+	}
+	if ok == false {
+		SendResponse(ms, "failed", "unauthorized", 0)
+		return false, nil
+	}
+
+	switch *action {
+	case "create":
+		if resourceName == nil || ownerName == nil {
+			return false, errors.New("Nil parameters for createRequest")
+		}
+		err := createRequest(m, ms, *resourceName, *ownerName)
+		return false, err
+	case "delete":
+		err := deleteRequest(m, ms, *resourceName)
+		return false, err
+	case "getfile":
+		if programPolicyObject.MySymKeys == nil {
+			log.Printf("HandleFileRequest, getfile keys nil\n")
+		} else {
+			log.Printf("HandleFileRequest, getfile keys NOT nil\n")
+		}
+		err := readRequest(m, ms, *resourceName, programPolicyObject.MySymKeys)
+		return false, err
+	case "sendfile":
+		if programPolicyObject.MySymKeys == nil {
+			log.Printf("HandleFileRequest, sendfile keys nil\n")
+		} else {
+			log.Printf("HandleFileRequest, sendfile keys NOT nil\n")
+		}
+		err := writeRequest(m, ms, *resourceName, programPolicyObject.MySymKeys)
+		return false, err
+	case "terminate":
+		return true, nil
+	default:
+		SendResponse(ms, "failed", "unsupported action", 0)
+		return false, errors.New("unsupported action")
+	}
+}
+
+func (m *ResourceMaster) InitMaster(filepath string, masterInfoDir string, prin string) error {
+	log.Printf("filehandler: InitMaster\n")
+	m.Policy = policy
+	m.AdditionalPolicy = additional_policy
+	m.ResourceArray = make([]ResourceInfo, 100)
+	m.ResourceArray = m.ResourceArray[0:0]
+	m.PrincipalArray = make([]PrincipalInfo, 100)
+	m.PrincipalArray = m.PrincipalArray[0:0]
+	m.BaseDirectory = filepath
+	m.InitGuard(masterInfoDir + "rules")
+	m.PrintAllPolicy()
+	return nil
+}
+
+func (m *ResourceMaster) SaveMaster(masterInfoDir string) error {
+	log.Printf("filehandler: SaveMaster\n")
+	err := m.SaveResourceData(masterInfoDir+"masterFile", masterInfoDir+"resourceFile",
+		masterInfoDir+"resourceFile", masterInfoDir+"ruleFile")
+	if err != nil {
+		log.Printf("filehandler: cant m.SaveResourceData\n")
+		return err
+	}
+	return m.SaveRules(masterInfoDir + "rules")
+}
diff --git a/apps/fileproxy/fileproxy.go b/apps/fileproxy/fileproxy.go
new file mode 100644
index 0000000..58ec4fb
--- /dev/null
+++ b/apps/fileproxy/fileproxy.go
@@ -0,0 +1,782 @@
+// Copyright (c) 2014, Google Corporation.  All rights reserved.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//     http://www.apache.org/licenses/LICENSE-2.0
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// File: fileproxy.go
+
+package fileproxy
+
+import (
+	"bytes"
+	"crypto/aes"
+	"crypto/cipher"
+	"crypto/hmac"
+	"crypto/rand"
+	"crypto/sha256"
+	"crypto/tls"
+	"crypto/x509"
+	"errors"
+	"flag"
+	"hash"
+	"io"
+	"io/ioutil"
+	"log"
+	"os"
+	"strings"
+
+	"code.google.com/p/goprotobuf/proto"
+
+	"github.com/jlmucb/cloudproxy/tao"
+	"github.com/jlmucb/cloudproxy/tao/auth"
+	taonet "github.com/jlmucb/cloudproxy/tao/net"
+	"github.com/jlmucb/cloudproxy/util"
+)
+
+var caAddr = flag.String("caAddr", "localhost:8124", "The address to listen on")
+var taoChannelAddr = flag.String("taoChannelAddr", "localhost:8124", "The address to listen on")
+var configPath = flag.String("config", "tao.config", "The Tao domain config")
+
+const SizeofSymmetricKeys = 64
+
+type ProgramPolicy struct {
+	Initialized   bool
+	TaoName       string
+	ThePolicyCert []byte
+	MySigningKey  tao.Keys
+	MySymKeys     []byte
+	MyProgramCert []byte
+}
+
+func (pp *ProgramPolicy) InitProgramPolicy(policyCert []byte, taoName string, signingKey tao.Keys, symKeys []byte, programCert []byte) bool {
+	log.Printf("InitProgramPolicy\n")
+	pp.ThePolicyCert = policyCert
+	pp.TaoName = taoName
+	pp.MySigningKey = signingKey
+	pp.MySymKeys = symKeys
+	pp.MyProgramCert = programCert
+	pp.Initialized = true
+	log.Printf("InitProgramPolicy done\n")
+	return true
+}
+
+// RequestTruncatedAttestation connects to a CA instance, sends the attestation
+// for an X.509 certificate, and gets back a truncated attestation with a new
+// principal name based on the policy key.
+func RequestKeyNegoAttestation(network, addr string, keys *tao.Keys, v *tao.Verifier) (*tao.Attestation, error) {
+	if keys.Cert == nil {
+		return nil, errors.New("client: can't dial with an empty client certificate\n")
+	}
+	tlsCert, err := taonet.EncodeTLSCert(keys)
+	if err != nil {
+		return nil, err
+	}
+	conn, err := tls.Dial(network, addr, &tls.Config{
+		RootCAs:            x509.NewCertPool(),
+		Certificates:       []tls.Certificate{*tlsCert},
+		InsecureSkipVerify: true,
+	})
+	if err != nil {
+		return nil, err
+	}
+	defer conn.Close()
+
+	// Tao handshake: send client delegation.
+	ms := util.NewMessageStream(conn)
+	if _, err = ms.WriteMessage(keys.Delegation); err != nil {
+		return nil, err
+	}
+
+	// Read the truncated attestation and check it.
+	var a tao.Attestation
+	if err := ms.ReadMessage(&a); err != nil {
+		return nil, err
+	}
+
+	ok, err := v.Verify(a.SerializedStatement, tao.AttestationSigningContext, a.Signature)
+	if err != nil {
+		return nil, err
+	}
+	if !ok {
+		return nil, errors.New("invalid attestation signature from Tao CA")
+	}
+
+	return &a, nil
+}
+
+func ZeroBytes(buf []byte) {
+	n := len(buf)
+	for i := 0; i < n; i++ {
+		buf[i] = 0
+	}
+}
+
+func PrincipalNameFromDERCert(derCert []byte) *string {
+	cert, err := x509.ParseCertificate(derCert)
+	if err != nil {
+		log.Printf("PrincipalNameFromDERCert: Can't get name from certificate\n")
+		return nil
+	}
+	cn := cert.Subject.CommonName
+	return &cn
+}
+
+// returns sealed symmetric key, sealed signing key, DER encoded cert, delegation, error
+func LoadProgramKeys(path string) ([]byte, []byte, []byte, []byte, error) {
+	_, err := os.Stat(path + "sealedsymmetrickey")
+	if err != nil {
+		return nil, nil, nil, nil, err
+	}
+	_, err = os.Stat(path + "sealedsigningKey")
+	if err != nil {
+		return nil, nil, nil, nil, err
+	}
+	_, err = os.Stat(path + "signerCert")
+	if err != nil {
+		return nil, nil, nil, nil, err
+	}
+
+	sealedSymmetricKey, err := ioutil.ReadFile(path + "sealedsymmetricKey")
+	if err != nil {
+		return nil, nil, nil, nil, err
+	}
+	log.Printf("fileproxy: Got sealedSymmetricKey\n")
+	sealedSigningKey, err := ioutil.ReadFile(path + "sealedsigningKey")
+	if err != nil {
+		return nil, nil, nil, nil, err
+	}
+	log.Printf("fileproxy: Got sealedSigningKey\n")
+	derCert, err := ioutil.ReadFile(path + "signerCert")
+	if err != nil {
+		return nil, nil, nil, nil, err
+	}
+	log.Printf("fileproxy: Got signerCert\n")
+	ds, err := ioutil.ReadFile(path + "delegationBlob")
+	if err != nil {
+		return nil, nil, nil, nil, err
+	}
+	log.Printf("LoadProgramKeys succeeded\n")
+	return sealedSymmetricKey, sealedSigningKey, derCert, ds, nil
+}
+
+func CreateSigningKey(t tao.Tao) (*tao.Keys, []byte, error) {
+	log.Printf("CreateSigningKey\n")
+	self, err := t.GetTaoName()
+	k, err := tao.NewTemporaryKeys(tao.Signing)
+	if k == nil || err != nil {
+		return nil, nil, errors.New("Can't generate signing key")
+	}
+	publicString := strings.Replace(self.String(), "(", "", -1)
+	publicString = strings.Replace(publicString, ")", "", -1)
+	details := tao.X509Details{
+		Country:      "US",
+		Organization: "Google",
+		CommonName:   publicString}
+	subjectname := tao.NewX509Name(details)
+	derCert, err := k.SigningKey.CreateSelfSignedDER(subjectname)
+	if err != nil {
+		return nil, nil, errors.New("Can't self sign cert\n")
+	}
+	cert, err := x509.ParseCertificate(derCert)
+	if err != nil {
+		return nil, nil, err
+	}
+	k.Cert = cert
+	s := &auth.Speaksfor{
+		Delegate:  k.SigningKey.ToPrincipal(),
+		Delegator: self}
+	if s == nil {
+		return nil, nil, errors.New("Can't produce speaksfor")
+	}
+	if k.Delegation, err = t.Attest(&self, nil, nil, s); err != nil {
+		return nil, nil, err
+	}
+	if err == nil {
+		_, _ = auth.UnmarshalForm(k.Delegation.SerializedStatement)
+	}
+	return k, derCert, nil
+}
+
+func InitializeSealedSymmetricKeys(path string, t tao.Tao, keysize int) ([]byte, error) {
+	log.Printf("InitializeSealedSymmetricKeys\n")
+	unsealed, err := tao.Parent().GetRandomBytes(keysize)
+	if err != nil {
+		return nil, errors.New("Can't get random bytes")
+	}
+	sealed, err := tao.Parent().Seal(unsealed, tao.SealPolicyDefault)
+	if err != nil {
+		return nil, errors.New("Can't seal random bytes")
+	}
+	ioutil.WriteFile(path+"sealedsymmetrickey", sealed, os.ModePerm)
+	return unsealed, nil
+}
+
+func InitializeSealedSigningKey(path string, t tao.Tao, domain tao.Domain) (*tao.Keys, error) {
+	log.Printf("InitializeSealedSigningKey\n")
+	k, derCert, err := CreateSigningKey(t)
+	if err != nil {
+		log.Printf("fileproxy: CreateSigningKey failed with error %s\n", err)
+		return nil, err
+	}
+	if derCert == nil {
+		log.Printf("fileproxy: CreateSigningKey failed, no dercert\n")
+		return nil, errors.New("No DER cert")
+	}
+	na, err := RequestKeyNegoAttestation("tcp", *caAddr, k, domain.Keys.VerifyingKey)
+	if err != nil {
+		log.Printf("fileproxy: error from taonet.RequestTruncatedAttestation\n")
+		return nil, err
+	}
+	if na == nil {
+		return nil, errors.New("tao returned nil attestation")
+	}
+	k.Delegation = na
+	pa, _ := auth.UnmarshalForm(na.SerializedStatement)
+	var saysStatement *auth.Says
+	if ptr, ok := pa.(*auth.Says); ok {
+		saysStatement = ptr
+	} else if val, ok := pa.(auth.Says); ok {
+		saysStatement = &val
+	}
+	sf, ok := saysStatement.Message.(auth.Speaksfor)
+	if ok != true {
+		return nil, errors.New("says doesnt have speaksfor message")
+	}
+	kprin, ok := sf.Delegate.(auth.Term)
+	if ok != true {
+		return nil, errors.New("speaksfor message doesnt have Delegate")
+	}
+	newCert := auth.Bytes(kprin.(auth.Bytes))
+	k.Cert, err = x509.ParseCertificate(newCert)
+	if err != nil {
+		log.Printf("can't parse returned certificate", err)
+		log.Printf("\n")
+		return nil, err
+	}
+	signingKeyBlob, err := tao.MarshalSignerDER(k.SigningKey)
+	if err != nil {
+		return nil, errors.New("Can't produce signing key blob")
+	}
+	sealedSigningKey, err := t.Seal(signingKeyBlob, tao.SealPolicyDefault)
+	if err != nil {
+		return nil, errors.New("Can't seal signing key")
+	}
+	err = ioutil.WriteFile(path+"sealedsigningKey", sealedSigningKey, os.ModePerm)
+	if err != nil {
+		return nil, err
+	}
+	err = ioutil.WriteFile(path+"signerCert", newCert, os.ModePerm)
+	if err != nil {
+		return nil, err
+	}
+	delegateBlob, err := proto.Marshal(k.Delegation)
+	if err != nil {
+		return nil, errors.New("Can't seal random bytes")
+	}
+	err = ioutil.WriteFile(path+"delegationBlob", delegateBlob, os.ModePerm)
+	if err != nil {
+		return nil, err
+	}
+	return k, nil
+}
+
+func SigningKeyFromBlob(t tao.Tao, sealedKeyBlob []byte, certBlob []byte, delegateBlob []byte) (*tao.Keys, error) {
+	log.Printf("SigningKeyFromBlob\n")
+	k := &tao.Keys{}
+	cert, err := x509.ParseCertificate(certBlob)
+	if err != nil {
+		return nil, err
+	}
+	k.Cert = cert
+	k.Delegation = new(tao.Attestation)
+	err = proto.Unmarshal(delegateBlob, k.Delegation)
+	if err != nil {
+		return nil, err
+	}
+	log.Printf("SigningKeyFromBlob: unmarshaled\n")
+	signingKeyBlob, policy, err := tao.Parent().Unseal(sealedKeyBlob)
+	if err != nil {
+		log.Printf("fileproxy: signingkey unsealing error: %s\n", err)
+	}
+	if policy != tao.SealPolicyDefault {
+		log.Printf("fileproxy: unexpected policy on unseal\n")
+	}
+	log.Printf("fileproxy: Unsealed Signing Key blob: %x\n", signingKeyBlob)
+	k.SigningKey, err = tao.UnmarshalSignerDER(signingKeyBlob)
+	k.Cert = cert
+	return k, err
+}
+
+func SendRequest(ms *util.MessageStream, subject *string, action *string, item *string, owner *string) error {
+	if action == nil {
+		log.Printf("SendRequest\n")
+	} else {
+		log.Printf("SendRequest %s\n", *action)
+	}
+	fpMessage := new(FPMessage)
+	fpMessage.MessageType = proto.Int32(int32(MessageType_REQUEST))
+	if subject != nil {
+		fpMessage.SubjectName = proto.String(string(*subject))
+	}
+	if action != nil {
+		fpMessage.ActionName = proto.String(*action)
+	}
+	if item != nil {
+		fpMessage.ResourceName = proto.String(*item)
+	}
+	if owner != nil {
+		fpMessage.ResourceOwner = proto.String(*owner)
+	}
+	out, err := proto.Marshal(fpMessage)
+	if err != nil {
+		log.Printf("SendRequest: can't marshal message\n")
+		return errors.New("transmission error")
+	}
+	_, err = ms.WriteString(string(out))
+	return err
+}
+
+func SendCounterRequest(ms *util.MessageStream, counter int64) error {
+	log.Printf("SendCounterRequest")
+	fpMessage := new(FPMessage)
+	fpMessage.MessageType = proto.Int32(int32(MessageType_REQUEST))
+	fpMessage.ActionName = proto.String("setrollbackcounter")
+	fpMessage.MonotonicCounter = proto.Int64(counter)
+	log.Printf("SendCounterRequest, counter: %d\n", counter)
+	out, err := proto.Marshal(fpMessage)
+	if err != nil {
+		log.Printf("SendCounterRequest: can't marshal message\n")
+		return errors.New("transmission error")
+	}
+
+	_, err = ms.WriteString(string(out))
+	return err
+}
+
+func SendCounterResponse(ms *util.MessageStream, status string, errMessage string, counter int64) error {
+	log.Printf("SendCounterResponse %d\n", counter)
+	fpMessage := new(FPMessage)
+	fpMessage.MessageType = proto.Int32(int32(MessageType_RESPONSE))
+	fpMessage.MonotonicCounter = proto.Int64(counter)
+	fpMessage.StatusOfRequest = proto.String(status)
+	fpMessage.MessageFromRequest = proto.String(errMessage)
+	out, err := proto.Marshal(fpMessage)
+	if err != nil {
+		log.Printf("SendCounterResponse: can't marshal message\n")
+		return errors.New("transmission error")
+	}
+
+	_, err = ms.WriteString(string(out))
+	return err
+}
+
+func PrintRequest(subject []byte, action *string, resource *string, owner []byte) {
+	log.Printf("PrintRequest\n")
+	if subject != nil {
+		log.Printf("\tsubject: % x\n", subject)
+		subjectName := PrincipalNameFromDERCert(subject)
+		if subjectName != nil {
+			log.Printf("\tsubject: %s\n", *subjectName)
+		}
+	}
+	if action != nil {
+		log.Printf("\taction: %s\n", *action)
+	}
+	if resource != nil {
+		log.Printf("\tresource: %s\n", *resource)
+	}
+	if owner != nil {
+		log.Printf("\towner: % x\n", owner)
+		ownerName := PrincipalNameFromDERCert(owner)
+		if ownerName != nil {
+			log.Printf("\towner: %s\n", *ownerName)
+		}
+	}
+}
+
+func GetResponse(ms *util.MessageStream) (*string, *string, *int, error) {
+	log.Printf("GetResponse\n")
+
+	strbytes, err := ms.ReadString()
+
+	fpMessage := new(FPMessage)
+	err = proto.Unmarshal([]byte(strbytes), fpMessage)
+	if err != nil {
+		return nil, nil, nil, errors.New("GetResponse can't unmarshal message")
+	}
+	if fpMessage.MessageType == nil {
+		return nil, nil, nil, errors.New("GetResponse: no message type")
+	}
+	if *fpMessage.MessageType != int32(MessageType_RESPONSE) {
+		log.Printf("GetResponse bad type\n")
+		return nil, nil, nil, errors.New("reception error")
+	}
+	var status *string
+	var errMessage *string
+	var size int
+
+	if fpMessage.StatusOfRequest == nil {
+		log.Printf("GetResponse no status\n")
+		return nil, nil, nil, errors.New("reception error")
+	}
+	status = fpMessage.StatusOfRequest
+	errMessage = fpMessage.MessageFromRequest
+	if fpMessage.BufferSize == nil {
+		return status, errMessage, nil, nil
+	} else {
+		size = int(*fpMessage.BufferSize)
+		return status, errMessage, &size, nil
+	}
+}
+
+func GetCounterResponse(ms *util.MessageStream) (*string, *string, *int64, error) {
+	strbytes, err := ms.ReadString()
+	log.Printf("GetCounterResponse read %d bytes\n", len(strbytes))
+
+	fpMessage := new(FPMessage)
+	err = proto.Unmarshal([]byte(strbytes), fpMessage)
+	if err != nil {
+		return nil, nil, nil, errors.New("GetCounterResponse can't unmarshal message")
+	}
+	if fpMessage.MessageType == nil {
+		return nil, nil, nil, errors.New("GetCounterResponse: no message type")
+	}
+	if *fpMessage.MessageType != int32(MessageType_RESPONSE) {
+		log.Printf("GetCounterResponse bad type\n")
+		return nil, nil, nil, errors.New("reception error")
+	}
+	var status *string
+	var errMessage *string
+
+	if fpMessage.StatusOfRequest == nil {
+		log.Printf("GetResponse no status\n")
+		return nil, nil, nil, errors.New("reception error")
+	}
+	status = fpMessage.StatusOfRequest
+	if status == nil {
+		log.Printf("GetCounterResponse status is nil\n")
+	} else {
+		log.Printf("GetCounterResponse status: %s\n", *status)
+	}
+	errMessage = fpMessage.MessageFromRequest
+	if fpMessage.MonotonicCounter == nil {
+		log.Printf("GetCounterResponse fpMessage.MonotonicCounter is nil\n")
+		return status, errMessage, nil, nil
+	} else {
+		counter := *fpMessage.MonotonicCounter
+		log.Printf("GetCounterResponse counter: %d\n", counter)
+		return status, errMessage, &counter, nil
+	}
+}
+
+func PrintResponse(status *string, message *string, size *int) {
+	log.Printf("PrintResponse\n")
+	if status != nil {
+		log.Printf("\tstatus: %s\n", *status)
+	} else {
+		log.Printf("\tstatus: empty\n")
+	}
+	if message != nil {
+		log.Printf("\tmessage: %s\n", *message)
+	}
+	if size != nil {
+		log.Printf("\tsize: %d\n", *size)
+	}
+}
+
+func SendResponse(ms *util.MessageStream, status string, errMessage string, size int) error {
+	fpMessage := new(FPMessage)
+	fpMessage.MessageType = proto.Int32(int32(MessageType_RESPONSE))
+	fpMessage.StatusOfRequest = proto.String(status)
+	fpMessage.MessageFromRequest = proto.String(errMessage)
+	out, err := proto.Marshal(fpMessage)
+	if err != nil {
+		log.Printf("SendResponse can't encode response\n")
+		return err
+	}
+	send := string(out)
+	log.Printf("SendResponse sending %s %s %d\n", status, errMessage, len(send))
+	n, err := ms.WriteString(send)
+	if err != nil {
+		log.Printf("SendResponse Writestring error %d\n", n, err)
+		return err
+	}
+	return nil
+}
+
+func SendProtocolMessage(ms *util.MessageStream, size int, buf []byte) error {
#*
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-11-13T10:24:13-0800
#*
#- MessageStream already does all this framing for you. You can use WriteMessage
#- and ReadMessage on the MessageStream directly.
#-
+	log.Printf("SendProtocolMessage\n")
+	fpMessage := new(FPMessage)
+	fpMessage.MessageType = proto.Int32(int32(MessageType_PROTOCOL_RESPONSE))
+	fpMessage.BufferSize = proto.Int32(int32(size))
+	fpMessage.TheBuffer = proto.String(string(buf))
+	out, err := proto.Marshal(fpMessage)
+	if err != nil {
+		log.Printf("SendResponse can't encode response\n")
+		return err
+	}
+	n, err := ms.WriteString(string(out))
+	if err != nil {
+		log.Printf("SendProtocolMessage Writestring error %d\n", n, err)
+		return err
+	}
+	return nil
+}
+
+func GetProtocolMessage(ms *util.MessageStream) ([]byte, error) {
+	log.Printf("GetProtocolMessage\n")
+	strbytes, err := ms.ReadString()
+	if err != nil {
+		return nil, err
+	}
+	fpMessage := new(FPMessage)
+	err = proto.Unmarshal([]byte(strbytes), fpMessage)
+	if err != nil {
+		return nil, errors.New("GetProtocolMessage can't unmarshal message")
+	}
+	if fpMessage.MessageType == nil {
+		return nil, errors.New("GetProtocolMessage: no message type")
+	}
+	if *fpMessage.MessageType != int32(MessageType_PROTOCOL_RESPONSE) {
+		return nil, errors.New("GetProtocolMessage: Wrong message type")
+	}
+	out := fpMessage.TheBuffer
+	if out == nil {
+		return nil, errors.New("GetProtocolMessage: empty buffer")
+	}
+	return []byte(*out), nil
+}
+
+func SendFile(ms *util.MessageStream, path string, filename string, keys []byte) error {
+	log.Printf("SendFile %s%s\n", path, filename)
+
+	fpMessage := new(FPMessage)
+	var buf []byte
+	buf = make([]byte, 2048)
+	fileInfo, err := os.Stat(path + filename)
+	if err != nil {
+		return errors.New("SendFile no such file")
+	}
+	file, err := os.Open(path + filename)
+	if err != nil {
+		return errors.New("SendFile: can't open file ")
+	}
+	defer file.Close()
+
+	var aesObj cipher.Block
+	var iv [16]byte
+	var ctrCipher cipher.Stream
+
+	bytesLeft := int(fileInfo.Size())
+	var final bool
+	final = false
+	var toRead int
+	var plaintext []byte
+	var hmacObj hash.Hash
+	plaintext = make([]byte, 2048)
+	if keys != nil {
+		aesObj, err = aes.NewCipher(keys[0:16])
+		if err != nil || aesObj == nil {
+			log.Printf("SendFile can't create aes object")
+		}
+		// read iv
+		_, err := file.Read(iv[0:16])
#*
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-11-13T10:26:11-0800
#*
#- Can use iv[:] instead, since iv is exactly 16 bytes long.
#-
+		if err != nil {
+			return err
+		}
+		hmacObj = hmac.New(sha256.New, keys[16:32])
+		log.Printf("SendFile initialized hmac keys %x", keys[16:32])
+		hmacObj.Write(iv[0:16])
+		log.Printf("SendFile wrote iv to hmac %x", iv)
+		ctrCipher = cipher.NewCTR(aesObj, iv[0:16])
+		if ctrCipher == nil {
+			log.Printf("SendFile can't create counter cipher object")
+		}
+		bytesLeft = bytesLeft - 16
+		log.Printf("sent iv message\n")
+	}
+	if keys != nil {
+		bytesLeft = bytesLeft - 32
+	}
+	for {
+		if bytesLeft <= 2048 {
+			toRead = bytesLeft
+			final = true
+		} else {
+			toRead = 2048
+		}
+		n, err := file.Read(buf[0:toRead])
+		if err != nil {
+			return err
+		}
+		if final {
+			fpMessage.MessageType = proto.Int32(int32(MessageType_FILE_LAST))
+		} else {
+			fpMessage.MessageType = proto.Int32(int32(MessageType_FILE_NEXT))
+		}
+		bytesLeft = bytesLeft - n
+		fpMessage.BufferSize = proto.Int32(int32(n))
+		if keys != nil {
+			hmacObj.Write(buf[0:n])
+			log.Printf("SendFile wrote to hmac %x", buf[0:n])
+			ctrCipher.XORKeyStream(plaintext[0:n], buf[0:n])
+			fpMessage.TheBuffer = proto.String(string(plaintext[0:n]))
+			log.Printf("sent cipher block %d\n", n)
+		} else {
+			fpMessage.TheBuffer = proto.String(string(buf[0:n]))
+		}
+		out, err := proto.Marshal(fpMessage)
+		if err != nil {
+			log.Printf("SendFile can't file contents message\n")
+			return errors.New("transmission error")
+		}
+		_, _ = ms.WriteString(string(out))
+		if final {
+			break
+		}
+	}
+	if keys != nil {
+		// read mac and check it
+		_, err := file.Read(buf[0:32])
+		if err != nil {
+			return err
+		}
+		mac := hmacObj.Sum(nil)
+		if bytes.Equal(mac, buf[0:32]) {
+			log.Printf("SendFile: hmac matches\n")
+		} else {
+			log.Printf("SendFile: hmac does not match\n")
+			log.Printf("expected: %x\n", mac)
+			log.Printf("received: %x\n", buf[0:32])
+		}
+	}
+	return nil
+}
+
+func GetFile(ms *util.MessageStream, path string, filename string, keys []byte) error {
+	log.Printf("GetFile %s%s\n", path, filename)
+	fpMessage := new(FPMessage)
+	var final bool
+	final = false
+	file, err := os.Create(path + filename)
+	if err != nil {
+		return errors.New("GetFile can't creat file")
+	}
+	defer file.Close()
+
+	var aesObj cipher.Block
+	var iv [16]byte
+	var ctrCipher cipher.Stream
+	var ciphertext []byte
+	var hmacObj hash.Hash
+	ciphertext = make([]byte, 2048)
+	if keys != nil {
+		aesObj, err = aes.NewCipher(keys[0:16])
+		if err != nil || aesObj == nil {
+			log.Printf("GetFile can't create aes object")
+		}
+		hmacObj = hmac.New(sha256.New, keys[16:32])
+		log.Printf("GetFile initialized keys for hmac %x", keys[16:32])
+		if _, err := io.ReadFull(rand.Reader, iv[0:16]); err != nil {
+			panic(err)
+		}
+		hmacObj.Write(iv[0:16])
+		log.Printf("GetFile wrote iv to hmac %x", iv[0:16])
+		ctrCipher = cipher.NewCTR(aesObj, iv[0:16])
+		if ctrCipher == nil {
+			log.Printf("GetFile can't create counter cipher object")
+		}
+		_, err = file.Write(iv[0:16])
+	}
+
+	for {
+		in, err := ms.ReadString()
+		if err != nil {
+			log.Printf("GetFile can't readstring\n")
+			return errors.New("reception error")
+		}
+		err = proto.Unmarshal([]byte(in), fpMessage)
+		if err != nil {
+			return errors.New("GetFile can't unmarshal message")
+		}
+		if fpMessage.MessageType == nil {
+			return errors.New("GetFile no message type")
+		}
+		if *fpMessage.MessageType == int32(MessageType_FILE_LAST) {
+			final = true
+		} else if *fpMessage.MessageType == int32(MessageType_FILE_NEXT) {
+			final = false
+		} else {
+			log.Printf("GetFile bad message type\n")
+			return errors.New("reception error")
+		}
+		if fpMessage.BufferSize == nil {
+			log.Printf("GetFile no buffer size\n")
+			return errors.New("expected buffer size")
+		}
+		if fpMessage.TheBuffer == nil {
+			return errors.New("GetFile: empty buffer")
+		}
+		out := []byte(*fpMessage.TheBuffer)
+		if keys != nil {
+			ctrCipher.XORKeyStream(ciphertext, out[0:int(*fpMessage.BufferSize)])
+			hmacObj.Write(ciphertext[0:int(*fpMessage.BufferSize)])
+			log.Printf("GetFile wrote hmac %x", ciphertext[0:int(*fpMessage.BufferSize)])
+			_, err = file.Write(ciphertext[0:int(*fpMessage.BufferSize)])
+		} else {
+			_, err = file.Write(out[0:int(*fpMessage.BufferSize)])
+		}
+		if final {
+			break
+		}
+	}
+	if keys != nil {
+		// write Mac
+		hmacBytes := hmacObj.Sum(nil)
+		_, err = file.Write(hmacBytes[0:32])
+	}
+	return nil
+}
+
+func SendSendFile(ms *util.MessageStream, subjectCert []byte, filename string) error {
+	log.Printf("SendSendFile, filename: %s\n", filename)
+	subject := string(subjectCert)
+	action := "sendfile"
+	return SendRequest(ms, &subject, &action, &filename, nil)
+}
+
+func SendGetFile(ms *util.MessageStream, subjectCert []byte, filename string) error {
+	log.Printf("SendGetFile, filename: %s\n", filename)
+	subject := string(subjectCert)
+	action := "getfile"
+	return SendRequest(ms, &subject, &action, &filename, nil)
+}
+
+func SendCreateFile(ms *util.MessageStream, subjectCert []byte, filename string) error {
+	log.Printf("SendCreateFile, filename: %s\n", filename)
+	subject := string(subjectCert)
+	action := "create"
+	return SendRequest(ms, &subject, &action, &filename, &subject)
+}
+
+func SendRule(ms *util.MessageStream, rule string, signerCert []byte) error {
+	log.Printf("SendRule, rule: %s\n", rule)
+	subject := string(signerCert)
+	action := "sendrule"
+	return SendRequest(ms, &subject, &action, &rule, &subject)
+}
+
+func SendDeleteFile(ms *util.MessageStream, creds []byte, filename string) error {
+	return errors.New("CreateFile request not implemented")
+}
+
+func SendAddFilePermissions(ms *util.MessageStream, creds []byte, filename string) error {
+	return errors.New("AddFilePermissions request not implemented")
+}
diff --git a/apps/fileproxy/fileproxymessages.proto b/apps/fileproxy/fileproxymessages.proto
new file mode 100644
index 0000000..be1c6ab
--- /dev/null
+++ b/apps/fileproxy/fileproxymessages.proto
@@ -0,0 +1,59 @@
+//  Copyright (c) 2013, Google Inc.  All rights reserved.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package fileproxy;
+
+enum MessageType {
+   REQUEST = 1;
+   RESPONSE = 2;
+   FILE_NEXT = 3;
+   FILE_LAST = 4;
+   PROTOCOL_RESPONSE= 5;
+ }
+
+message FPMessage {
#*
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-11-13T10:27:38-0800
#*
#- Go style point: don't stutter. There is already a package name here called
#- fileproxy, so this can simply be Message, ResourceMaster, ResourceInfo, and
#- PrincipalInfo.
#-
+  required  int32   message_type = 1;
+  optional  string  subject_name = 2;
+  optional  string  action_name = 3;
+  optional  string  resource_name = 4;
+  optional  string  resource_owner= 5;
+  optional  string  status_of_request = 6;
+  optional  string  message_from_request = 7;
+  optional  int64   monotonic_counter= 8;
+  optional  int32   buffer_size = 9;
+  optional  string  the_buffer = 10;
+}
+
+message FPResourceMaster {
+  optional  string  prin_name = 1;
+  optional  string  baseDirectory_name = 2;
+  required  int32   num_fileinfos = 3;
+}
+
+message FPResourceInfo {
+  required string resource_name = 1;
+  required string resource_type = 2;
+  required string resource_status = 3;
+  required string resource_location= 4;
+  optional int32  resource_size= 5;
+  optional string resource_owner= 6;
+}
+
+message FPPrincipalInfo {
+  required string principal_name = 1;
+  required string principal_cert= 2;
+  required string principal_status = 3;
+}
+
+
diff --git a/apps/fileproxy/fileserver/fileserver.go b/apps/fileproxy/fileserver/fileserver.go
index 0fb9819..d779d71 100644
--- a/apps/fileproxy/fileserver/fileserver.go
+++ b/apps/fileproxy/fileserver/fileserver.go
@@ -1,350 +1,236 @@
-// Copyright (c) 2014, Kevin Walsh.  All rights reserved.
+// Copyright (c) 2014, Google Corporation.  All rights reserved.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
 // You may obtain a copy of the License at
-//
 //     http://www.apache.org/licenses/LICENSE-2.0
-//
 // Unless required by applicable law or agreed to in writing, software
 // distributed under the License is distributed on an "AS IS" BASIS,
 // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 // See the License for the specific language governing permissions and
 // limitations under the License.
-// FIle: fileserver.go
+//
+// File: fileserver.go
 
 package main
 
 import (
-	"bufio"
+	"crypto/sha256"
 	"crypto/tls"
 	"crypto/x509"
-	"crypto/x509/pkix"
-	"errors"
+	"encoding/hex"
 	"flag"
-	"fmt"
+	"log"
 	"net"
-	"os"
-	"strings"
-	"github.com/jlmucb/cloudproxy/tao"
+
+	"github.com/jlmucb/cloudproxy/apps/fileproxy"
+	tao "github.com/jlmucb/cloudproxy/tao"
 	"github.com/jlmucb/cloudproxy/tao/auth"
 	taonet "github.com/jlmucb/cloudproxy/tao/net"
+	"github.com/jlmucb/cloudproxy/util"
 )
 
+var hostcfg = flag.String("../hostdomain/tao.config", "../hostdomain/tao.config", "path to host tao configuration")
 var serverHost = flag.String("host", "localhost", "address for client/server")
 var serverPort = flag.String("port", "8123", "port for client/server")
-var serverAddr string // see main()
-var localMode = flag.Bool("local", true, "Run host demo")
-var clientMode = flag.Bool("client", true, "Run demo client")
-var serverMode = flag.Bool("server", true, "Run demo server")
-var pingCount = flag.Int("n", 5, "Number of client/server pings")
-var demoAuth = flag.String("auth", "tao", "\"tcp\", \"tls\", or \"tao\"")
-var configPath = flag.String("config", "tao.config", "The Tao domain config")
-var ca = flag.String("ca", "", "address for Tao CA, if any")
-
-var subprinRule = "(forall P: forall Hash: TrustedProgramHash(Hash) and Subprin(P, %v, Hash) implies MemberProgram(P))"
-var argsRule = "(forall Y: forall P: forall S: MemberProgram(P) and TrustedArgs(S) and Subprin(Y, P, S) implies Authorized(Y, \"Execute\"))"
-var demoRule = "TrustedArgs(ext.Args(%s))"
-
-// client/server driver
-
-func doRequest(guard tao.Guard, domain *tao.Domain, keys *tao.Keys) bool {
-	fmt.Printf("client: connecting to %s using %s authentication.\n", serverAddr, *demoAuth)
-	var conn net.Conn
-	var err error
-	network := "tcp"
-
-	switch *demoAuth {
-	case "tcp":
-		conn, err = net.Dial(network, serverAddr)
-	case "tls":
-		conn, err = taonet.DialTLSWithKeys(network, serverAddr, keys)
-	case "tao":
-		conn, err = taonet.DialWithKeys(network, serverAddr, guard, domain.Keys.VerifyingKey, keys)
-	}
-	if err != nil {
-		fmt.Printf("client: error connecting to %s: %s\n", serverAddr, err.Error())
-		return false
-	}
-	defer conn.Close()
-
-	_, err = fmt.Fprintf(conn, "Hello\n")
-	if err != nil {
-		fmt.Printf("client: can't write: %s\n", err.Error())
-		return false
-	}
-	msg, err := bufio.NewReader(conn).ReadString('\n')
-	if err != nil {
-		fmt.Printf("client can't read: %s\n", err.Error())
-		return false
-	}
-	msg = strings.TrimSpace(msg)
-	fmt.Printf("client: got reply: %s\n", msg)
-	return true
-}
+var fileserverPath = flag.String("fileserver_files/", "fileserver_files/", "fileserver directory")
+var fileserverFilePath = flag.String("fileserver_files/stored_files/", "fileserver_files/stored_files/",
+	"fileserver directory")
+var serverAddr string
+var testFile = flag.String("originalTestFile", "originalTestFile", "test file")
 
-func newTempCAGuard(v *tao.Verifier) (tao.Guard, error) {
-	g := tao.NewTemporaryDatalogGuard()
-	vprin := v.ToPrincipal()
-	rule := fmt.Sprintf(subprinRule, vprin)
+func clientServiceThead(ms *util.MessageStream, clientProgramName string, fileServerProgramPolicy *fileproxy.ProgramPolicy, resourceMaster *fileproxy.ResourceMaster) {
+	log.Printf("fileserver: clientServiceThead\n")
 
-	// Add a rule that says that valid args are the ones we were called with.
-	args := ""
-	for i, a := range os.Args {
-		if i > 0 {
-			args += ", "
+	// How do I know if the connection terminates?
+	for {
+		log.Printf("clientServiceThead: ReadString\n")
+		strbytes, err := ms.ReadString()
+		if err != nil {
+			return
+		}
+		terminate, err := resourceMaster.HandleServiceRequest(ms, fileServerProgramPolicy, clientProgramName, []byte(strbytes))
+		if terminate {
+			break
 		}
-		args += "\"" + a + "\""
-	}
-	authRule := fmt.Sprintf(demoRule, args)
-
-	if err := g.AddRule(rule); err != nil {
-		return nil, err
-	}
-	if err := g.AddRule(argsRule); err != nil {
-		return nil, err
-	}
-	if err := g.AddRule(authRule); err != nil {
-		return nil, err
 	}
-	return g, nil
+	log.Printf("fileserver: client thread terminating\n")
 }
 
-func doResponse(conn net.Conn, responseOk chan<- bool) {
-	defer conn.Close()
+func server(serverAddr string, prin string, derPolicyCert []byte, signingKey *tao.Keys, fileServerProgramPolicy *fileproxy.ProgramPolicy, fileServerResourceMaster *fileproxy.ResourceMaster) {
+	var sock net.Listener
+	log.Printf("fileserver: server\n")
 
-	// Both the TLS and the Tao/TLS connections and listeners handle
-	// authorization during the Accept operation. So, no extra authorization is
-	// needed here.
-	msg, err := bufio.NewReader(conn).ReadString('\n')
+	err := fileServerResourceMaster.InitMaster(*fileserverFilePath, *fileserverPath, prin)
 	if err != nil {
-		fmt.Printf("server: can't read: %s\n", err.Error())
-		conn.Close()
-		responseOk <- false
+		log.Printf("fileserver: can't InitMaster\n")
 		return
 	}
-	msg = strings.TrimSpace(msg)
-	fmt.Printf("server: got message: %s\n", msg)
-	responseOk <- true
-	fmt.Fprintf(conn, "echo(%s)\n", msg)
-	conn.Close()
-}
 
-func doServer(stop chan bool, ready, done chan<- bool) {
-	var sock net.Listener
-	var err error
-	var keys *tao.Keys
-	network := "tcp"
-	domain, err := tao.LoadDomain(*configPath, nil)
+	policyCert, err := x509.ParseCertificate(derPolicyCert)
 	if err != nil {
-		ready <- false
-		done <- true
+		log.Printf("fileserver: can't ParseCertificate\n")
 		return
 	}
-
-	switch *demoAuth {
-	case "tcp":
-		sock, err = net.Listen(network, serverAddr)
-	case "tls", "tao":
-		keys, err = tao.NewTemporaryTaoDelegatedKeys(tao.Signing, tao.Parent())
-		if err != nil {
-			ready <- false
-			done <- true
-			return
-		}
-		keys.Cert, err = keys.SigningKey.CreateSelfSignedX509(&pkix.Name{
-			Organization: []string{"Google Tao Demo"}})
-		if err != nil {
-			ready <- false
-			done <- true
-			return
-		}
-
-		g := domain.Guard
-		if *ca != "" {
-			na, err := taonet.RequestTruncatedAttestation(network, *ca, keys, domain.Keys.VerifyingKey)
-			if err != nil {
-				ready <- false
-				done <- true
-				return
-			}
-
-			keys.Delegation = na
-			g, err = newTempCAGuard(domain.Keys.VerifyingKey)
-			if err != nil {
-				fmt.Printf("server: couldn't set up a new guard: %s\n", err)
-				return
-			}
-		}
-
-		tlsc, err := taonet.EncodeTLSCert(keys)
-		if err != nil {
-			ready <- false
-			done <- true
-			return
-		}
-		conf := &tls.Config{
-			RootCAs:            x509.NewCertPool(),
-			Certificates:       []tls.Certificate{*tlsc},
-			InsecureSkipVerify: true,
-			ClientAuth:         tls.RequireAnyClientCert,
-		}
-		if *demoAuth == "tao" {
-			sock, err = taonet.Listen(network, serverAddr, conf, g, domain.Keys.VerifyingKey, keys.Delegation)
-		} else {
-			sock, err = tls.Listen(network, serverAddr, conf)
-		}
+	pool := x509.NewCertPool()
+	pool.AddCert(policyCert)
+	tlsc, err := taonet.EncodeTLSCert(signingKey)
+	if err != nil {
+		log.Printf("fileserver, encode error: ", err)
+		log.Printf("\n")
+		return
+	}
+	conf := &tls.Config{
+		RootCAs:            pool,
+		Certificates:       []tls.Certificate{*tlsc},
+		InsecureSkipVerify: false,
+		ClientAuth:         tls.RequireAnyClientCert,
 	}
+	log.Printf("Listening\n")
+	sock, err = tls.Listen("tcp", serverAddr, conf)
 	if err != nil {
-		fmt.Printf("server: can't listen at %s: %s\n", serverAddr, err.Error())
-		ready <- false
-		done <- true
+		log.Printf("fileserver, listen error: ", err)
+		log.Printf("\n")
 		return
 	}
-	fmt.Printf("server: listening at %s using %s authentication.\n", serverAddr, *demoAuth)
-	ready <- true
-
-	pings := make(chan bool, 10)
-	connCount := 0
-
-	go func() {
-		for connCount = 0; connCount < *pingCount || *pingCount < 0; connCount++ { // negative means forever
-			conn, err := sock.Accept()
+	for {
+		log.Printf("fileserver: at Accept\n")
+		conn, err := sock.Accept()
+		if err != nil {
+			log.Printf("fileserver: can't accept connection: %s\n", err.Error())
+		} else {
+			var clientName string
+			clientName = "XYZZY"
+			err = conn.(*tls.Conn).Handshake()
 			if err != nil {
-				fmt.Printf("server: can't accept connection: %s\n", err.Error())
-				stop <- true
-				return
+				log.Printf("TLS handshake failed\n")
 			}
-			go doResponse(conn, pings)
-		}
-	}()
-
-	pingGood := 0
-	pingFail := 0
-
-loop:
-	for {
-		select {
-		case <-stop:
-			break loop
-		case ok := <-pings:
-			if ok {
-				pingGood++
+			peerCerts := conn.(*tls.Conn).ConnectionState().PeerCertificates
+			if peerCerts == nil {
+				log.Printf("fileserver: can't get peer list\n")
 			} else {
-				pingFail++
+				peerCert := conn.(*tls.Conn).ConnectionState().PeerCertificates[0]
+				if peerCert.Raw == nil {
+					log.Printf("fileserver: can't get peer name\n")
+				} else {
+					if peerCert.Subject.OrganizationalUnit != nil {
#*
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-11-13T10:29:28-0800
#*
#- After thinking about this some more, I think the right place to put the name
#- is probably actually in the extensions, since that's the official place for
#- extensions like ours.
#-
+						clientName = peerCert.Subject.OrganizationalUnit[0]
+					}
+				}
 			}
+			log.Printf("fileserver, peer name: %s\n", clientName)
+			ms := util.NewMessageStream(conn)
+			go clientServiceThead(ms, clientName, fileServerProgramPolicy, fileServerResourceMaster)
 		}
 	}
-
-	sock.Close()
-	fmt.Printf("server: handled %d connections, finished %d ok, %d bad pings\n",
-		connCount, pingGood, pingFail)
-
-	done <- true
 }
 
-// Tao Host demo
+func main() {
 
-func hostTaoDemo() error {
-	name, err := tao.Parent().GetTaoName()
-	if err != nil {
-		return err
-	}
-	fmt.Printf("My root name is %s\n", name)
+	var fileServerResourceMaster fileproxy.ResourceMaster
+	var FileServerResourceMaster *fileproxy.ResourceMaster
+	var fileServerProgramPolicy fileproxy.ProgramPolicy
+	var FileServerProgramPolicy *fileproxy.ProgramPolicy
 
-	// TODO(kwalsh) Make a convenience function for this
-	var args []auth.Term
-	for _, arg := range os.Args {
-		args = append(args, auth.Str(arg))
-	}
-	e := auth.PrinExt{Name: "Args", Arg: args}
-	err = tao.Parent().ExtendTaoName(auth.SubPrin{e})
-	if err != nil {
-		return err
-	}
+	flag.Parse()
+	serverAddr = *serverHost + ":" + *serverPort
 
-	name, err = tao.Parent().GetTaoName()
+	hostDomain, err := tao.LoadDomain(*hostcfg, nil)
 	if err != nil {
-		return err
+		return
 	}
-	fmt.Printf("My full name is %s\n", name)
-
-	random, err := tao.Parent().GetRandomBytes(10)
-	if err != nil {
-		return err
+	log.Printf("fileserver: Domain name: %s\n", hostDomain.ConfigPath)
+	var derPolicyCert []byte
+	if hostDomain.Keys.Cert != nil {
+		derPolicyCert = hostDomain.Keys.Cert.Raw
 	}
-	fmt.Printf("Random bytes  : % x\n", random)
-
-	n, err := tao.Parent().Rand().Read(random)
-	if err != nil {
-		return err
+	if derPolicyCert == nil {
+		log.Printf("fileserver: can't retrieve policy cert\n")
+		return
 	}
-	fmt.Printf("%d more bytes : % x\n", n, random)
 
-	secret, err := tao.Parent().GetSharedSecret(10, tao.SharedSecretPolicyDefault)
+	/*
+	 Replace with: hostDomai.ExtendTaoDomain(tao)
+	*/
+	sha256Hash := sha256.New()
+	sha256Hash.Write(derPolicyCert)
+	policyCertHash := sha256Hash.Sum(nil)
+	hexCertHash := hex.EncodeToString(policyCertHash)
+	e := auth.PrinExt{Name: hexCertHash}
+	err = tao.Parent().ExtendTaoName(auth.SubPrin{e})
 	if err != nil {
-		return err
+		return
 	}
-	fmt.Printf("Shared secret : % x\n", secret)
 
-	sealed, err := tao.Parent().Seal(random, tao.SealPolicyDefault)
+	e = auth.PrinExt{Name: "fileserver_version_1"}
+	err = tao.Parent().ExtendTaoName(auth.SubPrin{e})
 	if err != nil {
-		return err
+		return
 	}
-	fmt.Printf("Sealed bytes  : % x\n", sealed)
 
-	unsealed, policy, err := tao.Parent().Unseal(sealed)
+	taoName, err := tao.Parent().GetTaoName()
 	if err != nil {
-		return err
-	}
-	if policy != tao.SealPolicyDefault {
-		return errors.New("unexpected policy on unseal")
-	}
-	fmt.Printf("Unsealed bytes: % x\n", unsealed)
-
-	return nil
-}
-
-func main() {
-	flag.Parse()
-	serverAddr = *serverHost + ":" + *serverPort
-	switch *demoAuth {
-	case "tcp", "tls", "tao":
-	default:
-		fmt.Printf("unrecognized authentication mode: %s\n", *demoAuth)
+		log.Printf("fileserver: cant get tao name\n")
 		return
 	}
+	log.Printf("fileserver: my name is %s\n", taoName)
 
-	fmt.Printf("Go Tao Demo\n")
-
-	if !tao.Hosted() {
-		fmt.Printf("can't continue: No host Tao available\n")
-		return
+	var programCert []byte
+	sealedSymmetricKey, sealedSigningKey, programCert, delegation, err := fileproxy.LoadProgramKeys(*fileserverPath)
+	if err != nil {
+		log.Printf("fileserver: cant retrieve key material\n")
+	}
+	if sealedSymmetricKey == nil || sealedSigningKey == nil || delegation == nil || programCert == nil {
+		log.Printf("fileserver: No key material present\n")
 	}
 
-	if *localMode {
-		err := hostTaoDemo()
+	var symKeys []byte
+	defer fileproxy.ZeroBytes(symKeys)
+	if sealedSymmetricKey != nil {
+		symKeys, policy, err := tao.Parent().Unseal(sealedSymmetricKey)
 		if err != nil {
-			fmt.Printf("error: %s\n", err.Error())
 			return
 		}
+		if policy != tao.SealPolicyDefault {
+			log.Printf("fileserver: unexpected policy on unseal\n")
+		}
+		log.Printf("fileserver: Unsealed symKeys: % x\n", symKeys)
+	} else {
+		symKeys, err = fileproxy.InitializeSealedSymmetricKeys(*fileserverPath, tao.Parent(), fileproxy.SizeofSymmetricKeys)
+		if err != nil {
+			log.Printf("fileserver: InitializeSealedSymmetricKeys error: %s\n", err)
+		}
+		log.Printf("fileserver: InitilizedsymKeys: % x\n", symKeys)
 	}
 
-	serverStop := make(chan bool, 1)
-	serverReady := make(chan bool, 1)
-	serverDone := make(chan bool, 1)
+	var signingKey *tao.Keys
+	if sealedSigningKey != nil {
+		log.Printf("retrieving signing key\n")
+		signingKey, err = fileproxy.SigningKeyFromBlob(tao.Parent(),
+			sealedSigningKey, programCert, delegation)
+		if err != nil {
+			log.Printf("fileserver: SigningKeyFromBlob error: %s\n", err)
+		}
+		log.Printf("fileserver: Retrieved Signing key: % x\n", *signingKey)
+	} else {
+		log.Printf("fileserver: initializing signing key\n")
+		signingKey, err = fileproxy.InitializeSealedSigningKey(*fileserverPath,
+			tao.Parent(), *hostDomain)
+		if err != nil {
+			log.Printf("fileserver: InitializeSealedSigningKey error: %s\n", err)
+		}
+		log.Printf("fileserver: Initialized signingKey\n")
+		programCert = signingKey.Cert.Raw
+	}
+	taoNameStr := taoName.String()
 
-	// TODO(tmroeder): use the Domain and the tao parent to set up the keys and
-	// the guard. Also need to hook the datalog guard into the domain and get
-	// the basic tests working with this guard, especially execution
-	// authorization.
-	go doServer(serverStop, serverReady, serverDone)
+	FileServerProgramPolicy = &fileServerProgramPolicy
+	FileServerResourceMaster = &fileServerResourceMaster
+	_ = FileServerProgramPolicy.InitProgramPolicy(derPolicyCert, taoNameStr, *signingKey, symKeys, programCert)
 
-	domain, err := tao.LoadDomain(*configPath, nil)
+	server(serverAddr, taoNameStr, derPolicyCert, signingKey, FileServerProgramPolicy, FileServerResourceMaster)
 	if err != nil {
-		fmt.Printf("error: couldn't load the tao domain from %s\n", *configPath)
-		return
+		log.Printf("fileserver: server error\n")
 	}
-	<-serverDone
-	fmt.Printf("Done\n")
+	log.Printf("fileserver: done\n")
 }
diff --git a/apps/fileproxy/fileserver/rebuild b/apps/fileproxy/fileserver/rebuild
new file mode 100755
index 0000000..caaff89
--- /dev/null
+++ b/apps/fileproxy/fileserver/rebuild
@@ -0,0 +1,8 @@
+#
+echo "rebuilding fileproxy"
+cd ..
+go build ...
+cd fileserver
+echo "rebuilding fileserver"
+go build fileserver.go
+echo "done"
diff --git a/apps/fileproxy/fileserver/run b/apps/fileproxy/fileserver/run
new file mode 100755
index 0000000..6602182
--- /dev/null
+++ b/apps/fileproxy/fileserver/run
@@ -0,0 +1,3 @@
+#
+PROG_DIR=/Users/manferdelli/src/github.com/jlmucb/cloudproxy/apps/fileproxy/fileserver
+linux_host -path="../hostdomain/linux_tao_host" -run -- $PROG_DIR/fileserver 
diff --git a/apps/fileproxy/hostdomain/checkprog b/apps/fileproxy/hostdomain/checkprog
new file mode 100755
index 0000000..c5261e2
--- /dev/null
+++ b/apps/fileproxy/hostdomain/checkprog
@@ -0,0 +1,7 @@
+#
+ps aux | fgrep linux_host
+ps aux | fgrep keynegoserver
+ps aux | fgrep fileclient
+ps aux | fgrep fileserver
+ps aux | fgrep rollbackserver
+
diff --git a/apps/fileproxy/hostdomain/inithost b/apps/fileproxy/hostdomain/inithost
new file mode 100755
index 0000000..73a2aea
--- /dev/null
+++ b/apps/fileproxy/hostdomain/inithost
@@ -0,0 +1,10 @@
+#
+export TAO_HOST_DIR=/Users/manferdelli/src/github.com/jlmucb/cloudproxy/apps/fileproxy/hostdomain
+export TAO_ROOTDIR=/Users/manferdelli/src/github.com/jlmucb/cloudproxy
+cd $TAO_HOST_DIR
+mkdir linux_tao_host
+mkdir policy_keys
+export TAO_USE_TPM=no
+export TAO_config_path=$TAO_HOST_DIR/tao.config
+export TAO_guard=AllowAll
+tao_admin -create -name fileproxy -pass nopassword
diff --git a/apps/fileproxy/hostdomain/reinit b/apps/fileproxy/hostdomain/reinit
new file mode 100755
index 0000000..b7086c5
--- /dev/null
+++ b/apps/fileproxy/hostdomain/reinit
@@ -0,0 +1,21 @@
+#
+cd fileclient_files
+rm delegationBlob
+rm sealedsigningKey
+rm sealedsymmetricKey
+rm signerCert
+cd stored_files
+rm originalTestFile.received
+cd ../../fileserver_files
+rm delegationBlob
+rm sealedsigningKey
+rm sealedsymmetricKey
+rm signerCert
+cd stored_files
+rm originalTestFile
+cd ../../rollbackserver_files
+rm delegationBlob
+rm sealedsigningKey
+rm sealedsymmetricKey
+rm signerCert
+
diff --git a/apps/fileproxy/hostdomain/runfc b/apps/fileproxy/hostdomain/runfc
new file mode 100755
index 0000000..4488f93
--- /dev/null
+++ b/apps/fileproxy/hostdomain/runfc
@@ -0,0 +1,3 @@
+#
+PROG_DIR=/Users/manferdelli/src/github.com/jlmucb/cloudproxy/apps/fileproxy/fileclient
+linux_host -path="../hostdomain/linux_tao_host" -run -- $PROG_DIR/fileclient 
diff --git a/apps/fileproxy/hostdomain/runfs b/apps/fileproxy/hostdomain/runfs
new file mode 100755
index 0000000..6602182
--- /dev/null
+++ b/apps/fileproxy/hostdomain/runfs
@@ -0,0 +1,3 @@
+#
+PROG_DIR=/Users/manferdelli/src/github.com/jlmucb/cloudproxy/apps/fileproxy/fileserver
+linux_host -path="../hostdomain/linux_tao_host" -run -- $PROG_DIR/fileserver 
diff --git a/apps/fileproxy/hostdomain/runhost b/apps/fileproxy/hostdomain/runhost
new file mode 100755
index 0000000..66b9202
--- /dev/null
+++ b/apps/fileproxy/hostdomain/runhost
@@ -0,0 +1,6 @@
+#
+export TAO_HOST_DIR=/Users/manferdelli/src/github.com/jlmucb/cloudproxy/apps/fileproxy/hostdomain
+export TAO_ROOTDIR=/Users/manferdelli/src/github.com/jlmucb/cloudproxy
+cd $TAO_HOST_DIR
+linux_host -create -root -pass nopassword
+linux_host -service -root -pass nopassword &
diff --git a/apps/fileproxy/hostdomain/runkns b/apps/fileproxy/hostdomain/runkns
new file mode 100755
index 0000000..d11a440
--- /dev/null
+++ b/apps/fileproxy/hostdomain/runkns
@@ -0,0 +1,3 @@
+#
+PROG_DIR=/Users/manferdelli/src/github.com/jlmucb/cloudproxy/apps/fileproxy/keynegoserver
+linux_host -path="../hostdomain/linux_tao_host" -run -- $PROG_DIR/keynegoserver 
diff --git a/apps/fileproxy/hostdomain/runrb b/apps/fileproxy/hostdomain/runrb
new file mode 100755
index 0000000..de556a4
--- /dev/null
+++ b/apps/fileproxy/hostdomain/runrb
@@ -0,0 +1,3 @@
+#
+PROG_DIR=/Users/manferdelli/src/github.com/jlmucb/cloudproxy/apps/fileproxy/rollbackserver
+linux_host -path="../hostdomain/linux_tao_host" -run -- $PROG_DIR/rollbackserver
diff --git a/apps/fileproxy/keynegoserver/keynegoserver.go b/apps/fileproxy/keynegoserver/keynegoserver.go
index c6f50b7..771b5f1 100644
--- a/apps/fileproxy/keynegoserver/keynegoserver.go
+++ b/apps/fileproxy/keynegoserver/keynegoserver.go
@@ -1,271 +1,292 @@
 // Copyright (c) 2014, Google Inc. All rights reserved.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
 // You may obtain a copy of the License at
 //     http://www.apache.org/licenses/LICENSE-2.0
 // Unless required by applicable law or agreed to in writing, software
 // distributed under the License is distributed on an "AS IS" BASIS,
 // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 // See the License for the specific language governing permissions and
 // limitations under the License.
-// File: keynegoserver.go
 
 package main
 
 import (
+	"crypto/rand"
+	"crypto/tls"
 	"crypto/x509"
 	"crypto/x509/pkix"
-	"io/ioutil"
-	"crypto/tls"
-	"fmt"
-	"os"
 	"errors"
-	// "path"
-	// "time"
 	"flag"
+	"io/ioutil"
+	"log"
+	"math/big"
+	"net"
+	"os"
+	"time"
 
-	// "code.google.com/p/go.crypto/hkdf"
-	// "code.google.com/p/go.crypto/pbkdf2"
 	"code.google.com/p/goprotobuf/proto"
 
-	tao "../../../tao"
+	"github.com/jlmucb/cloudproxy/tao"
+	"github.com/jlmucb/cloudproxy/tao/auth"
 	taonet "github.com/jlmucb/cloudproxy/tao/net"
-	auth "github.com/jlmucb/cloudproxy/tao/auth"
-	util "github.com/jlmucb/cloudproxy/util"
-	"net"
+	"github.com/jlmucb/cloudproxy/util"
 )
 
 var network = flag.String("network", "tcp", "The network to use for connections")
 var addr = flag.String("addr", "localhost:8124", "The address to listen on")
-var domainPass = flag.String("password", "BogusPass", "The domain password for the policy key")
+var domainPass = flag.String("password", "nopassword", "The domain password for the policy key")
 var configPath = flag.String("config", "tao.config", "The Tao domain config")
 
+var SerialNumber int64
 
-// zeroBytes clears the bytes in a slice.
-func zeroBytes(b []byte) {
-	for i := range b {
-		b[i] = 0
-	}
-}
-
-func GetOnDiskPBEKeys(keyTypes tao.KeyType, password []byte, path string, name *pkix.Name) (*tao.Keys, error) {
-	k := &tao.Keys{}
-	//{
-//		tao.keyTypes: keyTypes,
-//		tao.dir:      path,
-	//}
-	k.SetKeysetPath(path)
-	k.SetKeyType(keyTypes)
-	f, err := os.Open(k.PBEKeysetPath())
-	if err == nil {
-		return nil, errors.New("Cant get policy keys\n");
-	}
-	defer f.Close()
-	ks, err := ioutil.ReadAll(f)
-	if err != nil {
-		return nil, err
-	}
-
-	data, err := tao.PBEDecrypt(ks, password)
-	if err != nil {
-		return nil, err
-	}
-	defer zeroBytes(data)
-	var cks tao.CryptoKeyset
-	if err = proto.Unmarshal(data, &cks); err != nil {
-		return nil, err
+func IsAuthenticationValid(name *string) bool {
+	log.Printf("keynegoserver, IsAuthenticationValid name is %s\n", *name)
+	if name == nil {
+		return false
 	}
-	ktemp, err := tao.UnmarshalKeyset(&cks)
-	if err != nil {
-		return nil, err
-	}
-	err = k.LoadCert()
-	if err != nil {
-		return nil, err
-	}
-	k.SigningKey = ktemp.SigningKey
-	k.VerifyingKey = ktemp.VerifyingKey
-	k.CryptingKey = ktemp.CryptingKey
-	k.DerivingKey = ktemp.DerivingKey
-
-	return k, nil
+	log.Printf("keynegoserver, IsAuthenticationValid returning true\n")
+	return true
 }
 
-
-// HandleKeyNegoRequest checks a request from a program and responds with a truncated
-// delegation signed by the policy key.
-func HandleKeyNegoRequest(conn net.Conn, s *tao.Signer, guard tao.Guard) {
-	defer conn.Close()
-
+// First return is terminate flag.
+func KeyNegoRequest(conn net.Conn, policyKey *tao.Keys, guard tao.Guard) (bool, error) {
+	log.Printf("keynegoerver: KeyNegoRequest\n")
 	// Expect an attestation from the client.
 	ms := util.NewMessageStream(conn)
 	var a tao.Attestation
 	if err := ms.ReadMessage(&a); err != nil {
-		fmt.Fprintln(os.Stderr, "Couldn't read attestation from channel:", err)
-		return
+		log.Printf("Couldn't read attestation from channel:", err)
+		log.Printf("\n")
+		return false, err
 	}
 
 	peerCert := conn.(*tls.Conn).ConnectionState().PeerCertificates[0]
-// 	if err := taonet.ValidatePeerAttestation(&a, peerCert, guard); err != nil {
-// 		fmt.Fprintln(os.Stderr, "Couldn't validate peer attestation:", err)
-// 		return
-// 	}
+	if err := taonet.ValidatePeerAttestation(&a, peerCert, guard); err != nil {
+		log.Printf("Couldn't validate peer attestation:", err)
+		return false, err
+	}
 
-  	truncSays, pe, err := taonet.TruncateAttestation(s.ToPrincipal(), &a)
-//	if err != nil {
-//		fmt.Fprintln(os.Stderr, "Couldn't truncate the attestation:", err)
-//		return
-//	}
+	// Sign cert and put it in attestation statement
+	// a consists of serialized statement, sig and SignerInfo
+	// a is a says speaksfor, Delegate of speaksfor is cert and should be DER encoded
 
-	// TODO(tmroeder): fix this to check the time and make sure we're not
-	// signing an unbounded attestation to this program.
-	ra, err := tao.GenerateAttestation(s, nil, truncSays)
+	// Get underlying says
+	// log.Print("keynegoserver, attest: ", a)
+	// log.Print("\n")
+	f, err := auth.UnmarshalForm(a.SerializedStatement)
 	if err != nil {
-		fmt.Fprintln(os.Stderr, "Couldn't attest to the new says statement:", err)
-		return
+		log.Printf("\nkeynegoserver: can't unmarshal a.SerializedStatement\n")
+		return false, err
 	}
-
-	// Add an endorsement to this PrinExt Program hash so the receiver can check
-	// it successfully against policy.
-	endorsement := auth.Says{
-		Speaker: s.ToPrincipal(),
-		Message: auth.Pred{
-			Name: "TrustedProgramHash",
-			Arg:  []auth.Term{auth.PrinTail{Ext: []auth.PrinExt{pe}}},
-		},
+	// log.Print("\nkeynegoserver, unmarshaled serialized: ", f.String())
+	// log.Print("\n")
+
+	var saysStatement *auth.Says
+	if ptr, ok := f.(*auth.Says); ok {
+		saysStatement = ptr
+	} else if val, ok := f.(auth.Says); ok {
+		saysStatement = &val
 	}
-//	if truncSays.Time != nil {
-//		i := *truncSays.Time
-//		endorsement.Time = &i
-//	}
-//	if truncSays.Expiration != nil {
-//		i := *truncSays.Expiration
-//		endorsement.Expiration = &i
-//	}
-	ea, err := tao.GenerateAttestation(s, nil, endorsement)
-	if err != nil {
-		fmt.Fprintln(os.Stderr, "Couldn't generate an endorsement for this program:", err)
-		return
+	sf, ok := saysStatement.Message.(auth.Speaksfor)
+	if ok != true {
+		log.Printf("keynegoserver: says doesnt have speaksfor message\n")
+		return false, err
 	}
-	eab, err := proto.Marshal(ea)
-	if err != nil {
-		fmt.Fprintln(os.Stderr, "Couldn't marshal an endorsement:", err)
-		return
+	// log.Print("keynegoserver, speaksfor: ", sf)
+	// log.Print("\n")
+	kprin, ok := sf.Delegate.(auth.Prin)
+	if ok != true {
+		log.Printf("keynegoserver: speaksfor Delegate is not auth.Prin\n")
+		return false, err
 	}
-	ra.SerializedEndorsements = [][]byte{eab}
-
-	if _, err := ms.WriteMessage(ra); err != nil {
-		fmt.Fprintln(os.Stderr, "Couldn't return the attestation on the channel:", err)
-		return
+	subjectPrin, ok := sf.Delegator.(auth.Prin)
+	if ok != true {
+		log.Printf("keynegoserver: can't get subject principal\n")
+		return false, errors.New("Cant get principal name from verifier")
 	}
-
-	return
-}
-
-// RequestTruncatedAttestation connects to a CA instance, sends the attestation
-// for an X.509 certificate, and gets back a truncated attestation with a new
-// principal name based on the policy key.
-func KeyNegoRequestTruncatedAttestation(network, addr string, keys *tao.Keys, v *tao.Verifier) (*tao.Attestation, error) {
-	if keys.Cert == nil {
-		return nil, fmt.Errorf("client: can't dial with an empty client certificate\n")
+	subjectnamestr := subjectPrin.String()
+	verified := IsAuthenticationValid(&subjectnamestr)
+	if !verified {
+		log.Printf("keynegoserver: name verification failed\n")
+		return false, err
+	}
+	log.Printf("keynegoserver, IsAuthenticationValid succeeded: subject principal name: %s\n", subjectnamestr)
+	details := tao.X509Details{
+		Country:            "US",
+		Organization:       "Google",
+		OrganizationalUnit: subjectnamestr,
+		CommonName:         "localhost"}
+	subjectname := tao.NewX509Name(details)
+	SerialNumber = SerialNumber + 1
+	template := &x509.Certificate{
+		SignatureAlgorithm: x509.ECDSAWithSHA256,
+		PublicKeyAlgorithm: x509.ECDSA,
+		Version:            2,
+		SerialNumber:       new(big.Int).SetInt64(SerialNumber),
+		Subject:            *subjectname,
+		NotBefore:          time.Now(),
+		NotAfter:           time.Now().AddDate(1 /* years */, 0 /* months */, 0 /* days */),
+		KeyUsage:           x509.KeyUsageKeyAgreement,
+		ExtKeyUsage:        []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth, x509.ExtKeyUsageClientAuth},
 	}
-	tlsCert, err := taonet.EncodeTLSCert(keys)
+	verifier, err := tao.FromPrincipal(kprin)
 	if err != nil {
-		return nil, err
+		return false, errors.New("can't get principal from kprin")
 	}
-	conn, err := tls.Dial(network, addr, &tls.Config{
-		RootCAs:            x509.NewCertPool(),
-		Certificates:       []tls.Certificate{*tlsCert},
-		InsecureSkipVerify: true,
-	})
+	clientDerCert, err := x509.CreateCertificate(rand.Reader, template, policyKey.Cert,
+		verifier.GetVerifierEc(),
+		policyKey.SigningKey.GetSignerEc())
 	if err != nil {
-		return nil, err
+		log.Printf("keynegoserver: can't create client certificate: %s\n", err)
+		return false, err
 	}
-	defer conn.Close()
-
-	// Tao handshake: send client delegation.
-	ms := util.NewMessageStream(conn)
-	if _, err = ms.WriteMessage(keys.Delegation); err != nil {
-		return nil, err
+	err = ioutil.WriteFile("ClientCert", clientDerCert, os.ModePerm)
+
+	nowTime := time.Now().UnixNano()
+	expireTime := time.Now().AddDate(1, 0, 0).UnixNano()
+	// Replace self signed cert in attest request
+	newspeaksFor := &auth.Speaksfor{
+		Delegate:  auth.Bytes(clientDerCert),
+		Delegator: sf.Delegator}
+	keynegoSays := &auth.Says{
+		Speaker:    policyKey.SigningKey.ToPrincipal(),
+		Time:       &nowTime,
+		Expiration: &expireTime,
+		Message:    newspeaksFor}
+
+	delegator, ok := sf.Delegator.(auth.Prin)
+	if !ok {
+		log.Printf("keynegoserver: the delegator must be a principal")
+		return false, err
 	}
-
-	// Read the truncated attestation and check it.
-	var a tao.Attestation
-	if err := ms.ReadMessage(&a); err != nil {
-		return nil, err
+	var prog auth.PrinExt
+	found := false
+	for _, sprin := range delegator.Ext {
+		if !found && (sprin.Name == "Program") {
+			found = true
+			prog = sprin
+		}
+		if found {
+			kprin.Ext = append(kprin.Ext, sprin)
+		}
 	}
-
-	truncStmt, err := auth.UnmarshalForm(a.SerializedStatement)
+	ra, err := tao.GenerateAttestation(policyKey.SigningKey, nil, *keynegoSays)
 	if err != nil {
-		return nil, err
+		log.Printf("Couldn't attest to the new says statement:", err)
+		return false, err
 	}
 
-	says, _, err := taonet.TruncateAttestation(v.ToPrincipal(), keys.Delegation)
-	if err != nil {
-		return nil, err
+	// Add an endorsement to this PrinExt Program hash so the receiver can check
+	// it successfully against policy.
+	endorsement := auth.Says{
+		Speaker: policyKey.SigningKey.ToPrincipal(),
+		Message: auth.Pred{
+			Name: "TrustedProgramHash",
+			Arg:  []auth.Term{auth.PrinTail{Ext: []auth.PrinExt{prog}}},
+		},
 	}
-
-	if !taonet.IdenticalDelegations(says, truncStmt) {
-		return nil, fmt.Errorf("the statement returned by the TaoCA was different than what we expected")
+	if keynegoSays.Time != nil {
+		i := *keynegoSays.Time
+		endorsement.Time = &i
 	}
-
-	ok, err := v.Verify(a.SerializedStatement, tao.AttestationSigningContext, a.Signature)
+	if keynegoSays.Expiration != nil {
+		i := *keynegoSays.Expiration
+		endorsement.Expiration = &i
+	}
+	ea, err := tao.GenerateAttestation(policyKey.SigningKey, nil, endorsement)
 	if err != nil {
-		return nil, err
+		log.Printf("Couldn't generate an endorsement for this program:", err)
+		return false, err
 	}
-	if !ok {
-		return nil, fmt.Errorf("invalid attestation signature from Tao CA")
+	eab, err := proto.Marshal(ea)
+	if err != nil {
+		log.Printf("Couldn't marshal an endorsement:", err)
+		return false, err
 	}
+	ra.SerializedEndorsements = [][]byte{eab}
 
-	return &a, nil
+	if _, err := ms.WriteMessage(ra); err != nil {
+		log.Printf("Couldn't return the attestation on the channel:", err)
+		log.Printf("\n")
+		return false, err
+	}
+
+	return false, nil
 }
 
 func main() {
 	flag.Parse()
 	domain, err := tao.LoadDomain(*configPath, []byte(*domainPass))
-	if err != nil {
-		fmt.Fprintf(os.Stderr, "Couldn't load the config path %s: %s\n", *configPath, err)
+	if domain == nil {
+		log.Printf("keynegoserver: no domain\n")
+		return
+	} else if err != nil {
+		log.Printf("keynegoserver: Couldn't load the config path %s: %s\n", *configPath, err)
 		return
 	}
 
 	// Set up temporary keys for the connection, since the only thing that
 	// matters to the remote client is that they receive a correctly-signed new
 	// attestation from the policy key.
+	// JLM:  I left this in place but I'm not sure what a TLS connection with a
+	//   self signed Cert buys in terms of security.  The security of this protocol should
+	//   not depend on the confidentiality or intergity of the channel.  All that said,
+	//   if we do ever distribute a signed keynegoserver cert for this TLS channel, it would
+	//   be good.
 	keys, err := tao.NewTemporaryKeys(tao.Signing)
-	if err != nil {
-		fmt.Fprintln(os.Stderr, "Couldn't set up temporary keys for the connection:", err)
+	if keys == nil || err != nil {
+		log.Printf("keynegoserver: Couldn't set up temporary keys for the connection:", err)
 		return
 	}
 	keys.Cert, err = keys.SigningKey.CreateSelfSignedX509(&pkix.Name{
 		Organization: []string{"Google Tao Demo"}})
 	if err != nil {
-		fmt.Fprintln(os.Stderr, "Couldn't set up a self-signed cert:", err)
+		log.Printf("keynegoserver: Couldn't set up a self-signed cert:", err)
 		return
 	}
+	SerialNumber = int64(time.Now().UnixNano()) / (1000000)
+	policyKey, err := tao.NewOnDiskPBEKeys(tao.Signing, []byte(*domainPass), "policy_keys", nil)
+	if err != nil {
+		log.Printf("keynegoserver: Couldn't get policy key\n", err)
+		return
+	}
+	log.Printf("Policy key %x\n: ", policyKey)
 
 	tlsc, err := taonet.EncodeTLSCert(keys)
 	if err != nil {
-		fmt.Fprintln(os.Stderr, "Couldn't encode a TLS cert:", err)
+		log.Printf("keynegoserver: Couldn't encode a TLS cert:", err)
 		return
 	}
 	conf := &tls.Config{
 		RootCAs:            x509.NewCertPool(),
 		Certificates:       []tls.Certificate{*tlsc},
 		InsecureSkipVerify: true,
 		ClientAuth:         tls.RequireAnyClientCert,
 	}
 	sock, err := tls.Listen(*network, *addr, conf)
+	if err != nil {
+		log.Printf("keynegoserver: error: %s\n", err)
+	}
+	if sock == nil {
+		log.Printf("keynegoserver: Empty socket, terminating\n")
+		return
+	}
+	defer sock.Close()
 
-	fmt.Println("KeyNegoServer: accepting connections")
+	log.Printf("keynegoserver: accepting connections\n")
 	for {
 		conn, err := sock.Accept()
-		if err != nil {
-			fmt.Fprintf(os.Stderr, "Couldn't accept a connection on %s: %s\n", *addr, err)
+		if conn == nil {
+			log.Printf("keynegoserver: Empty connection\n")
+			return
+		} else if err != nil {
+			log.Printf("keynegoserver: Couldn't accept a connection on %s: %s\n", *addr, err)
 			return
 		}
-
-		go HandleKeyNegoRequest(conn, domain.Keys.SigningKey, domain.Guard)
+		log.Printf("keynegoserver: calling RequestLoop\n")
+		go KeyNegoRequest(conn, policyKey, domain.Guard)
 	}
-	// zeroKeyset(&cks)
+	log.Printf("keynegoserver: finishing\n")
 }
diff --git a/apps/fileproxy/keynegoserver/rebuild b/apps/fileproxy/keynegoserver/rebuild
new file mode 100755
index 0000000..561d2d0
--- /dev/null
+++ b/apps/fileproxy/keynegoserver/rebuild
@@ -0,0 +1,8 @@
+#
+echo "rebuilding fileproxy"
+cd ..
+go build ...
+cd keynegoserver
+echo "rebuilding keynegoserver"
+go build keynegoserver.go
+echo "done"
diff --git a/apps/fileproxy/rollbackhandler.go b/apps/fileproxy/rollbackhandler.go
new file mode 100644
index 0000000..bb47b1d
--- /dev/null
+++ b/apps/fileproxy/rollbackhandler.go
@@ -0,0 +1,338 @@
+// Copyright (c) 2014, Google Corporation.  All rights reserved.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//     http://www.apache.org/licenses/LICENSE-2.0
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// File: rollbackhandler.go
+
+package fileproxy
+
+import (
+	"crypto/sha256"
+	"encoding/binary"
+	"errors"
+	"log"
+
+	"code.google.com/p/goprotobuf/proto"
+
+	"github.com/jlmucb/cloudproxy/util"
+)
+
+type NameandHash struct {
+	ItemName string
+	Hash     []byte
+}
+
+type RollbackProgramInfo struct {
+	MasterInfoSaveFile string
+	HashSaveFile       string
+	ProgramName        string
+	MonotonicCounter   int64
+	Initialized        bool
+	NameandHashArray   []NameandHash
#*
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-11-13T10:32:29-0800
#*
#- Go naming conventions require "and" to be "And" here and above.
#-
+}
+
+type RollbackMaster struct {
#*
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-11-13T10:32:11-0800
#*
#- Exported types and functions need comments.
#-
+	ProgramName string
+	Initialized bool
+	ProgramInfo []RollbackProgramInfo
+}
+
+func (r *RollbackMaster) FindRollbackProgramTable(programName string) *RollbackProgramInfo {
+	for i := range r.ProgramInfo {
+		if r.ProgramInfo[i].ProgramName == programName {
+			return &r.ProgramInfo[i]
+		}
+	}
+	return nil
+}
+
+func (r *RollbackMaster) AddRollbackProgramTable(programName string) *RollbackProgramInfo {
+	log.Printf("AddRollbackProgramTable: %s\n", programName)
+	pi := r.FindRollbackProgramTable(programName)
+	if pi != nil {
+		return pi
+	}
+	if len(r.ProgramInfo) >= cap(r.ProgramInfo) {
#*
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-11-13T10:33:03-0800
#*
#- Use builtin append() function.
#-
+		t := make([]RollbackProgramInfo, 2*cap(r.ProgramInfo))
+		copy(t, r.ProgramInfo)
+		r.ProgramInfo = t
+	}
+	r.ProgramInfo = r.ProgramInfo[0 : len(r.ProgramInfo)+1]
+	log.Printf("len(r.ProgramInfo)= %d, cap(r.ProgramInfo)= %d\n", len(r.ProgramInfo), cap(r.ProgramInfo))
+	pi = &r.ProgramInfo[len(r.ProgramInfo)-1]
+	pi.ProgramName = programName
+	pi.MonotonicCounter = 3
#*
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-11-13T10:33:22-0800
#*
#- Why 3?
#-
+	pi.NameandHashArray = make([]NameandHash, 100)
+	pi.NameandHashArray = pi.NameandHashArray[0:0]
#*
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-11-13T10:34:18-0800
#*
#- Why?
#-
+	log.Printf("len(pi.pi.NameandHashArray)= %d, cap(pi.pi.NameandHashArray)= %d\n", len(pi.NameandHashArray), cap(pi.NameandHashArray))
+	pi.Initialized = true
+	return pi
+}
+
+func (r *RollbackMaster) ReadMasterRollbackInfo(masterFile string, hashFile string) bool {
+	return false
#*
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-11-13T10:34:31-0800
#*
#- Use errors instead of bool to return error conditions like "not implemented"
#-
+}
+
+func (r *RollbackMaster) SaveMasterRollbackInfo(masterFile string, hashFile string) bool {
+	return false
+}
+
+func (pi *RollbackProgramInfo) ReadProgramRollbackInfo(programName string, masterFile string, hashFile string) bool {
+	return false
+}
+
+func (pi *RollbackProgramInfo) SaveProgramRollbackInfo(programName string, masterFile string, hashFile string) bool {
+	return false
+}
+
+func (pi *RollbackProgramInfo) FindRollbackHashEntry(itemName string) *NameandHash {
+	for i := range pi.NameandHashArray {
#*
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-11-13T10:34:59-0800
#*
#- Use a map instead of an array for this. Then you get lookup.
#-
+		log.Printf("FindRollbackHashEntry %s %s\n", itemName, pi.NameandHashArray[i].ItemName)
+		if pi.NameandHashArray[i].ItemName == itemName {
+			return &pi.NameandHashArray[i]
+		}
+	}
+	return nil
+}
+
+func (pi *RollbackProgramInfo) AddHashEntry(itemName string, hash []byte) *NameandHash {
+	log.Printf("AddHashEntry %s\n", itemName)
+	he := pi.FindRollbackHashEntry(itemName)
+	if he != nil {
+		he.Hash = hash
+		return he
+	}
+	if len(pi.NameandHashArray) >= cap(pi.NameandHashArray) {
+		t := make([]NameandHash, 2*cap(pi.NameandHashArray))
+		copy(t, pi.NameandHashArray)
+		pi.NameandHashArray = t
+	}
+	pi.NameandHashArray = pi.NameandHashArray[0 : len(pi.NameandHashArray)+1]
+	he = &pi.NameandHashArray[len(pi.NameandHashArray)-1]
+	he.ItemName = itemName
+	he.Hash = hash
+	log.Printf("item: %s, hash %x\n", itemName, hash)
+	return he
+}
+
+func (r *RollbackMaster) InitRollbackMaster(masterprogramName string) bool {
+	log.Printf("InitRollbackMaster\n")
+	r.Initialized = true
+	r.ProgramName = masterprogramName
+	r.ProgramInfo = make([]RollbackProgramInfo, 100)
+	r.ProgramInfo = r.ProgramInfo[0:0]
+	log.Printf("len(r.ProgramInfo)= %d, cap(r.ProgramInfo)= %d\n", len(r.ProgramInfo), cap(r.ProgramInfo))
+	// read master
+	// decrypt
+	// update
+
+	// read hash table
+	// decrypt
+	// update
+	return true
+}
+
+func (r *RollbackMaster) SetRollbackCounter(ms *util.MessageStream, programName string, counter int64) bool {
+	pi := r.FindRollbackProgramTable(programName)
+	if pi == nil {
+		log.Printf("SetRollbackCounter: program has no program info table 1")
+		SendResponse(ms, "failed", "Rollback doesn't exist", 0)
+		return false
+	}
+	if pi.MonotonicCounter > counter {
+		log.Printf("SetRollbackCounter: can't set counter backwards")
+		SendResponse(ms, "failed", "Rollback counter can't decrease", 0)
+		return false
+	}
+	pi.MonotonicCounter = counter
+	log.Printf("SetRollbackCounter (%s) table counter: %d\n", pi.ProgramName, pi.MonotonicCounter)
+	SendResponse(ms, "succeeded", "", 0)
+	return true
+}
+
+func (r *RollbackMaster) SetRollbackResourceHash(ms *util.MessageStream, programName string, itemName string) bool {
+	pi := r.FindRollbackProgramTable(programName)
+	if pi == nil {
+		log.Printf("SetRollbackResourceHash: program has no program info table 2")
+		SendResponse(ms, "failed", "Rollback doesn't exist", 0)
+		return false
+	}
+	SendResponse(ms, "succeeded", "", 0)
+	// get hash
+	hash, err := GetProtocolMessage(ms)
+	if err != nil {
+		log.Printf("SetRollbackResourceHash: GetProtocolMessage failed\n")
+		SendResponse(ms, "failed", "Rollback doesn't exist", 0)
+		return false
+	}
+	hi := pi.FindRollbackHashEntry(itemName)
+	if hi == nil {
+		hi = pi.AddHashEntry(itemName, hash)
+		if hi == nil {
+			log.Printf("SetRollbackResourceHash: no hash entry\n")
+			SendResponse(ms, "failed", "can't insert entry", 0)
+			return false
+		}
+	} else {
+		log.Printf("SetRollbackResourceHash, found %s entry\n", hi.ItemName)
+		hi.Hash = hash
+	}
+	return true
+}
+
+func (r *RollbackMaster) GetRollbackCounter(ms *util.MessageStream, programName string) bool {
+	pi := r.FindRollbackProgramTable(programName)
+	if pi == nil {
+		log.Printf("GetRollbackCounter: program has no program info table\n")
+		SendResponse(ms, "failed", "Rollback doesn't exist", 0)
+		return false
+	}
+	log.Printf("GetRollbackCounter(%s), counter: %d\n", pi.ProgramName, pi.MonotonicCounter)
+	SendCounterResponse(ms, "succeeded", "", pi.MonotonicCounter)
+	return true
+}
+
+func (r *RollbackMaster) GetRollbackHashedVerifier(ms *util.MessageStream, programName string, itemName string) bool {
+	log.Printf("GetRollbackHashedVerifier\n")
+	pi := r.FindRollbackProgramTable(programName)
+	if pi == nil {
+		log.Printf("GetRollbackHashedVerifier: program has no program info table")
+		SendResponse(ms, "failed", "Rollback doesn't exist", 0)
+		return false
+	}
+	hi := pi.FindRollbackHashEntry(itemName)
+	if hi == nil {
+		log.Printf("GetRollbackResourceHash: program has no hash entry for %s\n", itemName)
+		SendResponse(ms, "failed", "can't insert entry", 0)
+		return false
+	}
+	// now has the epoch and the hash and return thatkk
+	sha256Hash := sha256.New()
+	b := make([]byte, 8)
+	binary.PutVarint(b, pi.MonotonicCounter)
#*
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-11-13T10:36:05-0800
#*
#- Don't use a variable-length integer if you're going to insist on 8 bytes.
#-
+	sha256Hash.Write(b)
+	sha256Hash.Write(hi.Hash)
+	sha256Hash.Write(b)
+	hash := sha256Hash.Sum(nil)
+	SendResponse(ms, "succeeded", "", 0)
+	SendProtocolMessage(ms, len(hash), hash)
+	return true
+}
+
+// Update hash for resouce named resource
+func ClientSetRollbackCounter(ms *util.MessageStream, counter int64) bool {
#*
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-11-13T10:38:04-0800
#*
#- Are negative counters valid? If not, then use uint64.
#-
+	SendCounterRequest(ms, counter)
+	status, _, _, err := GetResponse(ms)
+	if err != nil || status == nil || *status != "succeeded" {
+		return false
+	}
+	return true
+}
+
+func ClientSetResourceHashRequest(ms *util.MessageStream, clientProgramName string, item string, hash []byte) bool {
+	log.Printf("ClientSetResourceHashRequest %s, %s\n", clientProgramName, item)
+	action := "setrollbackhash"
+	SendRequest(ms, nil, &action, &item, nil)
+	status, _, _, err := GetResponse(ms)
+	if err != nil || status == nil || *status != "succeeded" {
+		log.Printf("ClientSetResourceHashRequest failed\n")
+		return false
+	}
+	err = SendProtocolMessage(ms, len(hash), hash)
+	return true
+}
+
+func ClientGetRollbackCounter(ms *util.MessageStream, clientProgramName string) (bool, int64) {
+	log.Printf("ClientGetRollbackCounter%s, %s\n", clientProgramName)
+	action := "getrollbackcounter"
+	SendRequest(ms, &clientProgramName, &action, nil, nil)
+	status, _, counter, err := GetCounterResponse(ms)
+	if err != nil || status == nil || *status != "succeeded" || counter == nil {
+		if err != nil {
+			log.Printf("ClientGetRollbackCounter, err is not nil\n")
+		}
+		if status == nil {
+			log.Printf("ClientGetRollbackCounter, status is nil\n")
+		}
+		log.Printf("ClientGetRollbackCounter: %s\n", *status)
+		if counter == nil {
+			log.Printf("ClientGetRollbackCounter, counter is nil\n")
+		}
+		return false, 0
+	}
+	return true, *counter
+}
+
+func ClientGetRollbackHashedVerifierRequest(ms *util.MessageStream, clientProgramName string, item string) (bool, []byte) {
+	log.Printf("ClientGetRollbackHashedVerifierRequest: %s, %s\n", clientProgramName, item)
+	action := "getrollbackcounterverifier"
+	SendRequest(ms, nil, &action, &item, nil)
+	status, _, _, err := GetResponse(ms)
+	if status == nil || *status != "succeeded" || err != nil {
+		return false, nil
+	}
+	hash, err := GetProtocolMessage(ms)
+	return true, hash
+}
+
+// First return value is terminate flag
+func (r *RollbackMaster) HandleServiceRequest(ms *util.MessageStream, programPolicyObject *ProgramPolicy, clientProgramName string, request []byte) (bool, error) {
+	log.Printf("rollbackhandler: HandleServiceRequest for %s\n", clientProgramName)
+
+	fpMessage := new(FPMessage)
+	err := proto.Unmarshal(request, fpMessage)
+	if err != nil {
+		return false, errors.New("HandleService can't unmarshal request")
+	}
+	if fpMessage.MessageType == nil {
+		return false, errors.New("HandleService: no message type")
+	}
+	switch MessageType(*fpMessage.MessageType) {
+	case MessageType_REQUEST:
+	default:
+		return false, errors.New("HandleService does not get MessageType_REQUEST")
+	}
+	action := fpMessage.ActionName
+	if action == nil {
+		SendResponse(ms, "failed", "", 0)
+		return false, errors.New("no action")
+	}
+
+	switch *action {
+	case "setrollbackcounter":
#*
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-11-13T10:37:14-0800
#*
#- This needs either separators or capitalization to be readable. Same comment
#- for the other string constants.
#-
+		if fpMessage.MonotonicCounter == nil {
+			log.Printf("HandleServiceRequest: no counter in setrollbackcounter message")
+			SendResponse(ms, "failed", "no counter", 0)
+		}
+		_ = r.SetRollbackCounter(ms, clientProgramName, *fpMessage.MonotonicCounter)
+		return false, nil
+	case "getrollbackcounter":
+		_ = r.GetRollbackCounter(ms, clientProgramName)
+		return false, nil
+	case "setrollbackhash":
+		if fpMessage.ResourceName == nil {
+			log.Printf("HandleServiceRequest: no resource name in setrollbackhash message")
+			SendResponse(ms, "failed", "no counter", 0)
+		}
+		_ = r.SetRollbackResourceHash(ms, clientProgramName, *fpMessage.ResourceName)
+		return false, nil
+	case "getrollbackcounterverifier":
+		if fpMessage.ResourceName == nil {
+			log.Printf("HandleServiceRequest: no resource name in getrollbackcounterverifier message")
+			SendResponse(ms, "failed", "no counter", 0)
+		}
+		r.GetRollbackHashedVerifier(ms, clientProgramName, *fpMessage.ResourceName)
+		return false, nil
+	default:
+		SendResponse(ms, "failed", "", 0)
+		return false, errors.New("unsupported action")
+	}
+}
diff --git a/apps/fileproxy/rollbackserver/rebuild b/apps/fileproxy/rollbackserver/rebuild
new file mode 100755
index 0000000..928d2a7
--- /dev/null
+++ b/apps/fileproxy/rollbackserver/rebuild
@@ -0,0 +1,8 @@
+#
+echo "rebuilding rollbackproxy"
+cd ..
+go build ...
+cd rollbackserver
+echo "rebuilding rollbackserver"
+go build rollbackserver.go
+echo "done"
diff --git a/apps/fileproxy/rollbackserver/rollbackserver.go b/apps/fileproxy/rollbackserver/rollbackserver.go
new file mode 100644
index 0000000..70deb11
--- /dev/null
+++ b/apps/fileproxy/rollbackserver/rollbackserver.go
@@ -0,0 +1,238 @@
+// Copyright (c) 2014, Google Corporation.  All rights reserved.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//     http://www.apache.org/licenses/LICENSE-2.0
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// File: rollbackserver.go
+
+package main
+
+import (
+	"crypto/sha256"
+	"crypto/tls"
+	"crypto/x509"
+	"encoding/hex"
+	"flag"
+	"log"
+	"net"
+
+	"github.com/jlmucb/cloudproxy/apps/fileproxy"
+	tao "github.com/jlmucb/cloudproxy/tao"
+	"github.com/jlmucb/cloudproxy/tao/auth"
+	taonet "github.com/jlmucb/cloudproxy/tao/net"
+	"github.com/jlmucb/cloudproxy/util"
+)
+
+var hostcfg = flag.String("../hostdomain/tao.config", "../hostdomain/tao.config", "path to host tao configuration")
+var serverHost = flag.String("host", "localhost", "address for client/server")
+var serverPort = flag.String("port", "8129", "port for client/server")
+var rollbackserverPath = flag.String("rollbackserver_files/", "rollbackserver_files/", "rollbackserver directory")
+var serverAddr string
+
+var DerPolicyCert []byte
+var SigningKey tao.Keys
+var SymKeys []byte
+var ProgramCert []byte
+
+func clientServiceThead(ms *util.MessageStream, clientName string, rollbackPolicy *fileproxy.ProgramPolicy, rollbackMasterTable *fileproxy.RollbackMaster) {
+	log.Printf("rollbackserver: clientServiceThead\n")
+	pi := rollbackMasterTable.AddRollbackProgramTable(clientName)
+	if pi == nil {
+		log.Printf("rollbackserver cannot rollbackMasterTable.AddRollbackProgramTable\n")
+		return
+	}
+	// How do I know if the connection terminates?
#*
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-11-13T10:38:28-0800
#*
#- Look at MessageStream; it gives you errors on connection termination.
#-
+	for {
+		log.Printf("clientServiceThead: ReadString\n")
+		strbytes, err := ms.ReadString()
+		if err != nil {
+			return
+		}
+		terminate, err := rollbackMasterTable.HandleServiceRequest(ms, rollbackPolicy, clientName, []byte(strbytes))
#*
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-11-13T10:38:50-0800
#*
#- Maybe do this in a go routine so it can handle more than one simultaneous
#- connection? Then you need to add locking using the sync package, probably
#- just with a simple sync.RWMutex (Reader/Writer lock).
#-
+		if terminate {
+			break
+		}
+	}
+	log.Printf("fileserver: client thread terminating\n")
+}
+
+func server(serverAddr string, prin string, rollbackPolicy *fileproxy.ProgramPolicy, rollbackMasterTable *fileproxy.RollbackMaster) {
+	var sock net.Listener
+	log.Printf("fileserver: server\n")
+
+	policyCert, err := x509.ParseCertificate(DerPolicyCert)
+	if err != nil {
+		log.Printf("fileserver: can't ParseCertificate\n")
+		return
+	}
+	pool := x509.NewCertPool()
+	pool.AddCert(policyCert)
+	tlsc, err := taonet.EncodeTLSCert(&SigningKey)
+	if err != nil {
+		log.Printf("fileserver, encode error: ", err)
+		log.Printf("\n")
+		return
+	}
+	conf := &tls.Config{
+		RootCAs:            pool,
+		Certificates:       []tls.Certificate{*tlsc},
+		InsecureSkipVerify: false,
+		ClientAuth:         tls.RequireAnyClientCert,
+	}
+	log.Printf("Listenting\n")
+	sock, err = tls.Listen("tcp", serverAddr, conf)
+	if err != nil {
+		log.Printf("rollbackserver, listen error: ", err)
+		log.Printf("\n")
+		return
+	}
+	for {
#*
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-11-13T10:39:54-0800
#*
#- There's a lot of duplication here. Can this be encapsulated and put into
#- github.com/jlmucb/cloudproxy/tao/net?
#-
+		log.Printf("rollbackserver: at Accept\n")
+		conn, err := sock.Accept()
+		if err != nil {
+			log.Printf("rollbackserver: can't accept connection: %s\n", err.Error())
+		}
+		var clientName string
+		clientName = "XYZZY"
+		err = conn.(*tls.Conn).Handshake()
+		if err != nil {
+			log.Printf("TLS handshake failed\n")
+		}
+		peerCerts := conn.(*tls.Conn).ConnectionState().PeerCertificates
+		if peerCerts == nil {
+			log.Printf("rollbackserver: can't get peer list\n")
+		} else {
+			peerCert := conn.(*tls.Conn).ConnectionState().PeerCertificates[0]
+			if peerCert.Raw == nil {
+				log.Printf("rollbackserver: can't get peer name\n")
+			} else {
+				if peerCert.Subject.OrganizationalUnit != nil {
+					clientName = peerCert.Subject.OrganizationalUnit[0]
+				}
+			}
+		}
+		log.Printf("rollbackserver, peer name: %s\n", clientName)
+		ms := util.NewMessageStream(conn)
+		go clientServiceThead(ms, clientName, rollbackPolicy, rollbackMasterTable)
+	}
+}
+
+func main() {
+	log.Printf("rollback server\n")
+
+	var rollbackMaster fileproxy.RollbackMaster
+	var RollbackMaster *fileproxy.RollbackMaster
#*
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-11-13T10:40:30-0800
#*
#- Following Go naming conventions requires not having variables that start with
#- a capital letter like this.
#-
+	var rollbackProgramPolicyObject fileproxy.ProgramPolicy
+	var RollbackProgramPolicyObject *fileproxy.ProgramPolicy
+	RollbackMaster = &rollbackMaster
+	RollbackProgramPolicyObject = &rollbackProgramPolicyObject
+
+	flag.Parse()
+	serverAddr = *serverHost + ":" + *serverPort
+
+	hostDomain, err := tao.LoadDomain(*hostcfg, nil)
+	if err != nil {
+		return
+	}
+	log.Printf("rollbackserver: Domain name: %s\n", hostDomain.ConfigPath)
+	DerPolicyCert = nil
+	if hostDomain.Keys.Cert != nil {
+		DerPolicyCert = hostDomain.Keys.Cert.Raw
+	}
+	if DerPolicyCert == nil {
+		log.Printf("rollbackserver: can't retrieve policy cert\n")
+		return
+	}
+
+	/*
+	 Replace with: hostDomai.ExtendTaoDomain(tao)
+	*/
+	sha256Hash := sha256.New()
+	sha256Hash.Write(DerPolicyCert)
+	policyCertHash := sha256Hash.Sum(nil)
+	hexCertHash := hex.EncodeToString(policyCertHash)
+	e := auth.PrinExt{Name: hexCertHash}
+	err = tao.Parent().ExtendTaoName(auth.SubPrin{e})
+	if err != nil {
+		return
+	}
+
+	e = auth.PrinExt{Name: "rollbackserver_version_1"}
+	err = tao.Parent().ExtendTaoName(auth.SubPrin{e})
+	if err != nil {
+		log.Printf("rollbackserver: can't get tao name\n")
+		return
+	}
+
+	taoName, err := tao.Parent().GetTaoName()
+	if err != nil {
+		return
+	}
+	log.Printf("rollbackserver: my name is %s\n", taoName)
+
+	sealedSymmetricKey, sealedSigningKey, derCert, delegation, err := fileproxy.LoadProgramKeys(*rollbackserverPath)
+	if err != nil {
+		log.Printf("rollbackserver: can't retrieve key material\n")
+	}
+	if sealedSymmetricKey == nil || sealedSigningKey == nil || delegation == nil || derCert == nil {
+		log.Printf("rollbackserver: No key material present\n")
+	}
+	ProgramCert = derCert
+
+	defer fileproxy.ZeroBytes(SymKeys)
+	if sealedSymmetricKey != nil {
+		symkeys, policy, err := tao.Parent().Unseal(sealedSymmetricKey)
+		if err != nil {
+			return
+		}
+		if policy != tao.SealPolicyDefault {
+			log.Printf("rollbackserver: unexpected policy on unseal\n")
+		}
+		SymKeys = symkeys
+		log.Printf("rollbackserver: Unsealed symKeys: % x\n", SymKeys)
+	} else {
+		symkeys, err := fileproxy.InitializeSealedSymmetricKeys(*rollbackserverPath, tao.Parent(), fileproxy.SizeofSymmetricKeys)
+		if err != nil {
+			log.Printf("rollbackserver: InitializeSealedSymmetricKeys error: %s\n", err)
+		}
+		SymKeys = symkeys
+		log.Printf("rollbackserver: InitilizedsymKeys: % x\n", SymKeys)
+	}
+
+	if sealedSigningKey != nil {
+		log.Printf("rollbackserver: retrieving signing key\n")
+		signingkey, err := fileproxy.SigningKeyFromBlob(tao.Parent(),
+			sealedSigningKey, derCert, delegation)
+		if err != nil {
+			log.Printf("rollbackserver: SigningKeyFromBlob error: %s\n", err)
+		}
+		SigningKey = *signingkey
+		log.Printf("rollbackserver: Retrieved Signing key: % x\n", SigningKey)
+	} else {
+		log.Printf("rollbackserver: initializing signing key\n")
+		signingkey, err := fileproxy.InitializeSealedSigningKey(*rollbackserverPath,
+			tao.Parent(), *hostDomain)
+		if err != nil {
+			log.Printf("rollbackserver: InitializeSealedSigningKey error: %s\n", err)
+		}
+		SigningKey = *signingkey
+		log.Printf("rollbackserver: Initialized signingKey\n")
+		ProgramCert = SigningKey.Cert.Raw
+	}
+	taoNameStr := taoName.String()
+	_ = RollbackProgramPolicyObject.InitProgramPolicy(DerPolicyCert, taoNameStr, SigningKey, SymKeys, ProgramCert)
+	RollbackMaster.InitRollbackMaster(taoNameStr)
+
+	server(serverAddr, taoNameStr, RollbackProgramPolicyObject, RollbackMaster)
+	if err != nil {
+		log.Printf("rollbackserver: server error\n")
+	}
+	log.Printf("rollbackserver: done\n")
+}
diff --git a/apps/tao_admin/main.go b/apps/tao_admin/main.go
index 7c89844..96eb492 100644
--- a/apps/tao_admin/main.go
+++ b/apps/tao_admin/main.go
@@ -7,63 +7,77 @@
 //     http://www.apache.org/licenses/LICENSE-2.0
 //
 // Unless required by applicable law or agreed to in writing, software
 // distributed under the License is distributed on an "AS IS" BASIS,
 // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
 package main
 
 import (
 	"crypto/sha256"
 	"crypto/x509"
 	"flag"
 	"fmt"
 	"io"
 	"io/ioutil"
 	"log"
 	"os"
 	"path"
-
+	"time"
+	"math/big"
+	"crypto/rand"
+	"code.google.com/p/goprotobuf/proto"
 	"github.com/google/go-tpm/tpm"
 	"github.com/jlmucb/cloudproxy/tao"
 	"github.com/jlmucb/cloudproxy/tao/auth"
 	"github.com/jlmucb/cloudproxy/util"
 )
 
 // common options
 var configPath = flag.String("config_path", "tao.config", "Location of tao domain configuration.")
 var pass = flag.String("pass", "", "Password for unlocking policy private key.")
 var quiet = flag.Bool("quiet", false, "Be more quiet.")
 var show = flag.Bool("show", false, "Show info when done.")
 var host = flag.String("host", "", "The principal name of the host where programs will execute.")
 
 // initializing a new domain
 var create = flag.Bool("create", false, "Create a new domain configuration.")
 var name = flag.String("name", "", "Name for a new configuration.")
 var guard = flag.String("guard", "TrivialLiberalGuard", "Name of guard: ACLs, Datalog, etc.")
 
 // execution policy changes
 var canExecute = flag.String("canexecute", "", "Path of a program to be authorized to execute.")
 var retractCanExecute = flag.String("retractcanexecute", "", "Path of a program to retract authorization to execute.")
 
+// Sign a user cert
+var newUserKey= flag.Bool("newuserkey", false, "Create key and cert.")
+var commonName= flag.String("commonname", "", "Mandatory user name")
+var ouName= flag.String("fileproxyUser", "fileproxy-user", "OU")
+var serialNumber= flag.Int("serial number", 43, "serial number")
+var keyPath= flag.String("./keys/", "./keys/", "key path")
#*
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-11-13T10:41:09-0800
#*
#- No "." or "/" in flag names.
#-
+var keyFileName= flag.String("key", "key", "key file")
+var certFileName= flag.String("cert", "cert", "cert file")
+
+var readKey=flag.Bool("readkey", false, "Read key and cert.")
+
 // arbitrary policy changes
 var add = flag.String("add", "", "A policy rule to be added.")
 var retract = flag.String("retract", "", "A policy rule to be retracted.")
 var clear = flag.Bool("clear", false, "Clear all policy rules before other changes.")
 var query = flag.String("query", "", "A policy query to be checked.")
 
 // misc. utilities
 var getProgramHash = flag.String("getprogramhash", "", "Path of program to be hashed.")
 var getPCR = flag.Int("getpcr", -1, "Index of a PCR to return.")
 var tpmPath = flag.String("tpm", "/dev/tpm0", "Path to a TPM device.")
 var aikFile = flag.String("aikblob", "", "A file containing a TPM AIK.")
 
 func main() {
 	help := "Administrative utility for Tao Domain.\n"
 	help += "Usage: %[1]s [options] -create [-name name]\n"
 	help += "%[1]s [options] -(retractcanexecute|canexecute) progpath\n"
 	help += "%[1]s [options] -(add|retract|query) rule\n"
 	help += "%[1]s [options] -clear\n"
 	flag.Usage = func() {
 		fmt.Fprintf(os.Stderr, help, os.Args[0])
@@ -103,40 +117,107 @@ func main() {
 		switch *guard {
 		case "ACLs":
 			cfg.ACLGuard.SignedACLsPath = rulesPath
 		case "Datalog":
 			cfg.DatalogGuard.SignedRulesPath = rulesPath
 		}
 
 		domain, err = tao.CreateDomain(cfg, *configPath, []byte(*pass))
 		fatalIf(err)
 	} else {
 		domain, err = tao.LoadDomain(*configPath, []byte(*pass))
 		fatalIf(err)
 	}
 
 	if *clear {
 		didWork = true
 		domain.Guard.Clear()
 		err := domain.Save()
 		fatalIf(err)
 	}
+	if *newUserKey {
+		if(*commonName=="") {
+			log.Fatal("commonName is required.")
+		} else {
+			domain, err = tao.LoadDomain(*configPath, []byte(*pass))
+			if(err!=nil) {
+				fatalIf(err)
+			}
+			policyKey:= domain.Keys
+			fmt.Fprintf(noise, "Creating key for user: %s\n", *commonName)
+			userKey, err:=  tao.NewTemporaryKeys(tao.Signing)
+			if userKey==nil || err!= nil {
+				log.Fatal("Can't create key.")
+			}
+			details:= tao.X509Details {
+			Country: "US",
+			Organization: "Google",
+			OrganizationalUnit: *ouName,
+			CommonName: *commonName, }
+			subjectname:= tao.NewX509Name(details)
+			*serialNumber= *serialNumber+1
+			template := &x509.Certificate {
+				SignatureAlgorithm: x509.ECDSAWithSHA256,
+				PublicKeyAlgorithm: x509.ECDSA,
+				// It's always allowed for self-signed certs to have serial 1.
+				SerialNumber: new(big.Int).SetInt64(int64(*serialNumber)),
+				Subject:      *subjectname,
+				NotBefore:    time.Now(),
+				NotAfter:     time.Now().AddDate(1 /* years */, 0 /* months */, 0 /* days */),
+				KeyUsage:    x509.KeyUsageKeyAgreement,
+				ExtKeyUsage: []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth, x509.ExtKeyUsageClientAuth},
+			}
+			userDerCert, err := x509.CreateCertificate(rand.Reader, template, policyKey.Cert,
+				userKey.VerifyingKey.GetVerifierEc(), policyKey.SigningKey.GetSignerEc())
+			if(err!=nil) {
+				log.Fatal("Cant create cert\n")
+			}
+			err= ioutil.WriteFile(*keyPath+*certFileName, userDerCert, os.ModePerm)
+			cks, err := tao.MarshalKeyset(userKey)
+			if err != nil {
+				log.Fatal("Cant marshal user key.")
#*
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-11-13T10:41:39-0800
#*
#- Spelling. "Cant" (and elsewhere)
#-
+			}
+			// TODO?: defer zeroKeyset(cks)
+			pks, err := proto.Marshal(cks)
+			if err != nil {
+				log.Fatal("Cant marshal CryptoKey.")
+			}
+			ioutil.WriteFile(*keyPath+*keyFileName, pks, os.ModePerm)
+		}
+	}
+	if *readKey {
+		pks, err:= ioutil.ReadFile(*keyPath+*keyFileName)
+		if err != nil {
+			log.Fatal("Cant read key file.")
+		}
+		var cks *tao.CryptoKeyset
+		err= proto.Unmarshal(pks, cks)
+		if err != nil {
+			log.Fatal("Cant key protobuf.")
+		}
+		userKey, err:= tao.UnmarshalKeyset(cks)
+		if err != nil {
+			log.Fatal("Cant Unmarshal keyset.")
+		}
+		fmt.Printf("user key: ", userKey)
+		fmt.Printf("\n");
+	}
 	if *canExecute != "" {
 		path := *canExecute
 		prin := makeHostPrin(*host)
 		subprin := makeProgramSubPrin(path)
 		prog := prin.MakeSubprincipal(subprin)
 		fmt.Fprintf(noise, "Authorizing program to execute:\n"+
 			"  path: %s\n"+
 			"  host: %s\n"+
 			"  name: %s\n", path, prin, subprin)
 		err := domain.Guard.Authorize(prog, "Execute", nil)
 		fatalIf(err)
 		err = domain.Save()
 		fatalIf(err)
 		didWork = true
 	}
 	if *retractCanExecute != "" {
 		path := *retractCanExecute
 		prin := makeHostPrin(*host)
 		subprin := makeProgramSubPrin(path)
 		prog := prin.MakeSubprincipal(subprin)
diff --git a/apps/testcode/jlmtest b/apps/testcode/jlmtest
new file mode 100755
index 0000000..8f3788c
Binary files /dev/null and b/apps/testcode/jlmtest differ
diff --git a/apps/testcode/jlmtest.go b/apps/testcode/jlmtest.go
new file mode 100644
index 0000000..2fe66b3
--- /dev/null
+++ b/apps/testcode/jlmtest.go
@@ -0,0 +1,139 @@
+// Copyright (c) 2014, Kevin Walsh.  All rights reserved.
+// Copyright (c) 2014, Google COrporation.  All rights reserved.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//     http://www.apache.org/licenses/LICENSE-2.0
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+// jlmtest.go
+
+package main
+
+import (
+	//"bufio"
+	//"crypto/tls"
+	//"crypto/x509"
+	//"crypto/x509/pkix"
+	"errors"
+	"flag"
+	"fmt"
+	//"net"
+	"os"
+	"code.google.com/p/goprotobuf/proto"
+	//"strings"
+
+	"github.com/jlmucb/cloudproxy/tao"
+	"github.com/jlmucb/cloudproxy/tao/auth"
+	//taonet "github.com/jlmucb/cloudproxy/tao/net"
+)
+
+var ca = flag.String("ca", "", "address for Tao CA, if any")
+var subprinRule = "(forall P: forall Hash: TrustedProgramHash(Hash) and Subprin(P, %v, Hash) implies MemberProgram(P))"
+var argsRule = "(forall Y: forall P: forall S: MemberProgram(P) and TrustedArgs(S) and Subprin(Y, P, S) implies Authorized(Y, \"Execute\"))"
+var demoRule = "TrustedArgs(ext.Args(%s))"
+
+
+func doClient(domain *tao.Domain) {
+	// keys, err := tao.NewTemporaryTaoDelegatedKeys(tao.Signing, tao.Parent())
+	// cert, err := keys.SigningKey.CreateSelfSignedX509(&pkix.Name{
+	//	Organization: []string{"Google Tao Demo"}})
+	//keys.Cert = cert
+	// g := domain.Guard
+}
+
+// jlmtest
+
+func JlmTest() error {
#*
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-11-13T10:42:19-0800
#*
#- Instead of naming the test for yourself, name it for its functionality, or
#- drop it. In this, I think this test duplicates the functionality of other
#- tests, so it doesn't belong here.
#-
+	if(tao.Hosted()) {
+		fmt.Printf("I have a host\n")
+	} else {
+		fmt.Printf("I have no host\n")
+	}
+	name, err := tao.Parent().GetTaoName()
+	if err != nil {
+		return err
+	}
+	fmt.Printf("My root name is %s\n", name)
+
+	var args []auth.Term
+	for _, arg := range os.Args {
+		args = append(args, auth.Str(arg))
+	}
+
+	e := auth.PrinExt{Name: "Args", Arg: args}
+	err = tao.Parent().ExtendTaoName(auth.SubPrin{e})
+	if err != nil {
+		return err
+	}
+
+	name, err = tao.Parent().GetTaoName()
+	if err != nil {
+		return err
+	}
+	fmt.Printf("My full name is %s\n", name)
+
+	random, err := tao.Parent().GetRandomBytes(10)
+	if err != nil {
+		return err
+	}
+	fmt.Printf("Random bytes  : % x\n", random)
+
+	n, err := tao.Parent().Rand().Read(random)
+	if err != nil {
+		return err
+	}
+	fmt.Printf("%d more bytes : % x\n", n, random)
+
+	secret, err := tao.Parent().GetSharedSecret(10, tao.SharedSecretPolicyDefault)
+	if err != nil {
+		return err
+	}
+	fmt.Printf("Shared secret : % x\n", secret)
+
+	sealed, err := tao.Parent().Seal(random, tao.SealPolicyDefault)
+	if err != nil {
+		return err
+	}
+	fmt.Printf("Sealed bytes  : % x\n", sealed)
+
+	unsealed, policy, err := tao.Parent().Unseal(sealed)
+	if err != nil {
+		return err
+	}
+	if policy != tao.SealPolicyDefault {
+		return errors.New("unexpected policy on unseal")
+	}
+	fmt.Printf("Unsealed bytes: % x\n", unsealed)
+
+	// var childSubprin auth.Prin
+	// childSubprin= auth.SubPrin{auth.PrinExt{Name: "TestChild"}}
+	attest, err:= tao.Parent().Attest(nil, nil, nil, auth.Const(true))
+	if (err==nil) {
+		statement:= proto.CompactTextString(attest)
+		fmt.Printf("Attest worked\n%s\n", statement)
+	} else {
+		fmt.Printf("Attest failed\n")
+	}
+
+
+	return nil
+}
+
+func main() {
+	flag.Parse()
+	if !tao.Hosted() {
+		fmt.Printf("can't continue: No host Tao available\n")
+		return
+	}
+
+	err := JlmTest()
+	if (err!=nil) {
+		fmt.Printf("error from Jlmtest: %s\n", err.Error())
+	}
+	fmt.Printf("Done\n")
+}
diff --git a/apps/testcode/starthost.sh b/apps/testcode/starthost.sh
new file mode 100644
index 0000000..1fc386f
--- /dev/null
+++ b/apps/testcode/starthost.sh
@@ -0,0 +1,14 @@
+#	
+cd $TAO_TEST
+mkdir linux_tao_host
+mkdir policy_keys
+export TAO_USE_TPM=no
+export TAO_config_path=$TAO_TEST/tao.config
+export TAO_guard=AllowAll
+tao_admin -create -name testing -pass nopassword
+linux_host -create -root -pass nopassword
+linux_host -service -root -pass nopassword
+go build jlmtest.go
+cd test
+linux_host -run -- ../jlmtest
+
diff --git a/apps/testcode/test/linux_tao_host/keys b/apps/testcode/test/linux_tao_host/keys
new file mode 100644
index 0000000..3966169
Binary files /dev/null and b/apps/testcode/test/linux_tao_host/keys differ
diff --git a/apps/testcode/test/policy_keys/cert b/apps/testcode/test/policy_keys/cert
new file mode 100644
index 0000000..b8c686b
Binary files /dev/null and b/apps/testcode/test/policy_keys/cert differ
diff --git a/apps/testcode/test/policy_keys/signer b/apps/testcode/test/policy_keys/signer
new file mode 100644
index 0000000..aa88aa1
--- /dev/null
+++ b/apps/testcode/test/policy_keys/signer
@@ -0,0 +1,8 @@
+-----BEGIN EC PRIVATE KEY-----
+Proc-Type: 4,ENCRYPTED
+DEK-Info: AES-128-CBC,984d31f51f153b9e4b7c5756179c0774
+
+zG7JWuAPlrHMV1hmO8TxMH6FGQbaXu5SJZ0K9rhp4KeF2LML4zvNBh1YFo2D8qES
+VhLhaPsi4M1E47n31Fz6W+EdbSLN6YGsjQGKctxx5A5nNtuit5JKnGfa4qNufWCB
+ZIbSlIlQDuNkgl8vf5YfeavzHhWJN3QC2/wcF4AtBCU=
+-----END EC PRIVATE KEY-----
diff --git a/apps/testcode/test/tao.config b/apps/testcode/test/tao.config
new file mode 100644
index 0000000..1254711
--- /dev/null
+++ b/apps/testcode/test/tao.config
@@ -0,0 +1,9 @@
+# Tao Domain Configuration file
+
+[Domain]
+Name = testing
+PolicyKeysPath = policy_keys
+GuardType = AllowAll
+
+[X509Details]
+CommonName = testing
diff --git a/tao/domain.go b/tao/domain.go
index 8e6d203..f777d2f 100644
--- a/tao/domain.go
+++ b/tao/domain.go
@@ -185,23 +185,24 @@ func LoadDomain(configPath string, password []byte) (*Domain, error) {
 		var err error
 		guard, err = LoadACLGuard(keys.VerifyingKey, cfg.ACLGuard)
 		if err != nil {
 			return nil, err
 		}
 	case "Datalog":
 		var err error
 		datalogGuard, err := NewDatalogGuard(keys.VerifyingKey, cfg.DatalogGuard)
 		if err != nil {
 			return nil, err
 		}
 		if err := datalogGuard.ReloadIfModified(); err != nil {
 			return nil, err
 		}
 		guard = datalogGuard
 	case "AllowAll":
 		guard = LiberalGuard
 	case "DenyAll":
 		guard = ConservativeGuard
 	}
+	//TODO (important!): Need to modify tao name to reflect policy key
#*
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-11-13T10:43:42-0800
#*
#- This is done now, right?
#-
 
 	return &Domain{cfg, configPath, keys, guard}, nil
 }
diff --git a/tao/keys.go b/tao/keys.go
index 6d7f3ee..79d1259 100644
--- a/tao/keys.go
+++ b/tao/keys.go
@@ -59,40 +59,48 @@ const hmacKeySize = 32 // SHA-256
 type Signer struct {
 	ec *ecdsa.PrivateKey
 }
 
 // A Verifier is used to verify signatures.
 type Verifier struct {
 	ec *ecdsa.PublicKey
 }
 
 // A Crypter is used to encrypt and decrypt data.
 type Crypter struct {
 	aesKey  []byte
 	hmacKey []byte
 }
 
 // A Deriver is used to derive key material from a context using HKDF.
 type Deriver struct {
 	secret []byte
 }
 
+func (s *Signer) GetSignerEc() (*ecdsa.PrivateKey) {
+	return s.ec
+}
+
+func (v *Verifier) GetVerifierEc() (*ecdsa.PublicKey) {
+	return v.ec
+}
+
#*
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-11-13T10:44:07-0800
#*
#- These functions violate encapsulation. If this is needed to create an X.509
#- cert, then we need to add that to the keys.go file rather than violating the
#- encapsulation property.
#-
 // GenerateSigner creates a new Signer with a fresh key.
 func GenerateSigner() (*Signer, error) {
 	ec, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)
 	if err != nil {
 		return nil, err
 	}
 
 	return &Signer{ec}, nil
 }
 
 // ToPrincipal produces a "key" type Prin for this signer. This contains a
 // serialized CryptoKey for the public half of this signing key.
 func (s *Signer) ToPrincipal() auth.Prin {
 	ck := MarshalPublicSignerProto(s)
 
 	// proto.Marshal won't fail here since we fill all required fields of the
 	// message. Propagating impossible errors just leads to clutter later.
 	data, _ := proto.Marshal(ck)
 
 	return auth.NewKeyPrin(data)
@@ -100,76 +108,90 @@ func (s *Signer) ToPrincipal() auth.Prin {
 
 // MarshalSignerDER serializes the signer to DER.
 func MarshalSignerDER(s *Signer) ([]byte, error) {
 	return x509.MarshalECPrivateKey(s.ec)
 }
 
 // UnmarshalSignerDER deserializes a Signer from DER.
 func UnmarshalSignerDER(signer []byte) (*Signer, error) {
 	k := new(Signer)
 	var err error
 	if k.ec, err = x509.ParseECPrivateKey(signer); err != nil {
 		return nil, err
 	}
 
 	return k, nil
 }
 
 // X509Details is a simplified version of pkix.Name, suitable for most purposes.
 // All of the fields are optional.
 type X509Details struct {
-	CommonName, Country, State, Organization string
+	CommonName, Country, State, Organization, OrganizationalUnit string
 }
 
 // NewX509Name returns a new pkix.Name.
 func NewX509Name(p X509Details) *pkix.Name {
 	return &pkix.Name{
 		Country:      []string{string(p.Country)},
 		Organization: []string{string(p.Organization)},
+		OrganizationalUnit:[]string{string(p.OrganizationalUnit)},
 		Province:     []string{string(p.State)},
 		CommonName:   string(p.CommonName),
 	}
 }
 
 // prepareX509Template fills out an X.509 template for use in x509.CreateCertificate.
 func prepareX509Template(subjectName *pkix.Name) *x509.Certificate {
 	return &x509.Certificate{
 		SignatureAlgorithm: x509.ECDSAWithSHA256,
 		PublicKeyAlgorithm: x509.ECDSA,
 		Version:            2, // x509v3
 		// It's always allowed for self-signed certs to have serial 1.
 		SerialNumber: new(big.Int).SetInt64(1),
 		Subject:      *subjectName,
 		NotBefore:    time.Now(),
 		NotAfter:     time.Now().AddDate(1 /* years */, 0 /* months */, 0 /* days */),
 		// TODO(tmroeder): I'm not sure which of these I need to make
 		// OpenSSL happy.
 		KeyUsage:    x509.KeyUsageKeyAgreement | x509.KeyUsageCertSign,
 		ExtKeyUsage: []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth, x509.ExtKeyUsageClientAuth},
 	}
 }
 
+func (s *Signer) CreateSelfSignedDER(name *pkix.Name) ([]byte, error) {
+	template := prepareX509Template(name)
+	template.BasicConstraintsValid= true
+	template.IsCA = true
+	template.Issuer = template.Subject
+	der, err := x509.CreateCertificate(rand.Reader, template, template, &s.ec.PublicKey, s.ec)
+	if err != nil {
+		return nil, err
+	}
+	return der, nil
+}
+
 // CreateSelfSignedX509 creates a self-signed X.509 certificate for the public
 // key of this Signer.
 func (s *Signer) CreateSelfSignedX509(name *pkix.Name) (*x509.Certificate, error) {
 	template := prepareX509Template(name)
 	template.IsCA = true
+	template.BasicConstraintsValid= true
 	template.Issuer = template.Subject
 
 	der, err := x509.CreateCertificate(rand.Reader, template, template, &s.ec.PublicKey, s.ec)
 	if err != nil {
 		return nil, err
 	}
 
 	return x509.ParseCertificate(der)
 }
 
 // CreateSignedX509 creates a signed X.509 certificate for some other subject's
 // key.
 func (s *Signer) CreateSignedX509(caCert *x509.Certificate, certSerial int, subjectKey *Verifier, subjectName *pkix.Name) (*x509.Certificate, error) {
 	template := prepareX509Template(subjectName)
 
 	der, err := x509.CreateCertificate(rand.Reader, template, caCert, subjectKey.ec, s.ec)
 	if err != nil {
 		return nil, err
 	}
 	return x509.ParseCertificate(der)
@@ -783,55 +805,63 @@ type Keys struct {
 	keyTypes KeyType
 
 	SigningKey   *Signer
 	CryptingKey  *Crypter
 	VerifyingKey *Verifier
 	DerivingKey  *Deriver
 	Delegation   *Attestation
 	Cert         *x509.Certificate
 }
 
 // X509Path returns the path to the verifier key, stored as an X.509
 // certificate.
 func (k *Keys) X509Path() string {
 	if k.dir == "" {
 		return ""
 	}
 
 	return path.Join(k.dir, "cert")
 }
 
+// SetMyKeyPath sets path for stored keys.
#*
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-11-13T10:44:55-0800
#*
#- Don't use "My" in function names. Also, it looks like go fmt hasn't been run
#- on this file. And it looks like these functions aren't used anywhere anymore,
#- so they should be removed.
#-
+func (k *Keys) SetMyKeyPath(dir_name string) {
+	k.dir= dir_name;
+}
+
+// SetKeyType sets key type
+func (k *Keys) SetKeyType(types KeyType) {
+	k.keyTypes= types;
+}
+
 // PBEKeysetPath returns the path for stored keys.
 func (k *Keys) PBEKeysetPath() string {
 	if k.dir == "" {
 		return ""
 	}
-
 	return path.Join(k.dir, "keys")
 }
 
 // PBESignerPath returns the path for a stored signing key.
 func (k *Keys) PBESignerPath() string {
 	if k.dir == "" {
 		return ""
 	}
-
 	return path.Join(k.dir, "signer")
 }
 
 // SealedKeysetPath returns the path for a stored signing key.
 func (k *Keys) SealedKeysetPath() string {
 	if k.dir == "" {
 		return ""
 	}
 
 	return path.Join(k.dir, "sealed_keyset")
 }
 
 // DelegationPath returns the path for a stored signing key.
 func (k *Keys) DelegationPath() string {
 	if k.dir == "" {
 		return ""
 	}
 
 	return path.Join(k.dir, "delegation")
 }
@@ -1076,40 +1106,45 @@ func (k *Keys) newCert(name *pkix.Name) (err error) {
 	}
 	return nil
 }
 
 func (k *Keys) loadCert() error {
 	f, err := os.Open(k.X509Path())
 	if err != nil {
 		return nil
 	}
 	defer f.Close()
 
 	der, err := ioutil.ReadAll(f)
 	if err != nil {
 		return err
 	}
 
 	k.Cert, err = x509.ParseCertificate(der)
 	return err
 }
 
+// LoadCert loads cert
#*
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-11-13T10:45:52-0800
#*
#- More descriptive comment, please. Why does it do this?
#-
+func (k *Keys) LoadCert() error {
+	return k.loadCert()
+}
+
 // NewTemporaryTaoDelegatedKeys initializes a set of temporary keys under a host
 // Tao, using the Tao to generate a delegation for the signing key. Since these
 // keys are never stored on disk, they are not sealed to the Tao.
 func NewTemporaryTaoDelegatedKeys(keyTypes KeyType, t Tao) (*Keys, error) {
 	k, err := NewTemporaryKeys(keyTypes)
 	if err != nil {
 		return nil, err
 	}
 	self, err := t.GetTaoName()
 	if err != nil {
 		return nil, err
 	}
 
 	if k.SigningKey != nil {
 		s := &auth.Speaksfor{
 			Delegate:  k.SigningKey.ToPrincipal(),
 			Delegator: self,
 		}
 		if k.Delegation, err = t.Attest(&self, nil, nil, s); err != nil {
 			return nil, err
diff --git a/tao/linux_host.go b/tao/linux_host.go
index 42919cc..8e8b735 100644
--- a/tao/linux_host.go
+++ b/tao/linux_host.go
@@ -128,42 +128,41 @@ func (lh *LinuxHost) GetSharedSecret(child *LinuxHostChild, n int, policy string
 		tag = policy + "|" + child.ChildSubprin.String()
 	case SharedSecretPolicyLiberal:
 		// The most liberal we can do is allow any hosted process
 		// running on a similar LinuxHost instance.
 		tag = policy
 	default:
 		return nil, newError("policy not supported for GetSharedSecret: " + policy)
 	}
 	return lh.taoHost.GetSharedSecret(tag, n)
 }
 
 // Seal encrypts data for the child. This call also zeroes the data parameter.
 func (lh *LinuxHost) Seal(child *LinuxHostChild, data []byte, policy string) ([]byte, error) {
 	defer zeroBytes(data)
 	lhsb := &LinuxHostSealedBundle{
 		Policy: proto.String(policy),
 		Data:   data,
 	}
 
 	switch policy {
-	case SharedSecretPolicyDefault:
-	case SharedSecretPolicyConservative:
+	case SharedSecretPolicyDefault, SharedSecretPolicyConservative:
 		// We are using a master key-deriving key shared among all
 		// similar LinuxHost instances. For LinuxHost, the default
 		// and conservative policies means any process running the same
 		// program binary as the caller hosted on a similar
 		// LinuxHost.
 		lhsb.PolicyInfo = proto.String(child.ChildSubprin.String())
 	case SharedSecretPolicyLiberal:
 		// The most liberal we can do is allow any hosted process
 		// running on a similar LinuxHost instance. So, we don't set
 		// any policy info.
 	default:
 		return nil, newError("policy not supported for Seal: " + policy)
 	}
 
 	m, err := proto.Marshal(lhsb)
 	if err != nil {
 		return nil, err
 	}
 	defer zeroBytes(m)
 
@@ -172,52 +171,50 @@ func (lh *LinuxHost) Seal(child *LinuxHostChild, data []byte, policy string) ([]
 
 // Unseal decrypts data for the child, but only if the policy is satisfied.
 func (lh *LinuxHost) Unseal(child *LinuxHostChild, sealed []byte) ([]byte, string, error) {
 	decrypted, err := lh.taoHost.Decrypt(sealed)
 	if err != nil {
 		return nil, "", err
 	}
 	defer zeroBytes(decrypted)
 
 	var lhsb LinuxHostSealedBundle
 	if err := proto.Unmarshal(decrypted, &lhsb); err != nil {
 		return nil, "", err
 	}
 
 	if lhsb.Policy == nil {
 		return nil, "", newError("invalid policy in sealed data")
 	}
 
 	policy := *lhsb.Policy
 	switch policy {
-	case SharedSecretPolicyDefault:
-	case SharedSecretPolicyConservative:
+	case SharedSecretPolicyConservative, SharedSecretPolicyDefault:
 		if lhsb.PolicyInfo == nil || child.ChildSubprin.String() != *lhsb.PolicyInfo {
 			return nil, "", newError("principal not authorized for unseal")
 		}
 	case SharedSecretPolicyLiberal:
 		// Allow all
 		break
 	default:
 		return nil, "", newError("policy not supported for Unseal: " + policy)
 	}
-
 	return lhsb.Data, policy, nil
 }
 
 // Attest signs a statement on behalf of the child.
 func (lh *LinuxHost) Attest(child *LinuxHostChild, issuer *auth.Prin, time, expiration *int64, stmt auth.Form) (*Attestation, error) {
 	return lh.taoHost.Attest(child.ChildSubprin, issuer, time, expiration, stmt)
 }
 
 // StartHostedProgram starts a new hosted program.
 func (lh *LinuxHost) StartHostedProgram(path string, args []string) (auth.SubPrin, int, error) {
 	lh.idm.Lock()
 	id := lh.nextChildID
 	if lh.nextChildID != 0 {
 		lh.nextChildID++
 	} else {
 		glog.Warning("Running without unique child IDs")
 	}
 	lh.idm.Unlock()
 
 	subprin, temppath, err := lh.childFactory.MakeHostedProgramSubprin(id, path)
diff --git a/tao/net/client.go b/tao/net/client.go
index 109b24c..d3011d0 100644
--- a/tao/net/client.go
+++ b/tao/net/client.go
@@ -37,41 +37,40 @@ const (
 	x509keySize  = 2048
 )
 
 // EncodeTLSCert combines a signing key and a certificate in a single tls
 // certificate suitable for a TLS config.
 func EncodeTLSCert(keys *tao.Keys) (*tls.Certificate, error) {
 	if keys.Cert == nil {
 		return nil, fmt.Errorf("client: can't encode a nil certificate")
 	}
 	certPem := pem.EncodeToMemory(&pem.Block{Type: "CERTIFICATE", Bytes: keys.Cert.Raw})
 	keyBytes, err := tao.MarshalSignerDER(keys.SigningKey)
 	if err != nil {
 		return nil, err
 	}
 	keyPem := pem.EncodeToMemory(&pem.Block{Type: "ECDSA PRIVATE KEY", Bytes: keyBytes})
 
 	tlsCert, err := tls.X509KeyPair(certPem, keyPem)
 	if err != nil {
 		return nil, fmt.Errorf("can't parse cert: %s\n", err.Error())
 	}
-
 	return &tlsCert, nil
 }
 
 // generateX509 creates a fresh set of Tao-delegated keys and gets a certificate
 // from these keys.
 func generateX509() (*tao.Keys, *tls.Certificate, error) {
 	keys, err := tao.NewTemporaryTaoDelegatedKeys(tao.Signing, tao.Parent())
 	if err != nil {
 		return nil, nil, err
 	}
 
 	// TODO(tmroeder): fix the name
 	cert, err := keys.SigningKey.CreateSelfSignedX509(&pkix.Name{
 		Organization: []string{"Google Tao Demo"}})
 	if err != nil {
 		return nil, nil, err
 	}
 	// TODO(kwalsh) keys should save cert on disk if keys are on disk
 	keys.Cert = cert
 	tc, err := EncodeTLSCert(keys)
