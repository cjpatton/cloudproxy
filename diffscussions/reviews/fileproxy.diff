#* 
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-12-12T16:35:47-0800
#* 
#- Get the filehandler/rollbackhandler to build.
#- 
#- 
#- Port file client to use the new API.
#- 
#- This commit ports fileclient into the new API.
#- 
#- 
#- Port the applications to the new fileproxy code.
#- 
#- This commit ports fileserver, keynegoserver, and rollbackserver to use more
#- idiomatic Go style and to use the changed versions of ResourceMaster and
#- RollbackMaster.
#- 
#- These versions haven't been tested yet.
#- 
#- 
#- Fix the code to get all fileclient tests to pass.
#- 
#- This version of the code can run in the context of the install.sh script and can
#- successfully run all fileclient tests.
#- 
#- 
#- Remove unnecessary functions.
#- 
#- This commit removes the functions that expose the internal structure of the
#- Signer and Verifier in keys.go
#- 
#- 
#- Port fileclient to use standard key methods.
#- 
#- 
#- Port fileserver to use standard tao/key.go funcs.
#- 
#- 
#- Port the rollback server to use keys functions.
#- 
#- 
#- Remove superfluous key code.
#- 
#- This commit removes the key code that duplicates the code in keys.go, and it
#- refactors the keynegoserver code into tao/net.
#- 
#- 
#- Clean up the fileproxy files.
#- 
#- This commit renames the files and gets rid of the scripts, since fileproxy now
#- works in the standard install.sh framework.
#- 
#- 
#- Make fileclient create a test file.
#- 
#- This commit creates a simple test file in fileclient rather than relying on the
#- user to do it. It also adds a run.sh script that contains the actions needed to
#- get fileproxy to run in the context of a directory created by install.sh -notpm.
#- 
#- 
diff --git a/apps/fileproxy/fileclient/fileclient.go b/apps/fileproxy/fileclient/fileclient.go
index a6d4566..2174d9e 100644
--- a/apps/fileproxy/fileclient/fileclient.go
+++ b/apps/fileproxy/fileclient/fileclient.go
@@ -1,347 +1,233 @@
-// Copyright (c) 2014, Google, Inc.,  All rights reserved.
+// Copyright (c) 2014, Google, Inc. All rights reserved.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
 // You may obtain a copy of the License at
+//
 //     http://www.apache.org/licenses/LICENSE-2.0
+//
 // Unless required by applicable law or agreed to in writing, software
 // distributed under the License is distributed on an "AS IS" BASIS,
 // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 // See the License for the specific language governing permissions and
 // limitations under the License.
 //
 // File: fileclient.go
 
 package main
 
 import (
+	"crypto/rand"
 	"crypto/sha256"
+	"crypto/subtle"
 	"crypto/tls"
 	"crypto/x509"
-	"encoding/binary"
 	"flag"
 	"io/ioutil"
 	"log"
-
-	"code.google.com/p/goprotobuf/proto"
+	"net"
+	"os"
+	"path"
 
 	"github.com/jlmucb/cloudproxy/apps/fileproxy"
-	tao "github.com/jlmucb/cloudproxy/tao"
+	"github.com/jlmucb/cloudproxy/tao"
 	"github.com/jlmucb/cloudproxy/tao/auth"
 	taonet "github.com/jlmucb/cloudproxy/tao/net"
 	"github.com/jlmucb/cloudproxy/util"
 )
 
-var hostcfg = flag.String("../hostdomain/tao.config", "../hostdomain/tao.config", "path to host tao configuration")
-var serverHost = flag.String("host", "localhost", "address for client/server")
-var serverPort = flag.String("port", "8123", "port for client/server")
-var rollbackserverHost = flag.String("rollbackhost", "localhost", "address for rollback client/server")
-var rollbackserverPort = flag.String("rollbackport", "8129", "port for client/server")
-var fileclientPath = flag.String("fileclient_files/", "fileclient_files/", "fileclient directory")
-var serverAddr string
-var rollbackserverAddr string
-var fileclientFilePath = flag.String("fileclient_files/stored_files/", "fileclient_files/stored_files/",
-	"fileclient file directory")
-var testFile = flag.String("originalTestFile", "originalTestFile", "test file")
-var fileclientKeyPath = flag.String("usercreds/", "usercreds/", "user keys and certs")
-
 func main() {
-
-	var fileClientProgramObject fileproxy.ProgramPolicy
+	caAddr := flag.String("caAddr", "localhost:8124", "The address of the CA for setting up a certificate signed by the policy key")
+	hostcfg := flag.String("hostconfig", "tao.config", "path to host tao configuration")
+	serverHost := flag.String("host", "localhost", "address for client/server")
+	serverPort := flag.String("port", "8123", "port for client/server")
+	rollbackServerHost := flag.String("rollbackhost", "localhost", "address for rollback client/server")
+	rollbackServerPort := flag.String("rollbackport", "8129", "port for client/server")
+	fileClientPassword := flag.String("password", "BogusPass", "A password for unlocking the user certificates")
+	fileClientPath := flag.String("fileclient_files", "fileclient_files", "fileclient directory")
+	fileClientFilePath := flag.String("stored_files", "fileclient_files/stored_files", "fileclient file directory")
+	testFile := flag.String("test_file", "originalTestFile", "test file")
+	fileClientKeyPath := flag.String("usercreds", "usercreds", "user keys and certs")
+	country := flag.String("country", "US", "The country for the fileclient certificate")
+	org := flag.String("organization", "Google", "The organization for the fileclient certificate")
 
 	flag.Parse()
-	serverAddr = *serverHost + ":" + *serverPort
 
+	serverAddr := net.JoinHostPort(*serverHost, *serverPort)
 	hostDomain, err := tao.LoadDomain(*hostcfg, nil)
 	if err != nil {
 		log.Fatalln("fileclient: Can't load domain")
 	}
 	var derPolicyCert []byte
 	if hostDomain.Keys.Cert != nil {
 		derPolicyCert = hostDomain.Keys.Cert.Raw
 	}
 	if derPolicyCert == nil {
 		log.Fatalln("fileclient: Can't retrieve policy cert")
 	}
 
-	if err := hostDomain.ExtendTaoName(tao.Parent()); err != nil {
+	parentTao := tao.Parent()
+	if err := hostDomain.ExtendTaoName(parentTao); err != nil {
 		log.Fatalln("fileclient: can't extend the Tao with the policy key")
 	}
 	e := auth.PrinExt{Name: "fileclient_version_1"}
-	err = tao.Parent().ExtendTaoName(auth.SubPrin{e})
-	if err != nil {
-		return
+	if err = parentTao.ExtendTaoName(auth.SubPrin{e}); err != nil {
+		log.Fatalln("fileclient: couldn't extend the tao name with the policy key")
 	}
 
-	taoName, err := tao.Parent().GetTaoName()
+	taoName, err := parentTao.GetTaoName()
 	if err != nil {
 		log.Fatalln("fileclient: Can't get tao name")
-		return
 	}
-	log.Printf("fileclient: my name is %s\n", taoName)
 
-	sealedSymmetricKey, sealedSigningKey, programCert, delegation, err := fileproxy.LoadProgramKeys(*fileclientPath)
+	// Create or read the keys for fileclient.
+	fcKeys, err := tao.NewOnDiskTaoSealedKeys(tao.Signing|tao.Crypting, parentTao, *fileClientPath, tao.SealPolicyDefault)
 	if err != nil {
-		log.Printf("fileclient: can't retrieve key material\n")
+		log.Fatalln("fileclient: couldn't set up the Tao-sealed keys:", err)
 	}
-	if sealedSymmetricKey == nil || sealedSigningKey == nil || delegation == nil || programCert == nil {
-		log.Printf("fileclient: No key material present\n")
-	}
-	log.Printf("fileclient: Finished fileproxy.LoadProgramKeys\n")
 
-	var symKeys []byte
-	if sealedSymmetricKey != nil {
-		symKeys, policy, err := tao.Parent().Unseal(sealedSymmetricKey)
-		if err != nil {
-			return
-		}
-		if policy != tao.SealPolicyDefault {
-			log.Printf("fileclient: unexpected policy on unseal\n")
-		}
-		log.Printf("fileclient: Unsealed symKeys: % x\n", symKeys)
-	} else {
-		symKeys, err := fileproxy.InitializeSealedSymmetricKeys(*fileclientPath, tao.Parent(), fileproxy.SizeofSymmetricKeys)
-		if err != nil {
-			log.Printf("fileclient: InitializeSealedSymmetricKeys error: %s\n", err)
-		}
-		log.Printf("fileclient: InitilizedsymKeys: % x\n", symKeys)
+	// Set up a temporary cert for communication with keyNegoServer.
+	fcKeys.Cert, err = fcKeys.SigningKey.CreateSelfSignedX509(tao.NewX509Name(tao.X509Details{
+		Country:      *country,
+		Organization: *org,
+		CommonName:   taoName.String(),
+	}))
+	if err != nil {
+		log.Fatalln("fileclient: couldn't create a self-signed cert for fileclient keys:", err)
 	}
-	defer fileproxy.ZeroBytes(symKeys)
 
-	var signingKey *tao.Keys
-	if sealedSigningKey != nil {
-		signingKey, err = fileproxy.SigningKeyFromBlob(tao.Parent(),
-			sealedSigningKey, programCert, delegation)
-		if err != nil {
-			log.Printf("fileclient: SigningKeyFromBlob error: %s\n", err)
-		}
-		log.Printf("fileclient: Retrieved Signing key: % x\n", *signingKey)
-	} else {
-		signingKey, err = fileproxy.InitializeSealedSigningKey(*fileclientPath,
-			tao.Parent(), *hostDomain)
-		if err != nil {
-			log.Printf("fileclient: InitializeSealedSigningKey error: %s\n", err)
-		}
-		log.Printf("fileclient: Initilized signingKey\n")
+	// Contact keyNegoServer for the certificate.
+	if err := fileproxy.EstablishCert("tcp", *caAddr, fcKeys, hostDomain.Keys.VerifyingKey); err != nil {
+		log.Fatalf("fileclient: couldn't establish a cert signed by the policy key: %s", err)
 	}
 
-	_ = fileClientProgramObject.InitProgramPolicy(derPolicyCert, taoName.String(), *signingKey, symKeys, programCert)
-
-	policyCert, err := x509.ParseCertificate(derPolicyCert)
-	if err != nil {
-		log.Fatalln("fileclient:can't ParseCertificate")
-		return
-	}
-	log.Printf("fileclient: place 0\n")
+	// Get the policy cert and set up TLS.
 	pool := x509.NewCertPool()
-	pool.AddCert(policyCert)
+	pool.AddCert(hostDomain.Keys.Cert)
 
-	tlsc, err := taonet.EncodeTLSCert(signingKey)
+	tlsc, err := taonet.EncodeTLSCert(fcKeys)
 	if err != nil {
-		log.Printf("fileclient, encode error: ", err)
-		log.Printf("\n")
-		return
+		log.Fatalln("fileclient, encode error: ", err)
 	}
 	conn, err := tls.Dial("tcp", serverAddr, &tls.Config{
 		RootCAs:            pool,
 		Certificates:       []tls.Certificate{*tlsc},
 		InsecureSkipVerify: false,
 	})
 	if err != nil {
-		log.Printf("fileclient: can't establish channel\n", err)
-		log.Printf("\n")
-		return
+		log.Fatalln("fileclient: can't establish channel: ", err)
 	}
 	ms := util.NewMessageStream(conn)
-	log.Printf("fileclient: Established channel\n")
 
-	// Authenticate user principal(s).
-	userCert, err := ioutil.ReadFile(*fileclientPath + *fileclientKeyPath + "cert")
-	if err != nil {
-		log.Printf("fileclient: can't read cert %s\n", *fileclientPath+*fileclientKeyPath+"cert")
-		return
-	}
-	log.Printf("fileclient: read cert\n")
-	if userCert == nil {
-		log.Printf("fileclient: nil user cert\n")
-	}
-	pks, err := ioutil.ReadFile(*fileclientPath + *fileclientKeyPath + "keys")
-	if err != nil {
-		log.Printf("fileclient: can't read key blob\n")
-		return
-	}
-	if pks == nil {
-		log.Printf("fileclient: nil pks\n")
-	}
-	log.Printf("fileclient: read key blob\n")
-	var cks tao.CryptoKeyset
-	err = proto.Unmarshal(pks, &cks)
-	if err != nil {
-		log.Printf("fileclient: can't proto unmarshal key set\n")
-		return
-	}
-	if pks == nil {
-		log.Printf("fileclient: can't proto unmarshaled is nil \n")
-		return
-	}
-	log.Printf("fileclient: unmarshaled proto key\n")
-	userKey, err := tao.UnmarshalKeyset(&cks)
-	if err != nil {
-		log.Printf("fileclient: can't unmarshal key set\n")
-		return
-	}
-	log.Printf("fileclient: unmarshaled key\n")
-	ok := fileproxy.AuthenticatePrincipalRequest(ms, userKey, userCert)
-	if !ok {
-		log.Printf("fileclient: can't authenticate principal\n")
-		return
-	}
-	log.Printf("fileclient: AuthenticatedPrincipalRequest\n")
+	// Before doing any tests, create a simple file to send to the server.
+	testContents := `
+This is a simple file to test
+It has some new lines
+And it doesn't have very much content.
+	`
 
-	// Send a rule.
-	rule := "Delegate(\"jlm\", \"tom\", \"getfile\",\"myfile\")"
-	log.Printf("fileclient, sending rule: %s\n", rule)
-	err = fileproxy.SendRule(ms, rule, userCert)
-	if err != nil {
-		log.Printf("fileclient: can't create file\n")
-		return
-	}
-	status, message, size, err := fileproxy.GetResponse(ms)
-	if err != nil {
-		log.Printf("fileclient: Error in response to SendCreate\n")
-		return
-	}
-	log.Printf("Response to SendCreate\n")
-	fileproxy.PrintResponse(status, message, size)
-	if *status != "succeeded" {
-		return
+	if _, err := os.Stat(*fileClientFilePath); err != nil {
+		if err := os.MkdirAll(*fileClientFilePath, 0700); err != nil {
+			log.Fatalf("fileclient: couldn't create the file storage path %s: %s", *fileClientFilePath, err)
+		}
 	}
 
-	// Create a file.
 	sentFileName := *testFile
-	log.Printf("fileclient, Creating: %s\n", sentFileName)
-	err = fileproxy.SendCreateFile(ms, userCert, sentFileName)
-	if err != nil {
-		log.Printf("fileclient: can't create file\n")
-		return
-	}
-	status, message, size, err = fileproxy.GetResponse(ms)
-	if err != nil {
-		log.Printf("fileclient: Error in response to SendCreate\n")
-		return
-	}
-	log.Printf("fileclient: Response to SendCreate\n")
-	fileproxy.PrintResponse(status, message, size)
-	if *status != "succeeded" {
-		return
+	sentFilePath := path.Join(*fileClientFilePath, sentFileName)
+	if err := ioutil.WriteFile(sentFilePath, []byte(testContents), 0600); err != nil {
+		log.Fatalf("fileclient: couldn't create a test file at %s: %s", sentFilePath, err)
 	}
 
-	// Send File.
-	log.Printf("\nfileclient sending file %s\n", sentFileName)
-	err = fileproxy.SendSendFile(ms, userCert, sentFileName)
-	if err != nil {
-		log.Printf("fileclient: SendSendFile has error\n")
-		return
+	// Authenticate user principal(s).
+	if _, err := os.Stat(*fileClientKeyPath); err != nil {
+		log.Fatalf("fileclient: couldn't get user credentials from %s: %s\n", *fileClientKeyPath, err)
 	}
 
-	status, message, size, err = fileproxy.GetResponse(ms)
+	// This method won't generate the right certificate in general for
+	// signing, which is why we check first to make sure the right directory
+	// already exists. But it will successfully read the signer and the
+	// certificate.
+	userKeys, err := tao.NewOnDiskPBEKeys(tao.Signing, []byte(*fileClientPassword), *fileClientKeyPath, nil)
 	if err != nil {
-		log.Printf("fileclient: Error in response to SendSend\n")
-		return
-	}
-	log.Printf("fileclient: Response to SendSend\n")
-	fileproxy.PrintResponse(status, message, size)
-	if *status != "succeeded" {
-		return
+		log.Fatalf("Couldn't read the keys from %s: %s\n", *fileClientKeyPath, err)
 	}
+	userCert := userKeys.Cert.Raw
 
-	err = fileproxy.SendFile(ms, *fileclientFilePath, sentFileName, nil)
-	if err != nil {
-		log.Printf("fileclient: Error in response to SendFile ", err)
-		log.Printf("\n")
-		return
+	// Authenticate a key to use for requests to the server.
+	if err = fileproxy.AuthenticatePrincipal(ms, userKeys, userCert); err != nil {
+		log.Fatalf("fileclient: can't authenticate principal: %s", err)
 	}
 
-	// Get file
-	log.Printf("\nfileclient getting file %s\n", sentFileName)
-	err = fileproxy.SendGetFile(ms, userCert, sentFileName)
-	if err != nil {
-		log.Printf("fileclient: SendGetFile has error\n")
-		return
+	// Create a file.
+	if err = fileproxy.CreateFile(ms, userCert, sentFileName); err != nil {
+		log.Fatalln("fileclient: can't create file:", err)
 	}
 
-	status, message, size, err = fileproxy.GetResponse(ms)
-	if err != nil {
-		log.Printf("fileclient: Error in response to GetFile\n")
-		return
-	}
-	log.Printf("fileclient: Response to SendGet\n")
-	fileproxy.PrintResponse(status, message, size)
-	if *status != "succeeded" {
-		return
+	// Send File.
+	if err = fileproxy.WriteFile(ms, userCert, *fileClientFilePath, sentFileName); err != nil {
+		log.Fatalf("fileclient: couldn't write the file %s to the server: %s", sentFileName, err)
 	}
 
-	err = fileproxy.GetFile(ms, *fileclientFilePath, sentFileName+".received", nil)
-	if err != nil {
-		log.Printf("fileclient: can't get file ", err)
-		log.Printf("\n")
-		return
+	// Get file.
+	outputFileName := sentFileName + ".out"
+	if err = fileproxy.ReadFile(ms, userCert, *fileClientFilePath, sentFileName, outputFileName); err != nil {
+		log.Fatalf("fileclient: couldn't get file %s to output file %s: %s", sentFileName, outputFileName, err)
 	}
 
-	// rollback test
-	rollbackserverAddr = *serverHost + ":" + *rollbackserverPort
-	rbconn, err := tls.Dial("tcp", rollbackserverAddr, &tls.Config{
+	// TODO(tmroeder): compare the received file against the sent file.
+
+	// Set up a TLS connection to the rollback server, just like the one to
+	// the file server.
+	rollbackServerAddr := net.JoinHostPort(*rollbackServerHost, *rollbackServerPort)
+	rbconn, err := tls.Dial("tcp", rollbackServerAddr, &tls.Config{
 		RootCAs:            pool,
 		Certificates:       []tls.Certificate{*tlsc},
 		InsecureSkipVerify: false,
 	})
 	if err != nil {
-		log.Printf("fileclient: can't establish rollback channel\n", err)
-		log.Printf("\n")
-		return
+		log.Fatalf("fileclient: can't establish rollback channel: %s", err)
 	}
 	newms := util.NewMessageStream(rbconn)
-	if newms == nil {
-		log.Printf("can't get newms\n")
+
+	// Create a fake hash value, and set this value for an item.
+	hashLen := 32
+	hash := make([]byte, hashLen)
+	if _, err := rand.Read(hash); err != nil {
+		log.Fatalf("fileclient: failed to read a random value for the hash")
 	}
-	log.Printf("fileclient: Established rollback channel\n")
-	// set hash
-	hash := make([]byte, 128)
-	for i := 0; i < 32; i++ {
-		hash[i] = byte(i)
+
+	progName := taoName.String()
+	resName := "test_resource"
+	if err := fileproxy.SetHash(newms, resName, hash); err != nil {
+		log.Fatalf("Couldn't set the hash for program '%s', resource '%s', hash % x on the remote server: %s", progName, resName, hash, err)
 	}
-	clientProgramName := taoName.String()
-	ok2 := fileproxy.ClientSetResourceHashRequest(newms, clientProgramName, "test_resource", []byte(hash))
-	if !ok2 {
-		log.Printf("fileclient: fileproxy.ClientSetResourceHashRequest failed")
-		return
+
+	// Set the counter to 10 and check that we get the same value back.
+	if err := fileproxy.SetCounter(newms, uint64(10)); err != nil {
+		log.Fatalf("fileclient: couldn't set the counter in the file client")
 	}
-	log.Printf("fileclient: set fileproxy.ClientSetResourceHashRequest succeeded\n")
-	// set counter
-	fileproxy.ClientSetRollbackCounter(newms, int64(10))
-	log.Printf("fileclient: set fileproxy.ClientSetRollbackCounter\n")
-	// get counter
-	ok2, counter := fileproxy.ClientGetRollbackCounter(newms, clientProgramName)
-	if !ok2 {
-		log.Printf("fileclient: fileproxy.ClientGetRollbackCounter failed")
-		return
+
+	c, err := fileproxy.GetCounter(newms)
+	if err != nil {
+		log.Fatalf("fileclient: couldn't get the value of the counter from the rollback server")
 	}
-	log.Printf("counter is %d\n", counter)
-	// get verify
-	ok2, newhash := fileproxy.ClientGetRollbackHashedVerifierRequest(newms, clientProgramName, "test_resource")
-	if !ok2 {
-		log.Printf("fileclient: fileproxy.ClientGetRollbackHashedVerifierRequest failed")
-		return
+
+	// Get the hash verification value.
+	newHash, err := fileproxy.GetHashedVerifier(newms, resName)
+	if err != nil {
+		log.Fatalf("fileclient: couldn't get the hashed verifier from the rollback server")
+	}
+
+	// Try to recompute the hashed verifier directly to see if it matches.
+	sh := sha256.New()
+	vi := fileproxy.EncodeCounter(c)
+	sh.Write(vi)
+	sh.Write(hash)
+	sh.Write(vi)
+	computed := sh.Sum(nil)
+	if subtle.ConstantTimeCompare(newHash, computed) != 1 {
+		log.Fatalf("fileclient: the hashed verifier % x returned by the server didn't match the value % x computed locally", newHash, computed)
 	}
-	log.Printf("fileclient: newhash is %x\n", newhash)
-	sha256HashCtr := sha256.New()
-	bc := make([]byte, 8)
-	binary.PutVarint(bc, counter)
-	sha256HashCtr.Write(bc)
-	sha256HashCtr.Write(hash)
-	sha256HashCtr.Write(bc)
-	computed_hash := sha256HashCtr.Sum(nil)
-	log.Printf("fileclient: computed_hash is %x\n", computed_hash)
 
-	log.Printf("fileclient: Done\n")
+	log.Println("All fileclient tests pass")
 }
diff --git a/apps/fileproxy/fileclient/rebuild b/apps/fileproxy/fileclient/rebuild
deleted file mode 100755
index 5e3c928..0000000
--- a/apps/fileproxy/fileclient/rebuild
+++ /dev/null
@@ -1,7 +0,0 @@
-#
-echo "rebuilding fileproxy"
-cd ..
-go build ...
-cd fileclient
-go build fileclient.go
-echo "done"
diff --git a/apps/fileproxy/filehandler.go b/apps/fileproxy/filehandler.go
deleted file mode 100644
index 09fe9e2..0000000
--- a/apps/fileproxy/filehandler.go
+++ /dev/null
@@ -1,830 +0,0 @@
-// Copyright (c) 2014, Google, Inc. .  All rights reserved.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//     http://www.apache.org/licenses/LICENSE-2.0
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//
-// File: filehandler.go
-
-package fileproxy
-
-import (
-	"bytes"
-	"crypto/rand"
-	"crypto/x509"
-	"errors"
-	"io/ioutil"
-	"log"
-	"os"
-
-	"code.google.com/p/goprotobuf/proto"
-
-	tao "github.com/jlmucb/cloudproxy/tao"
-	"github.com/jlmucb/cloudproxy/util"
-)
-
-const SizeofNonce = 32
-const ChallengeContext = "fileproxy-challenge"
-
-// Resource types: files, channels
-type ResourceInfo struct {
-	ResourceName      string
-	ResourceType      string
-	ResourceStatus    string
-	ResourceLocation  string
-	ResourceSize      int
-	ResourceOwner     string
-	DateCreated       string
-	DateModified      string
-	AuthenticatorType string
-	Authenticator     [][]byte
-}
-
-type PrincipalInfo struct {
-	Name   string
-	Der    []byte
-	Status string
-}
-
-type ResourceMaster struct {
-	ProgramName      string
-	Guard            tao.Guard
-	BaseDirectory    string
-	NumResources     int
-	ResourceArray    []ResourceInfo
-	NumPrincipals    int
-	PrincipalArray   []PrincipalInfo
-	Policy           []string
-	AdditionalPolicy []string
-}
-
-// Policy for managing files in the fileserver.
-var policy = []string{
-	// Fileserver owns everything.
-	"forall FS: forall R: FileServer(FS) and Resource(R) implies Owner(FS, R)",
-	// Creators are owners.
-	"forall C: forall R: Creator(C, R) implies Owner(C, R)",
-	// Owners can perform all actions and make all delegations.
-	"forall O: forall A: forall R: Owner(O, R) and Resource(R) and Action(A) implies Authorized(O, \"delegate\", A, R)",
-	"forall O: forall A: forall R: Owner(O, R) and Resource(R) and Action(A) implies Authorized(O, A, R)",
-	// Principals have namespaces where they can create things.
-	// The guard needs to understand that Authorized(P, "create-subdir",
-	// path) means that P can create a path with its name underneath (or
-	// something like the hash of its name).
-	"forall P: Authorized(P, \"execute\") implies Authorized(P, \"create-subdir\", \"/principals\")",
-	// Basic Delegation.
-	"forall U1: forall U2: forall R: forall A: Authorized(U1, \"delegate\", A, R) and Delegate(U1, U2, A, R) implies Authorized(U2, A, R)",
-	// Redelegation.
-	"forall U1: forall U2: forall R: forall A: Authorized(U1, \"delegate\", A, R) and Delegate(U1, U2, \"delegate\", A, R) implies Authorized(U2, \"delegate\", A, R)",
-}
-
-// Some fake additional statements for the purpose of testing the guard.
-var additional_policy = []string{
-	"FileServer(\"fileserver\")",
-	"Action(\"create\")",
-	"Action(\"getfile\")",
-	"Action(\"sendfile\")",
-	"Action(\"delete\")",
-}
-
-func delegateResource(owner, delegate, op, res string, g tao.Guard) {
-	if err := g.AddRule("Delegate(\"" + owner + "\", \"" + delegate + "\", \"" + op + "\", \"" + res + "\")"); err != nil {
-		log.Printf("Couldn't delegate operation '%s' on '%s' from '%s' to '%s': %s\n", op, res, owner, delegate, err)
-	}
-}
-
-func redelegateResource(owner, delegate, op, res string, g tao.Guard) {
-	if err := g.AddRule("Delegate(\"" + owner + "\", \"" + delegate + "\", \"delegate\", \"" + op + "\", \"" + res + "\")"); err != nil {
-		log.Printf("Couldn't redelegate operation '%s' on '%s' from '%s' to '%s': %s\n", op, res, owner, delegate, err)
-	}
-}
-
-func addResource(creator, resource string, g tao.Guard) error {
-	if err := g.AddRule("Resource(\"" + resource + "\")"); err != nil {
-		return errors.New("Can't add resource in rules\n")
-	}
-	if err := g.AddRule("Creator(\"" + creator + "\", \"" + resource + "\")"); err != nil {
-		return errors.New("Can't add creator in rules\n")
-	}
-	return nil
-}
-
-func makeQuery(subject string, action string, resource string) *string {
-	var out string
-	if action == "create" {
-		out = "Authorized(\"" + subject + "\", \"" + action + "\",  \"" + resource + "\")"
-	} else if action == "getfile" {
-		out = "Authorized(\"" + subject + "\", \"" + action + "\", \"" + resource + "\")"
-	} else if action == "sendfile" {
-		out = "Authorized(\"" + subject + "\", \"" + action + "\", \"" + resource + "\")"
-	} else {
-		log.Printf("makeQuery: unknown action\n")
-		return nil
-	}
-	log.Printf("makeQuery: %s\n", out)
-	return &out
-}
-
-func (m *ResourceMaster) Query(query string) bool {
-	b, err := m.Guard.Query(query)
-	if err != nil {
-		log.Printf("Query: %s generates error %s\n", query, err)
-		return false
-	}
-	if b {
-		log.Printf("%s succeeds\n", query)
-	} else {
-		log.Printf("%s failed\n", query)
-	}
-	return b
-}
-
-func (m *ResourceMaster) FindResource(resourcename string) (*ResourceInfo, error) {
-	for i := range m.ResourceArray {
-		if m.ResourceArray[i].ResourceName == resourcename {
-			return &m.ResourceArray[i], nil
-		}
-	}
-	return nil, nil
-}
-
-func (m *ResourceMaster) InsertResource(path string, resourcename string, owner string) (*ResourceInfo, error) {
-	found, err := m.FindResource(resourcename)
-	if err != nil {
-		return nil, err
-	}
-	if found != nil {
-		return found, nil
-	}
-	if len(m.ResourceArray) >= cap(m.ResourceArray) {
-		t := make([]ResourceInfo, 2*cap(m.ResourceArray))
-		copy(t, m.ResourceArray)
-		m.ResourceArray = t
-	}
-	m.ResourceArray = m.ResourceArray[0 : len(m.ResourceArray)+1]
-	n := len(m.ResourceArray) - 1
-	m.ResourceArray[n].ResourceName = resourcename
-	m.ResourceArray[n].ResourceType = "file"
-	m.ResourceArray[n].ResourceStatus = "created"
-	m.ResourceArray[n].ResourceLocation = path + resourcename
-	m.ResourceArray[n].ResourceOwner = owner
-	return &m.ResourceArray[n], nil
-}
-
-func (m *ResourceMaster) FindPrincipal(name string) (*PrincipalInfo, error) {
-	for i := range m.PrincipalArray {
-		if m.PrincipalArray[i].Name == name {
-			return &m.PrincipalArray[i], nil
-		}
-	}
-	return nil, nil
-}
-
-func (m *ResourceMaster) InsertPrincipal(name string, cert []byte, authStatus string) (*PrincipalInfo, error) {
-	found, err := m.FindPrincipal(name)
-	if err != nil {
-		return nil, err
-	}
-	if found != nil {
-		return found, nil
-	}
-	if len(m.PrincipalArray) >= cap(m.PrincipalArray) {
-		t := make([]PrincipalInfo, 2*cap(m.PrincipalArray))
-		copy(t, m.PrincipalArray)
-		m.PrincipalArray = t
-	}
-	m.PrincipalArray = m.PrincipalArray[0 : len(m.PrincipalArray)+1]
-	n := len(m.PrincipalArray) - 1
-	m.PrincipalArray[n].Name = name
-	m.PrincipalArray[n].Der = cert
-	m.PrincipalArray[n].Status = authStatus
-	return &m.PrincipalArray[n], nil
-}
-
-func (m *ResourceMaster) Delete(resourceName string) error {
-	return nil // not implemented
-}
-
-func (m *ResourceMaster) EncodeMaster() ([]byte, error) {
-	log.Printf("filehandler: encodeMaster\n")
-	p := &FPResourceMaster{
-		PrinName:          proto.String(m.ProgramName),
-		BaseDirectoryName: proto.String(m.BaseDirectory),
-		NumFileinfos:      proto.Int(len(m.ResourceArray)),
-	}
-	return proto.Marshal(p)
-}
-
-func (m *ResourceMaster) DecodeMaster(in []byte) (*int, error) {
-	log.Printf("filehandler: DecodeMaster\n")
-	var message FPResourceMaster
-	if err := proto.Unmarshal(in, &message); err != nil {
-		return nil, err
-	}
-	/*
-		rMessage := new(FPResourceMaster)
-		err := proto.Unmarshal(in, rMessage)
-		if err != nil {
-		return nil, err
-		}
-		m.ProgramName = *rMessage.PrinName
-		m.BaseDirectory = *rMessage.BaseDirectoryName
-		size := *rMessage.NumFileinfos
-		isize := int(size) //TODO: Fix
-		return &isize, nil
-	*/
-	m.ProgramName = *message.PrinName
-	m.BaseDirectory = *message.BaseDirectoryName
-	isize := int(*message.NumFileinfos)
-	return &isize, nil
-}
-
-func (m *ResourceMaster) PrintMaster(printResources bool) {
-	log.Printf("Program principal: %s\n", m.ProgramName)
-	log.Printf("Base Directory: %s\n", m.BaseDirectory)
-	log.Printf("%d resources\n", len(m.ResourceArray))
-	if printResources {
-		for i := range m.ResourceArray {
-			m.ResourceArray[i].PrintResourceInfo()
-		}
-	}
-}
-
-func (r *ResourceInfo) EncodeResourceInfo() ([]byte, error) {
-	log.Printf("filehandler: encodeResourceInfo\n")
-	protoMessage := new(FPResourceInfo)
-	protoMessage.ResourceName = proto.String(r.ResourceName)
-	protoMessage.ResourceType = proto.String(r.ResourceType)
-	protoMessage.ResourceStatus = proto.String(r.ResourceStatus)
-	protoMessage.ResourceLocation = proto.String(r.ResourceLocation)
-	protoMessage.ResourceSize = proto.Int(r.ResourceSize)
-	protoMessage.ResourceOwner = proto.String(r.ResourceOwner)
-	out, err := proto.Marshal(protoMessage)
-	return out, err
-}
-
-func (r *ResourceInfo) DecodeResourceInfo(in []byte) error {
-	log.Printf("filehandler: DecodeResourceInfo\n")
-	rMessage := new(FPResourceInfo)
-	_ = proto.Unmarshal(in, rMessage)
-	r.ResourceName = *rMessage.ResourceName
-	r.ResourceType = *rMessage.ResourceType
-	r.ResourceLocation = *rMessage.ResourceLocation
-	r.ResourceSize = int(*rMessage.ResourceSize)
-	r.ResourceOwner = *rMessage.ResourceOwner
-	return nil
-}
-
-func (r *ResourceInfo) PrintResourceInfo() {
-	log.Printf("Resource name: %s\n", r.ResourceName)
-	log.Printf("Resource type: %s\n", r.ResourceType)
-	log.Printf("Resource status: %s\n", r.ResourceStatus)
-	log.Printf("Resource location: %s\n", r.ResourceLocation)
-	log.Printf("Resource size: %d\n", r.ResourceSize)
-	log.Printf("Resource creation date: %s\n", r.DateCreated)
-	log.Printf("Resource modified date: %s\n", r.DateModified)
-	log.Printf("\n")
-}
-
-func (p *PrincipalInfo) EncodePrincipal() ([]byte, error) {
-	log.Printf("filehandler: encodePrincipalInfo\n")
-	protoMessage := new(FPPrincipalInfo)
-	protoMessage.PrincipalName = proto.String(p.Name)
-	protoMessage.PrincipalStatus = proto.String(p.Status)
-	protoMessage.PrincipalCert = proto.String(string(p.Der))
-	out, err := proto.Marshal(protoMessage)
-	return out, err
-}
-
-func (p *PrincipalInfo) DecodePrincipal(in []byte) error {
-	log.Printf("filehandler: DecodePrincipalInfo\n")
-	rMessage := new(FPPrincipalInfo)
-	_ = proto.Unmarshal(in, rMessage)
-	p.Name = *rMessage.PrincipalName
-	p.Status = *rMessage.PrincipalStatus
-	p.Der = []byte(*rMessage.PrincipalCert)
-	return nil
-}
-
-func (p *PrincipalInfo) PrintPrincipal() {
-	log.Printf("Principal name: %s\n", p.Name)
-	log.Printf("Principal status: %s\n", p.Status)
-	log.Printf("Principal cert: %s\n", p.Der)
-	log.Printf("\n")
-}
-
-func (m *ResourceMaster) PrintAllPolicy() {
-	for i := range m.Policy {
-		log.Printf("Rule: %s\n", m.Policy[i])
-	}
-	for i := range m.AdditionalPolicy {
-		log.Printf("Rule: %s\n", m.AdditionalPolicy[i])
-	}
-}
-
-func (m *ResourceMaster) InitGuard(rulefile string) error {
-	log.Printf("filehandler: InitGuard\n")
-	m.Guard = tao.NewTemporaryDatalogGuard()
-	for i := range m.Policy {
-		if err := m.Guard.AddRule(m.Policy[i]); err != nil {
-			return errors.New("Couldn't add rule in InitGuard")
-		}
-	}
-
-	for i := range m.AdditionalPolicy {
-		if err := m.Guard.AddRule(m.AdditionalPolicy[i]); err != nil {
-			return errors.New("Couldn't add rule in InitGuard")
-		}
-	}
-	return nil
-}
-
-func (m *ResourceMaster) ReadRules(rulefile string) error {
-	log.Printf("filehandler: ReadRules\n")
-	// Read/Save is not implemented since it is not especially instructive in this prototype
-	// but should be in a real system.
-	return nil
-}
-
-func (m *ResourceMaster) SaveRules(rulefile string) error {
-	log.Printf("filehandler: SaveRules\n")
-	// Read/Save is not implemented since it is not especially instructive in this prototype
-	// but should be in a real system.
-	return nil
-}
-
-func (m *ResourceMaster) GetResourceData(masterFile string, resourceFile string, principalFile string, ruleFile string) error {
-	log.Printf("filehandler: GetResourceData\n")
-	// Read/Save is not implemented since it is not especially instructive in this prototype
-	// but should be in a real system.
-	// Alson in a real system, this data should be encrypted.
-
-	// Read master
-	masterRecord, _ := ioutil.ReadFile(masterFile)
-	_, _ = m.DecodeMaster([]byte(masterRecord))
-	log.Printf("masterRecord size: %d\n", len(masterRecord))
-
-	// Save resources
-	fo, _ := os.Open(resourceFile)
-	rs := util.NewMessageStream(fo)
-	for i := range m.ResourceArray {
-		resourceRecord, _ := rs.ReadString()
-		_ = m.ResourceArray[i].DecodeResourceInfo([]byte(resourceRecord))
-		log.Printf("resourceRecord size: %d\n", len(resourceRecord))
-	}
-	fo.Close()
-
-	// Read principals
-	fo, _ = os.Open(principalFile)
-	ps := util.NewMessageStream(fo)
-	for i := range m.PrincipalArray {
-		principalRecord, _ := ps.ReadString()
-		_ = m.PrincipalArray[i].DecodePrincipal([]byte(principalRecord))
-		log.Printf("principalRecord size: %d\n", len(principalRecord))
-	}
-	fo.Close()
-
-	// Read rules
-	_ = m.ReadRules(ruleFile)
-	return nil
-}
-
-func (m *ResourceMaster) SaveResourceData(masterFile string, resourceFile string, principalFile string, ruleFile string) error {
-	log.Printf("filehandler: SaveResourceData\n")
-	// This has never been tested (see above); also, in a real system, it should be encrypted.
-	// Save master
-	masterRecord, _ := m.EncodeMaster()
-	log.Printf("masterRecord size: %d\n", len(masterRecord))
-	ioutil.WriteFile(masterFile, masterRecord, os.ModePerm)
-	// Save resources
-	fo, _ := os.Create(resourceFile)
-	rs := util.NewMessageStream(fo)
-	for i := range m.ResourceArray {
-		resourceRecord, _ := m.ResourceArray[i].EncodeResourceInfo()
-		log.Printf("resourceRecord size: %d\n", len(resourceRecord))
-		_, _ = rs.WriteString(string(resourceRecord))
-	}
-	fo.Close()
-	// Save principals
-	fo, _ = os.Create(principalFile)
-	ps := util.NewMessageStream(fo)
-	for i := range m.PrincipalArray {
-		principalRecord, _ := m.PrincipalArray[i].EncodePrincipal()
-		log.Printf("principalRecord size: %d\n", len(principalRecord))
-		_, _ = ps.WriteString(string(principalRecord))
-	}
-	fo.Close()
-
-	// Save rules (see above)
-	_ = m.SaveRules(ruleFile)
-	return nil
-}
-
-func AuthenticatePrincipal(m *ResourceMaster, ms *util.MessageStream, programPolicyObject *ProgramPolicy) (bool, []byte) {
-	log.Printf("AuthenticatePrincipal\n")
-	offeredCert, err := GetProtocolMessage(ms)
-	if err != nil {
-		log.Printf("cant GetProtocolMessage in AuthenticatePrincipal % x\n", offeredCert)
-		return false, nil
-	}
-	nonce := make([]byte, SizeofNonce)
-	_, err = rand.Read(nonce)
-	if err != nil {
-		log.Printf("Rand error in AuthenticatePrincipal\n")
-		return false, nil
-	}
-	SendProtocolMessage(ms, len(nonce), nonce)
-	signedRand, err := GetProtocolMessage(ms)
-	if err != nil {
-		log.Printf("cant GetProtocolMessage in AuthenticatePrincipal\n")
-		return false, nil
-	}
-	log.Printf("AuthenticatePrincipal: got signed nonce % x\n", signedRand)
-	// Decrypt nonce
-	cert, err := x509.ParseCertificate(offeredCert)
-	if err != nil {
-		log.Printf("cant Parse Certificate in AuthenticatePrincipal\n")
-		return false, nil
-	}
-	v, err := tao.FromX509(cert)
-	if err != nil {
-		log.Printf("cant get verifier from x509 AuthenticatePrincipal\n")
-		return false, nil
-	}
-	ok, err := v.Verify(nonce, ChallengeContext, signedRand)
-	if err != nil {
-		return false, nil
-	}
-	if ok {
-		var opts x509.VerifyOptions
-		roots := x509.NewCertPool()
-		if !programPolicyObject.Initialized {
-			log.Printf("ProgramPolicy not initialized")
-			return false, nil
-		}
-		policyCert, err := x509.ParseCertificate(programPolicyObject.ThePolicyCert)
-		if err != nil || policyCert == nil {
-			log.Printf("Can't parse policy cert")
-			return false, nil
-		}
-		roots.AddCert(policyCert)
-		opts.Roots = roots
-		// Now check cert chain
-		chains, err := cert.Verify(opts)
-		if chains == nil || err != nil {
-			log.Printf("Can't validate cert chain to policy")
-			return false, nil
-		}
-		log.Printf("Cert chain for challenge verified\n")
-	}
-	if ok {
-		log.Printf("nonce verified\n")
-	} else {
-		log.Printf("nonce did not verified\n")
-	}
-	var status string
-	if ok {
-		status = "succeeded"
-	} else {
-		status = "failed"
-	}
-	msg := ""
-	SendResponse(ms, status, msg, 0)
-	return ok, offeredCert
-}
-
-func AuthenticatePrincipalRequest(ms *util.MessageStream, key *tao.Keys, derCert []byte) bool {
-	log.Printf("AuthenticatePrincipalRequest\n")
-	// Format request
-	subject := string(derCert)
-	action := "authenticateprincipal"
-	err := SendRequest(ms, &subject, &action, &subject, nil)
-	if err != nil {
-		log.Printf("AuthenticatePrincipalRequest: couldn't send request\n")
-	}
-	SendProtocolMessage(ms, len(derCert), derCert)
-	nonce, err := GetProtocolMessage(ms)
-	if err != nil {
-		log.Printf("cant GetProtocolMessage in AuthenticatePrincipalRequest\n")
-		return false
-	}
-	log.Printf("AuthenticatePrincipalRequest: got nonce\n")
-	// Encrypt nonce
-	signedBlob, err := key.SigningKey.Sign(nonce, "fileproxy-challenge")
-	if err != nil {
-		log.Printf("AuthenticatePrincipalRequest: cant sign\n")
-	}
-	SendProtocolMessage(ms, len(signedBlob), signedBlob)
-	log.Printf("AuthenticatePrincipalRequest: sent signed\n")
-	status, _, _, err := GetResponse(ms)
-	if err != nil {
-		log.Printf("cant GetResponse in AuthenticatePrincipalRequest\n")
-		return false
-	}
-	log.Printf("AuthenticatePrincipalRequest: status of response: %s\n", *status)
-	return true
-}
-
-func readRequest(m *ResourceMaster, ms *util.MessageStream, resourcename string, symKey []byte) error {
-	log.Printf("filehandler: readRequest\n")
-	rInfo, _ := m.FindResource(resourcename)
-	if rInfo == nil {
-		SendResponse(ms, "failed", "resource does not exist", 0)
-		return nil
-	}
-	status := "succeeded"
-	SendResponse(ms, status, "", 0)
-	return SendFile(ms, m.BaseDirectory, resourcename, symKey)
-}
-
-func writeRequest(m *ResourceMaster, ms *util.MessageStream, resourcename string, symKey []byte) error {
-	log.Printf("filehandler: writeRequest\n")
-	rInfo, _ := m.FindResource(resourcename)
-	if rInfo == nil {
-		SendResponse(ms, "failed", "resource does not exist", 0)
-		return nil
-	}
-	status := "succeeded"
-	SendResponse(ms, status, "", 0)
-	return GetFile(ms, m.BaseDirectory, resourcename, symKey)
-}
-
-func createRequest(m *ResourceMaster, ms *util.MessageStream,
-	resourcename string, owner string) error {
-	log.Printf("filehandler: createRequest\n")
-	rInfo, _ := m.FindResource(resourcename)
-	if rInfo != nil {
-		SendResponse(ms, "failed", "resource exists", 0)
-		return nil
-	}
-	rInfo, _ = m.InsertResource(m.BaseDirectory, resourcename, owner)
-	if rInfo == nil {
-		SendResponse(ms, "failed", "cant insert resource", 0)
-		return nil
-	}
-	rInfo.PrintResourceInfo()
-	status := "succeeded"
-	SendResponse(ms, status, "", 0)
-	return nil
-}
-
-func newruleRequest(m *ResourceMaster, ms *util.MessageStream,
-	rule string, signerCert []byte) error {
-
-	log.Printf("filehandler, newruleRequest, rule: %s\n", rule)
-	signerName := PrincipalNameFromDERCert(signerCert)
-	if signerName == nil {
-		log.Printf("filehandler, newruleRequest: cant get name from cert\n")
-		return nil
-	}
-	prin, err := m.FindPrincipal(*signerName)
-	if prin != nil {
-		log.Printf("filehandler, newRuleRequest: found principal, %s %s\n", prin.Name, prin.Status)
-	}
-	if err != nil || prin == nil || !bytes.Equal(prin.Der, signerCert) {
-		SendResponse(ms, "failed", "cert doesn't match", 0)
-		return nil
-	}
-	// Check a signature?
-	m.Guard.AddRule(rule)
-	SendResponse(ms, "succeeded", "", 0)
-	return nil
-}
-
-func deleteRequest(m *ResourceMaster, ms *util.MessageStream, resourcename string) error {
-	return errors.New("deleteRequest not implemented")
-}
-
-func addRuleRequest(m *ResourceMaster, ms *util.MessageStream, resourcename string) error {
-	return errors.New("addRuleRequest not implemented")
-}
-
-func addOwnerRequest(m *ResourceMaster, ms *util.MessageStream, resourcename string) error {
-	return errors.New("addOwnerRequest not implemented")
-}
-
-func deleteOwnerRequest(m *ResourceMaster, ms *util.MessageStream, resourcename string) error {
-	return errors.New("deleteOwnerRequest not implemented")
-}
-
-func (m *ResourceMaster) certToAuthenticatedName(subjectCert []byte) *string {
-	if subjectCert == nil {
-		return nil
-	}
-	var subjectName *string
-	subjectName = nil
-	subjectName = PrincipalNameFromDERCert([]byte(subjectCert))
-	if subjectName == nil {
-		log.Printf("filehandler, certToAuthenticatedName: cant get name from cert\n")
-		return nil
-	}
-	prin, err := m.FindPrincipal(*subjectName)
-	if prin != nil {
-		log.Printf("filehandler, certToAuthenticatedName: found principal, %s %s\n", prin.Name, prin.Status)
-	}
-	if err != nil || prin == nil || bytes.Equal(prin.Der, []byte(*subjectName)) {
-		return nil
-	}
-	return subjectName
-}
-
-// First return value is terminate flag
-func (m *ResourceMaster) HandleServiceRequest(ms *util.MessageStream, programPolicyObject *ProgramPolicy, clientProgramName string, request []byte) (bool, error) {
-	log.Printf("filehandler: HandleServiceRequest\n")
-
-	fpMessage := new(FPMessage)
-	err := proto.Unmarshal(request, fpMessage)
-	if err != nil {
-		return false, errors.New("HandleService can't unmarshal request")
-	}
-	if fpMessage.MessageType == nil {
-		return false, errors.New("HandleService: no message type")
-	}
-	switch MessageType(*fpMessage.MessageType) {
-	default:
-		return false, errors.New("HandleService does not get MessageType_REQUEST")
-	case MessageType_REQUEST:
-	}
-	action := fpMessage.ActionName
-	if action == nil {
-		SendResponse(ms, "failed", "", 0)
-		return false, errors.New("no action")
-	}
-	subject := fpMessage.SubjectName
-	resourceName := fpMessage.ResourceName
-	owner := fpMessage.ResourceOwner
-
-	log.Printf("HandleServiceRequest %s\n", *action)
-
-	switch *action {
-	case "authenticateprincipal":
-		ok, ownerCert := AuthenticatePrincipal(m, ms, programPolicyObject)
-		if ok {
-			ownerName := PrincipalNameFromDERCert([]byte(ownerCert))
-			if ownerName == nil {
-				log.Printf("can't get ownername after AuthenticatePrincipal\n")
-				return false, nil
-			}
-			log.Printf("filehandler inserting %s %s\n", *ownerName, "authenticated")
-			_, err = m.InsertPrincipal(*ownerName, []byte(ownerCert), "authenticated")
-			if err != nil {
-				log.Printf("cant insert principal name in file\n")
-				return false, errors.New("cant insert principal name in file")
-			}
-			log.Printf("HandleServiceRequest: Added %s to Principal table\n", *ownerName)
-			return false, nil
-		} else {
-			return false, errors.New("AuthenticatePrincipal failed")
-		}
-	case "sendrule":
-		log.Printf("filehandler sendrule %s\n", *resourceName)
-		if resourceName == nil || owner == nil {
-			SendResponse(ms, "failed", "no ownername or resourcename", 0)
-			return false, nil
-		}
-		err = newruleRequest(m, ms, *resourceName /* rule */, []byte(*owner))
-		if err != nil {
-			return false, errors.New("Can't construct newrulequest")
-		}
-		return false, nil
-	default:
-	}
-
-	// Replace owner and subject with name
-	var ownerName *string
-	ownerName = nil
-	if owner != nil {
-		ownerName = m.certToAuthenticatedName([]byte(*owner))
-		if ownerName == nil {
-			status := "failed"
-			message := "unknown owner specified"
-			SendResponse(ms, status, message, 0)
-			return false, errors.New("unauthenticated principal")
-		}
-	}
-	var subjectName *string
-	subjectName = nil
-	if subject != nil {
-		subjectName = m.certToAuthenticatedName([]byte(*subject))
-		if subjectName == nil {
-			status := "failed"
-			message := "unknown owner specified"
-			SendResponse(ms, status, message, 0)
-			return false, errors.New("unauthenticated principal")
-		}
-	}
-	if subjectName != nil {
-		log.Printf("filehandler, HandleRequest, Subjectname: %s\n", *subjectName)
-	}
-	if ownerName != nil {
-		log.Printf("filehandler, HandleRequest, Ownername: %s\n", *ownerName)
-	}
-
-	// Is it authorized?
-	var ok bool
-	switch *action {
-	case "create":
-		if ownerName == nil {
-			SendResponse(ms, "failed", "no owner name", 0)
-			return false, nil
-		}
-		addResource(*ownerName, *resourceName, m.Guard)
-		fileserverSubject := "fileserver"
-		query := makeQuery(fileserverSubject, *action, *resourceName)
-		if query == nil {
-			log.Printf("bad query")
-		}
-		ok = m.Query(*query)
-
-	case "getfile":
-		if subjectName == nil || resourceName == nil {
-			SendResponse(ms, "failed", "no subjectname or resourcename", 0)
-			return false, nil
-		}
-		query := makeQuery(*subjectName, *action, *resourceName)
-		if query == nil {
-			log.Printf("bad query")
-		}
-		ok = m.Query(*query)
-	case "sendfile":
-		if subjectName == nil || resourceName == nil {
-			SendResponse(ms, "failed", "no subjectname or resourcename", 0)
-			return false, nil
-		}
-		query := makeQuery(*subjectName, *action, *resourceName)
-		if query == nil {
-			log.Printf("bad query")
-		}
-		ok = m.Query(*query)
-	default:
-		ok = false
-	}
-	if ok == false {
-		SendResponse(ms, "failed", "unauthorized", 0)
-		return false, nil
-	}
-
-	switch *action {
-	case "create":
-		if resourceName == nil || ownerName == nil {
-			return false, errors.New("Nil parameters for createRequest")
-		}
-		err := createRequest(m, ms, *resourceName, *ownerName)
-		return false, err
-	case "delete":
-		err := deleteRequest(m, ms, *resourceName)
-		return false, err
-	case "getfile":
-		if programPolicyObject.ProgramSymKeys == nil {
-			log.Printf("HandleFileRequest, getfile keys nil\n")
-		} else {
-			log.Printf("HandleFileRequest, getfile keys NOT nil\n")
-		}
-		err := readRequest(m, ms, *resourceName, programPolicyObject.ProgramSymKeys)
-		return false, err
-	case "sendfile":
-		if programPolicyObject.ProgramSymKeys == nil {
-			log.Printf("HandleFileRequest, sendfile keys nil\n")
-		} else {
-			log.Printf("HandleFileRequest, sendfile keys NOT nil\n")
-		}
-		err := writeRequest(m, ms, *resourceName, programPolicyObject.ProgramSymKeys)
-		return false, err
-	case "terminate":
-		return true, nil
-	default:
-		SendResponse(ms, "failed", "unsupported action", 0)
-		return false, errors.New("unsupported action")
-	}
-}
-
-func (m *ResourceMaster) InitMaster(filepath string, masterInfoDir string, prin string) error {
-	log.Printf("filehandler: InitMaster\n")
-	m.Policy = policy
-	m.AdditionalPolicy = additional_policy
-	m.ResourceArray = make([]ResourceInfo, 100)
-	m.ResourceArray = m.ResourceArray[0:0]
-	m.PrincipalArray = make([]PrincipalInfo, 100)
-	m.PrincipalArray = m.PrincipalArray[0:0]
-	m.BaseDirectory = filepath
-	m.InitGuard(masterInfoDir + "rules")
-	m.PrintAllPolicy()
-	return nil
-}
-
-func (m *ResourceMaster) SaveMaster(masterInfoDir string) error {
-	log.Printf("filehandler: SaveMaster\n")
-	err := m.SaveResourceData(masterInfoDir+"masterFile", masterInfoDir+"resourceFile",
-		masterInfoDir+"resourceFile", masterInfoDir+"ruleFile")
-	if err != nil {
-		log.Printf("filehandler: cant m.SaveResourceData\n")
-		return err
-	}
-	return m.SaveRules(masterInfoDir + "rules")
-}
diff --git a/apps/fileproxy/fileproxy.go b/apps/fileproxy/fileproxy.go
index fbcdab4..266ce8d 100644
--- a/apps/fileproxy/fileproxy.go
+++ b/apps/fileproxy/fileproxy.go
@@ -1,782 +1,337 @@
-// Copyright (c) 2014, Google, Inc..  All rights reserved.
+// Copyright (c) 2014, Google, Inc. All rights reserved.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
 // You may obtain a copy of the License at
+//
 //     http://www.apache.org/licenses/LICENSE-2.0
+//
 // Unless required by applicable law or agreed to in writing, software
 // distributed under the License is distributed on an "AS IS" BASIS,
 // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 // See the License for the specific language governing permissions and
 // limitations under the License.
 //
 // File: fileproxy.go
 
 package fileproxy
 
 import (
-	"bytes"
 	"crypto/aes"
 	"crypto/cipher"
 	"crypto/hmac"
 	"crypto/rand"
 	"crypto/sha256"
-	"crypto/tls"
 	"crypto/x509"
 	"errors"
-	"flag"
+	"fmt"
 	"hash"
-	"io"
-	"io/ioutil"
-	"log"
 	"os"
-	"strings"
-
-	"code.google.com/p/goprotobuf/proto"
+	"path"
 
 	"github.com/jlmucb/cloudproxy/tao"
 	"github.com/jlmucb/cloudproxy/tao/auth"
 	taonet "github.com/jlmucb/cloudproxy/tao/net"
 	"github.com/jlmucb/cloudproxy/util"
 )
 
-var caAddr = flag.String("caAddr", "localhost:8124", "The address to listen on")
-var taoChannelAddr = flag.String("taoChannelAddr", "localhost:8124", "The address to listen on")
-var configPath = flag.String("config", "tao.config", "The Tao domain config")
-
-const SizeofSymmetricKeys = 64
+// The size of a symmetric key is the size of an AES key plus the size of an
+// HMAC key.
+const SymmetricKeySize = 64
 
+// A ProgramPolicy object represents the current domain policy of a program.
 type ProgramPolicy struct {
-	Initialized       bool
-	TaoName           string
-	ThePolicyCert     []byte
-	ProgramSigningKey tao.Keys
-	ProgramSymKeys    []byte
-	ProgramCert       []byte
-}
-
-func (pp *ProgramPolicy) InitProgramPolicy(policyCert []byte, taoName string, signingKey tao.Keys, symKeys []byte, programCert []byte) bool {
-	log.Printf("InitProgramPolicy\n")
-	pp.ThePolicyCert = policyCert
-	pp.TaoName = taoName
-	pp.ProgramSigningKey = signingKey
-	pp.ProgramSymKeys = symKeys
-	pp.ProgramCert = programCert
-	pp.Initialized = true
-	log.Printf("InitProgramPolicy done\n")
-	return true
-}
-
-// RequestTruncatedAttestation connects to a CA instance, sends the attestation
-// for an X.509 certificate, and gets back a truncated attestation with a new
-// principal name based on the policy key.
-func RequestKeyNegoAttestation(network, addr string, keys *tao.Keys, v *tao.Verifier) (*tao.Attestation, error) {
-	if keys.Cert == nil {
-		return nil, errors.New("client: can't dial with an empty client certificate\n")
-	}
-	tlsCert, err := taonet.EncodeTLSCert(keys)
-	if err != nil {
-		return nil, err
-	}
-	conn, err := tls.Dial(network, addr, &tls.Config{
-		RootCAs:            x509.NewCertPool(),
-		Certificates:       []tls.Certificate{*tlsCert},
-		InsecureSkipVerify: true,
-	})
-	if err != nil {
-		return nil, err
-	}
-	defer conn.Close()
-
-	// Tao handshake: send client delegation.
-	ms := util.NewMessageStream(conn)
-	if _, err = ms.WriteMessage(keys.Delegation); err != nil {
-		return nil, err
-	}
-
-	// Read the truncated attestation and check it.
-	var a tao.Attestation
-	if err := ms.ReadMessage(&a); err != nil {
-		return nil, err
-	}
-
-	ok, err := v.Verify(a.SerializedStatement, tao.AttestationSigningContext, a.Signature)
-	if err != nil {
-		return nil, err
-	}
-	if !ok {
-		return nil, errors.New("invalid attestation signature from Tao CA")
-	}
-
-	return &a, nil
+	TaoName     string
+	PolicyCert  []byte
+	SigningKey  *tao.Keys
+	SymKeys     []byte
+	ProgramCert []byte
 }
 
-func ZeroBytes(buf []byte) {
-	n := len(buf)
-	for i := 0; i < n; i++ {
-		buf[i] = 0
+// NewProgramPolicy creates a new ProgramPolicy for a given set of keys.
+func NewProgramPolicy(policyCert []byte, taoName string, signingKey *tao.Keys, symKeys []byte, programCert []byte) *ProgramPolicy {
+	pp := &ProgramPolicy{
+		PolicyCert:  policyCert,
+		TaoName:     taoName,
+		SigningKey:  signingKey,
+		SymKeys:     symKeys,
+		ProgramCert: programCert,
 	}
+	return pp
 }
 
-func PrincipalNameFromDERCert(derCert []byte) *string {
-	cert, err := x509.ParseCertificate(derCert)
-	if err != nil {
-		log.Printf("PrincipalNameFromDERCert: Can't get name from certificate\n")
-		return nil
-	}
-	cn := cert.Subject.CommonName
-	return &cn
-}
-
-// returns sealed symmetric key, sealed signing key, DER encoded cert, delegation, error
-func LoadProgramKeys(path string) ([]byte, []byte, []byte, []byte, error) {
-	_, err := os.Stat(path + "sealedsymmetrickey")
-	if err != nil {
-		return nil, nil, nil, nil, err
-	}
-	_, err = os.Stat(path + "sealedsigningKey")
+// EstablishCert contacts a CA to get a certificate signed by the policy key. It
+// replaces the current delegation and cert on k with the new delegation and
+// cert from the response.
+func EstablishCert(network, addr string, k *tao.Keys, v *tao.Verifier) error {
+	na, err := taonet.RequestAttestation(network, addr, k, v)
 	if err != nil {
-		return nil, nil, nil, nil, err
-	}
-	_, err = os.Stat(path + "signerCert")
-	if err != nil {
-		return nil, nil, nil, nil, err
-	}
-
-	sealedSymmetricKey, err := ioutil.ReadFile(path + "sealedsymmetricKey")
-	if err != nil {
-		return nil, nil, nil, nil, err
-	}
-	log.Printf("fileproxy: Got sealedSymmetricKey\n")
-	sealedSigningKey, err := ioutil.ReadFile(path + "sealedsigningKey")
-	if err != nil {
-		return nil, nil, nil, nil, err
-	}
-	log.Printf("fileproxy: Got sealedSigningKey\n")
-	derCert, err := ioutil.ReadFile(path + "signerCert")
-	if err != nil {
-		return nil, nil, nil, nil, err
-	}
-	log.Printf("fileproxy: Got signerCert\n")
-	ds, err := ioutil.ReadFile(path + "delegationBlob")
-	if err != nil {
-		return nil, nil, nil, nil, err
+		return err
 	}
-	log.Printf("LoadProgramKeys succeeded\n")
-	return sealedSymmetricKey, sealedSigningKey, derCert, ds, nil
-}
 
-func CreateSigningKey(t tao.Tao) (*tao.Keys, []byte, error) {
-	log.Printf("CreateSigningKey\n")
-	self, err := t.GetTaoName()
-	k, err := tao.NewTemporaryKeys(tao.Signing)
-	if k == nil || err != nil {
-		return nil, nil, errors.New("Can't generate signing key")
-	}
-	publicString := strings.Replace(self.String(), "(", "", -1)
-	publicString = strings.Replace(publicString, ")", "", -1)
-	details := tao.X509Details{
-		Country:      "US",
-		Organization: "Google",
-		CommonName:   publicString}
-	subjectname := tao.NewX509Name(details)
-	derCert, err := k.SigningKey.CreateSelfSignedDER(subjectname)
-	if err != nil {
-		return nil, nil, errors.New("Can't self sign cert\n")
-	}
-	cert, err := x509.ParseCertificate(derCert)
+	k.Delegation = na
+	pa, err := auth.UnmarshalForm(na.SerializedStatement)
 	if err != nil {
-		return nil, nil, err
-	}
-	k.Cert = cert
-	s := &auth.Speaksfor{
-		Delegate:  k.SigningKey.ToPrincipal(),
-		Delegator: self}
-	if s == nil {
-		return nil, nil, errors.New("Can't produce speaksfor")
-	}
-	if k.Delegation, err = t.Attest(&self, nil, nil, s); err != nil {
-		return nil, nil, err
-	}
-	if err == nil {
-		_, _ = auth.UnmarshalForm(k.Delegation.SerializedStatement)
+		return err
 	}
-	return k, derCert, nil
-}
 
-func InitializeSealedSymmetricKeys(path string, t tao.Tao, keysize int) ([]byte, error) {
-	log.Printf("InitializeSealedSymmetricKeys\n")
-	unsealed, err := tao.Parent().GetRandomBytes(keysize)
-	if err != nil {
-		return nil, errors.New("Can't get random bytes")
-	}
-	sealed, err := tao.Parent().Seal(unsealed, tao.SealPolicyDefault)
-	if err != nil {
-		return nil, errors.New("Can't seal random bytes")
-	}
-	ioutil.WriteFile(path+"sealedsymmetrickey", sealed, os.ModePerm)
-	return unsealed, nil
-}
-
-func InitializeSealedSigningKey(path string, t tao.Tao, domain tao.Domain) (*tao.Keys, error) {
-	log.Printf("InitializeSealedSigningKey\n")
-	k, derCert, err := CreateSigningKey(t)
-	if err != nil {
-		log.Printf("fileproxy: CreateSigningKey failed with error %s\n", err)
-		return nil, err
-	}
-	if derCert == nil {
-		log.Printf("fileproxy: CreateSigningKey failed, no dercert\n")
-		return nil, errors.New("No DER cert")
-	}
-	na, err := RequestKeyNegoAttestation("tcp", *caAddr, k, domain.Keys.VerifyingKey)
-	if err != nil {
-		log.Printf("fileproxy: error from taonet.RequestTruncatedAttestation\n")
-		return nil, err
-	}
-	if na == nil {
-		return nil, errors.New("tao returned nil attestation")
-	}
-	k.Delegation = na
-	pa, _ := auth.UnmarshalForm(na.SerializedStatement)
+	// Parse the received statement.
 	var saysStatement *auth.Says
 	if ptr, ok := pa.(*auth.Says); ok {
 		saysStatement = ptr
 	} else if val, ok := pa.(auth.Says); ok {
 		saysStatement = &val
 	}
 	sf, ok := saysStatement.Message.(auth.Speaksfor)
 	if ok != true {
-		return nil, errors.New("says doesnt have speaksfor message")
+		return errors.New("says doesn't have speaksfor message")
 	}
+
 	kprin, ok := sf.Delegate.(auth.Term)
 	if ok != true {
-		return nil, errors.New("speaksfor message doesnt have Delegate")
+		return errors.New("speaksfor message doesn't have Delegate")
 	}
 	newCert := auth.Bytes(kprin.(auth.Bytes))
 	k.Cert, err = x509.ParseCertificate(newCert)
 	if err != nil {
-		log.Printf("can't parse returned certificate", err)
-		log.Printf("\n")
-		return nil, err
-	}
-	signingKeyBlob, err := tao.MarshalSignerDER(k.SigningKey)
-	if err != nil {
-		return nil, errors.New("Can't produce signing key blob")
-	}
-	sealedSigningKey, err := t.Seal(signingKeyBlob, tao.SealPolicyDefault)
-	if err != nil {
-		return nil, errors.New("Can't seal signing key")
-	}
-	err = ioutil.WriteFile(path+"sealedsigningKey", sealedSigningKey, os.ModePerm)
-	if err != nil {
-		return nil, err
-	}
-	err = ioutil.WriteFile(path+"signerCert", newCert, os.ModePerm)
-	if err != nil {
-		return nil, err
-	}
-	delegateBlob, err := proto.Marshal(k.Delegation)
-	if err != nil {
-		return nil, errors.New("Can't seal random bytes")
-	}
-	err = ioutil.WriteFile(path+"delegationBlob", delegateBlob, os.ModePerm)
-	if err != nil {
-		return nil, err
+		return err
 	}
-	return k, nil
-}
 
-func SigningKeyFromBlob(t tao.Tao, sealedKeyBlob []byte, certBlob []byte, delegateBlob []byte) (*tao.Keys, error) {
-	log.Printf("SigningKeyFromBlob\n")
-	k := &tao.Keys{}
-	cert, err := x509.ParseCertificate(certBlob)
-	if err != nil {
-		return nil, err
-	}
-	k.Cert = cert
-	k.Delegation = new(tao.Attestation)
-	err = proto.Unmarshal(delegateBlob, k.Delegation)
-	if err != nil {
-		return nil, err
-	}
-	log.Printf("SigningKeyFromBlob: unmarshaled\n")
-	signingKeyBlob, policy, err := tao.Parent().Unseal(sealedKeyBlob)
-	if err != nil {
-		log.Printf("fileproxy: signingkey unsealing error: %s\n", err)
-	}
-	if policy != tao.SealPolicyDefault {
-		log.Printf("fileproxy: unexpected policy on unseal\n")
-	}
-	log.Printf("fileproxy: Unsealed Signing Key blob: %x\n", signingKeyBlob)
-	k.SigningKey, err = tao.UnmarshalSignerDER(signingKeyBlob)
-	k.Cert = cert
-	return k, err
+	return nil
 }
 
-func SendRequest(ms *util.MessageStream, subject *string, action *string, item *string, owner *string) error {
-	if action == nil {
-		log.Printf("SendRequest\n")
-	} else {
-		log.Printf("SendRequest %s\n", *action)
-	}
-	fpMessage := new(FPMessage)
-	fpMessage.MessageType = proto.Int32(int32(MessageType_REQUEST))
-	if subject != nil {
-		fpMessage.SubjectName = proto.String(string(*subject))
-	}
-	if action != nil {
-		fpMessage.ActionName = proto.String(*action)
-	}
-	if item != nil {
-		fpMessage.ResourceName = proto.String(*item)
-	}
-	if owner != nil {
-		fpMessage.ResourceOwner = proto.String(*owner)
-	}
-	out, err := proto.Marshal(fpMessage)
-	if err != nil {
-		log.Printf("SendRequest: can't marshal message\n")
-		return errors.New("transmission error")
-	}
-	_, err = ms.WriteString(string(out))
-	return err
-}
+const bufferSize = 2048
+const ivSize = 16
+const hmacKeySize = 16
+const aesKeySize = 16
+const minKeySize = hmacKeySize + aesKeySize
 
-func SendCounterRequest(ms *util.MessageStream, counter int64) error {
-	log.Printf("SendCounterRequest")
-	fpMessage := new(FPMessage)
-	fpMessage.MessageType = proto.Int32(int32(MessageType_REQUEST))
-	fpMessage.ActionName = proto.String("setrollbackcounter")
-	fpMessage.MonotonicCounter = proto.Int64(counter)
-	log.Printf("SendCounterRequest, counter: %d\n", counter)
-	out, err := proto.Marshal(fpMessage)
+// SendFile reads a file from disk and streams it to a receiver across a
+// MessageStream. If there are sufficient bytes in the keys (at least
+// hmacKeySize+aesKeySize), then it will attempt to check the integrity of the
+// file with HMAC-SHA256 and decrypt it with AES-CTR-128.
+func SendFile(ms *util.MessageStream, dir string, filename string, keys []byte) error {
+	fullpath := path.Join(dir, filename)
+	fileInfo, err := os.Stat(fullpath)
 	if err != nil {
-		log.Printf("SendCounterRequest: can't marshal message\n")
-		return errors.New("transmission error")
+		return fmt.Errorf("in SendFile: no file '%s' found: %s", fullpath, err)
 	}
-
-	_, err = ms.WriteString(string(out))
-	return err
-}
-
-func SendCounterResponse(ms *util.MessageStream, status string, errMessage string, counter int64) error {
-	log.Printf("SendCounterResponse %d\n", counter)
-	fpMessage := new(FPMessage)
-	fpMessage.MessageType = proto.Int32(int32(MessageType_RESPONSE))
-	fpMessage.MonotonicCounter = proto.Int64(counter)
-	fpMessage.StatusOfRequest = proto.String(status)
-	fpMessage.MessageFromRequest = proto.String(errMessage)
-	out, err := proto.Marshal(fpMessage)
+	file, err := os.Open(fullpath)
 	if err != nil {
-		log.Printf("SendCounterResponse: can't marshal message\n")
-		return errors.New("transmission error")
+		return fmt.Errorf("in SendFile: can't open file '%s': %s", fullpath, err)
 	}
+	defer file.Close()
 
-	_, err = ms.WriteString(string(out))
-	return err
-}
-
-func PrintRequest(subject []byte, action *string, resource *string, owner []byte) {
-	log.Printf("PrintRequest\n")
-	if subject != nil {
-		log.Printf("\tsubject: % x\n", subject)
-		subjectName := PrincipalNameFromDERCert(subject)
-		if subjectName != nil {
-			log.Printf("\tsubject: %s\n", *subjectName)
+	// This encryption scheme uses AES-CTR with HMAC-SHA256 for integrity
+	// protection.
+	var hm hash.Hash
+	var ctr cipher.Stream
+	iv := make([]byte, ivSize)
+	hasKeys := len(keys) >= minKeySize
+
+	// The variable "left" gives the total number of bytes left to read from
+	// the (maybe encrypted) file.
+	left := fileInfo.Size()
+	buf := make([]byte, bufferSize)
+	if hasKeys {
+		dec, err := aes.NewCipher(keys[:aesKeySize])
+		if err != nil || dec == nil {
+			return fmt.Errorf("can't create AES cipher in SendFile: %s", err)
 		}
-	}
-	if action != nil {
-		log.Printf("\taction: %s\n", *action)
-	}
-	if resource != nil {
-		log.Printf("\tresource: %s\n", *resource)
-	}
-	if owner != nil {
-		log.Printf("\towner: % x\n", owner)
-		ownerName := PrincipalNameFromDERCert(owner)
-		if ownerName != nil {
-			log.Printf("\towner: %s\n", *ownerName)
+		if _, err := file.Read(iv); err != nil {
+			return err
 		}
-	}
-}
+		// Remove the IV from the number of remaining bytes to decrypt.
+		left = left - ivSize
 
-func GetResponse(ms *util.MessageStream) (*string, *string, *int, error) {
-	log.Printf("GetResponse\n")
+		// Take all the remaining key bytes for the HMAC key.
+		hm = hmac.New(sha256.New, keys[aesKeySize:])
+		hmacSize := hm.Size()
 
-	strbytes, err := ms.ReadString()
+		// The HMAC input starts with the IV.
+		hm.Write(iv)
 
-	fpMessage := new(FPMessage)
-	err = proto.Unmarshal([]byte(strbytes), fpMessage)
-	if err != nil {
-		return nil, nil, nil, errors.New("GetResponse can't unmarshal message")
-	}
-	if fpMessage.MessageType == nil {
-		return nil, nil, nil, errors.New("GetResponse: no message type")
-	}
-	if *fpMessage.MessageType != int32(MessageType_RESPONSE) {
-		log.Printf("GetResponse bad type\n")
-		return nil, nil, nil, errors.New("reception error")
-	}
-	var status *string
-	var errMessage *string
-	var size int
-
-	if fpMessage.StatusOfRequest == nil {
-		log.Printf("GetResponse no status\n")
-		return nil, nil, nil, errors.New("reception error")
-	}
-	status = fpMessage.StatusOfRequest
-	errMessage = fpMessage.MessageFromRequest
-	if fpMessage.BufferSize == nil {
-		return status, errMessage, nil, nil
-	} else {
-		size = int(*fpMessage.BufferSize)
-		return status, errMessage, &size, nil
-	}
-}
-
-func GetCounterResponse(ms *util.MessageStream) (*string, *string, *int64, error) {
-	strbytes, err := ms.ReadString()
-	log.Printf("GetCounterResponse read %d bytes\n", len(strbytes))
-
-	fpMessage := new(FPMessage)
-	err = proto.Unmarshal([]byte(strbytes), fpMessage)
-	if err != nil {
-		return nil, nil, nil, errors.New("GetCounterResponse can't unmarshal message")
-	}
-	if fpMessage.MessageType == nil {
-		return nil, nil, nil, errors.New("GetCounterResponse: no message type")
-	}
-	if *fpMessage.MessageType != int32(MessageType_RESPONSE) {
-		log.Printf("GetCounterResponse bad type\n")
-		return nil, nil, nil, errors.New("reception error")
-	}
-	var status *string
-	var errMessage *string
-
-	if fpMessage.StatusOfRequest == nil {
-		log.Printf("GetResponse no status\n")
-		return nil, nil, nil, errors.New("reception error")
-	}
-	status = fpMessage.StatusOfRequest
-	if status == nil {
-		log.Printf("GetCounterResponse status is nil\n")
-	} else {
-		log.Printf("GetCounterResponse status: %s\n", *status)
-	}
-	errMessage = fpMessage.MessageFromRequest
-	if fpMessage.MonotonicCounter == nil {
-		log.Printf("GetCounterResponse fpMessage.MonotonicCounter is nil\n")
-		return status, errMessage, nil, nil
-	} else {
-		counter := *fpMessage.MonotonicCounter
-		log.Printf("GetCounterResponse counter: %d\n", counter)
-		return status, errMessage, &counter, nil
-	}
-}
+		ctr = cipher.NewCTR(dec, iv)
+		if ctr == nil {
+			return fmt.Errorf("can't create AES-CTR encryption")
+		}
 
-func PrintResponse(status *string, message *string, size *int) {
-	log.Printf("PrintResponse\n")
-	if status != nil {
-		log.Printf("\tstatus: %s\n", *status)
-	} else {
-		log.Printf("\tstatus: empty\n")
-	}
-	if message != nil {
-		log.Printf("\tmessage: %s\n", *message)
-	}
-	if size != nil {
-		log.Printf("\tsize: %d\n", *size)
-	}
-}
+		// Remove the HMAC-SHA256 output from the bytes to check.
+		left = left - int64(hmacSize)
+
+		// Secure decryption in this case requires reading the file
+		// twice: once to check the MAC, and once to decrypt the bytes.
+		// The MAC must be checked before *any* decryption occurs and
+		// before *any* decrypted bytes are sent to the receiver.
+		for {
+			// Figure out how many bytes to read on this iteration.
+			var readSize int64 = bufferSize
+			final := false
+			if left <= bufferSize {
+				readSize = left
+				final = true
+			}
+
+			// Read the (maybe encrypted) bytes from the file.
+			n, err := file.Read(buf[:readSize])
+			if err != nil {
+				return err
+			}
+			left = left - int64(n)
+			hm.Write(buf[:n])
+			if final {
+				break
+			}
+		}
+		computed := hm.Sum(nil)
+		original := buf[:hmacSize]
 
-func SendResponse(ms *util.MessageStream, status string, errMessage string, size int) error {
-	fpMessage := new(FPMessage)
-	fpMessage.MessageType = proto.Int32(int32(MessageType_RESPONSE))
-	fpMessage.StatusOfRequest = proto.String(status)
-	fpMessage.MessageFromRequest = proto.String(errMessage)
-	out, err := proto.Marshal(fpMessage)
-	if err != nil {
-		log.Printf("SendResponse can't encode response\n")
-		return err
-	}
-	send := string(out)
-	log.Printf("SendResponse sending %s %s %d\n", status, errMessage, len(send))
-	n, err := ms.WriteString(send)
-	if err != nil {
-		log.Printf("SendResponse Writestring error %d\n", n, err)
-		return err
-	}
-	return nil
-}
+		// Read the file's version of the HMAC and check it securely
+		// against the computed version.
+		if _, err := file.Read(original); err != nil {
+			return err
+		}
+		if !hmac.Equal(computed, original) {
+			return fmt.Errorf("invalid file HMAC on decryption for file '%s'", fullpath)
+		}
 
-func SendProtocolMessage(ms *util.MessageStream, size int, buf []byte) error {
-	log.Printf("SendProtocolMessage\n")
-	fpMessage := new(FPMessage)
-	fpMessage.MessageType = proto.Int32(int32(MessageType_PROTOCOL_RESPONSE))
-	fpMessage.BufferSize = proto.Int32(int32(size))
-	fpMessage.TheBuffer = proto.String(string(buf))
-	out, err := proto.Marshal(fpMessage)
-	if err != nil {
-		log.Printf("SendResponse can't encode response\n")
-		return err
-	}
-	n, err := ms.WriteString(string(out))
-	if err != nil {
-		log.Printf("SendProtocolMessage Writestring error %d\n", n, err)
-		return err
-	}
-	return nil
-}
+		// Go back to the beginning of the file (minus the IV) for
+		// decryption.
+		if _, err := file.Seek(ivSize, 0); err != nil {
+			return fmt.Errorf("couldn't seek back to the beginning of file '%s': %s", fullpath, err)
+		}
 
-func GetProtocolMessage(ms *util.MessageStream) ([]byte, error) {
-	log.Printf("GetProtocolMessage\n")
-	strbytes, err := ms.ReadString()
-	if err != nil {
-		return nil, err
-	}
-	fpMessage := new(FPMessage)
-	err = proto.Unmarshal([]byte(strbytes), fpMessage)
-	if err != nil {
-		return nil, errors.New("GetProtocolMessage can't unmarshal message")
-	}
-	if fpMessage.MessageType == nil {
-		return nil, errors.New("GetProtocolMessage: no message type")
-	}
-	if *fpMessage.MessageType != int32(MessageType_PROTOCOL_RESPONSE) {
-		return nil, errors.New("GetProtocolMessage: Wrong message type")
-	}
-	out := fpMessage.TheBuffer
-	if out == nil {
-		return nil, errors.New("GetProtocolMessage: empty buffer")
+		// Reset the number of bytes so it only includes the encrypted
+		// bytes.
+		left = fileInfo.Size() - int64(ivSize+hmacSize)
 	}
-	return []byte(*out), nil
-}
 
-func SendFile(ms *util.MessageStream, path string, filename string, keys []byte) error {
-	log.Printf("SendFile %s%s\n", path, filename)
+	// The input buffer, and a temporary buffer for holding decrypted
+	// plaintext.
+	temp := make([]byte, bufferSize)
 
-	fpMessage := new(FPMessage)
-	var buf []byte
-	buf = make([]byte, 2048)
-	fileInfo, err := os.Stat(path + filename)
-	if err != nil {
-		return errors.New("SendFile no such file")
-	}
-	file, err := os.Open(path + filename)
-	if err != nil {
-		return errors.New("SendFile: can't open file ")
+	// Set up a framing message to use to send the data.
+	m := &Message{
+		Type: MessageType_FILE_NEXT.Enum(),
 	}
-	defer file.Close()
 
-	var aesObj cipher.Block
-	var iv [16]byte
-	var ctrCipher cipher.Stream
-
-	bytesLeft := int(fileInfo.Size())
-	var final bool
-	final = false
-	var toRead int
-	var plaintext []byte
-	var hmacObj hash.Hash
-	plaintext = make([]byte, 2048)
-	if keys != nil {
-		aesObj, err = aes.NewCipher(keys[0:16])
-		if err != nil || aesObj == nil {
-			log.Printf("SendFile can't create aes object")
-		}
-		// read iv
-		_, err := file.Read(iv[:])
-		if err != nil {
-			return err
-		}
-		hmacObj = hmac.New(sha256.New, keys[16:32])
-		log.Printf("SendFile initialized hmac keys %x", keys[16:32])
-		hmacObj.Write(iv[:])
-		log.Printf("SendFile wrote iv to hmac %x", iv)
-		ctrCipher = cipher.NewCTR(aesObj, iv[:])
-		if ctrCipher == nil {
-			log.Printf("SendFile can't create counter cipher object")
-		}
-		bytesLeft = bytesLeft - 16
-		log.Printf("sent iv message\n")
-	}
-	if keys != nil {
-		bytesLeft = bytesLeft - 32
-	}
+	// Now that the integrity of the data has been verified, if needed, send
+	// the data (after decryption, if necessary) to the receiver.
 	for {
-		if bytesLeft <= 2048 {
-			toRead = bytesLeft
+		// Figure out how many bytes to read on this iteration.
+		var readSize int64 = bufferSize
+		final := false
+		if left <= bufferSize {
+			readSize = left
 			final = true
-		} else {
-			toRead = 2048
+			m.Type = MessageType_FILE_LAST.Enum()
 		}
-		n, err := file.Read(buf[0:toRead])
+
+		// Read the (maybe encrypted) bytes from the file.
+		n, err := file.Read(buf[:readSize])
 		if err != nil {
 			return err
 		}
-		if final {
-			fpMessage.MessageType = proto.Int32(int32(MessageType_FILE_LAST))
-		} else {
-			fpMessage.MessageType = proto.Int32(int32(MessageType_FILE_NEXT))
-		}
-		bytesLeft = bytesLeft - n
-		fpMessage.BufferSize = proto.Int32(int32(n))
-		if keys != nil {
-			hmacObj.Write(buf[0:n])
-			log.Printf("SendFile wrote to hmac %x", buf[0:n])
-			ctrCipher.XORKeyStream(plaintext[0:n], buf[0:n])
-			fpMessage.TheBuffer = proto.String(string(plaintext[0:n]))
-			log.Printf("sent cipher block %d\n", n)
+		left = left - int64(n)
+
+		if hasKeys {
+			ctr.XORKeyStream(temp[:n], buf[:n])
+			m.Data = temp[:n]
 		} else {
-			fpMessage.TheBuffer = proto.String(string(buf[0:n]))
+			m.Data = buf[:n]
 		}
-		out, err := proto.Marshal(fpMessage)
-		if err != nil {
-			log.Printf("SendFile can't file contents message\n")
-			return errors.New("transmission error")
+
+		// Send the decrypted data to the receiver.
+		if _, err := ms.WriteMessage(m); err != nil {
+			return err
 		}
-		_, _ = ms.WriteString(string(out))
 		if final {
 			break
 		}
 	}
-	if keys != nil {
-		// read mac and check it
-		_, err := file.Read(buf[0:32])
-		if err != nil {
-			return err
-		}
-		mac := hmacObj.Sum(nil)
-		if bytes.Equal(mac, buf[0:32]) {
-			log.Printf("SendFile: hmac matches\n")
-		} else {
-			log.Printf("SendFile: hmac does not match\n")
-			log.Printf("expected: %x\n", mac)
-			log.Printf("received: %x\n", buf[0:32])
-		}
-	}
 	return nil
 }
 
-func GetFile(ms *util.MessageStream, path string, filename string, keys []byte) error {
-	log.Printf("GetFile %s%s\n", path, filename)
-	fpMessage := new(FPMessage)
-	var final bool
-	final = false
-	file, err := os.Create(path + filename)
+// GetFile receives bytes from a sender and optionally encrypts them and adds
+// integrity protection, and writes them to disk.
+func GetFile(ms *util.MessageStream, dir string, filename string, keys []byte) error {
+	fullpath := path.Join(dir, filename)
+	file, err := os.Create(fullpath)
 	if err != nil {
-		return errors.New("GetFile can't creat file")
+		return fmt.Errorf("can't create file '%s' in GetFile", fullpath)
 	}
 	defer file.Close()
 
-	var aesObj cipher.Block
-	var iv [16]byte
-	var ctrCipher cipher.Stream
-	var ciphertext []byte
-	var hmacObj hash.Hash
-	ciphertext = make([]byte, 2048)
-	if keys != nil {
-		aesObj, err = aes.NewCipher(keys[0:16])
-		if err != nil || aesObj == nil {
-			log.Printf("GetFile can't create aes object")
+	var ctr cipher.Stream
+	var hm hash.Hash
+	iv := make([]byte, ivSize)
+
+	hasKeys := len(keys) >= minKeySize
+	if hasKeys {
+		enc, err := aes.NewCipher(keys[:aesKeySize])
+		if err != nil || enc == nil {
+			return fmt.Errorf("couldn't create an AES cipher: %s", err)
+		}
+
+		// Use the remaining bytes of the key slice for the HMAC key.
+		hm = hmac.New(sha256.New, keys[aesKeySize:])
+		if _, err := rand.Read(iv); err != nil {
+			return fmt.Errorf("couldn't read random bytes for a fresh IV: %s", err)
 		}
-		hmacObj = hmac.New(sha256.New, keys[16:32])
-		log.Printf("GetFile initialized keys for hmac %x", keys[16:32])
-		if _, err := io.ReadFull(rand.Reader, iv[:]); err != nil {
-			panic(err)
+
+		// The first bytes of the HMAC input are the IV.
+		hm.Write(iv)
+		ctr = cipher.NewCTR(enc, iv)
+		if ctr == nil {
+			return fmt.Errorf("couldn't create a new instance of AES-CTR-128")
 		}
-		hmacObj.Write(iv[:])
-		log.Printf("GetFile wrote iv to hmac %x", iv[:])
-		ctrCipher = cipher.NewCTR(aesObj, iv[:])
-		if ctrCipher == nil {
-			log.Printf("GetFile can't create counter cipher object")
+		if _, err = file.Write(iv); err != nil {
+			return err
 		}
-		_, err = file.Write(iv[:])
 	}
 
+	// temp holds temporary encrypted ciphertext before it's written to
+	// disk.
+	temp := make([]byte, bufferSize)
 	for {
-		in, err := ms.ReadString()
-		if err != nil {
-			log.Printf("GetFile can't readstring\n")
-			return errors.New("reception error")
+		var m Message
+		if err := ms.ReadMessage(&m); err != nil {
+			return nil
 		}
-		err = proto.Unmarshal([]byte(in), fpMessage)
-		if err != nil {
-			return errors.New("GetFile can't unmarshal message")
-		}
-		if fpMessage.MessageType == nil {
-			return errors.New("GetFile no message type")
-		}
-		if *fpMessage.MessageType == int32(MessageType_FILE_LAST) {
-			final = true
-		} else if *fpMessage.MessageType == int32(MessageType_FILE_NEXT) {
-			final = false
-		} else {
-			log.Printf("GetFile bad message type\n")
-			return errors.New("reception error")
-		}
-		if fpMessage.BufferSize == nil {
-			log.Printf("GetFile no buffer size\n")
-			return errors.New("expected buffer size")
-		}
-		if fpMessage.TheBuffer == nil {
-			return errors.New("GetFile: empty buffer")
+
+		// Sanity check: this must be FILE_LAST or FILE_NEXT.
+		t := *m.Type
+		if !(t == MessageType_FILE_LAST || t == MessageType_FILE_NEXT) {
+			return fmt.Errorf("received invalid message type %d during file streaming in GetFile", t)
 		}
-		out := []byte(*fpMessage.TheBuffer)
-		if keys != nil {
-			ctrCipher.XORKeyStream(ciphertext, out[0:int(*fpMessage.BufferSize)])
-			hmacObj.Write(ciphertext[0:int(*fpMessage.BufferSize)])
-			log.Printf("GetFile wrote hmac %x", ciphertext[0:int(*fpMessage.BufferSize)])
-			_, err = file.Write(ciphertext[0:int(*fpMessage.BufferSize)])
+
+		if hasKeys {
+			l := len(m.Data)
+			ctr.XORKeyStream(temp, m.Data)
+			hm.Write(temp[:l])
+			if _, err = file.Write(temp[:l]); err != nil {
+				return err
+			}
 		} else {
-			_, err = file.Write(out[0:int(*fpMessage.BufferSize)])
+			if _, err = file.Write(m.Data); err != nil {
+				return err
+			}
 		}
-		if final {
+
+		// FILE_LAST corresponds to receiving the final bytes of the
+		// file.
+		if *m.Type == MessageType_FILE_LAST {
 			break
 		}
 	}
-	if keys != nil {
-		// write Mac
-		hmacBytes := hmacObj.Sum(nil)
-		_, err = file.Write(hmacBytes[0:32])
-	}
-	return nil
-}
 
-func SendSendFile(ms *util.MessageStream, subjectCert []byte, filename string) error {
-	log.Printf("SendSendFile, filename: %s\n", filename)
-	subject := string(subjectCert)
-	action := "sendfile"
-	return SendRequest(ms, &subject, &action, &filename, nil)
-}
-
-func SendGetFile(ms *util.MessageStream, subjectCert []byte, filename string) error {
-	log.Printf("SendGetFile, filename: %s\n", filename)
-	subject := string(subjectCert)
-	action := "getfile"
-	return SendRequest(ms, &subject, &action, &filename, nil)
-}
-
-func SendCreateFile(ms *util.MessageStream, subjectCert []byte, filename string) error {
-	log.Printf("SendCreateFile, filename: %s\n", filename)
-	subject := string(subjectCert)
-	action := "create"
-	return SendRequest(ms, &subject, &action, &filename, &subject)
-}
-
-func SendRule(ms *util.MessageStream, rule string, signerCert []byte) error {
-	log.Printf("SendRule, rule: %s\n", rule)
-	subject := string(signerCert)
-	action := "sendrule"
-	return SendRequest(ms, &subject, &action, &rule, &subject)
-}
-
-func SendDeleteFile(ms *util.MessageStream, creds []byte, filename string) error {
-	return errors.New("CreateFile request not implemented")
-}
+	// Write the MAC at the end of the file.
+	if hasKeys {
+		hmacBytes := hm.Sum(nil)
+		if _, err = file.Write(hmacBytes[:]); err != nil {
+			return err
+		}
+	}
 
-func SendAddFilePermissions(ms *util.MessageStream, creds []byte, filename string) error {
-	return errors.New("AddFilePermissions request not implemented")
+	return nil
 }
diff --git a/apps/fileproxy/fileproxy.pb.go b/apps/fileproxy/fileproxy.pb.go
new file mode 100644
index 0000000..dc89c7b
--- /dev/null
+++ b/apps/fileproxy/fileproxy.pb.go
@@ -0,0 +1,282 @@
+// Code generated by protoc-gen-go.
+// source: fileproxy.proto
+// DO NOT EDIT!
+
+/*
+Package fileproxy is a generated protocol buffer package.
+
+It is generated from these files:
+	fileproxy.proto
+
+It has these top-level messages:
+	Message
+	FileOperation
+	OperationResult
+	ResourceMasterInfo
+	ResourceInfo
+	PrincipalInfo
+*/
+package fileproxy
+
+import proto "code.google.com/p/goprotobuf/proto"
+import math "math"
+
+// Reference imports to suppress errors if they are not otherwise used.
+var _ = proto.Marshal
+var _ = math.Inf
+
+type MessageType int32
+
+const (
+	MessageType_AUTH_CERT    MessageType = 1
+	MessageType_NONCE_CHALL  MessageType = 2
+	MessageType_SIGNED_NONCE MessageType = 3
+	MessageType_OP_RES       MessageType = 4
+	MessageType_CREATE       MessageType = 5
+	MessageType_DELETE       MessageType = 6
+	MessageType_READ         MessageType = 7
+	MessageType_WRITE        MessageType = 8
+	MessageType_FILE_NEXT    MessageType = 9
+	MessageType_FILE_LAST    MessageType = 10
+)
+
+var MessageType_name = map[int32]string{
+	1:  "AUTH_CERT",
+	2:  "NONCE_CHALL",
+	3:  "SIGNED_NONCE",
+	4:  "OP_RES",
+	5:  "CREATE",
+	6:  "DELETE",
+	7:  "READ",
+	8:  "WRITE",
+	9:  "FILE_NEXT",
+	10: "FILE_LAST",
+}
+var MessageType_value = map[string]int32{
+	"AUTH_CERT":    1,
+	"NONCE_CHALL":  2,
+	"SIGNED_NONCE": 3,
+	"OP_RES":       4,
+	"CREATE":       5,
+	"DELETE":       6,
+	"READ":         7,
+	"WRITE":        8,
+	"FILE_NEXT":    9,
+	"FILE_LAST":    10,
+}
+
+func (x MessageType) Enum() *MessageType {
+	p := new(MessageType)
+	*p = x
+	return p
+}
+func (x MessageType) String() string {
+	return proto.EnumName(MessageType_name, int32(x))
+}
+func (x *MessageType) UnmarshalJSON(data []byte) error {
+	value, err := proto.UnmarshalJSONEnum(MessageType_value, data, "MessageType")
+	if err != nil {
+		return err
+	}
+	*x = MessageType(value)
+	return nil
+}
+
+// A Message is a message sent like an RPC between fileproxy hosts. The
+// data is sometimes simply data and is sometimes a serialized protobuf,
+// depending on the message type.
+type Message struct {
+	Type             *MessageType `protobuf:"varint,1,req,name=type,enum=fileproxy.MessageType" json:"type,omitempty"`
+	Data             []byte       `protobuf:"bytes,2,req,name=data" json:"data,omitempty"`
+	XXX_unrecognized []byte       `json:"-"`
+}
+
+func (m *Message) Reset()         { *m = Message{} }
+func (m *Message) String() string { return proto.CompactTextString(m) }
+func (*Message) ProtoMessage()    {}
+
+func (m *Message) GetType() MessageType {
+	if m != nil && m.Type != nil {
+		return *m.Type
+	}
+	return MessageType_AUTH_CERT
+}
+
+func (m *Message) GetData() []byte {
+	if m != nil {
+		return m.Data
+	}
+	return nil
+}
+
+// A FileOperation contains the information needed to perform a file operation
+// (CREATE, DELETE, READ, WRITE).
+type FileOperation struct {
+	// The subject is the public key (in certificate form) of the principal taking
+	// the action.
+	Subject []byte `protobuf:"bytes,1,req,name=subject" json:"subject,omitempty"`
+	// The name is the name of the file. The action is already specified by the
+	// message type in the containing protobuf.
+	Name             *string `protobuf:"bytes,2,req,name=name" json:"name,omitempty"`
+	XXX_unrecognized []byte  `json:"-"`
+}
+
+func (m *FileOperation) Reset()         { *m = FileOperation{} }
+func (m *FileOperation) String() string { return proto.CompactTextString(m) }
+func (*FileOperation) ProtoMessage()    {}
+
+func (m *FileOperation) GetSubject() []byte {
+	if m != nil {
+		return m.Subject
+	}
+	return nil
+}
+
+func (m *FileOperation) GetName() string {
+	if m != nil && m.Name != nil {
+		return *m.Name
+	}
+	return ""
+}
+
+// An OperationResult is the final return value from a sequence of operations,
+// like the authentication of a principal.
+type OperationResult struct {
+	Result           *bool  `protobuf:"varint,1,req,name=result" json:"result,omitempty"`
+	XXX_unrecognized []byte `json:"-"`
+}
+
+func (m *OperationResult) Reset()         { *m = OperationResult{} }
+func (m *OperationResult) String() string { return proto.CompactTextString(m) }
+func (*OperationResult) ProtoMessage()    {}
+
+func (m *OperationResult) GetResult() bool {
+	if m != nil && m.Result != nil {
+		return *m.Result
+	}
+	return false
+}
+
+type ResourceMasterInfo struct {
+	PrinName          *string `protobuf:"bytes,1,opt,name=prin_name" json:"prin_name,omitempty"`
+	BaseDirectoryName *string `protobuf:"bytes,2,opt,name=base_directory_name" json:"base_directory_name,omitempty"`
+	NumFileInfos      *int32  `protobuf:"varint,3,req,name=num_file_infos" json:"num_file_infos,omitempty"`
+	XXX_unrecognized  []byte  `json:"-"`
+}
+
+func (m *ResourceMasterInfo) Reset()         { *m = ResourceMasterInfo{} }
+func (m *ResourceMasterInfo) String() string { return proto.CompactTextString(m) }
+func (*ResourceMasterInfo) ProtoMessage()    {}
+
+func (m *ResourceMasterInfo) GetPrinName() string {
+	if m != nil && m.PrinName != nil {
+		return *m.PrinName
+	}
+	return ""
+}
+
+func (m *ResourceMasterInfo) GetBaseDirectoryName() string {
+	if m != nil && m.BaseDirectoryName != nil {
+		return *m.BaseDirectoryName
+	}
+	return ""
+}
+
+func (m *ResourceMasterInfo) GetNumFileInfos() int32 {
+	if m != nil && m.NumFileInfos != nil {
+		return *m.NumFileInfos
+	}
+	return 0
+}
+
+type ResourceInfo struct {
+	Name             *string `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
+	Type             *int32  `protobuf:"varint,2,req,name=type" json:"type,omitempty"`
+	Status           *int32  `protobuf:"varint,3,req,name=status" json:"status,omitempty"`
+	Location         *string `protobuf:"bytes,4,req,name=location" json:"location,omitempty"`
+	Size             *int32  `protobuf:"varint,5,opt,name=size" json:"size,omitempty"`
+	Owner            *string `protobuf:"bytes,6,opt,name=owner" json:"owner,omitempty"`
+	XXX_unrecognized []byte  `json:"-"`
+}
+
+func (m *ResourceInfo) Reset()         { *m = ResourceInfo{} }
+func (m *ResourceInfo) String() string { return proto.CompactTextString(m) }
+func (*ResourceInfo) ProtoMessage()    {}
+
+func (m *ResourceInfo) GetName() string {
+	if m != nil && m.Name != nil {
+		return *m.Name
+	}
+	return ""
+}
+
+func (m *ResourceInfo) GetType() int32 {
+	if m != nil && m.Type != nil {
+		return *m.Type
+	}
+	return 0
+}
+
+func (m *ResourceInfo) GetStatus() int32 {
+	if m != nil && m.Status != nil {
+		return *m.Status
+	}
+	return 0
+}
+
+func (m *ResourceInfo) GetLocation() string {
+	if m != nil && m.Location != nil {
+		return *m.Location
+	}
+	return ""
+}
+
+func (m *ResourceInfo) GetSize() int32 {
+	if m != nil && m.Size != nil {
+		return *m.Size
+	}
+	return 0
+}
+
+func (m *ResourceInfo) GetOwner() string {
+	if m != nil && m.Owner != nil {
+		return *m.Owner
+	}
+	return ""
+}
+
+type PrincipalInfo struct {
+	Name             *string `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
+	Cert             []byte  `protobuf:"bytes,2,req,name=cert" json:"cert,omitempty"`
+	Status           *int32  `protobuf:"varint,3,req,name=status" json:"status,omitempty"`
+	XXX_unrecognized []byte  `json:"-"`
+}
+
+func (m *PrincipalInfo) Reset()         { *m = PrincipalInfo{} }
+func (m *PrincipalInfo) String() string { return proto.CompactTextString(m) }
+func (*PrincipalInfo) ProtoMessage()    {}
+
+func (m *PrincipalInfo) GetName() string {
+	if m != nil && m.Name != nil {
+		return *m.Name
+	}
+	return ""
+}
+
+func (m *PrincipalInfo) GetCert() []byte {
+	if m != nil {
+		return m.Cert
+	}
+	return nil
+}
+
+func (m *PrincipalInfo) GetStatus() int32 {
+	if m != nil && m.Status != nil {
+		return *m.Status
+	}
+	return 0
+}
+
+func init() {
+	proto.RegisterEnum("fileproxy.MessageType", MessageType_name, MessageType_value)
+}
diff --git a/apps/fileproxy/fileproxy.proto b/apps/fileproxy/fileproxy.proto
new file mode 100644
index 0000000..53c8b09
--- /dev/null
+++ b/apps/fileproxy/fileproxy.proto
@@ -0,0 +1,77 @@
+// Copyright (c) 2014, Google Inc. All rights reserved.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package fileproxy;
+
+enum MessageType {
+   AUTH_CERT = 1;
+   NONCE_CHALL = 2;
+   SIGNED_NONCE = 3;
+   OP_RES = 4;
+   CREATE = 5;
+   DELETE = 6;
+   READ = 7;
+   WRITE = 8;
+   FILE_NEXT = 9;
+   FILE_LAST = 10;
+}  
+
+// A Message is a message sent like an RPC between fileproxy hosts. The
+// data is sometimes simply data and is sometimes a serialized protobuf,
+// depending on the message type.
+message Message {
+  required MessageType type = 1;
+  required bytes data = 2;
+}
+
+// A FileOperation contains the information needed to perform a file operation
+// (CREATE, DELETE, READ, WRITE).
+message FileOperation {
+  // The subject is the public key (in certificate form) of the principal taking
+  // the action.
+  required bytes subject = 1;
+
+  // The name is the name of the file. The action is already specified by the
+  // message type in the containing protobuf.
+  required string name = 2;
+}
+
+// An OperationResult is the final return value from a sequence of operations,
+// like the authentication of a principal.
+message OperationResult {
+  required bool result = 1;
+}
+
+message ResourceMasterInfo {
+  optional  string  prin_name = 1;
+  optional  string  base_directory_name = 2;
+  required  int32   num_file_infos = 3;
+}
+
+message ResourceInfo {
+  required string name = 1;
+  required int32  type = 2;
+  required int32  status = 3;
+  required string location = 4;
+  optional int32  size = 5;
+  optional string owner = 6;
+}
+
+message PrincipalInfo {
+  required string name = 1;
+  required bytes cert = 2;
+  required int32 status = 3;
+}
+
+
diff --git a/apps/fileproxy/fileproxymessages.proto b/apps/fileproxy/fileproxymessages.proto
deleted file mode 100644
index be1c6ab..0000000
--- a/apps/fileproxy/fileproxymessages.proto
+++ /dev/null
@@ -1,59 +0,0 @@
-//  Copyright (c) 2013, Google Inc.  All rights reserved.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package fileproxy;
-
-enum MessageType {
-   REQUEST = 1;
-   RESPONSE = 2;
-   FILE_NEXT = 3;
-   FILE_LAST = 4;
-   PROTOCOL_RESPONSE= 5;
- }
-
-message FPMessage {
-  required  int32   message_type = 1;
-  optional  string  subject_name = 2;
-  optional  string  action_name = 3;
-  optional  string  resource_name = 4;
-  optional  string  resource_owner= 5;
-  optional  string  status_of_request = 6;
-  optional  string  message_from_request = 7;
-  optional  int64   monotonic_counter= 8;
-  optional  int32   buffer_size = 9;
-  optional  string  the_buffer = 10;
-}
-
-message FPResourceMaster {
-  optional  string  prin_name = 1;
-  optional  string  baseDirectory_name = 2;
-  required  int32   num_fileinfos = 3;
-}
-
-message FPResourceInfo {
-  required string resource_name = 1;
-  required string resource_type = 2;
-  required string resource_status = 3;
-  required string resource_location= 4;
-  optional int32  resource_size= 5;
-  optional string resource_owner= 6;
-}
-
-message FPPrincipalInfo {
-  required string principal_name = 1;
-  required string principal_cert= 2;
-  required string principal_status = 3;
-}
-
-
diff --git a/apps/fileproxy/fileserver/fileserver.go b/apps/fileproxy/fileserver/fileserver.go
index 1ef3089..b1810c0 100644
--- a/apps/fileproxy/fileserver/fileserver.go
+++ b/apps/fileproxy/fileserver/fileserver.go
@@ -1,218 +1,184 @@
-// Copyright (c) 2014, Google, Inc.  All rights reserved.
+// Copyright (c) 2014, Google, Inc. All rights reserved.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
 // You may obtain a copy of the License at
+//
 //     http://www.apache.org/licenses/LICENSE-2.0
+//
 // Unless required by applicable law or agreed to in writing, software
 // distributed under the License is distributed on an "AS IS" BASIS,
 // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 // See the License for the specific language governing permissions and
 // limitations under the License.
 //
 // File: fileserver.go
 
 package main
 
 import (
 	"crypto/tls"
 	"crypto/x509"
 	"flag"
 	"log"
 	"net"
+	"os"
+	"path"
 
 	"github.com/jlmucb/cloudproxy/apps/fileproxy"
-	tao "github.com/jlmucb/cloudproxy/tao"
+	"github.com/jlmucb/cloudproxy/tao"
 	"github.com/jlmucb/cloudproxy/tao/auth"
 	taonet "github.com/jlmucb/cloudproxy/tao/net"
 	"github.com/jlmucb/cloudproxy/util"
 )
 
-var hostcfg = flag.String("../hostdomain/tao.config", "../hostdomain/tao.config", "path to host tao configuration")
-var serverHost = flag.String("host", "localhost", "address for client/server")
-var serverPort = flag.String("port", "8123", "port for client/server")
-var fileserverPath = flag.String("fileserver_files/", "fileserver_files/", "fileserver directory")
-var fileserverFilePath = flag.String("fileserver_files/stored_files/", "fileserver_files/stored_files/",
-	"fileserver directory")
-var serverAddr string
-var testFile = flag.String("originalTestFile", "originalTestFile", "test file")
-
-func clientServiceThead(ms *util.MessageStream, clientProgramName string, fileServerProgramPolicy *fileproxy.ProgramPolicy, resourceMaster *fileproxy.ResourceMaster) {
-	log.Printf("fileserver: clientServiceThead\n")
-
-	// How do I know if the connection terminates?
-	for {
-		log.Printf("clientServiceThead: ReadString\n")
-		strbytes, err := ms.ReadString()
-		if err != nil {
-			return
-		}
-		terminate, err := resourceMaster.HandleServiceRequest(ms, fileServerProgramPolicy, clientProgramName, []byte(strbytes))
-		if terminate {
-			break
-		}
-	}
-	log.Printf("fileserver: client thread terminating\n")
-}
-
-func server(serverAddr string, prin string, derPolicyCert []byte, signingKey *tao.Keys, fileServerProgramPolicy *fileproxy.ProgramPolicy, fileServerResourceMaster *fileproxy.ResourceMaster) {
-	var sock net.Listener
-	log.Printf("fileserver: server\n")
+func serve(addr, fp string, cert []byte, signingKey *tao.Keys, policy *fileproxy.ProgramPolicy) error {
+	m := fileproxy.NewResourceMaster(fp)
 
-	err := fileServerResourceMaster.InitMaster(*fileserverFilePath, *fileserverPath, prin)
+	policyCert, err := x509.ParseCertificate(cert)
 	if err != nil {
-		log.Printf("fileserver: can't InitMaster\n")
-		return
-	}
-
-	policyCert, err := x509.ParseCertificate(derPolicyCert)
-	if err != nil {
-		log.Printf("fileserver: can't ParseCertificate\n")
-		return
+		return err
 	}
 	pool := x509.NewCertPool()
 	pool.AddCert(policyCert)
 	tlsc, err := taonet.EncodeTLSCert(signingKey)
 	if err != nil {
-		log.Printf("fileserver, encode error: ", err)
-		log.Printf("\n")
-		return
+		return err
 	}
 	conf := &tls.Config{
 		RootCAs:            pool,
 		Certificates:       []tls.Certificate{*tlsc},
 		InsecureSkipVerify: false,
 		ClientAuth:         tls.RequireAnyClientCert,
 	}
-	log.Printf("Listening\n")
-	sock, err = tls.Listen("tcp", serverAddr, conf)
+	log.Println("fileserver listening")
+	sock, err := tls.Listen("tcp", addr, conf)
 	if err != nil {
-		log.Printf("fileserver, listen error: ", err)
-		log.Printf("\n")
-		return
+		return err
 	}
+
 	for {
-		log.Printf("fileserver: at Accept\n")
+		// Accept and handle client connections one at a time.
 		conn, err := sock.Accept()
 		if err != nil {
-			log.Printf("fileserver: can't accept connection: %s\n", err.Error())
-		} else {
-			var clientName string
-			clientName = "XYZZY"
-			err = conn.(*tls.Conn).Handshake()
-			if err != nil {
-				log.Printf("fileserver: TLS handshake failed\n")
-			}
-			peerCerts := conn.(*tls.Conn).ConnectionState().PeerCertificates
-			if peerCerts == nil {
-				log.Printf("fileserver: can't get peer list\n")
-			} else {
-				peerCert := conn.(*tls.Conn).ConnectionState().PeerCertificates[0]
-				if peerCert.Raw == nil {
-					log.Printf("fileserver: can't get peer name\n")
-				} else {
-					if peerCert.Subject.OrganizationalUnit != nil {
-						clientName = peerCert.Subject.OrganizationalUnit[0]
-					}
-				}
-			}
-			log.Printf("fileserver, peer name: %s\n", clientName)
-			ms := util.NewMessageStream(conn)
-			go clientServiceThead(ms, clientName, fileServerProgramPolicy, fileServerResourceMaster)
+			return err
+		}
+
+		var clientName string
+		if err = conn.(*tls.Conn).Handshake(); err != nil {
+			log.Printf("fileserver: couldn't perform handshake: %s\n", err)
+			continue
+		}
+
+		peerCerts := conn.(*tls.Conn).ConnectionState().PeerCertificates
+		if peerCerts == nil {
+			log.Println("fileserver: couldn't get peer list")
+			continue
+		}
+
+		peerCert := conn.(*tls.Conn).ConnectionState().PeerCertificates[0]
+		if peerCert.Raw == nil {
+			log.Println("fileserver: couldn't get peer name")
+			continue
+		}
+
+		if peerCert.Subject.OrganizationalUnit != nil {
+			clientName = peerCert.Subject.OrganizationalUnit[0]
+		}
+		log.Printf("fileserver: peer name: '%s'\n", clientName)
+		ms := util.NewMessageStream(conn)
+
+		// TODO(tmroeder): support multiple simultaneous clients. This
+		// requires, e.g., adding locking to the ResourceMaster.
+		if err := m.RunMessageLoop(ms, policy); err != nil {
+			log.Printf("fileserver: failed to run message loop: %s\n", err)
+			continue
 		}
+
+		log.Println("Finished handling the client messages")
 	}
 }
 
 func main() {
-
-	var fileServerResourceMaster fileproxy.ResourceMaster
-	var fileServerProgramPolicy fileproxy.ProgramPolicy
+	caAddr := flag.String("caAddr", "localhost:8124", "The address of the CA for setting up a certificate signed by the policy key")
+	hostcfg := flag.String("hostconfig", "tao.config", "path to host tao configuration")
+	serverHost := flag.String("host", "localhost", "address for client/server")
+	serverPort := flag.String("port", "8123", "port for client/server")
+	fileServerPath := flag.String("fileserver_files", "fileserver_files/", "fileserver directory")
+	fileServerFilePath := flag.String("stored_files", "fileserver_files/stored_files/", "fileserver directory")
+	country := flag.String("country", "US", "The country for the fileclient certificate")
+	org := flag.String("organization", "Google", "The organization for the fileclient certificate")
 
 	flag.Parse()
-	serverAddr = *serverHost + ":" + *serverPort
 
+	serverAddr := net.JoinHostPort(*serverHost, *serverPort)
 	hostDomain, err := tao.LoadDomain(*hostcfg, nil)
 	if err != nil {
 		log.Fatalln("fileserver: can't LoadDomain")
 	}
-	log.Printf("fileserver: Domain name: %s\n", hostDomain.ConfigPath)
-	var derPolicyCert []byte
+
+	var policyCert []byte
 	if hostDomain.Keys.Cert != nil {
-		derPolicyCert = hostDomain.Keys.Cert.Raw
+		policyCert = hostDomain.Keys.Cert.Raw
 	}
-	if derPolicyCert == nil {
+	if policyCert == nil {
 		log.Fatalln("fileserver: can't retrieve policy cert")
 	}
 
-	if err := hostDomain.ExtendTaoName(tao.Parent()); err != nil {
+	parentTao := tao.Parent()
+	if err := hostDomain.ExtendTaoName(parentTao); err != nil {
 		log.Fatalln("fileserver: can't extend the Tao with the policy key")
 	}
 	e := auth.PrinExt{Name: "fileserver_version_1"}
-	err = tao.Parent().ExtendTaoName(auth.SubPrin{e})
+	if err = parentTao.ExtendTaoName(auth.SubPrin{e}); err != nil {
+		log.Fatalln("fileserver: couldn't extend the Tao name")
+	}
+
+	taoName, err := parentTao.GetTaoName()
 	if err != nil {
-		return
+		log.Fatalln("fileserver: couldn't get tao name")
 	}
-	taoName, err := tao.Parent().GetTaoName()
+
+	// Create or read the keys for fileclient.
+	fsKeys, err := tao.NewOnDiskTaoSealedKeys(tao.Signing|tao.Crypting, parentTao, *fileServerPath, tao.SealPolicyDefault)
 	if err != nil {
-		log.Printf("fileserver: cant get tao name\n")
-		return
+		log.Fatalln("fileserver: couldn't set up the Tao-sealed keys:", err)
 	}
-	log.Printf("fileserver: my name is %s\n", taoName)
 
-	var programCert []byte
-	sealedSymmetricKey, sealedSigningKey, programCert, delegation, err := fileproxy.LoadProgramKeys(*fileserverPath)
+	// Set up a temporary cert for communication with keyNegoServer.
+	fsKeys.Cert, err = fsKeys.SigningKey.CreateSelfSignedX509(tao.NewX509Name(tao.X509Details{
+		Country:      *country,
+		Organization: *org,
+		CommonName:   taoName.String(),
+	}))
 	if err != nil {
-		log.Printf("fileserver: cant retrieve key material\n")
+		log.Fatalln("fileserver: couldn't create a self-signed cert for fileclient keys:", err)
 	}
-	if sealedSymmetricKey == nil || sealedSigningKey == nil || delegation == nil || programCert == nil {
-		log.Printf("fileserver: No key material present\n")
+
+	// Contact keyNegoServer for the certificate.
+	if err := fileproxy.EstablishCert("tcp", *caAddr, fsKeys, hostDomain.Keys.VerifyingKey); err != nil {
+		log.Fatalf("fileserver: couldn't establish a cert signed by the policy key: %s", err)
 	}
 
-	var symKeys []byte
-	defer fileproxy.ZeroBytes(symKeys)
-	if sealedSymmetricKey != nil {
-		symKeys, policy, err := tao.Parent().Unseal(sealedSymmetricKey)
-		if err != nil {
-			return
-		}
-		if policy != tao.SealPolicyDefault {
-			log.Printf("fileserver: unexpected policy on unseal\n")
-		}
-		log.Printf("fileserver: Unsealed symKeys: % x\n", symKeys)
-	} else {
-		symKeys, err = fileproxy.InitializeSealedSymmetricKeys(*fileserverPath, tao.Parent(), fileproxy.SizeofSymmetricKeys)
-		if err != nil {
-			log.Printf("fileserver: InitializeSealedSymmetricKeys error: %s\n", err)
-		}
-		log.Printf("fileserver: InitilizedsymKeys: % x\n", symKeys)
+	symKeysPath := path.Join(*fileServerPath, "sealedEncKeys")
+	symKeys, err := fsKeys.NewSecret(symKeysPath, fileproxy.SymmetricKeySize)
+	if err != nil {
+		log.Fatalln("fileserver: couldn't get the file encryption keys")
 	}
+	tao.ZeroBytes(symKeys)
 
-	var signingKey *tao.Keys
-	if sealedSigningKey != nil {
-		log.Printf("retrieving signing key\n")
-		signingKey, err = fileproxy.SigningKeyFromBlob(tao.Parent(),
-			sealedSigningKey, programCert, delegation)
-		if err != nil {
-			log.Printf("fileserver: SigningKeyFromBlob error: %s\n", err)
-		}
-		log.Printf("fileserver: Retrieved Signing key: % x\n", *signingKey)
-	} else {
-		log.Printf("fileserver: initializing signing key\n")
-		signingKey, err = fileproxy.InitializeSealedSigningKey(*fileserverPath,
-			tao.Parent(), *hostDomain)
-		if err != nil {
-			log.Printf("fileserver: InitializeSealedSigningKey error: %s\n", err)
+	progPolicy := fileproxy.NewProgramPolicy(policyCert, taoName.String(), fsKeys, symKeys, fsKeys.Cert.Raw)
+
+	// Set up the file storage path if it doesn't exist.
+	if _, err := os.Stat(*fileServerFilePath); err != nil {
+		if err := os.MkdirAll(*fileServerFilePath, 0700); err != nil {
+			log.Fatalln("fileserver: couldn't create a file storage directory:", err)
 		}
-		log.Printf("fileserver: Initialized signingKey\n")
-		programCert = signingKey.Cert.Raw
 	}
-	taoNameStr := taoName.String()
-
-	_ = fileServerProgramPolicy.InitProgramPolicy(derPolicyCert, taoNameStr, *signingKey, symKeys, programCert)
 
-	server(serverAddr, taoNameStr, derPolicyCert, signingKey, &fileServerProgramPolicy, &fileServerResourceMaster)
-	if err != nil {
-		log.Printf("fileserver: server error\n")
+	if err := serve(serverAddr, *fileServerFilePath, policyCert, fsKeys, progPolicy); err != nil {
+		log.Fatalln("fileserver: couldn't serve connections:", err)
 	}
+
 	log.Printf("fileserver: done\n")
 }
diff --git a/apps/fileproxy/fileserver/rebuild b/apps/fileproxy/fileserver/rebuild
deleted file mode 100755
index caaff89..0000000
--- a/apps/fileproxy/fileserver/rebuild
+++ /dev/null
@@ -1,8 +0,0 @@
-#
-echo "rebuilding fileproxy"
-cd ..
-go build ...
-cd fileserver
-echo "rebuilding fileserver"
-go build fileserver.go
-echo "done"
diff --git a/apps/fileproxy/fileserver/run b/apps/fileproxy/fileserver/run
deleted file mode 100755
index 6602182..0000000
--- a/apps/fileproxy/fileserver/run
+++ /dev/null
@@ -1,3 +0,0 @@
-#
-PROG_DIR=/Users/manferdelli/src/github.com/jlmucb/cloudproxy/apps/fileproxy/fileserver
-linux_host -path="../hostdomain/linux_tao_host" -run -- $PROG_DIR/fileserver 
diff --git a/apps/fileproxy/hostdomain/checkprog b/apps/fileproxy/hostdomain/checkprog
deleted file mode 100755
index c5261e2..0000000
--- a/apps/fileproxy/hostdomain/checkprog
+++ /dev/null
@@ -1,7 +0,0 @@
-#
-ps aux | fgrep linux_host
-ps aux | fgrep keynegoserver
-ps aux | fgrep fileclient
-ps aux | fgrep fileserver
-ps aux | fgrep rollbackserver
-
diff --git a/apps/fileproxy/hostdomain/inithost b/apps/fileproxy/hostdomain/inithost
deleted file mode 100755
index 73a2aea..0000000
--- a/apps/fileproxy/hostdomain/inithost
+++ /dev/null
@@ -1,10 +0,0 @@
-#
-export TAO_HOST_DIR=/Users/manferdelli/src/github.com/jlmucb/cloudproxy/apps/fileproxy/hostdomain
-export TAO_ROOTDIR=/Users/manferdelli/src/github.com/jlmucb/cloudproxy
-cd $TAO_HOST_DIR
-mkdir linux_tao_host
-mkdir policy_keys
-export TAO_USE_TPM=no
-export TAO_config_path=$TAO_HOST_DIR/tao.config
-export TAO_guard=AllowAll
-tao_admin -create -name fileproxy -pass nopassword
diff --git a/apps/fileproxy/hostdomain/reinit b/apps/fileproxy/hostdomain/reinit
deleted file mode 100755
index b7086c5..0000000
--- a/apps/fileproxy/hostdomain/reinit
+++ /dev/null
@@ -1,21 +0,0 @@
-#
-cd fileclient_files
-rm delegationBlob
-rm sealedsigningKey
-rm sealedsymmetricKey
-rm signerCert
-cd stored_files
-rm originalTestFile.received
-cd ../../fileserver_files
-rm delegationBlob
-rm sealedsigningKey
-rm sealedsymmetricKey
-rm signerCert
-cd stored_files
-rm originalTestFile
-cd ../../rollbackserver_files
-rm delegationBlob
-rm sealedsigningKey
-rm sealedsymmetricKey
-rm signerCert
-
diff --git a/apps/fileproxy/hostdomain/runfc b/apps/fileproxy/hostdomain/runfc
deleted file mode 100755
index 4488f93..0000000
--- a/apps/fileproxy/hostdomain/runfc
+++ /dev/null
@@ -1,3 +0,0 @@
-#
-PROG_DIR=/Users/manferdelli/src/github.com/jlmucb/cloudproxy/apps/fileproxy/fileclient
-linux_host -path="../hostdomain/linux_tao_host" -run -- $PROG_DIR/fileclient 
diff --git a/apps/fileproxy/hostdomain/runfs b/apps/fileproxy/hostdomain/runfs
deleted file mode 100755
index 6602182..0000000
--- a/apps/fileproxy/hostdomain/runfs
+++ /dev/null
@@ -1,3 +0,0 @@
-#
-PROG_DIR=/Users/manferdelli/src/github.com/jlmucb/cloudproxy/apps/fileproxy/fileserver
-linux_host -path="../hostdomain/linux_tao_host" -run -- $PROG_DIR/fileserver 
diff --git a/apps/fileproxy/hostdomain/runhost b/apps/fileproxy/hostdomain/runhost
deleted file mode 100755
index 66b9202..0000000
--- a/apps/fileproxy/hostdomain/runhost
+++ /dev/null
@@ -1,6 +0,0 @@
-#
-export TAO_HOST_DIR=/Users/manferdelli/src/github.com/jlmucb/cloudproxy/apps/fileproxy/hostdomain
-export TAO_ROOTDIR=/Users/manferdelli/src/github.com/jlmucb/cloudproxy
-cd $TAO_HOST_DIR
-linux_host -create -root -pass nopassword
-linux_host -service -root -pass nopassword &
diff --git a/apps/fileproxy/hostdomain/runkns b/apps/fileproxy/hostdomain/runkns
deleted file mode 100755
index d11a440..0000000
--- a/apps/fileproxy/hostdomain/runkns
+++ /dev/null
@@ -1,3 +0,0 @@
-#
-PROG_DIR=/Users/manferdelli/src/github.com/jlmucb/cloudproxy/apps/fileproxy/keynegoserver
-linux_host -path="../hostdomain/linux_tao_host" -run -- $PROG_DIR/keynegoserver 
diff --git a/apps/fileproxy/hostdomain/runrb b/apps/fileproxy/hostdomain/runrb
deleted file mode 100755
index de556a4..0000000
--- a/apps/fileproxy/hostdomain/runrb
+++ /dev/null
@@ -1,3 +0,0 @@
-#
-PROG_DIR=/Users/manferdelli/src/github.com/jlmucb/cloudproxy/apps/fileproxy/rollbackserver
-linux_host -path="../hostdomain/linux_tao_host" -run -- $PROG_DIR/rollbackserver
diff --git a/apps/fileproxy/keynegoserver/keynegoserver.go b/apps/fileproxy/keynegoserver/keynegoserver.go
index e368f8f..9935643 100644
--- a/apps/fileproxy/keynegoserver/keynegoserver.go
+++ b/apps/fileproxy/keynegoserver/keynegoserver.go
@@ -1,290 +1,198 @@
 // Copyright (c) 2014, Google Inc. All rights reserved.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
 // You may obtain a copy of the License at
 //     http://www.apache.org/licenses/LICENSE-2.0
 // Unless required by applicable law or agreed to in writing, software
 // distributed under the License is distributed on an "AS IS" BASIS,
 // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
 package main
 
 import (
-	"crypto/rand"
 	"crypto/tls"
 	"crypto/x509"
 	"crypto/x509/pkix"
 	"errors"
 	"flag"
+	"fmt"
 	"io/ioutil"
 	"log"
-	"math/big"
 	"net"
 	"os"
 	"time"
 
-	"code.google.com/p/goprotobuf/proto"
-
 	"github.com/jlmucb/cloudproxy/tao"
 	"github.com/jlmucb/cloudproxy/tao/auth"
 	taonet "github.com/jlmucb/cloudproxy/tao/net"
 	"github.com/jlmucb/cloudproxy/util"
 )
 
-var network = flag.String("network", "tcp", "The network to use for connections")
-var addr = flag.String("addr", "localhost:8124", "The address to listen on")
-var domainPass = flag.String("password", "nopassword", "The domain password for the policy key")
-var configPath = flag.String("config", "tao.config", "The Tao domain config")
-
 var SerialNumber int64
 
-func IsAuthenticationValid(name *string) bool {
-	log.Printf("keynegoserver, IsAuthenticationValid name is %s\n", *name)
-	if name == nil {
-		return false
-	}
-	log.Printf("keynegoserver, IsAuthenticationValid returning true\n")
-	return true
-}
-
 // First return is terminate flag.
-func KeyNegoRequest(conn net.Conn, policyKey *tao.Keys, guard tao.Guard) (bool, error) {
-	log.Printf("keynegoerver: KeyNegoRequest\n")
+func handleRequest(conn net.Conn, policyKey *tao.Keys, guard tao.Guard) error {
 	// Expect an attestation from the client.
 	ms := util.NewMessageStream(conn)
 	var a tao.Attestation
 	if err := ms.ReadMessage(&a); err != nil {
-		log.Printf("Couldn't read attestation from channel:", err)
-		log.Printf("\n")
-		return false, err
+		return err
 	}
 
 	peerCert := conn.(*tls.Conn).ConnectionState().PeerCertificates[0]
 	if err := taonet.ValidatePeerAttestation(&a, peerCert, guard); err != nil {
-		log.Printf("Couldn't validate peer attestation:", err)
-		return false, err
+		return err
 	}
 
 	// Sign cert and put it in attestation statement
 	// a consists of serialized statement, sig and SignerInfo
 	// a is a says speaksfor, Delegate of speaksfor is cert and should be DER encoded
 
 	// Get underlying says
-	// log.Print("keynegoserver, attest: ", a)
-	// log.Print("\n")
 	f, err := auth.UnmarshalForm(a.SerializedStatement)
 	if err != nil {
-		log.Printf("\nkeynegoserver: can't unmarshal a.SerializedStatement\n")
-		return false, err
+		return err
 	}
-	// log.Print("\nkeynegoserver, unmarshaled serialized: ", f.String())
-	// log.Print("\n")
 
 	var saysStatement *auth.Says
 	if ptr, ok := f.(*auth.Says); ok {
 		saysStatement = ptr
 	} else if val, ok := f.(auth.Says); ok {
 		saysStatement = &val
 	}
 	sf, ok := saysStatement.Message.(auth.Speaksfor)
 	if ok != true {
-		log.Printf("keynegoserver: says doesnt have speaksfor message\n")
-		return false, err
+		return fmt.Errorf("keynegoserver: says doesn't have a speaksfor message\n")
 	}
-	// log.Print("keynegoserver, speaksfor: ", sf)
-	// log.Print("\n")
+
 	kprin, ok := sf.Delegate.(auth.Prin)
 	if ok != true {
-		log.Printf("keynegoserver: speaksfor Delegate is not auth.Prin\n")
-		return false, err
+		return fmt.Errorf("keynegoserver: speaksfor Delegate is not auth.Prin\n")
 	}
 	subjectPrin, ok := sf.Delegator.(auth.Prin)
 	if ok != true {
-		log.Printf("keynegoserver: can't get subject principal\n")
-		return false, errors.New("Can't get principal name from verifier")
+		return fmt.Errorf("keynegoserver: can't get subject principal\n")
 	}
-	subjectnamestr := subjectPrin.String()
-	verified := IsAuthenticationValid(&subjectnamestr)
-	if !verified {
-		log.Printf("keynegoserver: name verification failed\n")
-		return false, err
-	}
-	log.Printf("keynegoserver, IsAuthenticationValid succeeded: subject principal name: %s\n", subjectnamestr)
+	subjectName := subjectPrin.String()
 	details := tao.X509Details{
 		Country:            "US",
 		Organization:       "Google",
-		OrganizationalUnit: subjectnamestr,
+		OrganizationalUnit: subjectName,
 		CommonName:         "localhost"}
 	subjectname := tao.NewX509Name(details)
 	SerialNumber = SerialNumber + 1
-	template := &x509.Certificate{
-		SignatureAlgorithm: x509.ECDSAWithSHA256,
-		PublicKeyAlgorithm: x509.ECDSA,
-		Version:            2,
-		SerialNumber:       new(big.Int).SetInt64(SerialNumber),
-		Subject:            *subjectname,
-		NotBefore:          time.Now(),
-		NotAfter:           time.Now().AddDate(1 /* years */, 0 /* months */, 0 /* days */),
-		KeyUsage:           x509.KeyUsageKeyAgreement,
-		ExtKeyUsage:        []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth, x509.ExtKeyUsageClientAuth},
-	}
 	verifier, err := tao.FromPrincipal(kprin)
 	if err != nil {
-		return false, errors.New("can't get principal from kprin")
+		return errors.New("can't get principal from kprin")
 	}
-	clientDerCert, err := x509.CreateCertificate(rand.Reader, template, policyKey.Cert,
-		verifier.GetVerifierEc(),
-		policyKey.SigningKey.GetSignerEc())
+	clientCert, err := policyKey.SigningKey.CreateSignedX509(policyKey.Cert, int(SerialNumber), verifier, subjectname)
 	if err != nil {
-		log.Printf("keynegoserver: can't create client certificate: %s\n", err)
-		return false, err
+		return fmt.Errorf("keynegoserver: can't create client certificate: %s\n", err)
 	}
-	err = ioutil.WriteFile("ClientCert", clientDerCert, os.ModePerm)
+	clientDERCert := clientCert.Raw
+	err = ioutil.WriteFile("ClientCert", clientDERCert, os.ModePerm)
 
 	nowTime := time.Now().UnixNano()
 	expireTime := time.Now().AddDate(1, 0, 0).UnixNano()
 	// Replace self signed cert in attest request
-	newspeaksFor := &auth.Speaksfor{
-		Delegate:  auth.Bytes(clientDerCert),
-		Delegator: sf.Delegator}
-	keynegoSays := &auth.Says{
+	newSpeaksFor := &auth.Speaksfor{
+		Delegate:  auth.Bytes(clientDERCert),
+		Delegator: sf.Delegator,
+	}
+	keyNegoSays := auth.Says{
 		Speaker:    policyKey.SigningKey.ToPrincipal(),
 		Time:       &nowTime,
 		Expiration: &expireTime,
-		Message:    newspeaksFor}
+		Message:    newSpeaksFor,
+	}
 
 	delegator, ok := sf.Delegator.(auth.Prin)
 	if !ok {
-		log.Printf("keynegoserver: the delegator must be a principal")
-		return false, err
+		return fmt.Errorf("keynegoserver: the delegator must be a principal")
 	}
-	var prog auth.PrinExt
 	found := false
 	for _, sprin := range delegator.Ext {
 		if !found && (sprin.Name == "Program") {
 			found = true
-			prog = sprin
 		}
 		if found {
 			kprin.Ext = append(kprin.Ext, sprin)
 		}
 	}
-	ra, err := tao.GenerateAttestation(policyKey.SigningKey, nil, *keynegoSays)
-	if err != nil {
-		log.Printf("Couldn't attest to the new says statement:", err)
-		return false, err
-	}
-
-	// Add an endorsement to this PrinExt Program hash so the receiver can check
-	// it successfully against policy.
-	endorsement := auth.Says{
-		Speaker: policyKey.SigningKey.ToPrincipal(),
-		Message: auth.Pred{
-			Name: "TrustedProgramHash",
-			Arg:  []auth.Term{auth.PrinTail{Ext: []auth.PrinExt{prog}}},
-		},
-	}
-	if keynegoSays.Time != nil {
-		i := *keynegoSays.Time
-		endorsement.Time = &i
-	}
-	if keynegoSays.Expiration != nil {
-		i := *keynegoSays.Expiration
-		endorsement.Expiration = &i
-	}
-	ea, err := tao.GenerateAttestation(policyKey.SigningKey, nil, endorsement)
-	if err != nil {
-		log.Printf("Couldn't generate an endorsement for this program:", err)
-		return false, err
-	}
-	eab, err := proto.Marshal(ea)
+	ra, err := tao.GenerateAttestation(policyKey.SigningKey, nil, keyNegoSays)
 	if err != nil {
-		log.Printf("Couldn't marshal an endorsement:", err)
-		return false, err
+		return fmt.Errorf("Couldn't attest to the new says statement:", err)
 	}
-	ra.SerializedEndorsements = [][]byte{eab}
 
 	if _, err := ms.WriteMessage(ra); err != nil {
-		log.Printf("Couldn't return the attestation on the channel:", err)
-		log.Printf("\n")
-		return false, err
+		return fmt.Errorf("Couldn't return the attestation on the channel:", err)
 	}
 
-	return false, nil
+	return nil
 }
 
 func main() {
+	network := flag.String("network", "tcp", "The network to use for connections")
+	addr := flag.String("addr", "localhost:8124", "The address to listen on")
+	domainPass := flag.String("password", "nopassword", "The domain password for the policy key")
+	configPath := flag.String("config", "tao.config", "The Tao domain config")
+
 	flag.Parse()
 	domain, err := tao.LoadDomain(*configPath, []byte(*domainPass))
-	if domain == nil {
-		log.Printf("keynegoserver: no domain\n")
-		return
-	} else if err != nil {
-		log.Printf("keynegoserver: Couldn't load the config path %s: %s\n", *configPath, err)
-		return
+	if err != nil {
+		log.Fatalf("keynegoserver: Couldn't load the config path %s: %s\n", *configPath, err)
 	}
 
 	// Set up temporary keys for the connection, since the only thing that
 	// matters to the remote client is that they receive a correctly-signed new
 	// attestation from the policy key.
 	// JLM:  I left this in place but I'm not sure what a TLS connection with a
 	//   self signed Cert buys in terms of security.  The security of this protocol should
 	//   not depend on the confidentiality or intergity of the channel.  All that said,
 	//   if we do ever distribute a signed keynegoserver cert for this TLS channel, it would
 	//   be good.
 	keys, err := tao.NewTemporaryKeys(tao.Signing)
-	if keys == nil || err != nil {
+	if err != nil {
 		log.Fatalln("keynegoserver: Couldn't set up temporary keys for the connection:", err)
-		return
 	}
 	keys.Cert, err = keys.SigningKey.CreateSelfSignedX509(&pkix.Name{
 		Organization: []string{"Google Tao Demo"}})
 	if err != nil {
 		log.Fatalln("keynegoserver: Couldn't set up a self-signed cert:", err)
-		return
 	}
 	SerialNumber = int64(time.Now().UnixNano()) / (1000000)
 	policyKey, err := tao.NewOnDiskPBEKeys(tao.Signing, []byte(*domainPass), "policy_keys", nil)
 	if err != nil {
-		log.Fatalln("keynegoserver: Couldn't get policy key\n", err)
+		log.Fatalln("keynegoserver: Couldn't get policy key:", err)
 	}
-	log.Printf("keynegoserver: Policy key %x\n: ", policyKey)
 
 	tlsc, err := taonet.EncodeTLSCert(keys)
 	if err != nil {
 		log.Fatalln("keynegoserver: Couldn't encode a TLS cert:", err)
 	}
 	conf := &tls.Config{
 		RootCAs:            x509.NewCertPool(),
 		Certificates:       []tls.Certificate{*tlsc},
 		InsecureSkipVerify: true,
 		ClientAuth:         tls.RequireAnyClientCert,
 	}
 	sock, err := tls.Listen(*network, *addr, conf)
 	if err != nil {
-		log.Printf("keynegoserver: error: %s\n", err)
-	}
-	if sock == nil {
-		log.Printf("keynegoserver: Empty socket, terminating\n")
-		return
+		log.Printf("keynegoserver: error: %s", err)
 	}
 	defer sock.Close()
 
-	log.Printf("keynegoserver: accepting connections\n")
 	for {
 		conn, err := sock.Accept()
-		if conn == nil {
-			log.Printf("keynegoserver: Empty connection\n")
-			return
-		} else if err != nil {
-			log.Printf("keynegoserver: Couldn't accept a connection on %s: %s\n", *addr, err)
-			return
+		if err != nil {
+			log.Fatalln("keynegoserver: couldn't accept a connection:", err)
 		}
-		log.Printf("keynegoserver: calling RequestLoop\n")
-		go KeyNegoRequest(conn, policyKey, domain.Guard)
+
+		go handleRequest(conn, policyKey, domain.Guard)
 	}
-	log.Printf("keynegoserver: finishing\n")
+
+	log.Println("keynegoserver: shutting down")
 }
diff --git a/apps/fileproxy/keynegoserver/rebuild b/apps/fileproxy/keynegoserver/rebuild
deleted file mode 100755
index 561d2d0..0000000
--- a/apps/fileproxy/keynegoserver/rebuild
+++ /dev/null
@@ -1,8 +0,0 @@
-#
-echo "rebuilding fileproxy"
-cd ..
-go build ...
-cd keynegoserver
-echo "rebuilding keynegoserver"
-go build keynegoserver.go
-echo "done"
diff --git a/apps/fileproxy/notes.txt b/apps/fileproxy/notes.txt
deleted file mode 100644
index 2de97c9..0000000
--- a/apps/fileproxy/notes.txt
+++ /dev/null
@@ -1,22 +0,0 @@
-C++ to Go --- cgo
-Go Test
-diffs/CL's
-shared secrets
-interface implementation
-
-commit changes on branch
-diffscuss generate HEAD^..HEAD -o 
-
-
-tao.generatesigner
-string key.ToPrincipal()
-tao,err= NewFakeTao(name, "", nil)
-NewStackedLinuxHost(path, tao.LiberalGuard, tao)
-LinuxHostServer
-
-LinuxHostProgram()
-
-tao.Parent();
-
-
-
diff --git a/apps/fileproxy/resources.go b/apps/fileproxy/resources.go
new file mode 100644
index 0000000..1641af2
--- /dev/null
+++ b/apps/fileproxy/resources.go
@@ -0,0 +1,794 @@
+// Copyright (c) 2014, Google, Inc.  All rights reserved.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//     http://www.apache.org/licenses/LICENSE-2.0
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// File: filehandler.go
+
+package fileproxy
+
+import (
+	"bytes"
+	"crypto/rand"
+	"crypto/x509"
+	"fmt"
+	"log"
+	"path"
+	"time"
+
+	"code.google.com/p/goprotobuf/proto"
+
+	"github.com/jlmucb/cloudproxy/tao"
+	"github.com/jlmucb/cloudproxy/util"
+)
+
+const NonceSize = 32
+const ChallengeContext = "fileproxy-challenge"
+
+// A ResourceType is the type of resource managed by the handler.
+type ResourceType int
+
+// These constants represent the different types of resources.
+const (
+	File ResourceType = iota
+)
+
+// A ResourceStatus is the state in which a resource finds itself.
+type ResourceStatus int
+
+// These constants represent the difference states of resources.
+const (
+	Created ResourceStatus = iota
+)
+
+// A Resource represents a resource managed by a handler.
+type Resource struct {
+	Name              string
+	Type              ResourceType
+	Status            ResourceStatus
+	Location          string
+	Size              int
+	Owner             string
+	DateCreated       time.Time
+	DateModified      time.Time
+	AuthenticatorType string
+	Authenticator     [][]byte
+}
+
+// A PrincipalStatus gives the current state of a principal on a channel.
+type PrincipalStatus int
+
+// These constants represent the different states of principals.
+const (
+	Authenticated PrincipalStatus = iota
+)
+
+// A Principal represents a principal authenticated on a channel (or trying
+// to authenticate on a channel).
+type Principal struct {
+	Name    string
+	CertDER []byte
+	Cert    *x509.Certificate
+	Status  PrincipalStatus
+}
+
+// A ResourceMaster manages a set of resources for a set of principals, using a
+// Guard to make authorization decisions.
+type ResourceMaster struct {
+	ProgramName   string
+	Guard         tao.Guard
+	BaseDirectory string
+	Resources     map[string]*Resource
+	Principals    map[string]*Principal
+	Policy        []string
+}
+
+// Policy for managing files in the fileserver.
+var policy = []string{
+	// Fileserver owns everything.
+	"forall FS: forall R: FileServer(FS) and Resource(R) implies Owner(FS, R)",
+	// Creators are owners.
+	"forall C: forall R: Creator(C, R) implies Owner(C, R)",
+	// Owners can perform all actions and make all delegations.
+	"forall O: forall A: forall R: Owner(O, R) and Resource(R) and Action(A) implies Authorized(O, \"delegate\", A, R)",
+	"forall O: forall A: forall R: Owner(O, R) and Resource(R) and Action(A) implies Authorized(O, A, R)",
+	// Principals have namespaces where they can create things.
+	// The guard needs to understand that Authorized(P, "create-subdir",
+	// path) means that P can create a path with its name underneath (or
+	// something like the hash of its name).
+	"forall P: Authorized(P, \"execute\") implies Authorized(P, \"create-subdir\", \"/principals\")",
+	// Basic Delegation.
+	"forall U1: forall U2: forall R: forall A: Authorized(U1, \"delegate\", A, R) and Delegate(U1, U2, A, R) implies Authorized(U2, A, R)",
+	// Redelegation.
+	"forall U1: forall U2: forall R: forall A: Authorized(U1, \"delegate\", A, R) and Delegate(U1, U2, \"delegate\", A, R) implies Authorized(U2, \"delegate\", A, R)",
+	"Action(\"create\")",
+	"Action(\"getfile\")",
+	"Action(\"sendfile\")",
+	"Action(\"delete\")",
+	// Some simple test rules for fileclient
+	"Authorized(\"jlm\", \"create\", \"originalTestFile\")",
+	"Authorized(\"jlm\", \"write\", \"originalTestFile\")",
+	"Authorized(\"jlm\", \"read\", \"originalTestFile\")",
+}
+
+// delegateResource adds a delegation statement to the policy for a given
+// operation on a resource.
+func (m *ResourceMaster) delegateResource(owner, delegate, op, res string) error {
+	r := fmt.Sprintf("Delegate\"%s\", \"%s\", \"%s\", \"%s\")", owner, delegate, op, res)
+	return m.Guard.AddRule(r)
+}
+
+// redelegateResource adds a redelegation statement to the policy for a given
+// operation on a resource.
+func (m *ResourceMaster) redelegateResource(owner, delegate, op, res string) error {
+	r := fmt.Sprintf("Delegate(\"%s\", \"%s\", \"delegate\", \"%s\", \"%s\")", owner, delegate, op, res)
+	return m.Guard.AddRule(r)
+}
+
+// addResource adds Resource() and Creator() statements for a given resource
+// with a given creator.
+func (m *ResourceMaster) addResource(creator, resource string) error {
+	r := fmt.Sprintf("Resource(\"%s\")", resource)
+	if err := m.Guard.AddRule(r); err != nil {
+		return err
+	}
+
+	c := fmt.Sprintf("Creator(\"%s\", \"%s\")", creator, resource)
+	return m.Guard.AddRule(c)
+}
+
+// makeQuery formulates the simple Authorized query for a given (subject,
+// action, resource) tuple.
+func makeQuery(subject string, action string, resource string) string {
+	return fmt.Sprintf("Authorized(\"%s\", \"%s\", \"%s\")", subject, action, resource)
+}
+
+// checkFileAuth checks the given file operation to see if it is authorized
+// according to the Guard in the ResourceMaster.
+func (m *ResourceMaster) checkFileAuth(msg *Message, fop *FileOperation) error {
+	subject, err := m.certToAuthenticatedName(fop.Subject)
+	if err != nil {
+		return err
+	}
+
+	var action string
+	switch *msg.Type {
+	case MessageType_CREATE:
+		action = "create"
+	case MessageType_DELETE:
+		action = "delete"
+	case MessageType_READ:
+		action = "read"
+	case MessageType_WRITE:
+		action = "write"
+	default:
+		return fmt.Errorf("invalid action type %d\n", *msg.Type)
+	}
+
+	q := makeQuery(subject, action, *fop.Name)
+	ok, err := m.Query(q)
+	if err != nil {
+		return err
+	}
+	if !ok {
+		return fmt.Errorf("the authorization query '%s' didn't pass verification", q)
+	}
+	return nil
+}
+
+// Query checks the query against the guard to see if it is authorized.
+func (m *ResourceMaster) Query(query string) (bool, error) {
+	return m.Guard.Query(query)
+}
+
+// FindResource looks up the resource by its name.
+func (m *ResourceMaster) FindResource(name string) *Resource {
+	return m.Resources[name]
+}
+
+// InsertResource adds a resource with a given path, name, and owner.
+func (m *ResourceMaster) InsertResource(dir string, name string, owner string) *Resource {
+	r := m.Resources[name]
+	if r != nil {
+		// TODO(tmroeder): This should be an error if the two resources
+		// differ in some other way. For now, though, we'll return the
+		// old resource.
+		return r
+	}
+	r = &Resource{
+		Name:     name,
+		Type:     File,
+		Status:   Created,
+		Location: path.Join(dir, name),
+		Owner:    owner,
+	}
+	// TODO(tmroeder): note that this means that there can only be one
+	// resource with a given filename, even if the other resource with the
+	// same name is in another directory. This could be fixed by making the
+	// name of the resource its full path, or using something like struct
+	// keys in the map with {dir, name} as the key.
+	m.Resources[name] = r
+	return r
+}
+
+// FindPrincipal looks up a Principal by name
+func (m *ResourceMaster) FindPrincipal(name string) *Principal {
+	return m.Principals[name]
+}
+
+// InsertPrincipal adds a given principal with a given certificate to the set of
+// principals. It marks this principal with the given authentication status.
+// Note that if a principal already exists with the same name, then it just
+// returns that principal and makes no attempt to reconcile to the two
+// principals.
+func (m *ResourceMaster) InsertPrincipal(name string, cert []byte, authStatus PrincipalStatus) (*Principal, error) {
+	p := m.Principals[name]
+	if p != nil {
+		return p, nil
+	}
+	x, err := x509.ParseCertificate(cert)
+	if err != nil {
+		return nil, err
+	}
+	p = &Principal{
+		Name:    name,
+		CertDER: cert,
+		Cert:    x,
+		Status:  authStatus,
+	}
+	m.Principals[name] = p
+	return p, nil
+}
+
+// EncodeMaster encodes information about a ResourceMaster as a protobuf.
+func (m *ResourceMaster) EncodeMaster() ([]byte, error) {
+	p := &ResourceMasterInfo{
+		PrinName:          proto.String(m.ProgramName),
+		BaseDirectoryName: proto.String(m.BaseDirectory),
+		NumFileInfos:      proto.Int(len(m.Resources)),
+	}
+	return proto.Marshal(p)
+}
+
+// DecodeMaster decodes information about a ResourceMaster from a protobuf.
+// TODO(tmroeder): It would be more idiomatic to have this be something like
+// NewResourceMaster and take in something to read the protobuf bytes from.
+func (m *ResourceMaster) DecodeMaster(in []byte) error {
+	var message ResourceMasterInfo
+	if err := proto.Unmarshal(in, &message); err != nil {
+		return err
+	}
+	m.ProgramName = *message.PrinName
+	m.BaseDirectory = *message.BaseDirectoryName
+	return nil
+}
+
+// PrintMaster prints the ResourceMaster into the log.
+func (m *ResourceMaster) PrintMaster(printResources bool) {
+	log.Printf("Program principal: %s\n", m.ProgramName)
+	log.Printf("Base Directory: %s\n", m.BaseDirectory)
+	log.Printf("%d resources\n", len(m.Resources))
+	if printResources {
+		for _, r := range m.Resources {
+			r.PrintResource()
+		}
+	}
+}
+
+// EncodeResource creates a protobuf that represents a resource.
+// TODO(tmroeder): map the types and statuses to protobuf enums properly.
+func (r *Resource) EncodeResource() ([]byte, error) {
+	m := &ResourceInfo{
+		Name:     proto.String(r.Name),
+		Type:     proto.Int32(int32(r.Type)),
+		Status:   proto.Int32(int32(r.Status)),
+		Location: proto.String(r.Location),
+		Size:     proto.Int(r.Size),
+		Owner:    proto.String(r.Owner),
+	}
+	return proto.Marshal(m)
+}
+
+// DecodeResource fills a resource from the information in a protobuf. Note that
+// this would be more idiomatic as a NewResource method that took in a byte
+// slice.
+func (r *Resource) DecodeResource(in []byte) error {
+	var ri ResourceInfo
+	if err := proto.Unmarshal(in, &ri); err != nil {
+		return err
+	}
+	r.Name = *ri.Name
+	r.Type = ResourceType(*ri.Type)
+	r.Status = ResourceStatus(*ri.Status)
+	r.Location = *ri.Location
+	r.Size = int(*ri.Size)
+	r.Owner = *ri.Owner
+	return nil
+}
+
+// PrintResource prints a resource to the log.
+func (r *Resource) PrintResource() {
+	log.Printf("Resource name: %s\n", r.Name)
+	log.Printf("Resource type: %s\n", r.Type)
+	log.Printf("Resource status: %s\n", r.Status)
+	log.Printf("Resource location: %s\n", r.Location)
+	log.Printf("Resource size: %d\n", r.Size)
+	log.Printf("Resource creation date: %s\n", r.DateCreated)
+	log.Printf("Resource modified date: %s\n", r.DateModified)
+	log.Printf("\n")
+}
+
+// EncodePrincipal encodes information about a principal into a protobuf.
+func (p *Principal) EncodePrincipal() ([]byte, error) {
+	pi := &PrincipalInfo{
+		Name:   proto.String(p.Name),
+		Cert:   p.CertDER,
+		Status: proto.Int32(int32(p.Status)),
+	}
+	return proto.Marshal(pi)
+}
+
+// DecodePrincipal deserializes a principal from a protobuf. Note that this
+// would be more idiomatic as a NewPrincipal method that took in a byte slice.
+func (p *Principal) DecodePrincipal(in []byte) error {
+	var pi PrincipalInfo
+	if err := proto.Unmarshal(in, &pi); err != nil {
+		return err
+	}
+
+	p.Name = *pi.Name
+	p.CertDER = pi.Cert
+	var err error
+	if p.Cert, err = x509.ParseCertificate(p.CertDER); err != nil {
+		return err
+	}
+	p.Status = PrincipalStatus(*pi.Status)
+	return nil
+}
+
+// PrintPrincipal prints information about a principal to the log.
+func (p *Principal) PrintPrincipal() {
+	log.Printf("Principal name: %s\n", p.Name)
+	log.Printf("Principal status: %s\n", p.Status)
+	log.Printf("Principal cert: % x\n", p.CertDER)
+	log.Printf("\n")
+}
+
+// PrintAllPolicy prints all policy info to the log.
+func (m *ResourceMaster) PrintAllPolicy() {
+	for i := range m.Policy {
+		log.Printf("Rule: %s\n", m.Policy[i])
+	}
+}
+
+// InitGuard initializes the datalog guard with a rule file.
+func (m *ResourceMaster) InitGuard(rf string) error {
+	return nil
+}
+
+// readResult reads an OperationResult and returns its value or an error.
+func readResult(ms *util.MessageStream) (bool, error) {
+	// Read the response wrapper message.
+	var arm Message
+	if err := ms.ReadMessage(&arm); err != nil {
+		return false, err
+	}
+	if *arm.Type != MessageType_OP_RES {
+		return false, fmt.Errorf("didn't receive OP_RES from the server")
+	}
+
+	var opr OperationResult
+	if err := proto.Unmarshal(arm.Data, &opr); err != nil {
+		return false, err
+	}
+	return *opr.Result, nil
+}
+
+// sendResult sends an OperationResult with the given value on the given stream.
+func sendResult(ms *util.MessageStream, result bool) error {
+	res := &OperationResult{Result: proto.Bool(result)}
+	ar := &Message{
+		Type: MessageType_OP_RES.Enum(),
+	}
+	var err error
+	if ar.Data, err = proto.Marshal(res); err != nil {
+		return err
+	}
+
+	if _, err := ms.WriteMessage(ar); err != nil {
+		return err
+	}
+
+	return nil
+}
+
+// AuthenticatePrincipal runs a synchronous protocol to authenticate a single
+// principal on a single channel. In this toy implementation, it is assumed that
+// there are no other principals on the channel and that there are no other
+// simultaneous channels.
+func (m *ResourceMaster) AuthenticatePrincipal(ms *util.MessageStream, msg *Message, programPolicy *ProgramPolicy) ([]byte, error) {
+	// The certificate message is passed in by the caller as the first
+	// message.
+
+	// Process the certificate. For AUTH_CERT, the data is just the
+	// certificate.
+	cert, err := x509.ParseCertificate([]byte(msg.Data))
+	if err != nil {
+		log.Printf("couldn't Parse Certificate in AuthenticatePrincipal\n")
+		return nil, err
+	}
+
+	// Set up a nonce challenge for the reply. For NONCE_CHALL, the data is
+	// also just the message itself.
+	reply := &Message{
+		Type: MessageType_NONCE_CHALL.Enum(),
+		Data: make([]byte, NonceSize),
+	}
+	if _, err = rand.Read(reply.Data); err != nil {
+		return nil, err
+	}
+
+	// Step 1: Send a nonce to the principal.
+	if _, err := ms.WriteMessage(reply); err != nil {
+		return nil, err
+	}
+
+	// Step 2: Wait for the signed response.
+	var s Message
+	if err := ms.ReadMessage(&s); err != nil {
+		return nil, err
+	}
+	if *s.Type != MessageType_SIGNED_NONCE {
+		return nil, fmt.Errorf("received message was not SIGNED_NONCE")
+	}
+
+	// Verify the certificate against the root.
+	// TODO(tmroeder): move the VerifyOptions up into the ResourceMaster.
+	var opts x509.VerifyOptions
+	roots := x509.NewCertPool()
+	policyCert, err := x509.ParseCertificate(programPolicy.PolicyCert)
+	if err != nil || policyCert == nil {
+		return nil, err
+	}
+	roots.AddCert(policyCert)
+	opts.Roots = roots
+	chains, err := cert.Verify(opts)
+	if chains == nil || err != nil {
+		return nil, err
+	}
+	v, err := tao.FromX509(cert)
+	if err != nil {
+		return nil, err
+	}
+	ok, err := v.Verify(reply.Data, ChallengeContext, s.Data)
+	if err != nil {
+		return nil, err
+	}
+
+	if err := sendResult(ms, ok); err != nil {
+		return nil, fmt.Errorf("failed to return a result to the client")
+	}
+
+	if !ok {
+		return nil, fmt.Errorf("the nonce signature did not pass verification")
+	}
+
+	return msg.Data, nil
+}
+
+// Read causes the bytes of the file to be decrypted and read to the message
+// stream. By the time this function is called, the remote principal has already
+// been authenticated and the operation has already been authorized.
+func (m *ResourceMaster) Read(ms *util.MessageStream, fop *FileOperation, key []byte) error {
+	ri := m.FindResource(*fop.Name)
+	if ri == nil {
+		return sendResult(ms, false)
+	}
+	if err := sendResult(ms, true); err != nil {
+		return err
+	}
+	return SendFile(ms, m.BaseDirectory, *fop.Name, key)
+}
+
+// Write causes the bytes of the file to be encrypted and integrity-protected
+// and written to disk as they are read from the MessageStream.
+func (m *ResourceMaster) Write(ms *util.MessageStream, fop *FileOperation, key []byte) error {
+	// Note that a file has be created before it can be written to.
+	ri := m.FindResource(*fop.Name)
+	if ri == nil {
+		return sendResult(ms, false)
+	}
+	if err := sendResult(ms, true); err != nil {
+		return err
+	}
+	return GetFile(ms, m.BaseDirectory, *fop.Name, key)
+}
+
+// Create creates a file in the resource info in the ResourceMaster, but it
+// doesn't write any bits to disk about this file.
+func (m *ResourceMaster) Create(ms *util.MessageStream, fop *FileOperation) error {
+	ri := m.FindResource(*fop.Name)
+	if ri != nil {
+		// Can't create a file that already exists.
+		return sendResult(ms, false)
+	}
+
+	owner, err := m.certToAuthenticatedName(fop.Subject)
+	if err != nil {
+		// Failed to get the name from the cert.
+		return sendResult(ms, false)
+	}
+	ri = m.InsertResource(m.BaseDirectory, *fop.Name, owner)
+	if ri == nil {
+		// Couldn't insert the resource
+		return sendResult(ms, false)
+	}
+	if err := m.addResource(owner, *fop.Name); err != nil {
+		if e := sendResult(ms, false); e != nil {
+			return e
+		}
+		return err
+	}
+
+	return sendResult(ms, true)
+
+}
+
+// certToAuthenticatedName looks up a cert in the principals to make sure it's
+// known and has been authenticated. If so, it returns the name of this
+// principal.
+func (m *ResourceMaster) certToAuthenticatedName(cert []byte) (string, error) {
+	if len(cert) == 0 {
+		return "", fmt.Errorf("couldn't parse a null cert")
+	}
+	name, err := principalNameFromDERCert(cert)
+	if err != nil {
+		return "", err
+	}
+	prin := m.FindPrincipal(name)
+	if prin == nil {
+		return "", fmt.Errorf("couldn't find principal with name '%s'\n", name)
+	}
+	if bytes.Equal(prin.CertDER, []byte(name)) {
+		return "", fmt.Errorf("invalid principal name")
+	}
+	return name, nil
+}
+
+// RunMessageLoop handles messages from a client on a given message stream until
+// it gets an error trying to read a message.
+func (m *ResourceMaster) RunMessageLoop(ms *util.MessageStream, programPolicy *ProgramPolicy) error {
+	for {
+		var msg Message
+		if err := ms.ReadMessage(&msg); err != nil {
+			return err
+		}
+
+		var fop FileOperation
+		t := *msg.Type
+		if t == MessageType_CREATE || t == MessageType_DELETE || t == MessageType_READ || t == MessageType_WRITE {
+			if err := proto.Unmarshal(msg.Data, &fop); err != nil {
+				log.Printf("Couldn't unmarshal FileOperation for operation %d\n", t)
+				continue
+			}
+
+			if err := m.checkFileAuth(&msg, &fop); err != nil {
+				log.Printf("The file operation %d didn't pass authorization: %s\n", t, err)
+				continue
+			}
+		}
+
+		switch *msg.Type {
+		case MessageType_AUTH_CERT:
+			cert, err := m.AuthenticatePrincipal(ms, &msg, programPolicy)
+			if err != nil {
+				log.Printf("Failed to authenticate a principal: %s\n", err)
+				continue
+			}
+
+			owner, err := principalNameFromDERCert(cert)
+			if err != nil {
+				log.Printf("Couldn't get the owner name from the cert: %s\n", err)
+				continue
+			}
+			_, err = m.InsertPrincipal(owner, cert, Authenticated)
+			if err != nil {
+				log.Printf("Couldn't set the principal as authenticated")
+			}
+		case MessageType_CREATE:
+			if err := m.Create(ms, &fop); err != nil {
+				log.Printf("Couldn't create the file %s: %s\n", *fop.Name, err)
+			}
+		case MessageType_READ:
+			if err := m.Read(ms, &fop, programPolicy.SymKeys); err != nil {
+				log.Printf("Couldn't create the file %s: %s\n", *fop.Name, err)
+			}
+		case MessageType_WRITE:
+			if err := m.Write(ms, &fop, programPolicy.SymKeys); err != nil {
+				log.Printf("Couldn't create the file %s: %s\n", *fop.Name, err)
+			}
+		default:
+			if err := sendResult(ms, false); err != nil {
+				log.Printf("Couldn't signal failure for the invalid operation: %s", err)
+			}
+			log.Printf("Invalid initial message type %d\n", *msg.Type)
+		}
+	}
+
+	return nil
+}
+
+// NewResourceMaster creates a ResourceMaster from the static ruleset and
+// initializes it to manage the given directory.
+func NewResourceMaster(filepath string) *ResourceMaster {
+	m := &ResourceMaster{
+		Guard:         tao.NewTemporaryDatalogGuard(),
+		BaseDirectory: filepath,
+		Resources:     make(map[string]*Resource),
+		Principals:    make(map[string]*Principal),
+		Policy:        policy, // the global policy value.
+	}
+
+	for _, p := range m.Policy {
+		if err := m.Guard.AddRule(p); err != nil {
+			log.Printf("Couldn't add run '%s': %s\n", p, err)
+			return nil
+		}
+	}
+	return m
+}
+
+// The following are client methods that can be used to access the
+// ResourceMaster.
+
+// recvResult waits for a OperationResult on a MessageStream
+func recvResult(ms *util.MessageStream) (bool, error) {
+	var m Message
+	if err := ms.ReadMessage(&m); err != nil {
+		return false, err
+	}
+	var res OperationResult
+	if err := proto.Unmarshal(m.Data, &res); err != nil {
+		return false, err
+	}
+
+	return *res.Result, nil
+}
+
+// wrapResult takes a bool and an error and returns an error if the error is
+// non-nil or if the bool is false.
+func wrapResult(ok bool, err error) error {
+	if err != nil {
+		return err
+	}
+	if !ok {
+		return fmt.Errorf("the operation failed")
+	}
+	return nil
+}
+
+// sendOperation is a helper method that sets up the data structures needed for
+// a FileOperation message like CREATE, WRITE, or READ, and sends this message
+// on the MessageStream.
+func sendOperation(ms *util.MessageStream, mt MessageType, cert []byte, name string) error {
+	fop := &FileOperation{
+		Subject: cert,
+		Name:    proto.String(name),
+	}
+
+	fopb, err := proto.Marshal(fop)
+	if err != nil {
+		return err
+	}
+	m := &Message{
+		Type: mt.Enum(),
+		Data: fopb,
+	}
+
+	if _, err := ms.WriteMessage(m); err != nil {
+		return err
+	}
+
+	return nil
+}
+
+// CreateFile creates a file with a given creator and name.
+func CreateFile(ms *util.MessageStream, ownerCert []byte, name string) error {
+	if err := sendOperation(ms, MessageType_CREATE, ownerCert, name); err != nil {
+		return err
+	}
+
+	return wrapResult(recvResult(ms))
+}
+
+// WriteFile writes a local file, using SendFile without any keys to read the
+// file from disk and send it on the MessageStream.
+func WriteFile(ms *util.MessageStream, userCert []byte, dir, name string) error {
+	if err := sendOperation(ms, MessageType_WRITE, userCert, name); err != nil {
+		return err
+	}
+
+	if err := wrapResult(recvResult(ms)); err != nil {
+		return err
+	}
+
+	return SendFile(ms, dir, name, nil)
+}
+
+// ReadFile reads a file from the server and writes it to a local file, using
+// GetFile without any keys to read the file from the network and write it to
+// the disk.
+func ReadFile(ms *util.MessageStream, userCert []byte, dir, name, output string) error {
+	if err := sendOperation(ms, MessageType_READ, userCert, name); err != nil {
+		return err
+	}
+
+	if err := wrapResult(recvResult(ms)); err != nil {
+		return err
+	}
+
+	return GetFile(ms, dir, output, nil)
+}
+
+// AuthenticatePrincipal is a client method used to send a request to a
+// ResourceMaster to authenticate a principal with a given certificate and a
+// given set of keys.
+func AuthenticatePrincipal(ms *util.MessageStream, key *tao.Keys, derCert []byte) error {
+	// Send the authentication request, which supposes that a server is
+	// waiting to receive this request.
+	c := &Message{
+		Type: MessageType_AUTH_CERT.Enum(),
+		Data: derCert,
+	}
+	if _, err := ms.WriteMessage(c); err != nil {
+		return err
+	}
+
+	// Receive a challenge nonce from the server.
+	var nc Message
+	if err := ms.ReadMessage(&nc); err != nil {
+		return err
+	}
+	if *nc.Type != MessageType_NONCE_CHALL {
+		return fmt.Errorf("didn't receive NONCE_CHALL from the server")
+	}
+
+	// Sign the nonce.
+	sn := &Message{
+		Type: MessageType_SIGNED_NONCE.Enum(),
+	}
+	var err error
+	if sn.Data, err = key.SigningKey.Sign(nc.Data, ChallengeContext); err != nil {
+		return err
+	}
+	if _, err := ms.WriteMessage(sn); err != nil {
+		return err
+	}
+
+	// Get the result from the server after verificaton.
+	res, err := readResult(ms)
+	if err != nil {
+		return err
+	}
+
+	if !res {
+		return fmt.Errorf("the signed nonce failed verification")
+	}
+	return nil
+}
+
+func principalNameFromDERCert(derCert []byte) (string, error) {
+	cert, err := x509.ParseCertificate(derCert)
+	if err != nil {
+		return "", err
+	}
+	cn := cert.Subject.CommonName
+	return cn, nil
+}
diff --git a/apps/fileproxy/rollback.go b/apps/fileproxy/rollback.go
new file mode 100644
index 0000000..b98bee3
--- /dev/null
+++ b/apps/fileproxy/rollback.go
@@ -0,0 +1,400 @@
+// Copyright (c) 2014, Google, Inc.,  All rights reserved.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// File: rollbackhandler.go
+
+package fileproxy
+
+import (
+	"crypto/sha256"
+	"encoding/binary"
+	"fmt"
+	"log"
+
+	"code.google.com/p/goprotobuf/proto"
+
+	"github.com/jlmucb/cloudproxy/util"
+)
+
+// A RollbackProgram stores the rollback information for a given program.
+type RollbackProgram struct {
+	MasterInfoSaveFile string
+	HashSaveFile       string
+	Name               string
+	MonotonicCounter   uint64
+	Hashes             map[string][]byte
+}
+
+// A RollbackMaster stores information about the rollback state of all programs
+// that use the RollbackMaster.
+type RollbackMaster struct {
+	Name     string
+	Programs map[string]*RollbackProgram
+}
+
+// FindRollbackProgram finds a given RollbackProgram by name
+func (r *RollbackMaster) FindRollbackProgram(name string) *RollbackProgram {
+	return r.Programs[name]
+}
+
+// AddRollbackProgram inserts a rollback program with a given name into the
+// table. If there is already a program with this name, then it returns the
+// program that already has that name.
+func (r *RollbackMaster) AddRollbackProgram(name string) *RollbackProgram {
+	pi := r.FindRollbackProgram(name)
+	if pi != nil {
+		return pi
+	}
+
+	pi = &RollbackProgram{
+		Name:             name,
+		MonotonicCounter: 0,
+		Hashes:           make(map[string][]byte),
+	}
+	r.Programs[name] = pi
+	return pi
+}
+
+// FindRollbackHashEntry looks up the hash for a given item name in a rollback
+// program. Note that it returns the default value of a slice (nil) if the name
+// doesn't exist.
+func (pi *RollbackProgram) FindRollbackHashEntry(name string) []byte {
+	return pi.Hashes[name]
+}
+
+// AddRollbackHashEntry adds a given name/hash pair to the map and updates the
+// hash if this name already exists.
+func (pi *RollbackProgram) AddRollbackHashEntry(name string, newHash []byte) error {
+	pi.Hashes[name] = newHash
+	return nil
+}
+
+// NewRollbackMaster creates a new RollbackMaster with the given name.
+func NewRollbackMaster(name string) *RollbackMaster {
+	r := &RollbackMaster{
+		Name:     name,
+		Programs: make(map[string]*RollbackProgram),
+	}
+	return r
+}
+
+// EncodeCounter takes in a counter and returns a slice that exactly encodes a
+// varint representation of this counter.
+func EncodeCounter(counter uint64) []byte {
+	b := make([]byte, binary.MaxVarintLen64)
+	n := binary.PutUvarint(b, counter)
+	return b[:n]
+}
+
+// decodeCounter takes in a slice and attempts to decode it as a uint64 value.
+func decodeCounter(b []byte) (uint64, error) {
+	i, n := binary.Uvarint(b)
+	if n <= 0 {
+		return 0, fmt.Errorf("couldn't decode the counter")
+	}
+	return i, nil
+}
+
+// SetRollbackCounter sets the monotonic counter for a given program to a higher
+// value. It returns an error if the program doesn't exist or if the new value
+// of the counter is less than the current value of the counter.
+func (r *RollbackMaster) SetCounter(ms *util.MessageStream, name string, counter uint64) error {
+	emptyData := make([]byte, 0)
+	rr := &RollbackResponse{
+		Type: RollbackMessageType_ERROR.Enum(),
+		Data: emptyData,
+	}
+
+	p := r.FindRollbackProgram(name)
+	if p == nil {
+		if _, err := ms.WriteMessage(rr); err != nil {
+			return err
+		}
+		return fmt.Errorf("couldn't find a rollback program with name %s", name)
+	}
+
+	if p.MonotonicCounter > counter {
+		if _, err := ms.WriteMessage(rr); err != nil {
+			return err
+		}
+		return fmt.Errorf("couldn't write a smaller counter value %d for %s", counter, name)
+	}
+	// TODO(tmroeder): this needs synchronization for any real application.
+	p.MonotonicCounter = counter
+	rr.Type = RollbackMessageType_SET_COUNTER.Enum()
+	rr.Data = EncodeCounter(p.MonotonicCounter)
+	if _, err := ms.WriteMessage(rr); err != nil {
+		return err
+	}
+
+	return nil
+}
+
+// SetHash implements RollbackMessageType_SET_HASH by setting the value of the
+// hash for a given item to a given hash value.
+func (r *RollbackMaster) SetHash(ms *util.MessageStream, name string, item string, h []byte) error {
+	emptyData := make([]byte, 0)
+	rr := &RollbackResponse{
+		Type: RollbackMessageType_ERROR.Enum(),
+		Data: emptyData,
+	}
+
+	p := r.FindRollbackProgram(name)
+	if p == nil {
+		if _, err := ms.WriteMessage(rr); err != nil {
+			return err
+		}
+		return fmt.Errorf("couldn't find a rollback program with name %s", name)
+	}
+
+	// Set the hash.
+	if err := p.AddRollbackHashEntry(item, h); err != nil {
+		if _, e := ms.WriteMessage(rr); e != nil {
+			return e
+		}
+		return err
+	}
+
+	rh := &RollbackHash{
+		Item: proto.String(item),
+		Hash: h,
+	}
+	rhb, err := proto.Marshal(rh)
+	if err != nil {
+		if _, e := ms.WriteMessage(rr); e != nil {
+			return e
+		}
+		return err
+	}
+
+	// TODO(tmroeder): Do you need to update the counter when you update the
+	// hash?
+	rr.Type = RollbackMessageType_SET_HASH.Enum()
+	rr.Data = rhb
+	_, err = ms.WriteMessage(rr)
+	return err
+}
+
+// GetCounter implements RollbackMessageType_GET_COUNTER and returns the current
+// value of a counter to the requestor.
+func (r *RollbackMaster) GetCounter(ms *util.MessageStream, name string) error {
+	emptyData := make([]byte, 0)
+	rr := &RollbackResponse{
+		Type: RollbackMessageType_ERROR.Enum(),
+		Data: emptyData,
+	}
+
+	p := r.FindRollbackProgram(name)
+	if p == nil {
+		if _, err := ms.WriteMessage(rr); err != nil {
+			return err
+		}
+		return fmt.Errorf("couldn't find a rollback program with name %s", name)
+	}
+
+	rr.Type = RollbackMessageType_GET_COUNTER.Enum()
+	rr.Data = EncodeCounter(p.MonotonicCounter)
+	_, err := ms.WriteMessage(rr)
+	return err
+}
+
+// GetHashedVerifier gets a version of the hash for a given item along with the
+// current monotonic counter.
+func (r *RollbackMaster) GetHashedVerifier(ms *util.MessageStream, name string, item string) error {
+	emptyData := make([]byte, 0)
+	rr := &RollbackResponse{
+		Type: RollbackMessageType_ERROR.Enum(),
+		Data: emptyData,
+	}
+
+	p := r.FindRollbackProgram(name)
+	if p == nil {
+		if _, err := ms.WriteMessage(rr); err != nil {
+			return err
+		}
+		return fmt.Errorf("couldn't find a rollback program with name %s", name)
+	}
+
+	h := p.FindRollbackHashEntry(item)
+	if h == nil {
+		if _, err := ms.WriteMessage(rr); err != nil {
+			return err
+		}
+		return fmt.Errorf("couldn't find an item with name '%s' in program '%s'", item, name)
+	}
+	// Return SHA-256(Counter || Hash || Counter).
+	// TODO(tmroeder): what is the justification for this protocol?
+	sha256Hash := sha256.New()
+	b := EncodeCounter(p.MonotonicCounter)
+	sha256Hash.Write(b)
+	sha256Hash.Write(h)
+	sha256Hash.Write(b)
+	hash := sha256Hash.Sum(nil)
+
+	rr.Type = RollbackMessageType_GET_HASHED_VERIFIER.Enum()
+	rr.Data = hash[:]
+	_, err := ms.WriteMessage(rr)
+	return err
+}
+
+// The following functions are used by clients to access a remote rollback
+// server.
+
+// checkResponse waits for a RollbackResponse and checks to make sure it's not
+// an ERROR response from the server.
+func checkResponse(ms *util.MessageStream) error {
+	var rr RollbackResponse
+	if err := ms.ReadMessage(&rr); err != nil {
+		return err
+	}
+	if *rr.Type == RollbackMessageType_ERROR {
+		return fmt.Errorf("couldn't set the counter on the remote server")
+	}
+	return nil
+}
+
+// SetCounter sets the remote counter for this program.
+func SetCounter(ms *util.MessageStream, counter uint64) error {
+	rm := &RollbackMessage{
+		Type: RollbackMessageType_SET_COUNTER.Enum(),
+		Data: EncodeCounter(counter),
+	}
+	if _, err := ms.WriteMessage(rm); err != nil {
+		return err
+	}
+
+	// TODO(tmroeder): we currently ignore the value of the counter returned
+	// by the server.
+	return checkResponse(ms)
+}
+
+// SetHash sets the value of a hash for a given item for this program.
+func SetHash(ms *util.MessageStream, item string, hash []byte) error {
+	rh := &RollbackHash{
+		Item: proto.String(item),
+		Hash: hash,
+	}
+	rhb, err := proto.Marshal(rh)
+	if err != nil {
+		return err
+	}
+	rm := &RollbackMessage{
+		Type: RollbackMessageType_SET_HASH.Enum(),
+		Data: rhb,
+	}
+	if _, err := ms.WriteMessage(rm); err != nil {
+		return err
+	}
+
+	return checkResponse(ms)
+}
+
+// GetCounter gets the current value of the monotonic counter for a given
+// program name.
+func GetCounter(ms *util.MessageStream) (uint64, error) {
+	// The name of the program is managed by the rollback server, not the
+	// client, so it doesn't need to be passed in the message.
+	rm := &RollbackMessage{
+		Type: RollbackMessageType_GET_COUNTER.Enum(),
+		Data: make([]byte, 0),
+	}
+	if _, err := ms.WriteMessage(rm); err != nil {
+		return 0, err
+	}
+
+	// We can't use checkResponse here since we need to get the value out of
+	// the response to read the counter.
+	var rr RollbackResponse
+	if err := ms.ReadMessage(&rr); err != nil {
+		return 0, err
+	}
+	if *rr.Type == RollbackMessageType_ERROR {
+		return 0, fmt.Errorf("couldn't set the counter on the remote server")
+	}
+
+	return decodeCounter(rr.Data)
+}
+
+// GetHashedVerifier gets the hash of the counter and the item hash for a given
+// item.
+func GetHashedVerifier(ms *util.MessageStream, item string) ([]byte, error) {
+	rm := &RollbackMessage{
+		Type: RollbackMessageType_GET_HASHED_VERIFIER.Enum(),
+		Data: []byte(item),
+	}
+	if _, err := ms.WriteMessage(rm); err != nil {
+		return nil, err
+	}
+
+	// We can't use checkResponse here since we need to get the value out of
+	// the response to read the hash.
+	var rr RollbackResponse
+	if err := ms.ReadMessage(&rr); err != nil {
+		return nil, err
+	}
+	if *rr.Type == RollbackMessageType_ERROR {
+		return nil, fmt.Errorf("couldn't set the counter on the remote server")
+	}
+
+	return rr.Data, nil
+}
+
+// RunMessageLoop handles incoming messages for the RollbackMaster and passes
+// them to the appropriate functions.
+func (m *RollbackMaster) RunMessageLoop(ms *util.MessageStream, programPolicy *ProgramPolicy, name string) error {
+	for {
+		var msg RollbackMessage
+		if err := ms.ReadMessage(&msg); err != nil {
+			return err
+		}
+
+		switch *msg.Type {
+		case RollbackMessageType_SET_COUNTER:
+			i, err := decodeCounter(msg.Data)
+			if err != nil {
+				log.Printf("failed to decode counter for SET_COUNTER: %s", err)
+				continue
+			}
+
+			if err = m.SetCounter(ms, name, i); err != nil {
+				log.Printf("failed to set the counter on the RollbackMaster: %s", err)
+				continue
+			}
+		case RollbackMessageType_GET_COUNTER:
+			if err := m.GetCounter(ms, name); err != nil {
+				log.Printf("failed to get the counter for program %s", name)
+				continue
+			}
+		case RollbackMessageType_SET_HASH:
+			var rh RollbackHash
+			if err := proto.Unmarshal(msg.Data, &rh); err != nil {
+				log.Printf("failed to unmarshal the parameters for SET_HASH: %s", err)
+				continue
+			}
+			if err := m.SetHash(ms, name, *rh.Item, rh.Hash); err != nil {
+				log.Printf("failed to set the hash for item %s on program %s: %s", *rh.Item, name, err)
+				continue
+			}
+		case RollbackMessageType_GET_HASHED_VERIFIER:
+			if err := m.GetHashedVerifier(ms, name, string(msg.Data)); err != nil {
+				log.Printf("failed to get the hashed verifier for program %s: %s", name, err)
+				continue
+			}
+		default:
+			log.Printf("unknown rollback message %d", *msg.Type)
+		}
+	}
+
+	return nil
+}
diff --git a/apps/fileproxy/rollback.pb.go b/apps/fileproxy/rollback.pb.go
new file mode 100644
index 0000000..672a730
--- /dev/null
+++ b/apps/fileproxy/rollback.pb.go
@@ -0,0 +1,147 @@
+// Code generated by protoc-gen-go.
+// source: rollback.proto
+// DO NOT EDIT!
+
+/*
+Package fileproxy is a generated protocol buffer package.
+
+It is generated from these files:
+	rollback.proto
+
+It has these top-level messages:
+	RollbackMessage
+	RollbackHash
+	RollbackResponse
+*/
+package fileproxy
+
+import proto "code.google.com/p/goprotobuf/proto"
+import math "math"
+
+// Reference imports to suppress errors if they are not otherwise used.
+var _ = proto.Marshal
+var _ = math.Inf
+
+type RollbackMessageType int32
+
+const (
+	RollbackMessageType_SET_COUNTER         RollbackMessageType = 1
+	RollbackMessageType_GET_COUNTER         RollbackMessageType = 2
+	RollbackMessageType_SET_HASH            RollbackMessageType = 3
+	RollbackMessageType_GET_HASHED_VERIFIER RollbackMessageType = 4
+	RollbackMessageType_ERROR               RollbackMessageType = 5
+)
+
+var RollbackMessageType_name = map[int32]string{
+	1: "SET_COUNTER",
+	2: "GET_COUNTER",
+	3: "SET_HASH",
+	4: "GET_HASHED_VERIFIER",
+	5: "ERROR",
+}
+var RollbackMessageType_value = map[string]int32{
+	"SET_COUNTER":         1,
+	"GET_COUNTER":         2,
+	"SET_HASH":            3,
+	"GET_HASHED_VERIFIER": 4,
+	"ERROR":               5,
+}
+
+func (x RollbackMessageType) Enum() *RollbackMessageType {
+	p := new(RollbackMessageType)
+	*p = x
+	return p
+}
+func (x RollbackMessageType) String() string {
+	return proto.EnumName(RollbackMessageType_name, int32(x))
+}
+func (x *RollbackMessageType) UnmarshalJSON(data []byte) error {
+	value, err := proto.UnmarshalJSONEnum(RollbackMessageType_value, data, "RollbackMessageType")
+	if err != nil {
+		return err
+	}
+	*x = RollbackMessageType(value)
+	return nil
+}
+
+// A RollbackMessage is a message sent like an RPC between fileproxy hosts and a
+// rollback server. The data is sometimes simply data and is sometimes a
+// serialized protobuf, depending on the message type.
+type RollbackMessage struct {
+	Type             *RollbackMessageType `protobuf:"varint,1,req,name=type,enum=fileproxy.RollbackMessageType" json:"type,omitempty"`
+	Data             []byte               `protobuf:"bytes,2,req,name=data" json:"data,omitempty"`
+	XXX_unrecognized []byte               `json:"-"`
+}
+
+func (m *RollbackMessage) Reset()         { *m = RollbackMessage{} }
+func (m *RollbackMessage) String() string { return proto.CompactTextString(m) }
+func (*RollbackMessage) ProtoMessage()    {}
+
+func (m *RollbackMessage) GetType() RollbackMessageType {
+	if m != nil && m.Type != nil {
+		return *m.Type
+	}
+	return RollbackMessageType_SET_COUNTER
+}
+
+func (m *RollbackMessage) GetData() []byte {
+	if m != nil {
+		return m.Data
+	}
+	return nil
+}
+
+// A RollbackHash is a hash for a given item.
+type RollbackHash struct {
+	Item             *string `protobuf:"bytes,1,req,name=item" json:"item,omitempty"`
+	Hash             []byte  `protobuf:"bytes,2,req,name=hash" json:"hash,omitempty"`
+	XXX_unrecognized []byte  `json:"-"`
+}
+
+func (m *RollbackHash) Reset()         { *m = RollbackHash{} }
+func (m *RollbackHash) String() string { return proto.CompactTextString(m) }
+func (*RollbackHash) ProtoMessage()    {}
+
+func (m *RollbackHash) GetItem() string {
+	if m != nil && m.Item != nil {
+		return *m.Item
+	}
+	return ""
+}
+
+func (m *RollbackHash) GetHash() []byte {
+	if m != nil {
+		return m.Hash
+	}
+	return nil
+}
+
+// A RollbackResponse is the value received from the rollback server in response
+// to a RollbackMessage.
+type RollbackResponse struct {
+	Type             *RollbackMessageType `protobuf:"varint,1,req,name=type,enum=fileproxy.RollbackMessageType" json:"type,omitempty"`
+	Data             []byte               `protobuf:"bytes,2,req,name=data" json:"data,omitempty"`
+	XXX_unrecognized []byte               `json:"-"`
+}
+
+func (m *RollbackResponse) Reset()         { *m = RollbackResponse{} }
+func (m *RollbackResponse) String() string { return proto.CompactTextString(m) }
+func (*RollbackResponse) ProtoMessage()    {}
+
+func (m *RollbackResponse) GetType() RollbackMessageType {
+	if m != nil && m.Type != nil {
+		return *m.Type
+	}
+	return RollbackMessageType_SET_COUNTER
+}
+
+func (m *RollbackResponse) GetData() []byte {
+	if m != nil {
+		return m.Data
+	}
+	return nil
+}
+
+func init() {
+	proto.RegisterEnum("fileproxy.RollbackMessageType", RollbackMessageType_name, RollbackMessageType_value)
+}
diff --git a/apps/fileproxy/rollback.proto b/apps/fileproxy/rollback.proto
new file mode 100644
index 0000000..7c1410a
--- /dev/null
+++ b/apps/fileproxy/rollback.proto
@@ -0,0 +1,44 @@
+// Copyright (c) 2014, Google Inc. All rights reserved.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package fileproxy;
+
+enum RollbackMessageType {
+   SET_COUNTER = 1;
+   GET_COUNTER = 2;
+   SET_HASH = 3;
+   GET_HASHED_VERIFIER = 4;
+   ERROR = 5;
+}  
+
+// A RollbackMessage is a message sent like an RPC between fileproxy hosts and a
+// rollback server. The data is sometimes simply data and is sometimes a
+// serialized protobuf, depending on the message type.
+message RollbackMessage {
+  required RollbackMessageType type = 1;
+  required bytes data = 2;
+}
+
+// A RollbackHash is a hash for a given item.
+message RollbackHash {
+  required string item = 1;
+  required bytes hash = 2;
+}
+
+// A RollbackResponse is the value received from the rollback server in response
+// to a RollbackMessage.
+message RollbackResponse {
+  required RollbackMessageType type = 1;
+  required bytes data = 2;
+}
diff --git a/apps/fileproxy/rollbackhandler.go b/apps/fileproxy/rollbackhandler.go
deleted file mode 100644
index b3708c0..0000000
--- a/apps/fileproxy/rollbackhandler.go
+++ /dev/null
@@ -1,338 +0,0 @@
-// Copyright (c) 2014, Google, Inc.,  All rights reserved.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//     http://www.apache.org/licenses/LICENSE-2.0
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//
-// File: rollbackhandler.go
-
-package fileproxy
-
-import (
-	"crypto/sha256"
-	"encoding/binary"
-	"errors"
-	"log"
-
-	"code.google.com/p/goprotobuf/proto"
-
-	"github.com/jlmucb/cloudproxy/util"
-)
-
-type NameAndHash struct {
-	ItemName string
-	Hash     []byte
-}
-
-type RollbackProgramInfo struct {
-	MasterInfoSaveFile string
-	HashSaveFile       string
-	ProgramName        string
-	MonotonicCounter   int64
-	Initialized        bool
-	NameAndHashArray   []NameAndHash
-}
-
-type RollbackMaster struct {
-	ProgramName string
-	Initialized bool
-	ProgramInfo []RollbackProgramInfo
-}
-
-func (r *RollbackMaster) FindRollbackProgramTable(programName string) *RollbackProgramInfo {
-	for i := range r.ProgramInfo {
-		if r.ProgramInfo[i].ProgramName == programName {
-			return &r.ProgramInfo[i]
-		}
-	}
-	return nil
-}
-
-func (r *RollbackMaster) AddRollbackProgramTable(programName string) *RollbackProgramInfo {
-	log.Printf("AddRollbackProgramTable: %s\n", programName)
-	pi := r.FindRollbackProgramTable(programName)
-	if pi != nil {
-		return pi
-	}
-	if len(r.ProgramInfo) >= cap(r.ProgramInfo) {
-		t := make([]RollbackProgramInfo, 2*cap(r.ProgramInfo))
-		copy(t, r.ProgramInfo)
-		r.ProgramInfo = t
-	}
-	r.ProgramInfo = r.ProgramInfo[0 : len(r.ProgramInfo)+1]
-	log.Printf("len(r.ProgramInfo)= %d, cap(r.ProgramInfo)= %d\n", len(r.ProgramInfo), cap(r.ProgramInfo))
-	pi = &r.ProgramInfo[len(r.ProgramInfo)-1]
-	pi.ProgramName = programName
-	pi.MonotonicCounter = 0
-	pi.NameAndHashArray = make([]NameAndHash, 100)
-	pi.NameAndHashArray = pi.NameAndHashArray[0:0]
-	log.Printf("len(pi.pi.NameAndHashArray)= %d, cap(pi.pi.NameAndHashArray)= %d\n", len(pi.NameAndHashArray), cap(pi.NameAndHashArray))
-	pi.Initialized = true
-	return pi
-}
-
-func (r *RollbackMaster) ReadMasterRollbackInfo(masterFile string, hashFile string) bool {
-	return false
-}
-
-func (r *RollbackMaster) SaveMasterRollbackInfo(masterFile string, hashFile string) bool {
-	return false
-}
-
-func (pi *RollbackProgramInfo) ReadProgramRollbackInfo(programName string, masterFile string, hashFile string) bool {
-	return false
-}
-
-func (pi *RollbackProgramInfo) SaveProgramRollbackInfo(programName string, masterFile string, hashFile string) bool {
-	return false
-}
-
-func (pi *RollbackProgramInfo) FindRollbackHashEntry(itemName string) *NameAndHash {
-	for i := range pi.NameAndHashArray {
-		log.Printf("FindRollbackHashEntry %s %s\n", itemName, pi.NameAndHashArray[i].ItemName)
-		if pi.NameAndHashArray[i].ItemName == itemName {
-			return &pi.NameAndHashArray[i]
-		}
-	}
-	return nil
-}
-
-func (pi *RollbackProgramInfo) AddHashEntry(itemName string, hash []byte) *NameAndHash {
-	log.Printf("AddHashEntry %s\n", itemName)
-	he := pi.FindRollbackHashEntry(itemName)
-	if he != nil {
-		he.Hash = hash
-		return he
-	}
-	if len(pi.NameAndHashArray) >= cap(pi.NameAndHashArray) {
-		t := make([]NameAndHash, 2*cap(pi.NameAndHashArray))
-		copy(t, pi.NameAndHashArray)
-		pi.NameAndHashArray = t
-	}
-	pi.NameAndHashArray = pi.NameAndHashArray[0 : len(pi.NameAndHashArray)+1]
-	he = &pi.NameAndHashArray[len(pi.NameAndHashArray)-1]
-	he.ItemName = itemName
-	he.Hash = hash
-	log.Printf("item: %s, hash %x\n", itemName, hash)
-	return he
-}
-
-func (r *RollbackMaster) InitRollbackMaster(masterprogramName string) bool {
-	log.Printf("InitRollbackMaster\n")
-	r.Initialized = true
-	r.ProgramName = masterprogramName
-	r.ProgramInfo = make([]RollbackProgramInfo, 100)
-	r.ProgramInfo = r.ProgramInfo[0:0]
-	log.Printf("len(r.ProgramInfo)= %d, cap(r.ProgramInfo)= %d\n", len(r.ProgramInfo), cap(r.ProgramInfo))
-	// read master
-	// decrypt
-	// update
-
-	// read hash table
-	// decrypt
-	// update
-	return true
-}
-
-func (r *RollbackMaster) SetRollbackCounter(ms *util.MessageStream, programName string, counter int64) bool {
-	pi := r.FindRollbackProgramTable(programName)
-	if pi == nil {
-		log.Printf("SetRollbackCounter: program has no program info table 1")
-		SendResponse(ms, "failed", "Rollback doesn't exist", 0)
-		return false
-	}
-	if pi.MonotonicCounter > counter {
-		log.Printf("SetRollbackCounter: can't set counter backwards")
-		SendResponse(ms, "failed", "Rollback counter can't decrease", 0)
-		return false
-	}
-	pi.MonotonicCounter = counter
-	log.Printf("SetRollbackCounter (%s) table counter: %d\n", pi.ProgramName, pi.MonotonicCounter)
-	SendResponse(ms, "succeeded", "", 0)
-	return true
-}
-
-func (r *RollbackMaster) SetRollbackResourceHash(ms *util.MessageStream, programName string, itemName string) bool {
-	pi := r.FindRollbackProgramTable(programName)
-	if pi == nil {
-		log.Printf("SetRollbackResourceHash: program has no program info table 2")
-		SendResponse(ms, "failed", "Rollback doesn't exist", 0)
-		return false
-	}
-	SendResponse(ms, "succeeded", "", 0)
-	// get hash
-	hash, err := GetProtocolMessage(ms)
-	if err != nil {
-		log.Printf("SetRollbackResourceHash: GetProtocolMessage failed\n")
-		SendResponse(ms, "failed", "Rollback doesn't exist", 0)
-		return false
-	}
-	hi := pi.FindRollbackHashEntry(itemName)
-	if hi == nil {
-		hi = pi.AddHashEntry(itemName, hash)
-		if hi == nil {
-			log.Printf("SetRollbackResourceHash: no hash entry\n")
-			SendResponse(ms, "failed", "can't insert entry", 0)
-			return false
-		}
-	} else {
-		log.Printf("SetRollbackResourceHash, found %s entry\n", hi.ItemName)
-		hi.Hash = hash
-	}
-	return true
-}
-
-func (r *RollbackMaster) GetRollbackCounter(ms *util.MessageStream, programName string) bool {
-	pi := r.FindRollbackProgramTable(programName)
-	if pi == nil {
-		log.Printf("GetRollbackCounter: program has no program info table\n")
-		SendResponse(ms, "failed", "Rollback doesn't exist", 0)
-		return false
-	}
-	log.Printf("GetRollbackCounter(%s), counter: %d\n", pi.ProgramName, pi.MonotonicCounter)
-	SendCounterResponse(ms, "succeeded", "", pi.MonotonicCounter)
-	return true
-}
-
-func (r *RollbackMaster) GetRollbackHashedVerifier(ms *util.MessageStream, programName string, itemName string) bool {
-	log.Printf("GetRollbackHashedVerifier\n")
-	pi := r.FindRollbackProgramTable(programName)
-	if pi == nil {
-		log.Printf("GetRollbackHashedVerifier: program has no program info table")
-		SendResponse(ms, "failed", "Rollback doesn't exist", 0)
-		return false
-	}
-	hi := pi.FindRollbackHashEntry(itemName)
-	if hi == nil {
-		log.Printf("GetRollbackResourceHash: program has no hash entry for %s\n", itemName)
-		SendResponse(ms, "failed", "can't insert entry", 0)
-		return false
-	}
-	// now has the epoch and the hash and return thatkk
-	sha256Hash := sha256.New()
-	b := make([]byte, 8)
-	binary.PutVarint(b, pi.MonotonicCounter)
-	sha256Hash.Write(b)
-	sha256Hash.Write(hi.Hash)
-	sha256Hash.Write(b)
-	hash := sha256Hash.Sum(nil)
-	SendResponse(ms, "succeeded", "", 0)
-	SendProtocolMessage(ms, len(hash), hash)
-	return true
-}
-
-// Update hash for resouce named resource
-func ClientSetRollbackCounter(ms *util.MessageStream, counter int64) bool {
-	SendCounterRequest(ms, counter)
-	status, _, _, err := GetResponse(ms)
-	if err != nil || status == nil || *status != "succeeded" {
-		return false
-	}
-	return true
-}
-
-func ClientSetResourceHashRequest(ms *util.MessageStream, clientProgramName string, item string, hash []byte) bool {
-	log.Printf("ClientSetResourceHashRequest %s, %s\n", clientProgramName, item)
-	action := "setrollbackhash"
-	SendRequest(ms, nil, &action, &item, nil)
-	status, _, _, err := GetResponse(ms)
-	if err != nil || status == nil || *status != "succeeded" {
-		log.Printf("ClientSetResourceHashRequest failed\n")
-		return false
-	}
-	err = SendProtocolMessage(ms, len(hash), hash)
-	return true
-}
-
-func ClientGetRollbackCounter(ms *util.MessageStream, clientProgramName string) (bool, int64) {
-	log.Printf("ClientGetRollbackCounter%s, %s\n", clientProgramName)
-	action := "getrollbackcounter"
-	SendRequest(ms, &clientProgramName, &action, nil, nil)
-	status, _, counter, err := GetCounterResponse(ms)
-	if err != nil || status == nil || *status != "succeeded" || counter == nil {
-		if err != nil {
-			log.Printf("ClientGetRollbackCounter, err is not nil\n")
-		}
-		if status == nil {
-			log.Printf("ClientGetRollbackCounter, status is nil\n")
-		}
-		log.Printf("ClientGetRollbackCounter: %s\n", *status)
-		if counter == nil {
-			log.Printf("ClientGetRollbackCounter, counter is nil\n")
-		}
-		return false, 0
-	}
-	return true, *counter
-}
-
-func ClientGetRollbackHashedVerifierRequest(ms *util.MessageStream, clientProgramName string, item string) (bool, []byte) {
-	log.Printf("ClientGetRollbackHashedVerifierRequest: %s, %s\n", clientProgramName, item)
-	action := "getrollbackcounterverifier"
-	SendRequest(ms, nil, &action, &item, nil)
-	status, _, _, err := GetResponse(ms)
-	if status == nil || *status != "succeeded" || err != nil {
-		return false, nil
-	}
-	hash, err := GetProtocolMessage(ms)
-	return true, hash
-}
-
-// First return value is terminate flag
-func (r *RollbackMaster) HandleServiceRequest(ms *util.MessageStream, programPolicyObject *ProgramPolicy, clientProgramName string, request []byte) (bool, error) {
-	log.Printf("rollbackhandler: HandleServiceRequest for %s\n", clientProgramName)
-
-	fpMessage := new(FPMessage)
-	err := proto.Unmarshal(request, fpMessage)
-	if err != nil {
-		return false, errors.New("HandleService can't unmarshal request")
-	}
-	if fpMessage.MessageType == nil {
-		return false, errors.New("HandleService: no message type")
-	}
-	switch MessageType(*fpMessage.MessageType) {
-	case MessageType_REQUEST:
-	default:
-		return false, errors.New("HandleService does not get MessageType_REQUEST")
-	}
-	action := fpMessage.ActionName
-	if action == nil {
-		SendResponse(ms, "failed", "", 0)
-		return false, errors.New("no action")
-	}
-
-	switch *action {
-	case "setrollbackcounter":
-		if fpMessage.MonotonicCounter == nil {
-			log.Printf("HandleServiceRequest: no counter in setrollbackcounter message")
-			SendResponse(ms, "failed", "no counter", 0)
-		}
-		_ = r.SetRollbackCounter(ms, clientProgramName, *fpMessage.MonotonicCounter)
-		return false, nil
-	case "getrollbackcounter":
-		_ = r.GetRollbackCounter(ms, clientProgramName)
-		return false, nil
-	case "setrollbackhash":
-		if fpMessage.ResourceName == nil {
-			log.Printf("HandleServiceRequest: no resource name in setrollbackhash message")
-			SendResponse(ms, "failed", "no counter", 0)
-		}
-		_ = r.SetRollbackResourceHash(ms, clientProgramName, *fpMessage.ResourceName)
-		return false, nil
-	case "getrollbackcounterverifier":
-		if fpMessage.ResourceName == nil {
-			log.Printf("HandleServiceRequest: no resource name in getrollbackcounterverifier message")
-			SendResponse(ms, "failed", "no counter", 0)
-		}
-		r.GetRollbackHashedVerifier(ms, clientProgramName, *fpMessage.ResourceName)
-		return false, nil
-	default:
-		SendResponse(ms, "failed", "", 0)
-		return false, errors.New("unsupported action")
-	}
-}
diff --git a/apps/fileproxy/rollbackserver/rebuild b/apps/fileproxy/rollbackserver/rebuild
deleted file mode 100755
index 928d2a7..0000000
--- a/apps/fileproxy/rollbackserver/rebuild
+++ /dev/null
@@ -1,8 +0,0 @@
-#
-echo "rebuilding rollbackproxy"
-cd ..
-go build ...
-cd rollbackserver
-echo "rebuilding rollbackserver"
-go build rollbackserver.go
-echo "done"
diff --git a/apps/fileproxy/rollbackserver/rollbackserver.go b/apps/fileproxy/rollbackserver/rollbackserver.go
index cb5e5c5..54b6280 100644
--- a/apps/fileproxy/rollbackserver/rollbackserver.go
+++ b/apps/fileproxy/rollbackserver/rollbackserver.go
@@ -5,216 +5,157 @@
 // You may obtain a copy of the License at
 //     http://www.apache.org/licenses/LICENSE-2.0
 // Unless required by applicable law or agreed to in writing, software
 // distributed under the License is distributed on an "AS IS" BASIS,
 // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 // See the License for the specific language governing permissions and
 // limitations under the License.
 //
 // File: rollbackserver.go
 
 package main
 
 import (
 	"crypto/tls"
 	"crypto/x509"
 	"flag"
 	"log"
 	"net"
 
 	"github.com/jlmucb/cloudproxy/apps/fileproxy"
-	tao "github.com/jlmucb/cloudproxy/tao"
+	"github.com/jlmucb/cloudproxy/tao"
 	"github.com/jlmucb/cloudproxy/tao/auth"
 	taonet "github.com/jlmucb/cloudproxy/tao/net"
 	"github.com/jlmucb/cloudproxy/util"
 )
 
-var hostcfg = flag.String("../hostdomain/tao.config", "../hostdomain/tao.config", "path to host tao configuration")
-var serverHost = flag.String("host", "localhost", "address for client/server")
-var serverPort = flag.String("port", "8129", "port for client/server")
-var rollbackserverPath = flag.String("rollbackserver_files/", "rollbackserver_files/", "rollbackserver directory")
-var serverAddr string
-
-var DerPolicyCert []byte
-var SigningKey tao.Keys
-var SymKeys []byte
-var ProgramCert []byte
-
-func clientServiceThead(ms *util.MessageStream, clientName string, rollbackPolicy *fileproxy.ProgramPolicy, rollbackMasterTable *fileproxy.RollbackMaster) {
-	log.Printf("rollbackserver: clientServiceThead\n")
-	pi := rollbackMasterTable.AddRollbackProgramTable(clientName)
-	if pi == nil {
-		log.Printf("rollbackserver cannot rollbackMasterTable.AddRollbackProgramTable\n")
-		return
-	}
-	// How do I know if the connection terminates?
-	for {
-		log.Printf("clientServiceThead: ReadString\n")
-		strbytes, err := ms.ReadString()
-		if err != nil {
-			return
-		}
-		terminate, err := rollbackMasterTable.HandleServiceRequest(ms, rollbackPolicy, clientName, []byte(strbytes))
-		if terminate {
-			break
-		}
-	}
-	log.Printf("fileserver: client thread terminating\n")
-}
-
-func server(serverAddr string, prin string, rollbackPolicy *fileproxy.ProgramPolicy, rollbackMasterTable *fileproxy.RollbackMaster) {
-	var sock net.Listener
-	log.Printf("fileserver: server\n")
-
-	policyCert, err := x509.ParseCertificate(DerPolicyCert)
+func serve(serverAddr string, prin string, policyCert []byte, signingKey *tao.Keys, policy *fileproxy.ProgramPolicy, m *fileproxy.RollbackMaster) error {
+	pc, err := x509.ParseCertificate(policyCert)
 	if err != nil {
-		log.Printf("fileserver: can't ParseCertificate\n")
-		return
+		return err
 	}
 	pool := x509.NewCertPool()
-	pool.AddCert(policyCert)
-	tlsc, err := taonet.EncodeTLSCert(&SigningKey)
+	pool.AddCert(pc)
+	tlsc, err := taonet.EncodeTLSCert(signingKey)
 	if err != nil {
-		log.Printf("fileserver, encode error: ", err)
-		log.Printf("\n")
-		return
+		return err
 	}
 	conf := &tls.Config{
 		RootCAs:            pool,
 		Certificates:       []tls.Certificate{*tlsc},
 		InsecureSkipVerify: false,
 		ClientAuth:         tls.RequireAnyClientCert,
 	}
-	log.Printf("Listenting\n")
-	sock, err = tls.Listen("tcp", serverAddr, conf)
+	log.Println("Rollback server listening")
+	sock, err := tls.Listen("tcp", serverAddr, conf)
 	if err != nil {
-		log.Printf("rollbackserver, listen error: ", err)
-		log.Printf("\n")
-		return
+		return err
 	}
+
 	for {
-		log.Printf("rollbackserver: at Accept\n")
 		conn, err := sock.Accept()
 		if err != nil {
-			log.Printf("rollbackserver: can't accept connection: %s\n", err.Error())
+			return err
 		}
 		var clientName string
-		clientName = "XYZZY"
-		err = conn.(*tls.Conn).Handshake()
-		if err != nil {
-			log.Printf("TLS handshake failed\n")
+		if err = conn.(*tls.Conn).Handshake(); err != nil {
+			log.Println("TLS handshake failed")
+			continue
 		}
+
 		peerCerts := conn.(*tls.Conn).ConnectionState().PeerCertificates
 		if peerCerts == nil {
-			log.Printf("rollbackserver: can't get peer list\n")
-		} else {
-			peerCert := conn.(*tls.Conn).ConnectionState().PeerCertificates[0]
-			if peerCert.Raw == nil {
-				log.Printf("rollbackserver: can't get peer name\n")
-			} else {
-				if peerCert.Subject.OrganizationalUnit != nil {
-					clientName = peerCert.Subject.OrganizationalUnit[0]
-				}
-			}
+			log.Println("rollbackserver: can't get peer list")
+			continue
+		}
+
+		peerCert := conn.(*tls.Conn).ConnectionState().PeerCertificates[0]
+		if peerCert.Raw == nil {
+			log.Println("rollbackserver: can't get peer name")
+			continue
 		}
-		log.Printf("rollbackserver, peer name: %s\n", clientName)
+
+		if peerCert.Subject.OrganizationalUnit == nil {
+			log.Println("No OrganizationalUnit name in the peer certificate. Refusing the connection")
+			continue
+		}
+
+		clientName = peerCert.Subject.OrganizationalUnit[0]
 		ms := util.NewMessageStream(conn)
-		go clientServiceThead(ms, clientName, rollbackPolicy, rollbackMasterTable)
+		// TODO(tmroeder): support multiple simultaneous clients.
+		// Add this program as a rollback program.
+		log.Printf("Adding a program with name '%s'\n", clientName)
+		_ = m.AddRollbackProgram(clientName)
+		if err := m.RunMessageLoop(ms, policy, clientName); err != nil {
+			log.Printf("rollbackserver: failed to run message loop: %s\n", err)
+		}
 	}
 }
 
 func main() {
-	log.Printf("rollback server\n")
-
-	var rollbackMaster fileproxy.RollbackMaster
-	var rollbackProgramPolicyObject fileproxy.ProgramPolicy
+	caAddr := flag.String("caAddr", "localhost:8124", "The address of the CA for setting up a certificate signed by the policy key")
+	hostcfg := flag.String("hostconfig", "tao.config", "path to host tao configuration")
+	serverHost := flag.String("host", "localhost", "address for client/server")
+	serverPort := flag.String("port", "8129", "port for client/server")
+	rollbackServerPath := flag.String("rollbackserver_files", "rollbackserver_files", "rollbackserver directory")
+	country := flag.String("country", "US", "The country for the fileclient certificate")
+	org := flag.String("organization", "Google", "The organization for the fileclient certificate")
 
 	flag.Parse()
-	serverAddr = *serverHost + ":" + *serverPort
+	serverAddr := net.JoinHostPort(*serverHost, *serverPort)
 
 	hostDomain, err := tao.LoadDomain(*hostcfg, nil)
 	if err != nil {
-		log.Fatalln("rollbackserver: can't LoadDomain\n")
+		log.Fatalln("rollbackserver: can't load domain:", err)
 	}
-	log.Printf("rollbackserver: Domain name: %s\n", hostDomain.ConfigPath)
-	DerPolicyCert = nil
+	var policyCert []byte
 	if hostDomain.Keys.Cert != nil {
-		DerPolicyCert = hostDomain.Keys.Cert.Raw
+		policyCert = hostDomain.Keys.Cert.Raw
 	}
-	if DerPolicyCert == nil {
+	if policyCert == nil {
 		log.Fatalln("rollbackserver: can't retrieve policy cert")
 	}
 
-	if err := hostDomain.ExtendTaoName(tao.Parent()); err != nil {
+	parentTao := tao.Parent()
+	if err := hostDomain.ExtendTaoName(parentTao); err != nil {
 		log.Fatalln("fileserver: can't extend the Tao with the policy key")
 	}
 	e := auth.PrinExt{Name: "rollbackserver_version_1"}
-	err = tao.Parent().ExtendTaoName(auth.SubPrin{e})
-	if err != nil {
+	if err = parentTao.ExtendTaoName(auth.SubPrin{e}); err != nil {
 		log.Fatalln("rollbackserver: can't extend name")
 	}
 
-	taoName, err := tao.Parent().GetTaoName()
+	taoName, err := parentTao.GetTaoName()
 	if err != nil {
 		return
 	}
-	log.Printf("rollbackserver: my name is %s\n", taoName)
 
-	sealedSymmetricKey, sealedSigningKey, derCert, delegation, err := fileproxy.LoadProgramKeys(*rollbackserverPath)
+	// Create or read the keys for rollbackserver.
+	rbKeys, err := tao.NewOnDiskTaoSealedKeys(tao.Signing|tao.Crypting, parentTao, *rollbackServerPath, tao.SealPolicyDefault)
 	if err != nil {
-		log.Printf("rollbackserver: can't retrieve key material\n")
+		log.Fatalln("rollbackserver: couldn't set up the Tao-sealed keys:", err)
 	}
-	if sealedSymmetricKey == nil || sealedSigningKey == nil || delegation == nil || derCert == nil {
-		log.Printf("rollbackserver: No key material present\n")
-	}
-	ProgramCert = derCert
 
-	defer fileproxy.ZeroBytes(SymKeys)
-	if sealedSymmetricKey != nil {
-		symkeys, policy, err := tao.Parent().Unseal(sealedSymmetricKey)
-		if err != nil {
-			return
-		}
-		if policy != tao.SealPolicyDefault {
-			log.Printf("rollbackserver: unexpected policy on unseal\n")
-		}
-		SymKeys = symkeys
-		log.Printf("rollbackserver: Unsealed symKeys: % x\n", SymKeys)
-	} else {
-		symkeys, err := fileproxy.InitializeSealedSymmetricKeys(*rollbackserverPath, tao.Parent(), fileproxy.SizeofSymmetricKeys)
-		if err != nil {
-			log.Printf("rollbackserver: InitializeSealedSymmetricKeys error: %s\n", err)
-		}
-		SymKeys = symkeys
-		log.Printf("rollbackserver: InitilizedsymKeys: % x\n", SymKeys)
+	// Set up a temporary cert for communication with keyNegoServer.
+	rbKeys.Cert, err = rbKeys.SigningKey.CreateSelfSignedX509(tao.NewX509Name(tao.X509Details{
+		Country:      *country,
+		Organization: *org,
+		CommonName:   taoName.String(),
+	}))
+	if err != nil {
+		log.Fatalln("rollbackserver: couldn't create a self-signed cert for rollbackserver keys:", err)
 	}
 
-	if sealedSigningKey != nil {
-		log.Printf("rollbackserver: retrieving signing key\n")
-		signingkey, err := fileproxy.SigningKeyFromBlob(tao.Parent(),
-			sealedSigningKey, derCert, delegation)
-		if err != nil {
-			log.Printf("rollbackserver: SigningKeyFromBlob error: %s\n", err)
-		}
-		SigningKey = *signingkey
-		log.Printf("rollbackserver: Retrieved Signing key: % x\n", SigningKey)
-	} else {
-		log.Printf("rollbackserver: initializing signing key\n")
-		signingkey, err := fileproxy.InitializeSealedSigningKey(*rollbackserverPath,
-			tao.Parent(), *hostDomain)
-		if err != nil {
-			log.Printf("rollbackserver: InitializeSealedSigningKey error: %s\n", err)
-		}
-		SigningKey = *signingkey
-		log.Printf("rollbackserver: Initialized signingKey\n")
-		ProgramCert = SigningKey.Cert.Raw
+	// Contact keyNegoServer for the certificate.
+	if err := fileproxy.EstablishCert("tcp", *caAddr, rbKeys, hostDomain.Keys.VerifyingKey); err != nil {
+		log.Fatalf("rollbackserver: couldn't establish a cert signed by the policy key: %s", err)
 	}
-	taoNameStr := taoName.String()
-	_ = rollbackProgramPolicyObject.InitProgramPolicy(DerPolicyCert, taoNameStr, SigningKey, SymKeys, ProgramCert)
-	rollbackMaster.InitRollbackMaster(taoNameStr)
 
-	server(serverAddr, taoNameStr, &rollbackProgramPolicyObject, &rollbackMaster)
-	if err != nil {
-		log.Printf("rollbackserver: server error\n")
+	// The symmetric keys aren't used by the rollback server.
+	progPolicy := fileproxy.NewProgramPolicy(policyCert, taoName.String(), rbKeys, nil, rbKeys.Cert.Raw)
+	m := fileproxy.NewRollbackMaster(taoName.String())
+
+	if err := serve(serverAddr, taoName.String(), policyCert, rbKeys, progPolicy, m); err != nil {
+		log.Fatalf("rollbackserver: server error: %s\n", err)
 	}
-	log.Printf("rollbackserver: done\n")
+	log.Println("rollbackserver: done")
 }
diff --git a/apps/fileproxy/run.sh b/apps/fileproxy/run.sh
new file mode 100755
index 0000000..b2984f2
--- /dev/null
+++ b/apps/fileproxy/run.sh
@@ -0,0 +1,22 @@
+#!/bin/bash
+
+# This must be run in a directory created by install.sh.
+
+# Set up the linux host and its environment and get it started.
+scripts/setup.sh
+scripts/start.sh
+
+echo "Waiting for the Linux host to start"
+sleep 5
+
+# Set up the key server.
+bin/keynegoserver -password=BogusPass &
+
+# Set up the RollbackMaster and the ResourceMaster under the Tao.
+scripts/host.sh ./bin/rollbackserver -hostconfig=tao.config
+scripts/host.sh ./bin/fileserver -hostconfig=tao.config
+
+# Create a user and start the test client.
+bin/tao_admin -newuserkey -common_name="jlm" -pass=BogusPass
+scripts/host.sh ./bin/fileclient -hostconfig=tao.config
+
diff --git a/apps/tao_admin/main.go b/apps/tao_admin/main.go
index 96eb492..324da01 100644
--- a/apps/tao_admin/main.go
+++ b/apps/tao_admin/main.go
@@ -7,76 +7,72 @@
 //     http://www.apache.org/licenses/LICENSE-2.0
 //
 // Unless required by applicable law or agreed to in writing, software
 // distributed under the License is distributed on an "AS IS" BASIS,
 // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
 package main
 
 import (
 	"crypto/sha256"
 	"crypto/x509"
 	"flag"
 	"fmt"
 	"io"
 	"io/ioutil"
 	"log"
 	"os"
 	"path"
-	"time"
-	"math/big"
-	"crypto/rand"
-	"code.google.com/p/goprotobuf/proto"
+
 	"github.com/google/go-tpm/tpm"
 	"github.com/jlmucb/cloudproxy/tao"
 	"github.com/jlmucb/cloudproxy/tao/auth"
 	"github.com/jlmucb/cloudproxy/util"
 )
 
 // common options
 var configPath = flag.String("config_path", "tao.config", "Location of tao domain configuration.")
 var pass = flag.String("pass", "", "Password for unlocking policy private key.")
 var quiet = flag.Bool("quiet", false, "Be more quiet.")
 var show = flag.Bool("show", false, "Show info when done.")
 var host = flag.String("host", "", "The principal name of the host where programs will execute.")
 
 // initializing a new domain
 var create = flag.Bool("create", false, "Create a new domain configuration.")
 var name = flag.String("name", "", "Name for a new configuration.")
 var guard = flag.String("guard", "TrivialLiberalGuard", "Name of guard: ACLs, Datalog, etc.")
 
 // execution policy changes
 var canExecute = flag.String("canexecute", "", "Path of a program to be authorized to execute.")
 var retractCanExecute = flag.String("retractcanexecute", "", "Path of a program to retract authorization to execute.")
 
 // Sign a user cert
-var newUserKey= flag.Bool("newuserkey", false, "Create key and cert.")
-var commonName= flag.String("commonname", "", "Mandatory user name")
-var ouName= flag.String("fileproxyUser", "fileproxy-user", "OU")
-var serialNumber= flag.Int("serial number", 43, "serial number")
-var keyPath= flag.String("./keys/", "./keys/", "key path")
-var keyFileName= flag.String("key", "key", "key file")
-var certFileName= flag.String("cert", "cert", "cert file")
-
-var readKey=flag.Bool("readkey", false, "Read key and cert.")
+var newUserKey = flag.Bool("newuserkey", false, "Create key and cert.")
+var commonName = flag.String("common_name", "", "Mandatory user name")
+var country = flag.String("country", "US", "Country for the cert")
+var org = flag.String("organization", "Google", "Organization for the cert")
+var ouName = flag.String("user", "fileproxy-user", "OU")
+var serialNumber = flag.Int("serial_number", 43, "serial number")
+var keyPath = flag.String("key_path", "usercreds", "key path")
+var userKeyPass = flag.String("key_pass", "BogusPass", "password for the user credential")
 
 // arbitrary policy changes
 var add = flag.String("add", "", "A policy rule to be added.")
 var retract = flag.String("retract", "", "A policy rule to be retracted.")
 var clear = flag.Bool("clear", false, "Clear all policy rules before other changes.")
 var query = flag.String("query", "", "A policy query to be checked.")
 
 // misc. utilities
 var getProgramHash = flag.String("getprogramhash", "", "Path of program to be hashed.")
 var getPCR = flag.Int("getpcr", -1, "Index of a PCR to return.")
 var tpmPath = flag.String("tpm", "/dev/tpm0", "Path to a TPM device.")
 var aikFile = flag.String("aikblob", "", "A file containing a TPM AIK.")
 
 func main() {
 	help := "Administrative utility for Tao Domain.\n"
 	help += "Usage: %[1]s [options] -create [-name name]\n"
 	help += "%[1]s [options] -(retractcanexecute|canexecute) progpath\n"
 	help += "%[1]s [options] -(add|retract|query) rule\n"
 	help += "%[1]s [options] -clear\n"
 	flag.Usage = func() {
@@ -118,105 +114,58 @@ func main() {
 		case "ACLs":
 			cfg.ACLGuard.SignedACLsPath = rulesPath
 		case "Datalog":
 			cfg.DatalogGuard.SignedRulesPath = rulesPath
 		}
 
 		domain, err = tao.CreateDomain(cfg, *configPath, []byte(*pass))
 		fatalIf(err)
 	} else {
 		domain, err = tao.LoadDomain(*configPath, []byte(*pass))
 		fatalIf(err)
 	}
 
 	if *clear {
 		didWork = true
 		domain.Guard.Clear()
 		err := domain.Save()
 		fatalIf(err)
 	}
 	if *newUserKey {
-		if(*commonName=="") {
-			log.Fatal("commonName is required.")
-		} else {
-			domain, err = tao.LoadDomain(*configPath, []byte(*pass))
-			if(err!=nil) {
-				fatalIf(err)
-			}
-			policyKey:= domain.Keys
-			fmt.Fprintf(noise, "Creating key for user: %s\n", *commonName)
-			userKey, err:=  tao.NewTemporaryKeys(tao.Signing)
-			if userKey==nil || err!= nil {
-				log.Fatal("Can't create key.")
-			}
-			details:= tao.X509Details {
-			Country: "US",
-			Organization: "Google",
-			OrganizationalUnit: *ouName,
-			CommonName: *commonName, }
-			subjectname:= tao.NewX509Name(details)
-			*serialNumber= *serialNumber+1
-			template := &x509.Certificate {
-				SignatureAlgorithm: x509.ECDSAWithSHA256,
-				PublicKeyAlgorithm: x509.ECDSA,
-				// It's always allowed for self-signed certs to have serial 1.
-				SerialNumber: new(big.Int).SetInt64(int64(*serialNumber)),
-				Subject:      *subjectname,
-				NotBefore:    time.Now(),
-				NotAfter:     time.Now().AddDate(1 /* years */, 0 /* months */, 0 /* days */),
-				KeyUsage:    x509.KeyUsageKeyAgreement,
-				ExtKeyUsage: []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth, x509.ExtKeyUsageClientAuth},
-			}
-			userDerCert, err := x509.CreateCertificate(rand.Reader, template, policyKey.Cert,
-				userKey.VerifyingKey.GetVerifierEc(), policyKey.SigningKey.GetSignerEc())
-			if(err!=nil) {
-				log.Fatal("Cant create cert\n")
-			}
-			err= ioutil.WriteFile(*keyPath+*certFileName, userDerCert, os.ModePerm)
-			cks, err := tao.MarshalKeyset(userKey)
-			if err != nil {
-				log.Fatal("Cant marshal user key.")
-			}
-			// TODO?: defer zeroKeyset(cks)
-			pks, err := proto.Marshal(cks)
-			if err != nil {
-				log.Fatal("Cant marshal CryptoKey.")
-			}
-			ioutil.WriteFile(*keyPath+*keyFileName, pks, os.ModePerm)
-		}
-	}
-	if *readKey {
-		pks, err:= ioutil.ReadFile(*keyPath+*keyFileName)
-		if err != nil {
-			log.Fatal("Cant read key file.")
+		if *commonName == "" {
+			log.Fatalln("commonName is required")
 		}
-		var cks *tao.CryptoKeyset
-		err= proto.Unmarshal(pks, cks)
-		if err != nil {
-			log.Fatal("Cant key protobuf.")
-		}
-		userKey, err:= tao.UnmarshalKeyset(cks)
-		if err != nil {
-			log.Fatal("Cant Unmarshal keyset.")
+
+		if domain, err = tao.LoadDomain(*configPath, []byte(*pass)); err != nil {
+			fatalIf(err)
 		}
-		fmt.Printf("user key: ", userKey)
-		fmt.Printf("\n");
+		policyKey := domain.Keys
+		fmt.Fprintf(noise, "Creating key for user: %s\n", *commonName)
+
+		subjectName := tao.NewX509Name(tao.X509Details{
+			Country:            *country,
+			Organization:       *org,
+			OrganizationalUnit: *ouName,
+			CommonName:         *commonName,
+		})
+		_, err := tao.NewSignedOnDiskPBEKeys(tao.Signing, []byte(*userKeyPass), *keyPath, subjectName, *serialNumber, policyKey)
+		fatalIf(err)
 	}
 	if *canExecute != "" {
 		path := *canExecute
 		prin := makeHostPrin(*host)
 		subprin := makeProgramSubPrin(path)
 		prog := prin.MakeSubprincipal(subprin)
 		fmt.Fprintf(noise, "Authorizing program to execute:\n"+
 			"  path: %s\n"+
 			"  host: %s\n"+
 			"  name: %s\n", path, prin, subprin)
 		err := domain.Guard.Authorize(prog, "Execute", nil)
 		fatalIf(err)
 		err = domain.Save()
 		fatalIf(err)
 		didWork = true
 	}
 	if *retractCanExecute != "" {
 		path := *retractCanExecute
 		prin := makeHostPrin(*host)
 		subprin := makeProgramSubPrin(path)
diff --git a/tao/keys.go b/tao/keys.go
index 28130cc..714eabd 100644
--- a/tao/keys.go
+++ b/tao/keys.go
@@ -59,48 +59,40 @@ const hmacKeySize = 32 // SHA-256
 type Signer struct {
 	ec *ecdsa.PrivateKey
 }
 
 // A Verifier is used to verify signatures.
 type Verifier struct {
 	ec *ecdsa.PublicKey
 }
 
 // A Crypter is used to encrypt and decrypt data.
 type Crypter struct {
 	aesKey  []byte
 	hmacKey []byte
 }
 
 // A Deriver is used to derive key material from a context using HKDF.
 type Deriver struct {
 	secret []byte
 }
 
-func (s *Signer) GetSignerEc() *ecdsa.PrivateKey {
-	return s.ec
-}
-
-func (v *Verifier) GetVerifierEc() *ecdsa.PublicKey {
-	return v.ec
-}
-
 // GenerateSigner creates a new Signer with a fresh key.
 func GenerateSigner() (*Signer, error) {
 	ec, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)
 	if err != nil {
 		return nil, err
 	}
 
 	return &Signer{ec}, nil
 }
 
 // ToPrincipal produces a "key" type Prin for this signer. This contains a
 // serialized CryptoKey for the public half of this signing key.
 func (s *Signer) ToPrincipal() auth.Prin {
 	ck := MarshalPublicSignerProto(s)
 
 	// proto.Marshal won't fail here since we fill all required fields of the
 	// message. Propagating impossible errors just leads to clutter later.
 	data, _ := proto.Marshal(ck)
 
 	return auth.NewKeyPrin(data)
@@ -172,62 +164,63 @@ func (s *Signer) CreateSelfSignedDER(name *pkix.Name) ([]byte, error) {
 // CreateSelfSignedX509 creates a self-signed X.509 certificate for the public
 // key of this Signer.
 func (s *Signer) CreateSelfSignedX509(name *pkix.Name) (*x509.Certificate, error) {
 	template := prepareX509Template(name)
 	template.IsCA = true
 	template.BasicConstraintsValid = true
 	template.Issuer = template.Subject
 
 	der, err := x509.CreateCertificate(rand.Reader, template, template, &s.ec.PublicKey, s.ec)
 	if err != nil {
 		return nil, err
 	}
 
 	return x509.ParseCertificate(der)
 }
 
 // CreateSignedX509 creates a signed X.509 certificate for some other subject's
 // key.
 func (s *Signer) CreateSignedX509(caCert *x509.Certificate, certSerial int, subjectKey *Verifier, subjectName *pkix.Name) (*x509.Certificate, error) {
 	template := prepareX509Template(subjectName)
+	template.SerialNumber = new(big.Int).SetInt64(int64(certSerial))
 
 	der, err := x509.CreateCertificate(rand.Reader, template, caCert, subjectKey.ec, s.ec)
 	if err != nil {
 		return nil, err
 	}
 	return x509.ParseCertificate(der)
 }
 
 // marshalECDSA_SHA_SigningKeyV1 encodes a private key as a protobuf message.
 func marshalECDSA_SHA_SigningKeyV1(k *ecdsa.PrivateKey) *ECDSA_SHA_SigningKeyV1 {
 	return &ECDSA_SHA_SigningKeyV1{
 		Curve:     NamedEllipticCurve_PRIME256_V1.Enum(),
 		EcPrivate: k.D.Bytes(),
 		EcPublic:  elliptic.Marshal(k.Curve, k.X, k.Y),
 	}
 
 }
 
 // MarshalSignerProto encodes a signing key as a CryptoKey protobuf message.
 func MarshalSignerProto(s *Signer) (*CryptoKey, error) {
 	m := marshalECDSA_SHA_SigningKeyV1(s.ec)
-	defer zeroBytes(m.EcPrivate)
+	defer ZeroBytes(m.EcPrivate)
 
 	b, err := proto.Marshal(m)
 	if err != nil {
 		return nil, err
 	}
 
 	ck := &CryptoKey{
 		Version:   CryptoVersion_CRYPTO_VERSION_1.Enum(),
 		Purpose:   CryptoKey_SIGNING.Enum(),
 		Algorithm: CryptoKey_ECDSA_SHA.Enum(),
 		Key:       b,
 	}
 	return ck, nil
 }
 
 // marshalECDSA_SHA_VerifyingKeyV1 encodes a public key as a protobuf message.
 func marshalECDSA_SHA_VerifyingKeyV1(k *ecdsa.PublicKey) *ECDSA_SHA_VerifyingKeyV1 {
 	return &ECDSA_SHA_VerifyingKeyV1{
 		Curve:    NamedEllipticCurve_PRIME256_V1.Enum(),
 		EcPublic: elliptic.Marshal(k.Curve, k.X, k.Y),
@@ -275,41 +268,41 @@ func MarshalPublicSignerProto(s *Signer) *CryptoKey {
 func MarshalVerifierProto(v *Verifier) *CryptoKey {
 	return marshalPublicKeyProto(v.ec)
 }
 
 // UnmarshalSignerProto decodes a signing key from a CryptoKey protobuf
 // message.
 func UnmarshalSignerProto(ck *CryptoKey) (*Signer, error) {
 	if *ck.Version != CryptoVersion_CRYPTO_VERSION_1 {
 		return nil, newError("bad version")
 	}
 
 	if *ck.Purpose != CryptoKey_SIGNING {
 		return nil, newError("bad purpose")
 	}
 
 	if *ck.Algorithm != CryptoKey_ECDSA_SHA {
 		return nil, newError("bad algorithm")
 	}
 
 	k := new(ECDSA_SHA_SigningKeyV1)
-	defer zeroBytes(k.EcPrivate)
+	defer ZeroBytes(k.EcPrivate)
 	if err := proto.Unmarshal(ck.Key, k); err != nil {
 		return nil, err
 	}
 
 	if *k.Curve != NamedEllipticCurve_PRIME256_V1 {
 		return nil, newError("bad Curve")
 	}
 
 	s := new(Signer)
 	s.ec = new(ecdsa.PrivateKey)
 	s.ec.D = new(big.Int).SetBytes(k.EcPrivate)
 	s.ec.Curve = elliptic.P256()
 	s.ec.X, s.ec.Y = elliptic.Unmarshal(elliptic.P256(), k.EcPublic)
 	return s, nil
 }
 
 // CreateHeader encodes the version and a key hint into a CryptoHeader.
 func (s *Signer) CreateHeader() (*CryptoHeader, error) {
 	k := marshalECDSA_SHA_VerifyingKeyV1(&s.ec.PublicKey)
 	b, err := proto.Marshal(k)
@@ -633,41 +626,41 @@ func (c *Crypter) Decrypt(ciphertext []byte) ([]byte, error) {
 	s := cipher.NewCTR(block, ed.Iv)
 	data := make([]byte, len(ed.Ciphertext))
 	s.XORKeyStream(data, ed.Ciphertext)
 	return data, nil
 }
 
 // marshalAES_CTR_HMAC_SHA_CryptingKeyV1 encodes a private AES/HMAC key pair
 // into a protobuf message.
 func marshalAES_CTR_HMAC_SHA_CryptingKeyV1(c *Crypter) *AES_CTR_HMAC_SHA_CryptingKeyV1 {
 	return &AES_CTR_HMAC_SHA_CryptingKeyV1{
 		Mode:        CryptoCipherMode_CIPHER_MODE_CTR.Enum(),
 		AesPrivate:  c.aesKey,
 		HmacPrivate: c.hmacKey,
 	}
 }
 
 // MarshalCrypterProto encodes a Crypter as a CryptoKey protobuf message.
 func MarshalCrypterProto(c *Crypter) (*CryptoKey, error) {
 	k := marshalAES_CTR_HMAC_SHA_CryptingKeyV1(c)
 
-	// Note that we don't need to call zeroBytes on k.AesPrivate or
+	// Note that we don't need to call ZeroBytes on k.AesPrivate or
 	// k.HmacPrivate, since they're just slice references to the underlying
 	// keys.
 	m, err := proto.Marshal(k)
 	if err != nil {
 		return nil, err
 	}
 
 	ck := &CryptoKey{
 		Version:   CryptoVersion_CRYPTO_VERSION_1.Enum(),
 		Purpose:   CryptoKey_CRYPTING.Enum(),
 		Algorithm: CryptoKey_AES_CTR_HMAC_SHA.Enum(),
 		Key:       m,
 	}
 
 	return ck, nil
 }
 
 // UnmarshalCrypterProto decodes a crypting key from a CryptoKey protobuf
 // message.
 func UnmarshalCrypterProto(ck *CryptoKey) (*Crypter, error) {
@@ -688,41 +681,41 @@ func UnmarshalCrypterProto(ck *CryptoKey) (*Crypter, error) {
 		return nil, err
 	}
 
 	if *k.Mode != CryptoCipherMode_CIPHER_MODE_CTR {
 		return nil, newError("bad cipher mode")
 	}
 
 	c := new(Crypter)
 	c.aesKey = k.AesPrivate
 	c.hmacKey = k.HmacPrivate
 	return c, nil
 }
 
 // CreateHeader instantiates and fills in a header for this crypting key.
 func (c *Crypter) CreateHeader() (*CryptoHeader, error) {
 	k := marshalAES_CTR_HMAC_SHA_CryptingKeyV1(c)
 	b, err := proto.Marshal(k)
 	if err != nil {
 		return nil, err
 	}
-	defer zeroBytes(b)
+	defer ZeroBytes(b)
 
 	h := sha1.Sum(b)
 	ch := &CryptoHeader{
 		Version: CryptoVersion_CRYPTO_VERSION_1.Enum(),
 		KeyHint: h[:4],
 	}
 
 	return ch, nil
 
 }
 
 // GenerateDeriver generates a deriver with a fresh secret.
 func GenerateDeriver() (*Deriver, error) {
 	d := new(Deriver)
 	d.secret = make([]byte, deriverSecretSize)
 	if _, err := rand.Read(d.secret); err != nil {
 		return nil, err
 	}
 
 	return d, nil
@@ -734,41 +727,41 @@ func (d *Deriver) Derive(salt, context, material []byte) error {
 	f := hkdf.New(sha256.New, d.secret, salt, context)
 	if _, err := f.Read(material); err != nil {
 		return err
 	}
 
 	return nil
 }
 
 // marshalHMAC_SHA_DerivingKeyV1 encodes a deriving key as a protobuf message.
 func marshalHMAC_SHA_DerivingKeyV1(d *Deriver) *HMAC_SHA_DerivingKeyV1 {
 	return &HMAC_SHA_DerivingKeyV1{
 		Mode:        CryptoDerivingMode_DERIVING_MODE_HKDF.Enum(),
 		HmacPrivate: d.secret,
 	}
 }
 
 // MarshalDeriverProto encodes a Deriver as a CryptoKey protobuf message.
 func MarshalDeriverProto(d *Deriver) (*CryptoKey, error) {
 	k := marshalHMAC_SHA_DerivingKeyV1(d)
 
-	// Note that we don't need to call zeroBytes on k.HmacPrivate since
+	// Note that we don't need to call ZeroBytes on k.HmacPrivate since
 	// it's just a slice reference to the underlying keys.
 	m, err := proto.Marshal(k)
 	if err != nil {
 		return nil, err
 	}
 
 	ck := &CryptoKey{
 		Version:   CryptoVersion_CRYPTO_VERSION_1.Enum(),
 		Purpose:   CryptoKey_DERIVING.Enum(),
 		Algorithm: CryptoKey_HMAC_SHA.Enum(),
 		Key:       m,
 	}
 
 	return ck, nil
 }
 
 // UnmarshalDeriverProto decodes a deriving key from a CryptoKey protobuf
 // message.
 func UnmarshalDeriverProto(ck *CryptoKey) (*Deriver, error) {
 	if *ck.Version != CryptoVersion_CRYPTO_VERSION_1 {
@@ -805,86 +798,76 @@ type Keys struct {
 	keyTypes KeyType
 
 	SigningKey   *Signer
 	CryptingKey  *Crypter
 	VerifyingKey *Verifier
 	DerivingKey  *Deriver
 	Delegation   *Attestation
 	Cert         *x509.Certificate
 }
 
 // X509Path returns the path to the verifier key, stored as an X.509
 // certificate.
 func (k *Keys) X509Path() string {
 	if k.dir == "" {
 		return ""
 	}
 
 	return path.Join(k.dir, "cert")
 }
 
-// SetMyKeyPath sets path for stored keys.
-func (k *Keys) SetMyKeyPath(dir_name string) {
-	k.dir = dir_name
-}
-
-// SetKeyType sets key type
-func (k *Keys) SetKeyType(types KeyType) {
-	k.keyTypes = types
-}
-
 // PBEKeysetPath returns the path for stored keys.
 func (k *Keys) PBEKeysetPath() string {
 	if k.dir == "" {
 		return ""
 	}
 	return path.Join(k.dir, "keys")
 }
 
 // PBESignerPath returns the path for a stored signing key.
 func (k *Keys) PBESignerPath() string {
 	if k.dir == "" {
 		return ""
 	}
 	return path.Join(k.dir, "signer")
 }
 
 // SealedKeysetPath returns the path for a stored signing key.
 func (k *Keys) SealedKeysetPath() string {
 	if k.dir == "" {
 		return ""
 	}
 
 	return path.Join(k.dir, "sealed_keyset")
 }
 
-// DelegationPath returns the path for a stored signing key.
+// DelegationPath returns the path for a stored delegation.
 func (k *Keys) DelegationPath() string {
 	if k.dir == "" {
 		return ""
 	}
 
 	return path.Join(k.dir, "delegation")
 }
 
-// zeroBytes clears the bytes in a slice.
-func zeroBytes(b []byte) {
+// ZeroBytes clears the bytes in a slice.
+func ZeroBytes(b []byte) {
 	for i := range b {
 		b[i] = 0
 	}
 }
 
 // NewTemporaryKeys creates a new Keys structure with the specified keys.
 func NewTemporaryKeys(keyTypes KeyType) (*Keys, error) {
 	k := &Keys{
 		keyTypes: keyTypes,
 	}
 	if k.keyTypes == 0 || (k.keyTypes & ^Signing & ^Crypting & ^Deriving != 0) {
 		return nil, newError("bad key type")
 	}
 
 	var err error
 	if k.keyTypes&Signing == Signing {
 		k.SigningKey, err = GenerateSigner()
 		if err != nil {
 			return nil, err
 		}
@@ -892,40 +875,77 @@ func NewTemporaryKeys(keyTypes KeyType) (*Keys, error) {
 		k.VerifyingKey = k.SigningKey.GetVerifier()
 	}
 
 	if k.keyTypes&Crypting == Crypting {
 		k.CryptingKey, err = GenerateCrypter()
 		if err != nil {
 			return nil, err
 		}
 	}
 
 	if k.keyTypes&Deriving == Deriving {
 		k.DerivingKey, err = GenerateDeriver()
 		if err != nil {
 			return nil, err
 		}
 	}
 
 	return k, nil
 }
 
+// NewSignedOnDiskPBEKeys creates the same type of keys as NewOnDiskPBEKeys but
+// signs a certificate for the signer with the provided Keys, which must have
+// both a SigningKey and a Certificate.
+func NewSignedOnDiskPBEKeys(keyTypes KeyType, password []byte, path string, name *pkix.Name, serial int, signer *Keys) (*Keys, error) {
+	if signer == nil || name == nil {
+		return nil, newError("must supply a signer and a name")
+	}
+
+	if signer.Cert == nil || signer.SigningKey == nil {
+		return nil, newError("the signing key must have a SigningKey and a Cert")
+	}
+
+	if keyTypes & ^Signing != 0 {
+		return nil, newError("can't sign a key that has no signer")
+	}
+
+	k, err := NewOnDiskPBEKeys(keyTypes, password, path, nil)
+	if err != nil {
+		return nil, err
+	}
+
+	// If there's already a cert, then this means that there was already a
+	// keyset on disk, so don't create a new signed certificate.
+	if k.Cert == nil {
+		k.Cert, err = signer.SigningKey.CreateSignedX509(signer.Cert, serial, k.VerifyingKey, name)
+		if err != nil {
+			return nil, err
+		}
+
+		if err = util.WritePath(k.X509Path(), k.Cert.Raw, 0777, 0666); err != nil {
+			return nil, err
+		}
+	}
+
+	return k, nil
+}
+
 // NewOnDiskPBEKeys creates a new Keys structure with the specified key types
 // store under PBE on disk. If keys are generated and name is not nil, then a
 // self-signed x509 certificate will be generated and saved as well.
 func NewOnDiskPBEKeys(keyTypes KeyType, password []byte, path string, name *pkix.Name) (*Keys, error) {
 	if keyTypes == 0 || (keyTypes & ^Signing & ^Crypting & ^Deriving != 0) {
 		return nil, newError("bad key type")
 	}
 
 	if path == "" {
 		return nil, newError("bad init call: no path for keys")
 	}
 
 	k := &Keys{
 		keyTypes: keyTypes,
 		dir:      path,
 	}
 
 	if len(password) == 0 {
 		// This means there's no secret information: just load a public
 		// verifying key.
@@ -946,144 +966,146 @@ func NewOnDiskPBEKeys(keyTypes KeyType, password []byte, path string, name *pkix
 		}
 	} else {
 		// There are two different types of keysets: in one there's
 		// just a Signer, so we use an encrypted PEM format. In the
 		// other, there are multiple keys, so we use a custom protobuf
 		// format.
 		if k.keyTypes & ^Signing != 0 {
 			// Check to see if there are already keys.
 			f, err := os.Open(k.PBEKeysetPath())
 			if err == nil {
 				defer f.Close()
 				ks, err := ioutil.ReadAll(f)
 				if err != nil {
 					return nil, err
 				}
 
 				data, err := PBEDecrypt(ks, password)
 				if err != nil {
 					return nil, err
 				}
-				defer zeroBytes(data)
+				defer ZeroBytes(data)
 
 				var cks CryptoKeyset
 				if err = proto.Unmarshal(data, &cks); err != nil {
 					return nil, err
 				}
 
 				// TODO(tmroeder): defer zeroKeyset(&cks)
 
 				ktemp, err := UnmarshalKeyset(&cks)
 				if err != nil {
 					return nil, err
 				}
 
+				// Note that this loads the certificate if it's
+				// present, and it returns nil otherwise.
 				err = k.loadCert()
 				if err != nil {
 					return nil, err
 				}
 
 				k.SigningKey = ktemp.SigningKey
 				k.VerifyingKey = ktemp.VerifyingKey
 				k.CryptingKey = ktemp.CryptingKey
 				k.DerivingKey = ktemp.DerivingKey
 			} else {
 				// Create and store a new set of keys.
 				k, err = NewTemporaryKeys(keyTypes)
 				if err != nil {
 					return nil, err
 				}
 
 				k.dir = path
 
 				cks, err := MarshalKeyset(k)
 				if err != nil {
 					return nil, err
 				}
 
 				// TODO(tmroeder): defer zeroKeyset(cks)
 
 				m, err := proto.Marshal(cks)
 				if err != nil {
 					return nil, err
 				}
-				defer zeroBytes(m)
+				defer ZeroBytes(m)
 
 				enc, err := PBEEncrypt(m, password)
 				if err != nil {
 					return nil, err
 				}
 
 				if err = util.WritePath(k.PBEKeysetPath(), enc, 0777, 0600); err != nil {
 					return nil, err
 				}
 
 				if k.SigningKey != nil && name != nil {
 					err = k.newCert(name)
 					if err != nil {
 						return nil, err
 					}
 				}
 			}
 		} else {
 			// There's just a signer, so do PEM encryption of the encoded key.
 			f, err := os.Open(k.PBESignerPath())
 			if err == nil {
 				defer f.Close()
 				// Read the signer.
 				ss, err := ioutil.ReadAll(f)
 				if err != nil {
 					return nil, err
 				}
 
 				pb, rest := pem.Decode(ss)
 				if pb == nil || len(rest) > 0 {
 					return nil, newError("decoding failure")
 				}
 
 				p, err := x509.DecryptPEMBlock(pb, password)
 				if err != nil {
 					return nil, err
 				}
-				defer zeroBytes(p)
+				defer ZeroBytes(p)
 
 				err = k.loadCert()
 				if err != nil {
 					return nil, err
 				}
 
 				if k.SigningKey, err = UnmarshalSignerDER(p); err != nil {
 					return nil, err
 				}
 				k.VerifyingKey = k.SigningKey.GetVerifier()
 			} else {
 				// Create a fresh key and store it to the PBESignerPath.
 				if k.SigningKey, err = GenerateSigner(); err != nil {
 					return nil, err
 				}
 
 				k.VerifyingKey = k.SigningKey.GetVerifier()
 				p, err := MarshalSignerDER(k.SigningKey)
 				if err != nil {
 					return nil, err
 				}
-				defer zeroBytes(p)
+				defer ZeroBytes(p)
 
 				pb, err := x509.EncryptPEMBlock(rand.Reader, "EC PRIVATE KEY", p, password, x509.PEMCipherAES128)
 				if err != nil {
 					return nil, err
 				}
 
 				pbes, err := util.CreatePath(k.PBESignerPath(), 0700, 0600)
 				if err != nil {
 					return nil, err
 				}
 				defer pbes.Close()
 
 				if err = pem.Encode(pbes, pb); err != nil {
 					return nil, err
 				}
 
 				if k.SigningKey != nil && name != nil {
 					err = k.newCert(name)
 					if err != nil {
 						return nil, err
@@ -1092,40 +1114,42 @@ func NewOnDiskPBEKeys(keyTypes KeyType, password []byte, path string, name *pkix
 			}
 		}
 	}
 
 	return k, nil
 }
 
 func (k *Keys) newCert(name *pkix.Name) (err error) {
 	k.Cert, err = k.SigningKey.CreateSelfSignedX509(name)
 	if err != nil {
 		return err
 	}
 	if err = util.WritePath(k.X509Path(), k.Cert.Raw, 0777, 0666); err != nil {
 		return err
 	}
 	return nil
 }
 
 func (k *Keys) loadCert() error {
 	f, err := os.Open(k.X509Path())
+	// Allow this operation to fail silently, since there isn't always a
+	// certificate available.
 	if err != nil {
 		return nil
 	}
 	defer f.Close()
 
 	der, err := ioutil.ReadAll(f)
 	if err != nil {
 		return err
 	}
 
 	k.Cert, err = x509.ParseCertificate(der)
 	return err
 }
 
 // NewTemporaryTaoDelegatedKeys initializes a set of temporary keys under a host
 // Tao, using the Tao to generate a delegation for the signing key. Since these
 // keys are never stored on disk, they are not sealed to the Tao.
 func NewTemporaryTaoDelegatedKeys(keyTypes KeyType, t Tao) (*Keys, error) {
 	k, err := NewTemporaryKeys(keyTypes)
 	if err != nil {
@@ -1159,90 +1183,90 @@ func PBEEncrypt(plaintext, password []byte) ([]byte, error) {
 
 	pbed := &PBEData{
 		Version: CryptoVersion_CRYPTO_VERSION_1.Enum(),
 		Cipher:  proto.String("aes128-ctr"),
 		Hmac:    proto.String("sha256"),
 		// The IV is required, so we include it, but this algorithm doesn't use it.
 		Iv:         make([]byte, aes.BlockSize),
 		Iterations: proto.Int32(4096),
 		Salt:       make([]byte, aes.BlockSize),
 	}
 
 	// We use the first half of the salt for the AES key and the second
 	// half for the HMAC key, since the standard recommends at least 8
 	// bytes of salt.
 	if _, err := rand.Read(pbed.Salt); err != nil {
 		return nil, err
 	}
 
 	// 128-bit AES key.
 	aesKey := pbkdf2.Key(password, pbed.Salt[:8], int(*pbed.Iterations), 16, sha256.New)
-	defer zeroBytes(aesKey)
+	defer ZeroBytes(aesKey)
 
 	// 64-byte HMAC-SHA256 key.
 	hmacKey := pbkdf2.Key(password, pbed.Salt[8:], int(*pbed.Iterations), 64, sha256.New)
-	defer zeroBytes(hmacKey)
+	defer ZeroBytes(hmacKey)
 	c := &Crypter{aesKey, hmacKey}
 
 	// Note that we're abusing the PBEData format here, since the IV and
 	// the MAC are actually contained in the ciphertext from Encrypt().
 	var err error
 	if pbed.Ciphertext, err = c.Encrypt(plaintext); err != nil {
 		return nil, err
 	}
 
 	return proto.Marshal(pbed)
 }
 
 // PBEDecrypt decrypts ciphertext using a password to generate a key. Note that
 // since this is for private program data, we don't try for compatibility with
 // the C++ Tao version of the code.
 func PBEDecrypt(ciphertext, password []byte) ([]byte, error) {
 	if password == nil || len(password) == 0 {
 		return nil, newError("null or empty password")
 	}
 
 	var pbed PBEData
 	if err := proto.Unmarshal(ciphertext, &pbed); err != nil {
 		return nil, err
 	}
 
 	// Recover the keys from the password and the PBE header.
 	if *pbed.Version != CryptoVersion_CRYPTO_VERSION_1 {
 		return nil, newError("bad version")
 	}
 
 	if *pbed.Cipher != "aes128-ctr" {
 		return nil, newError("bad cipher")
 	}
 
 	if *pbed.Hmac != "sha256" {
 		return nil, newError("bad hmac")
 	}
 
 	// 128-bit AES key.
 	aesKey := pbkdf2.Key(password, pbed.Salt[:8], int(*pbed.Iterations), 16, sha256.New)
-	defer zeroBytes(aesKey)
+	defer ZeroBytes(aesKey)
 
 	// 64-byte HMAC-SHA256 key.
 	hmacKey := pbkdf2.Key(password, pbed.Salt[8:], int(*pbed.Iterations), 64, sha256.New)
-	defer zeroBytes(hmacKey)
+	defer ZeroBytes(hmacKey)
 	c := &Crypter{aesKey, hmacKey}
 
 	// Note that we're abusing the PBEData format here, since the IV and
 	// the MAC are actually contained in the ciphertext from Encrypt().
 	data, err := c.Decrypt(pbed.Ciphertext)
 	if err != nil {
 		return nil, err
 	}
 
 	return data, nil
 }
 
 // MarshalKeyset encodes the keys into a protobuf message.
 func MarshalKeyset(k *Keys) (*CryptoKeyset, error) {
 	var cks []*CryptoKey
 	if k.keyTypes&Signing == Signing {
 		ck, err := MarshalSignerProto(k.SigningKey)
 		if err != nil {
 			return nil, err
 		}
@@ -1309,41 +1333,41 @@ func UnmarshalKeyset(cks *CryptoKeyset) (*Keys, error) {
 func NewOnDiskTaoSealedKeys(keyTypes KeyType, t Tao, path, policy string) (*Keys, error) {
 	k := &Keys{
 		keyTypes: keyTypes,
 		dir:      path,
 		policy:   policy,
 	}
 
 	// Check to see if there are already keys.
 	f, err := os.Open(k.SealedKeysetPath())
 	if err == nil {
 		defer f.Close()
 		ks, err := ioutil.ReadAll(f)
 		if err != nil {
 			return nil, err
 		}
 
 		data, p, err := t.Unseal(ks)
 		if err != nil {
 			return nil, err
 		}
-		defer zeroBytes(data)
+		defer ZeroBytes(data)
 
 		if p != policy {
 			return nil, newError("invalid policy from Unseal")
 		}
 
 		var cks CryptoKeyset
 		if err = proto.Unmarshal(data, &cks); err != nil {
 			return nil, err
 		}
 
 		// TODO(tmroeder): defer zeroKeyset(&cks)
 
 		ktemp, err := UnmarshalKeyset(&cks)
 		if err != nil {
 			return nil, err
 		}
 
 		k.SigningKey = ktemp.SigningKey
 		k.VerifyingKey = ktemp.VerifyingKey
 		k.CryptingKey = ktemp.CryptingKey
@@ -1365,58 +1389,104 @@ func NewOnDiskTaoSealedKeys(keyTypes KeyType, t Tao, path, policy string) (*Keys
 		// Create and store a new set of keys.
 		k, err = NewTemporaryKeys(keyTypes)
 		if err != nil {
 			return nil, err
 		}
 
 		k.dir = path
 		k.policy = policy
 
 		cks, err := MarshalKeyset(k)
 		if err != nil {
 			return nil, err
 		}
 
 		// TODO(tmroeder): defer zeroKeyset(cks)
 
 		m, err := proto.Marshal(cks)
 		if err != nil {
 			return nil, err
 		}
-		defer zeroBytes(m)
+		defer ZeroBytes(m)
 
 		enc, err := t.Seal(m, policy)
 		if err != nil {
 			return nil, err
 		}
 
 		if err = util.WritePath(k.SealedKeysetPath(), enc, 0700, 0600); err != nil {
 			return nil, err
 		}
 
 		// Get and write a delegation.
 		if k.SigningKey != nil {
 			self, err := t.GetTaoName()
 			if err != nil {
 				return nil, err
 			}
 			s := &auth.Speaksfor{
 				Delegate:  k.SigningKey.ToPrincipal(),
 				Delegator: self,
 			}
 			if k.Delegation, err = t.Attest(&self, nil, nil, s); err != nil {
 				return nil, err
 			}
 
 			m, err := proto.Marshal(k.Delegation)
 			if err != nil {
 				return nil, err
 			}
 
 			if err = util.WritePath(k.DelegationPath(), m, 0700, 0600); err != nil {
 				return nil, err
 			}
 		}
 	}
 
 	return k, nil
 }
+
+// NewSecret creates and encrypts a new secret value of the given length, or it
+// reads and decrypts the value and checks that it's the right length. It
+// creates the file and its parent directories if these directories do not
+// exist.
+func (k *Keys) NewSecret(file string, length int) ([]byte, error) {
+	if _, err := os.Stat(file); err != nil {
+		// Create the parent directories and the file.
+		if err := os.MkdirAll(path.Dir(file), 0700); err != nil {
+			return nil, err
+		}
+
+		secret := make([]byte, length)
+		if _, err := rand.Read(secret); err != nil {
+			return nil, err
+		}
+
+		enc, err := k.CryptingKey.Encrypt(secret)
+		if err != nil {
+			return nil, err
+		}
+
+		if err := ioutil.WriteFile(file, enc, 0700); err != nil {
+			return nil, err
+		}
+
+		return secret, nil
+	}
+
+	enc, err := ioutil.ReadFile(file)
+	if err != nil {
+		return nil, err
+	}
+
+	dec, err := k.CryptingKey.Decrypt(enc)
+	if err != nil {
+		return nil, err
+	}
+
+	if len(dec) != length {
+		ZeroBytes(dec)
+		return nil, newError("The decrypted value had length %d, but it should have had length %d", len(dec), length)
+	}
+
+	return dec, nil
+}
diff --git a/tao/linux_host.go b/tao/linux_host.go
index 8e8b735..4370e6e 100644
--- a/tao/linux_host.go
+++ b/tao/linux_host.go
@@ -121,78 +121,78 @@ func (lh *LinuxHost) GetSharedSecret(child *LinuxHostChild, n int, policy string
 		// We are using a master key-deriving key shared among all
 		// similar LinuxHost instances. For LinuxHost, the default
 		// and conservative policies means any process running the same
 		// program binary as the caller hosted on a similar
 		// LinuxHost.
 		// TODO(kwalsh) conservative policy could include PID or other
 		// child info.
 		tag = policy + "|" + child.ChildSubprin.String()
 	case SharedSecretPolicyLiberal:
 		// The most liberal we can do is allow any hosted process
 		// running on a similar LinuxHost instance.
 		tag = policy
 	default:
 		return nil, newError("policy not supported for GetSharedSecret: " + policy)
 	}
 	return lh.taoHost.GetSharedSecret(tag, n)
 }
 
 // Seal encrypts data for the child. This call also zeroes the data parameter.
 func (lh *LinuxHost) Seal(child *LinuxHostChild, data []byte, policy string) ([]byte, error) {
-	defer zeroBytes(data)
+	defer ZeroBytes(data)
 	lhsb := &LinuxHostSealedBundle{
 		Policy: proto.String(policy),
 		Data:   data,
 	}
 
 	switch policy {
 	case SharedSecretPolicyDefault, SharedSecretPolicyConservative:
 		// We are using a master key-deriving key shared among all
 		// similar LinuxHost instances. For LinuxHost, the default
 		// and conservative policies means any process running the same
 		// program binary as the caller hosted on a similar
 		// LinuxHost.
 		lhsb.PolicyInfo = proto.String(child.ChildSubprin.String())
 	case SharedSecretPolicyLiberal:
 		// The most liberal we can do is allow any hosted process
 		// running on a similar LinuxHost instance. So, we don't set
 		// any policy info.
 	default:
 		return nil, newError("policy not supported for Seal: " + policy)
 	}
 
 	m, err := proto.Marshal(lhsb)
 	if err != nil {
 		return nil, err
 	}
-	defer zeroBytes(m)
+	defer ZeroBytes(m)
 
 	return lh.taoHost.Encrypt(m)
 }
 
 // Unseal decrypts data for the child, but only if the policy is satisfied.
 func (lh *LinuxHost) Unseal(child *LinuxHostChild, sealed []byte) ([]byte, string, error) {
 	decrypted, err := lh.taoHost.Decrypt(sealed)
 	if err != nil {
 		return nil, "", err
 	}
-	defer zeroBytes(decrypted)
+	defer ZeroBytes(decrypted)
 
 	var lhsb LinuxHostSealedBundle
 	if err := proto.Unmarshal(decrypted, &lhsb); err != nil {
 		return nil, "", err
 	}
 
 	if lhsb.Policy == nil {
 		return nil, "", newError("invalid policy in sealed data")
 	}
 
 	policy := *lhsb.Policy
 	switch policy {
 	case SharedSecretPolicyConservative, SharedSecretPolicyDefault:
 		if lhsb.PolicyInfo == nil || child.ChildSubprin.String() != *lhsb.PolicyInfo {
 			return nil, "", newError("principal not authorized for unseal")
 		}
 	case SharedSecretPolicyLiberal:
 		// Allow all
 		break
 	default:
diff --git a/tao/net/ca.go b/tao/net/ca.go
index ebd0f3d..08f760f 100644
--- a/tao/net/ca.go
+++ b/tao/net/ca.go
@@ -80,77 +80,93 @@ func HandleCARequest(conn net.Conn, s *tao.Signer, guard tao.Guard) {
 	ea, err := tao.GenerateAttestation(s, nil, endorsement)
 	if err != nil {
 		fmt.Fprintln(os.Stderr, "Couldn't generate an endorsement for this program:", err)
 		return
 	}
 	eab, err := proto.Marshal(ea)
 	if err != nil {
 		fmt.Fprintln(os.Stderr, "Couldn't marshal an endorsement:", err)
 		return
 	}
 	ra.SerializedEndorsements = [][]byte{eab}
 
 	if _, err := ms.WriteMessage(ra); err != nil {
 		fmt.Fprintln(os.Stderr, "Couldn't return the attestation on the channel:", err)
 		return
 	}
 
 	return
 }
 
-// RequestTruncatedAttestation connects to a CA instance, sends the attestation
-// for an X.509 certificate, and gets back a truncated attestation with a new
-// principal name based on the policy key.
-func RequestTruncatedAttestation(network, addr string, keys *tao.Keys, v *tao.Verifier) (*tao.Attestation, error) {
+// RequestAttestation connects to a CA and gets an attestation back from it.
+// This might be a truncated attestation (in which case, the right next step is
+// to verify the truncated attesation, as in RequestTruncatedAttestation), or it
+// might be some other kind of attestation (like a KeyNegoServer attestation,
+// which provides a policy-key-signed X.509 certificate for the auth name of
+// this program).
+func RequestAttestation(network, addr string, keys *tao.Keys, v *tao.Verifier) (*tao.Attestation, error) {
 	if keys.Cert == nil {
 		return nil, fmt.Errorf("client: can't dial with an empty client certificate\n")
 	}
 	tlsCert, err := EncodeTLSCert(keys)
 	if err != nil {
 		return nil, err
 	}
 	conn, err := tls.Dial(network, addr, &tls.Config{
 		RootCAs:            x509.NewCertPool(),
 		Certificates:       []tls.Certificate{*tlsCert},
 		InsecureSkipVerify: true,
 	})
 	if err != nil {
 		return nil, err
 	}
 	defer conn.Close()
 
 	// Tao handshake: send client delegation.
 	ms := util.NewMessageStream(conn)
 	if _, err = ms.WriteMessage(keys.Delegation); err != nil {
 		return nil, err
 	}
 
 	// Read the truncated attestation and check it.
 	var a tao.Attestation
 	if err := ms.ReadMessage(&a); err != nil {
 		return nil, err
 	}
 
-	truncStmt, err := auth.UnmarshalForm(a.SerializedStatement)
+	ok, err := v.Verify(a.SerializedStatement, tao.AttestationSigningContext, a.Signature)
 	if err != nil {
 		return nil, err
 	}
+	if !ok {
+		return nil, fmt.Errorf("invalid attestation signature from Tao CA")
+	}
 
-	says, _, err := TruncateAttestation(v.ToPrincipal(), keys.Delegation)
+	return &a, nil
+
+}
+
+// RequestTruncatedAttestation connects to a CA instance, sends the attestation
+// for an X.509 certificate, and gets back a truncated attestation with a new
+// principal name based on the policy key.
+func RequestTruncatedAttestation(network, addr string, keys *tao.Keys, v *tao.Verifier) (*tao.Attestation, error) {
+	a, err := RequestAttestation(network, addr, keys, v)
 	if err != nil {
 		return nil, err
 	}
 
-	if !IdenticalDelegations(says, truncStmt) {
-		return nil, fmt.Errorf("the statement returned by the TaoCA was different than what we expected")
+	truncStmt, err := auth.UnmarshalForm(a.SerializedStatement)
+	if err != nil {
+		return nil, err
 	}
 
-	ok, err := v.Verify(a.SerializedStatement, tao.AttestationSigningContext, a.Signature)
+	says, _, err := TruncateAttestation(v.ToPrincipal(), keys.Delegation)
 	if err != nil {
 		return nil, err
 	}
-	if !ok {
-		return nil, fmt.Errorf("invalid attestation signature from Tao CA")
+
+	if !IdenticalDelegations(says, truncStmt) {
+		return nil, fmt.Errorf("the statement returned by the TaoCA was different than what we expected")
 	}
 
-	return &a, nil
+	return a, nil
 }
diff --git a/tao/tpm_tao.go b/tao/tpm_tao.go
index c145740..5678172 100644
--- a/tao/tpm_tao.go
+++ b/tao/tpm_tao.go
@@ -238,100 +238,100 @@ func (tt *TPMTao) Attest(issuer *auth.Prin, start, expiration *int64, message au
 		Signature:           sig,
 		Signer:              auth.Marshal(signer),
 	}
 	return a, nil
 }
 
 // Seal encrypts data so only certain hosted programs can unseal it. Note that
 // at least some TPMs can only seal up to 149 bytes of data. So, we employ a
 // hybrid encryption scheme that seals a key and uses the key to encrypt the
 // data separately. We use the keys infrastructure to perform secure and
 // flexible encryption.
 func (tt *TPMTao) Seal(data []byte, policy string) (sealed []byte, err error) {
 	if policy != SealPolicyDefault {
 		return nil, errors.New("tpm-specific policies are not yet implemented")
 	}
 
 	crypter, err := GenerateCrypter()
 	if err != nil {
 		return nil, err
 	}
-	defer zeroBytes(crypter.aesKey)
-	defer zeroBytes(crypter.hmacKey)
+	defer ZeroBytes(crypter.aesKey)
+	defer ZeroBytes(crypter.hmacKey)
 
 	c, err := crypter.Encrypt(data)
 	if err != nil {
 		return nil, err
 	}
 
 	ck, err := MarshalCrypterProto(crypter)
 	if err != nil {
 		return nil, err
 	}
-	defer zeroBytes(ck.Key)
+	defer ZeroBytes(ck.Key)
 
 	ckb, err := proto.Marshal(ck)
 	if err != nil {
 		return nil, err
 	}
-	defer zeroBytes(ckb)
+	defer ZeroBytes(ckb)
 
 	s, err := tpm.Seal(tt.tpmfile, tt.locality, tt.pcrNums, ckb, tt.srkAuth[:])
 	if err != nil {
 		return nil, err
 	}
 
 	h := &HybridSealedData{
 		SealedKey:     s,
 		EncryptedData: c,
 	}
 
 	return proto.Marshal(h)
 }
 
 // Unseal decrypts data that has been sealed by the Seal() operation, but only
 // if the policy specified during the Seal() operation is satisfied.
 func (tt *TPMTao) Unseal(sealed []byte) (data []byte, policy string, err error) {
 	// The sealed data is a HybridSealedData.
 	var h HybridSealedData
 	if err := proto.Unmarshal(sealed, &h); err != nil {
 		return nil, "", err
 	}
 
 	unsealed, err := tpm.Unseal(tt.tpmfile, h.SealedKey, tt.srkAuth[:])
 	if err != nil {
 		return nil, "", err
 	}
-	defer zeroBytes(unsealed)
+	defer ZeroBytes(unsealed)
 
 	var ck CryptoKey
 	if err := proto.Unmarshal(unsealed, &ck); err != nil {
 		return nil, "", err
 	}
-	defer zeroBytes(ck.Key)
+	defer ZeroBytes(ck.Key)
 
 	crypter, err := UnmarshalCrypterProto(&ck)
 	if err != nil {
 		return nil, "", err
 	}
-	defer zeroBytes(crypter.aesKey)
-	defer zeroBytes(crypter.hmacKey)
+	defer ZeroBytes(crypter.aesKey)
+	defer ZeroBytes(crypter.hmacKey)
 
 	m, err := crypter.Decrypt(h.EncryptedData)
 	if err != nil {
 		return nil, "", err
 	}
 
 	return m, SealPolicyDefault, nil
 }
 
 // extractPCRs gets the PCRs from a tpm principal.
 func extractPCRs(p auth.Prin) ([]int, []byte, error) {
 	if p.Type != "tpm" {
 		return nil, nil, errors.New("can only extract PCRs from a TPM principal")
 	}
 
 	// The PCRs are stored as the first subprincipal value, with name "PCRs".
 	if len(p.Ext) == 0 {
 		return nil, nil, errors.New("no subprincipals available for PCR extraction")
 	}
 
