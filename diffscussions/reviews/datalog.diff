#* 
#* author: Kevin Walsh
#* email: kwalsh@holycross.edu
#* date: 2014-08-19T18:47:41-0400
#* 
#- Datalog guard (works, but still in progress)
#- 
#- 
#*
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-08-19T23:38:08-0700
#*
#- Other than some minor comments, this LGTM.
#- 
diff --git a/go/src/cloudproxy/tao/attestation.pb.go b/go/src/cloudproxy/tao/attestation.pb.go
index 8492392..dce4b18 100644
--- a/go/src/cloudproxy/tao/attestation.pb.go
+++ b/go/src/cloudproxy/tao/attestation.pb.go
@@ -1,29 +1,30 @@
 // Code generated by protoc-gen-go.
 // source: attestation.proto
 // DO NOT EDIT!
 
 /*
 Package tao is a generated protocol buffer package.
 
 It is generated from these files:
 	attestation.proto
+	datalog_guard.proto
 	keys.proto
 	linux_host_admin_rpc.proto
 	linux_host.proto
 	tao_rpc.proto
 
 It has these top-level messages:
 	Attestation
 */
 package tao
 
 import proto "code.google.com/p/goprotobuf/proto"
 import math "math"
 
 // Reference imports to suppress errors if they are not otherwise used.
 var _ = proto.Marshal
 var _ = math.Inf
 
 // An Attestation is a signature and a statement together, and it conveys:
 //   signer says statement
 // i.e.
diff --git a/go/src/cloudproxy/tao/datalog_guard.go b/go/src/cloudproxy/tao/datalog_guard.go
new file mode 100644
index 0000000..6ee09f4
--- /dev/null
+++ b/go/src/cloudproxy/tao/datalog_guard.go
@@ -0,0 +1,576 @@
+// Copyright (c) 2014, Kevin Walsh.  All rights reserved.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// This interface was derived from the code in src/tao/tao_guard.h.
+
+package tao
+
+import (
+	"fmt"
+	"io/ioutil"
+	"os"
+	"strings"
+	"time"
+
+	"code.google.com/p/goprotobuf/proto"
+	"github.com/kevinawalsh/datalog/dlengine"
+
+	"cloudproxy/tao/auth"
+	"cloudproxy/util"
+)
+
+const (
+	DatalogRulesSigningContext = "Datalog Rules Signing Context V1"
+)
#*
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-08-19T23:25:16-0700
#*
#- Minor style nit: golint will probably complain that this needs a comment.
#- 
+
+// DatalogGuardConfig holds persistent configuration data for a DatalogGuard.
+type DatalogGuardConfig struct {
+	SignedRulesPath string
+}
+
+// DatalogGuard implements a datalog-based policy engine. Rules in this engine
+// have the form:
+//   (forall X, Y, Z... : F implies G)
+// where
+//   F is a predicate or a conjunction of predicates
+//   G is a predicate
+// All predicate arguments must be either concrete terms (Int, Str, Prin, etc.)
+// or term-valued variables (TermVar) bound by the quantification. Any variable
+// appearing in G must also appear in F. If there are no variables, the
+// quantification can be omitted. The implication and its antecedent F can be
+// omitted (in which case there can be no variables so the quantification must
+// be omitted as well).

+//
+// TODO(kwalsh) We could easily support a slightly broader class of formulas,
+// e.g. by allowing G to be a conjunct of predicates, or by allowing a
+// disjunction of conjunctions for F. Anything beyond that seems complicated.
+//
+// Datalog translation
+//
+// We assume K speaksfor the guard, where K is the key used to sign the policy
+// file. If there is no signing key, a temporary principal (with a bogus key) is
+// used for K instead. All deduction takes place within the worldview of Guard.
+// Other than this relationship between K and the guard, we don't model the says
+// and speaksfor logic within datalog.
+//
+// Term objects are usually translated to datalog by just printing them. In this
+// case, a Prin object must not contain any TermVar objects. TermVar objects
+// must be uppercase.
+//
+// "Term says Pred(...)" is translated to "says(Term, \"Pred\", ...)".
+// 
+// "Pred(...)" alone is translated to "says(K, \"Pred\", ...)".
+//
+// "forall ... F1 and F2 and ... imp G" is translated to "G :- F1, F2, ...".
+type DatalogGuard struct {
+	Config DatalogGuardConfig
+	Key *Verifier
+	// TODO(kwalsh) maybe use a version number or timestamp inside the file?
+	modTime time.Time // Modification time of signed rules file at time of reading.
+	db DatalogRules
+	dl *dlengine.Engine
+}
+
+// This declaration ensures *DatalogGuard can be assigned to a Guard.
+var _ Guard = new(DatalogGuard)
+
+// NewTemporaryDatalogGuard returns a new datalog guard with a fresh, unsigned,
+// non-persistent rule set.
+func NewTemporaryDatalogGuard() *DatalogGuard {
#*
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-08-19T23:28:53-0700
#*
#- I think that we've usually returned the interface type from the
#- New* methods, and I think we should do the same here. So the return
#- type on this method and the next New method should be Guard rather
#- than *DatalogGuard. That also obviates the check
#- var _ Guard = new(DatalogGuard)
#- 
+	return &DatalogGuard{ dl: dlengine.NewEngine() }
+}
+
+// NewDatalogGuard returns a new datalog guard that uses a signed, persistent
+// signed rule set. ReloadIfModified() should be called to load the rule set.
+func NewDatalogGuard(key *Verifier, config DatalogGuardConfig) (*DatalogGuard, error) {
+	if key == nil || config.SignedRulesPath == "" {
+		return nil, newError("datalog guard missing key or path")
+	}
+	g := &DatalogGuard{Config: config, Key: key, dl: dlengine.NewEngine() }
+	return g, nil
+}
+
+// SubprincipalName returns subprincipal DatalogGuard, for temporary guards, or
+// DatalogGuard(<key>) for persistent guards.
+func (g *DatalogGuard) Subprincipal() auth.SubPrin {
+	if g.Key == nil {
+		e := auth.PrinExt{Name: "DatalogGuard"}
+		return auth.SubPrin{e}
+	} else {
+		e := auth.PrinExt{Name: "DatalogGuard", Arg: []auth.Term{g.Key.ToPrincipal()}}
+		return auth.SubPrin{e}
+	}
+}
+
+// ReloadIfModified reads all persistent policy data from disk if the file
+// timestamp is more recent than the last time it was read.
+func (g *DatalogGuard) ReloadIfModified() error {
+	if g.Key == nil {
+		return nil
+	}
+	file, err := os.Open(g.Config.SignedRulesPath)
+	if err != nil {
+		return err
+	}
+	defer file.Close()
+
+	// before parsing, check the timestamp
+	info, err := file.Stat()
+	if err != nil {
+		return err
+	}
+	if !info.ModTime().After(g.modTime) {
+		return nil
+	}
+
+	serialized, err := ioutil.ReadAll(file)
+	if err != nil {
+		return err
+	}
+	var sdb SignedDatalogRules
+	if err := proto.Unmarshal(serialized, &sdb); err != nil {
+		return err
+	}
+	if ok, err := g.Key.Verify(sdb.SerializedRules, DatalogRulesSigningContext, sdb.Signature); !ok {
+		if err != nil {
+			return err
+		}
+		return newError("datalog rule signature did not verify")
+	}
+	var db DatalogRules
+	if err := proto.Unmarshal(sdb.SerializedRules, &db); err != nil {
+		return err
+	}
+	if !info.ModTime().After(g.modTime) {
+		return nil
+	}
#*
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-08-19T23:31:48-0700
#*
#- Duplicate check?
#- 
+	g.Clear()
+	g.modTime = info.ModTime()
+	g.db = db
+	for _, rule := range db.Rules {
+		r, err := auth.UnmarshalForm(rule)
+		if err != nil {
+			return err
+		}
+		err = g.assert(r)
+		if err != nil {
+			return err
+		}
+	}
+	return nil
+}
+
+// Save writes all persistent policy data to disk, signed by key.
+func (g *DatalogGuard) Save(key *Signer) error {
+	if key == nil {
+		return newError("datalog temporary ruleset can't be saved")
+	}
+	rules, err := proto.Marshal(&g.db)
+	if err != nil {
+		return err
+	}
+	sig, err := key.Sign(rules, DatalogRulesSigningContext)
+	if err != nil {
+		return err
+	}
+	sdb := &SignedDatalogRules{
+		SerializedRules: rules,
+		Signature: sig,
+	}
+	serialized, err := proto.Marshal(sdb)
+	if err != nil {
+		return err
+	}
+	if err := util.WritePath(g.Config.SignedRulesPath, serialized, 0777, 0666); err != nil {
+		return err
+	}
+	return nil
+}
+
+func setContains(vars []string, v string) bool {
+	for _, s := range vars {
+		if s == v {
+			return true
+		}
+	}
+	return false
+}
+
+func setRemove(vars *[]string, v string) {
+	if vars == nil {
+		return
+	}
+	for i := 0; i < len(*vars); i++ {
+		if (*vars)[i] == v {
+			(*vars)[i] = (*vars)[len(*vars)-1]
+			*vars = (*vars)[:len(*vars)-1]
+			i--;
+		}
+	}
+}
+
+func stripQuantifiers(q auth.Form) (f auth.Form, vars []string) {
+	for {
+		var v string
+		switch f := q.(type) {
+		case auth.Forall:
+			v = f.Var
+			q = f.Body
+		case *auth.Forall:
+			v = f.Var
+			q = f.Body
#*
#* author: Tom Roeder
#* email: tmroeder@google.com
#* date: 2014-08-19T23:33:32-0700
#*
#- As in the auth_quant review, I think these cases can be collapsed with a
#- comma.
#- 
+		default:
+			return q, vars
+		}
+		if !setContains(vars, v) {
+			vars = append(vars, v)
+		}
+	}
+}
+
+func flattenConjuncts(f ...auth.Form) (conjuncts []auth.Form) {
+	for _, f := range f {
+		switch f := f.(type) {
+		case auth.And:
+			conjuncts = append(conjuncts, flattenConjuncts(f.Conjunct...)...)
+		case *auth.And:
+			conjuncts = append(conjuncts, flattenConjuncts(f.Conjunct...)...)
+		default:
+			conjuncts = append(conjuncts, f)
+		}
+	}
+	return
+}
+
+
+func stripConditions(f auth.Form) (conds []auth.Form, consequent auth.Form) {
+	switch f := f.(type) {
+	case auth.Implies:
+		conds = flattenConjuncts(f.Antecedent)
+		consequent = f.Consequent
+	case *auth.Implies:
+		conds = flattenConjuncts(f.Antecedent)
+		consequent = f.Consequent
+	default:
+		consequent = f
+	}
+	return
+}
+
+func checkTermVarUsage(vars []string, unusedVars *[]string, e ...auth.Term) error {
+	for _, e := range e {
+		switch e := e.(type) {
+		case auth.TermVar, *auth.TermVar:
+			if !setContains(vars, e.String()) {
+				return fmt.Errorf("illegal quantification variable: %v\n", e)
+			}
+		setRemove(unusedVars, e.String())
+		case auth.Prin:
+			err := checkTermVarUsage(vars, unusedVars, e.Key)
+			if err != nil {
+				return err
+			}
+			for _, ext := range e.Ext {
+				err := checkTermVarUsage(vars, unusedVars, ext.Arg...)
+				if err != nil {
+					return err
+				}
+			}
+		case *auth.Prin:
+			err := checkTermVarUsage(vars, unusedVars, e.Key)
+			if err != nil {
+				return err
+			}
+			for _, ext := range e.Ext {
+				err := checkTermVarUsage(vars, unusedVars, ext.Arg...)
+				if err != nil {
+					return err
+				}
+			}
+		}
+	}
+	return nil
+}
+
+func checkFormVarUsage(vars []string, unusedVars *[]string, e ...auth.Form) error {
+	for _, e := range e {
+		switch e := e.(type) {
+		case auth.Pred:
+			err := checkTermVarUsage(vars, unusedVars, e.Arg...)
+			if err != nil {
+				return err
+			}
+		case *auth.Pred:
+			err := checkTermVarUsage(vars, unusedVars, e.Arg...)
+			if err != nil {
+				return err
+			}
+		}
+	}
+	return nil
+}
+
+func (g *DatalogGuard) stmtToDatalog(f auth.Form, vars []string, unusedVars *[]string) (string, error) {
+	speaker := "guard"
+	if g.Key != nil {
+		speaker = g.Key.ToPrincipal().String()
+	}
+	stmt, ok := f.(*auth.Says)
+	if !ok {
+		var val auth.Says
+		val, ok = (f).(auth.Says)
+		if ok {
+			stmt = &val
+		}
+	}
+	if ok {
+		err := checkTermVarUsage(vars, unusedVars, stmt.Speaker)
+		if err != nil {
+			return "", err
+		}
+		speaker = stmt.Speaker.String()
+		f = stmt.Message
+	}
+	err := checkFormVarUsage(vars, unusedVars, f)
+	if err != nil {
+		return "", err
+	}
+	pred, ok := f.(*auth.Pred)
+	if !ok {
+		var val auth.Pred
+		val, ok = f.(auth.Pred)
+		if ok {
+			pred = &val
+		}
+	}
+	if !ok {
+		return "", fmt.Errorf("unsupported datalog statement: %v", f)
+	}
+	args := []string{fmt.Sprintf("%q", speaker), fmt.Sprintf("%q", pred.Name)}
+	for _, arg := range pred.Arg {
+		args = append(args, fmt.Sprintf("%q", arg.String()))
+	}
+	return "says(" + strings.Join(args, ", ") + ")", nil
+}
+
+// formToDatalogRule converts (a subset of) auth.Form to datalog syntax.
+func (g *DatalogGuard) formToDatalogRule(f auth.Form) (string, error) {
+	f, vars := stripQuantifiers(f)
+	conditions, consequent := stripConditions(f)
+	// vars must be upper-case
+	for _, v := range vars {
+		if len(v) == 0 || v[0] < 'A' || v[0] > 'Z' {
+			return "", fmt.Errorf("illegal quantification variable");
+		}
+	}
+	// convert the conditions
+	dcond := make([]string, len(conditions))
+	unusedVars := append([]string{}, vars...)
+	for i, cond := range conditions {
+		var err error
+		dcond[i], err = g.stmtToDatalog(cond, vars, &unusedVars)
+		if err != nil {
+			return "", err
+		}
+	}
+	// check for safety
+	if len(unusedVars) > 0 {
+		return "", fmt.Errorf("unsafe datalog variable usage: % s", unusedVars);
+	}
+	goal, err := g.stmtToDatalog(consequent, vars, nil)
+	if err != nil {
+		return "", err
+	}
+	if len(dcond) > 0 {
+		return goal + " :- " + strings.Join(dcond, ", "), nil
+	} else {
+		return goal, nil
+	}
+}
+
+func (g *DatalogGuard) findRule(f auth.Form) (string, int, error) {
+	rule, err := g.formToDatalogRule(f)
+	if err != nil {
+		return "", -1, err
+	}
+	for i, ser := range g.db.Rules {
+		f2, err := auth.UnmarshalForm(ser)
+		if err != nil {
+			continue
+		}
+		rule2, err := g.formToDatalogRule(f2)
+		if err != nil {
+			continue
+		}
+		if rule == rule2 {
+			return rule, i, nil
+		}
+	}
+	return rule, -1, nil
+}
+
+func (g *DatalogGuard) assert(f auth.Form) error {
+	rule, idx, err := g.findRule(f)
+	if err != nil {
+		return err
+	}
+	if idx >= 0 {
+		return nil
+	}
+	err = g.dl.Assert(rule)
+	if err != nil {
+		return err
+	}
+	g.db.Rules = append(g.db.Rules, auth.Marshal(f))
+	return nil
+}
+
+func (g *DatalogGuard) retract(f auth.Form) error {
+	rule, idx, err := g.findRule(f)
+	if err != nil {
+		return err
+	}
+	if idx < 0 {
+		return fmt.Errorf("no such rule")
+	}
+	err = g.dl.Retract(rule)
+	if err != nil {
+		return err
+	}
+	g.db.Rules = append(g.db.Rules[:idx], g.db.Rules[idx+1:]...)
+	return nil
+}
+
+func (g *DatalogGuard) query(f auth.Form) (bool, error) {
+	q, err := g.stmtToDatalog(f, nil, nil)
+	if err != nil {
+		return false, err
+	}
+	ans, err := g.dl.Query(q)
+	if err != nil {
+		return false, err
+	}
+	return len(ans) > 0, nil
+}
+
+func makeDatalogPredicate(p auth.Prin, op string, args []string) auth.Pred {
+	a := []interface{}{p, op}
+	for _, s := range args {
+		a = append(a, s)
+	}
+	return auth.MakePredicate("Authorized", a...)
+}
+
+// Authorize adds an authorization for p to perform op(args).
+func (g *DatalogGuard) Authorize(p auth.Prin, op string, args []string) error {
+	return g.assert(makeDatalogPredicate(p, op, args))
+}
+
+// Retract removes an authorization for p to perform op(args).
+func (g *DatalogGuard) Retract(p auth.Prin, op string, args []string) error {
+	return g.retract(makeDatalogPredicate(p, op, args))
+}
+
+// IsAuthorized checks whether p is authorized to perform op(args).
+func (g *DatalogGuard) IsAuthorized(p auth.Prin, op string, args []string) bool {
+	ok, _ := g.query(makeDatalogPredicate(p, op, args))
+	return ok
+}
+
+// AddRule adds a policy rule.
+func (g *DatalogGuard) AddRule(rule string) error {
+	var r auth.AnyForm
+	_, err := fmt.Sscanf("("+rule+")", "%v", &r)
+	if err != nil {
+		return err
+	}
+	return g.assert(r.Form)
+}
+
+// RetractRule removes a rule previously added via AddRule() or the
+// equivalent Authorize() call.
+func (g *DatalogGuard) RetractRule(rule string) error {
+	err := g.ReloadIfModified()
+	if err != nil {
+		return err
+	}
+	var r auth.AnyForm
+	_, err = fmt.Sscanf("("+rule+")", "%v", &r)
+	if err != nil {
+		return err
+	}
+	return g.retract(r.Form)
+}
+
+// Clear removes all rules.
+func (g *DatalogGuard) Clear() error {
+	g.db.Rules = nil
+	g.dl = dlengine.NewEngine()
+	return nil
+}
+
+// Query the policy. Implementations of this interface should support
+// at least queries of the form: Authorized(P, op, args...).
+func (g *DatalogGuard) Query(query string) (bool, error) {
+	err := g.ReloadIfModified()
+	if err != nil {
+		return false, err
+	}
+	var r auth.AnyForm
+	_, err = fmt.Sscanf("("+query+")", "%v", &r)
+	if err != nil {
+		return false, err
+	}
+	return g.query(r.Form)
+}
+
+// RuleCount returns a count of the total number of rules.
+func (g *DatalogGuard) RuleCount() int {
+	return len(g.db.Rules)
+}
+
+// GetRule returns the ith policy rule, if it exists.
+func (g *DatalogGuard) GetRule(i int) string {
+	if i < 0 || i >= len(g.db.Rules) {
+		return ""
+	}
+	rule := g.db.Rules[i]
+	r, err := auth.UnmarshalForm(rule)
+	if err != nil {
+		return ""
+	}
+	return r.String()
+}
+
+// RuleDebugString returns a debug string for the ith policy rule, if it exists.
+func (g *DatalogGuard) RuleDebugString(i int) string {
+	if i < 0 || i >= len(g.db.Rules) {
+		return ""
+	}
+	rule := g.db.Rules[i]
+	r, err := auth.UnmarshalForm(rule)
+	if err != nil {
+		return ""
+	}
+	return r.ShortString()
+}
+
+// String returns a string suitable for showing users authorization info.
+func (g *DatalogGuard) String() string {
+	rules := make([]string, len(g.db.Rules))
+	for i := range g.db.Rules {
+		rules[i] = g.GetRule(i)
+	}
+	return "DatalogGuard{\n" + strings.Join(rules, "\n") + "}\n";
+}
diff --git a/go/src/cloudproxy/tao/datalog_guard.pb.go b/go/src/cloudproxy/tao/datalog_guard.pb.go
new file mode 100644
index 0000000..67eb7d8
--- /dev/null
+++ b/go/src/cloudproxy/tao/datalog_guard.pb.go
@@ -0,0 +1,57 @@
+// Code generated by protoc-gen-go.
+// source: datalog_guard.proto
+// DO NOT EDIT!
+
+package tao
+
+import proto "code.google.com/p/goprotobuf/proto"
+import math "math"
+
+// Reference imports to suppress errors if they are not otherwise used.
+var _ = proto.Marshal
+var _ = math.Inf
+
+// A set of rules.
+type DatalogRules struct {
+	Rules            [][]byte `protobuf:"bytes,1,rep,name=rules" json:"rules,omitempty"`
+	XXX_unrecognized []byte   `json:"-"`
+}
+
+func (m *DatalogRules) Reset()         { *m = DatalogRules{} }
+func (m *DatalogRules) String() string { return proto.CompactTextString(m) }
+func (*DatalogRules) ProtoMessage()    {}
+
+func (m *DatalogRules) GetRules() [][]byte {
+	if m != nil {
+		return m.Rules
+	}
+	return nil
+}
+
+// A set of rules signed by a key.
+type SignedDatalogRules struct {
+	SerializedRules  []byte `protobuf:"bytes,1,req,name=serialized_rules" json:"serialized_rules,omitempty"`
+	Signature        []byte `protobuf:"bytes,2,req,name=signature" json:"signature,omitempty"`
+	XXX_unrecognized []byte `json:"-"`
+}
+
+func (m *SignedDatalogRules) Reset()         { *m = SignedDatalogRules{} }
+func (m *SignedDatalogRules) String() string { return proto.CompactTextString(m) }
+func (*SignedDatalogRules) ProtoMessage()    {}
+
+func (m *SignedDatalogRules) GetSerializedRules() []byte {
+	if m != nil {
+		return m.SerializedRules
+	}
+	return nil
+}
+
+func (m *SignedDatalogRules) GetSignature() []byte {
+	if m != nil {
+		return m.Signature
+	}
+	return nil
+}
+
+func init() {
+}
diff --git a/go/src/cloudproxy/tao/datalog_guard.proto b/go/src/cloudproxy/tao/datalog_guard.proto
new file mode 100644
index 0000000..7f6ee59
--- /dev/null
+++ b/go/src/cloudproxy/tao/datalog_guard.proto
@@ -0,0 +1,24 @@
+//  Copyright (c) 2014, Kevin Walsh.  All rights reserved.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package tao;
+
+// A set of rules.
+message DatalogRules { repeated bytes rules = 1; }
+
+// A set of rules signed by a key.
+message SignedDatalogRules {
+  required bytes serialized_rules = 1;
+  required bytes signature = 2;
+}
diff --git a/go/src/cloudproxy/tao/datalog_guard_test.go b/go/src/cloudproxy/tao/datalog_guard_test.go
new file mode 100644
index 0000000..aa30082
--- /dev/null
+++ b/go/src/cloudproxy/tao/datalog_guard_test.go
@@ -0,0 +1,146 @@
+// Copyright (c) 2014, Kevin Walsh.  All rights reserved.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package tao
+
+import (
+	"fmt"
+	"io/ioutil"
+	"os"
+	"testing"
+
+	"cloudproxy/tao/auth"
+)
+
+func makeDatalogGuard(t *testing.T) (*DatalogGuard, *Signer, string) {
+	tmpdir, err := ioutil.TempDir("/tmp", "test_datalog_guard")
+	if err != nil {
+		t.Fatal("Couldn't get a temp directory for the datalog guard test")
+	}
+	signer, err := GenerateSigner()
+	if err != nil {
+		t.Fatal(err.Error())
+	}
+	g, err := NewDatalogGuard(signer.GetVerifier(), DatalogGuardConfig{
+		SignedRulesPath: tmpdir + "/signed_rules",
+	})
+	if err != nil {
+		t.Fatal(err)
+	}
+	return g, signer, tmpdir
+}
+
+var subj = auth.NewKeyPrin([]byte("test1"))
+var subj2 = auth.NewKeyPrin([]byte("test2"))
+
+func TestDatalogSaveReload(t *testing.T) {
+	g, key, tmpdir := makeDatalogGuard(t)
+	defer os.RemoveAll(tmpdir)
+	err := g.Save(key)
+	if err != nil {
+		t.Fatal(err)
+	}
+	err = g.ReloadIfModified()
+	if err != nil {
+		t.Fatal(err)
+	}
+	err = g.Authorize(subj, "read", []string{"somefile"})
+	if err != nil {
+		t.Fatal(err)
+	}
+	err = g.Save(key)
+	if err != nil {
+		t.Fatal(err)
+	}
+	err = g.ReloadIfModified()
+	if err != nil {
+		t.Fatal(err)
+	}
+	if g.RuleCount() != 1 {
+		t.Fatal("wrong number of rules")
+	}
+	if g.GetRule(0) != `Authorized(key([7465737431]), "read", "somefile")` {
+		t.Fatalf("wrong rule: %s", g.GetRule(0))
+	}
+}
+
+func TestDatalogAuthorizeRetract(t *testing.T) {
+	g, _, tmpdir := makeDatalogGuard(t)
+	defer os.RemoveAll(tmpdir)
+
+	err := g.Authorize(subj, "read", []string{"somefile"})
+	if err != nil {
+		t.Fatal(err)
+	}
+
+	ok := g.IsAuthorized(subj, "read", []string{"somefile"})
+	if !ok {
+		t.Fatal("denied, should have been authorized")
+	}
+
+	ok = g.IsAuthorized(subj, "read", []string{"otherfile"})
+	if ok {
+		t.Fatal("authorized, should have been denied")
+	}
+
+	err = g.Retract(subj, "read", []string{"somefile"})
+	if err != nil {
+		t.Fatal(err)
+	}
+
+	ok = g.IsAuthorized(subj, "read", []string{"somefile"})
+	if ok {
+		t.Fatal("authorized, should have been denied")
+	}
+}
+
+func TestDatalogRules(t *testing.T) {
+	g, _, tmpdir := makeDatalogGuard(t)
+	defer os.RemoveAll(tmpdir)
+
+	err := g.AddRule(fmt.Sprintf(`(forall F: IsFile(F) implies Authorized(%s, "read", F))`, subj))
+	if err != nil {
+		t.Fatal(err)
+	}
+
+	err = g.AddRule(fmt.Sprintf(`IsFile("somefile")`))
+	if err != nil {
+		t.Fatal(err)
+	}
+
+	err = g.AddRule(fmt.Sprintf(`IsFile("otherfile")`))
+	if err != nil {
+		t.Fatal(err)
+	}
+
+	ok := g.IsAuthorized(subj, "read", []string{"somefile"})
+	if ok {
+		t.Fatal("denied, should have been authorized")
+	}
+
+	ok = g.IsAuthorized(subj, "read", []string{"otherfile"})
+	if ok {
+		t.Fatal("denied, should have been authorized")
+	}
+
+	ok = g.IsAuthorized(subj, "write", []string{"somefile"})
+	if ok {
+		t.Fatal("authorized, should have been denied")
+	}
+
+	ok = g.IsAuthorized(subj2, "read", []string{"somefile"})
+	if ok {
+		t.Fatal("authorized, should have been denied")
+	}
+}
diff --git a/go/src/cloudproxy/tao/domain.go b/go/src/cloudproxy/tao/domain.go
index 8b22401..69b4b11 100644
--- a/go/src/cloudproxy/tao/domain.go
+++ b/go/src/cloudproxy/tao/domain.go
@@ -31,62 +31,61 @@ import (
 // policy data.
 //
 // Except for a password used to encrypt the policy private key, top-level
 // configuration data for Domain is stored in a text file, typically named
 // "tao.config". This configuration file contains the locations of all other
 // files and directories, e.g. configuration files for the domain guard. File
 // and directory paths within the tao.config file are relative to the location
 // of the tao.config file itself.
 type Domain struct {
 	Config     DomainConfig
 	ConfigPath string
 	Keys       *Keys
 	Guard      Guard
 }
 
 // TODO(kwalsh) Move to acl_guard.go when that file exists.
 type ACLGuardConfig struct {
 	SignedACLsPath string
 }
 
-// TODO(kwalsh) Move to datalog_guard.go when that file exists.
-type DatalogGuard struct {
-	SignedRulesPath string
-}
-
-// DomainConfig holds the presistent configuration data for a domain.
+// DomainConfig holds the persistent configuration data for a domain.
 type DomainConfig struct {
+
 	// Policy-agnostic configuration
 	Domain struct {
 		// Name of the domain
 		Name string
 		// Path to the password-protected signing key
 		PolicyKeysPath string
 		// Type of guard to use for domain-wide policy decisions
 		GuardType string
 	}
+
 	// Details used for the domain signing key x509 certificate
 	X509Details X509Details
+
 	// Policy-specific configuration (optional)
 	// ACLGuard ACLGuardConfig
+
 	// Policy-specific configuration (optional)
-	// DatalogGuard DatalogGuardConfig
+	DatalogGuard DatalogGuardConfig
 }
 
 // Print prints the configuration to out.
 func (cfg DomainConfig) Print(out io.Writer) error {
 	return util.PrintAsGitConfig(out, cfg, "Tao Domain Configuration file")
 }
 
 // SetDefaults sets each blank field of cfg to a reasonable default value.
 func (cfg *DomainConfig) SetDefaults() {
 	if cfg.Domain.Name == "" {
 		cfg.Domain.Name = "Tao example domain"
 	}
 	if cfg.Domain.PolicyKeysPath == "" {
 		cfg.Domain.PolicyKeysPath = "policy_keys"
 	}
 	if cfg.Domain.GuardType == "" {
 		cfg.Domain.GuardType = "DenyAll"
 	}
 	if cfg.X509Details.CommonName == "" {
 		cfg.X509Details.CommonName = cfg.Domain.Name
