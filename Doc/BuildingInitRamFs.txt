Instructions for preparing initramfs for FileClient and FileServer
==================================================================

Decompress and unpack the existing initramfs
    cd /tmp
    mkdir init
    cd init
    cp /boot/initramfs.img-`uname -r` initrd.gz
    cd initramfs
    gunzip -c -9 /boot/initrd.img-2.6.32-5-686 \
    | cpio -i -d -H newc --no-absolute-filenames
    find > ../initramfs.content

    gzip -dc /boot/initrd.img-$(uname -r) | cpio -i

Copy the executables into the initramfs
    export DESTDIR=/tmp/init
    source /usr/share/initramfs-tools/hook-functions
    copy_exec ~/jlmcrypt/fileServer.exe bin
    copy_exec ~/jlmcrypt/fileClient.exe bin
    copy_exec ~/jlmcrypt/tcService.exe bin
    # note that you don't need keyNegoServer normally
    copy_exec ~/jlmcrypt/keyNegoServer.exe bin

Change the initscript (init) to run dmcrypt and change the way the 
system disk is mounted.
  vim init
  # replace the final exec with
  /bin/busybox sh

  - we don't yet have instructions for this
  - untested:
      swapoff -a
      cryptsetup [-c aes -h sha256] -s 128 -d /dev/urandom create swap /dev/sda1
      mkswap /dev/mapper/swap
      swapon /dev/mapper/swap

Put initramfs back together
    CORRECT:
        find .|cpio -H newc -o|gzip -9 > ../initrd.img-new
    INCORRECT
        rm initrd
        find . -print | cpio -ov > initrd
        gzip initrd
Copy it to the boot directory
  sudo cp initrd.gz /boot/initrd.img-staticLinux

Change /etc/grub.d to use this new initramfs.

Consult: http://manpages.ubuntu.com/manpages/karmic/man8/initramfs-tools.8.html

mkdir initramfs{,-old}
 cd initramfs
 gunzip -c -9 /boot/initrd.img-2.6.32-5-686 \
  | cpio -i -d -H newc --no-absolute-filenames
 find > ../initramfs.content
 cd ../initramfs-old
 gunzip -c -9 /boot/initrd.img-2.6.32-5-686.bak \
  | cpio -i -d -H newc --no-absolute-filenames
 find > ../initramfs-old.content
 cd ..
 diff -u initramfs-old.content initramfs.content

A sample init that dynamically loads the driver (don't do this) is:
 1 Decompress initrd into localdirectory
 2 Copy needed drivers in /drvs directory
 3 Copy fileProxy/fileClient/tcService binaries in /bin directory and required libraries in 
     lib and lib64 directories
 4 Copied keys to /bin/HWRoot directory
 5 Replaced init with my custom init
 6 Loaded tcioDD
 7 Configured Ethernet
 8 Script does not boot all services
 9 Package initramfs.igz
10 Copy to /boot
11 Modify entry for OS Tboot section in grub.cfg. replaced initrd by initramfs.igz
12 Reboot machine
13 From cmd line type : /bin/tcService.exe â€“directory /bin/ &
14 tcService connected to keynegoServer on different machine. 

 
Vinay's handcrafted initramfs script
 
#---start
#!/bin/sh
echo "Test CloudProxy minimal boot environment!"
 
[ -d /dev ] || mkdir -m 0755 /dev
[ -d /root ] || mkdir -m 0700 /root
[ -d /sys ] || mkdir /sys
[ -d /proc ] || mkdir /proc
[ -d /tmp ] || mkdir /tmp
 
mkdir -p /proc/net/dev
mkdir -p /var/lock
 
mount -t sysfs -o nodev,noexec,nosuid sysfs /sys
 
# Function for dropping to a shell
shell () {
 
        /bin/busybox sh
}
 
# Basic /dev content, we need it as fast as possible.
mount -t tmpfs dev /dev
mount -t proc proc /proc
 
test -c /dev/null || mknod /dev/null c 1 3
test -c /dev//tty || mknod /dev/tty c 5 0
test -c /dev/urandom || mknod /dev/urandom c 1 9
test -c /dev/random || mknod /dev/random c 1 8
test -c /dev/zero || mknod /dev/zero c 1 5
test -c /dev/tpm0 || mknod /dev/tpm0 c 10 224
test -c /dev/tcioDD0 || mknod /dev/tcioDD0 c 100 0
 
#insmod /drvs/tpm_tis.ko
insmod /drvs/tcioDD.ko
 
echo "loaded tcioDD drivers..."
 
insmod /drvs/e1000e.ko
 
/sbin/ifconfig eth0 192.168.241.11
/sbin/route add default gw 192.168.241.10
 
/bin/busybox sh
 
# Clean up.
umount /proc
umount /sys
 
# Not booting to the real thing at this time.
 
#---end


Standard initramfs init file:

#!/bin/sh

[ -d /dev ] || mkdir -m 0755 /dev
[ -d /root ] || mkdir -m 0700 /root
[ -d /sys ] || mkdir /sys
[ -d /proc ] || mkdir /proc
[ -d /tmp ] || mkdir /tmp
mkdir -p /var/lock
mount -t sysfs -o nodev,noexec,nosuid sysfs /sys
mount -t proc -o nodev,noexec,nosuid proc /proc
# Some things don't work properly without /etc/mtab.
ln -sf /proc/mounts /etc/mtab

grep -q '\<quiet\>' /proc/cmdline || echo "Loading, please wait..."

# Note that this only becomes /dev on the real filesystem if udev's scripts
# are used; which they will be, but it's worth pointing out
if ! mount -t devtmpfs -o mode=0755 udev /dev; then
	echo "W: devtmpfs not available, falling back to tmpfs for /dev"
	mount -t tmpfs -o mode=0755 udev /dev
	[ -e /dev/console ] || mknod -m 0600 /dev/console c 5 1
	[ -e /dev/null ] || mknod /dev/null c 1 3
fi
mkdir /dev/pts
mount -t devpts -o noexec,nosuid,gid=5,mode=0620 devpts /dev/pts || true
mount -t tmpfs -o "nosuid,size=20%,mode=0755" tmpfs /run
mkdir /run/initramfs
# compatibility symlink for the pre-oneiric locations
ln -s /run/initramfs /dev/.initramfs

# Export the dpkg architecture
export DPKG_ARCH=
. /conf/arch.conf

# Set modprobe env
export MODPROBE_OPTIONS="-qb"

# Export relevant variables
export ROOT=
export ROOTDELAY=
export ROOTFLAGS=
export ROOTFSTYPE=
export IP=
export BOOT=
export BOOTIF=
export UBIMTD=
export break=
export init=/sbin/init
export quiet=n
export readonly=y
export rootmnt=/root
export debug=
export panic=
export blacklist=
export resume=
export resume_offset=
export recovery=

# mdadm needs hostname to be set. This has to be done before the udev rules are called!
if [ -f "/etc/hostname" ]; then
        /bin/hostname -b -F /etc/hostname 2>&1 1>/dev/null
fi

# Bring in the main config
. /conf/initramfs.conf
for conf in conf/conf.d/*; do
	[ -f ${conf} ] && . ${conf}
done
. /scripts/functions

# Parse command line options
for x in $(cat /proc/cmdline); do
	case $x in
	init=*)
		init=${x#init=}
		;;
	root=*)
		ROOT=${x#root=}
		case $ROOT in
		LABEL=*)
			ROOT="${ROOT#LABEL=}"

			# support any / in LABEL= path (escape to \x2f)
			case "${ROOT}" in
			*/*)
			if command -v sed >/dev/null 2>&1; then
				ROOT="$(echo ${ROOT} | sed 's,/,\\x2f,g')"
			else
				if [ "${ROOT}" != "${ROOT#/}" ]; then
					ROOT="\x2f${ROOT#/}"
				fi
				if [ "${ROOT}" != "${ROOT%/}" ]; then
					ROOT="${ROOT%/}\x2f"
				fi
				IFS='/'
				newroot=
				for s in $ROOT; do
					newroot="${newroot:+${newroot}\\x2f}${s}"
				done
				unset IFS
				ROOT="${newroot}"
			fi
			esac
			ROOT="/dev/disk/by-label/${ROOT}"
			;;
		UUID=*)
			ROOT="/dev/disk/by-uuid/${ROOT#UUID=}"
			;;
		/dev/nfs)
			[ -z "${BOOT}" ] && BOOT=nfs
			;;
		esac
		;;
	rootflags=*)
		ROOTFLAGS="-o ${x#rootflags=}"
		;;
	rootfstype=*)
		ROOTFSTYPE="${x#rootfstype=}"
		;;
	rootdelay=*)
		ROOTDELAY="${x#rootdelay=}"
		case ${ROOTDELAY} in
		*[![:digit:].]*)
			ROOTDELAY=
			;;
		esac
		;;
	resumedelay=*)
		RESUMEDELAY="${x#resumedelay=}"
		;;
	loop=*)
		LOOP="${x#loop=}"
		;;
	loopflags=*)
		LOOPFLAGS="-o ${x#loopflags=}"
		;;
	loopfstype=*)
		LOOPFSTYPE="${x#loopfstype=}"
		;;
	cryptopts=*)
		cryptopts="${x#cryptopts=}"
		;;
	nfsroot=*)
		NFSROOT="${x#nfsroot=}"
		;;
	netboot=*)
		NETBOOT="${x#netboot=}"
		;;
	ip=*)
		IP="${x#ip=}"
		;;
	boot=*)
		BOOT=${x#boot=}
		;;
	ubi.mtd=*)
		UBIMTD=${x#ubi.mtd=}
		;;
	resume=*)
		RESUME="${x#resume=}"
		;;
	resume_offset=*)
		resume_offset="${x#resume_offset=}"
		;;
	noresume)
		noresume=y
		;;
	panic=*)
		panic="${x#panic=}"
		case ${panic} in
		*[![:digit:].]*)
			panic=
			;;
		esac
		;;
	quiet)
		quiet=y
		;;
	ro)
		readonly=y
		;;
	rw)
		readonly=n
		;;
	debug)
		debug=y
		quiet=n
		exec >/run/initramfs/initramfs.debug 2>&1
		set -x
		;;
	debug=*)
		debug=y
		quiet=n
		set -x
		;;
	break=*)
		break=${x#break=}
		;;
	break)
		break=premount
		;;
	blacklist=*)
		blacklist=${x#blacklist=}
		;;
	netconsole=*)
		netconsole=${x#netconsole=}
		;;
	BOOTIF=*)
		BOOTIF=${x#BOOTIF=}
		;;
	hwaddr=*)
		BOOTIF=${x#BOOTIF=}
		;;
	recovery)
		recovery=y
		;;
	esac
done

if [ -n "${noresume}" ]; then
	export noresume
	unset resume
else
	resume=${RESUME:-}
fi

maybe_break top

# export BOOT variable value for compcache,
# so we know if we run from casper
export BOOT

# Don't do log messages here to avoid confusing graphical boots
run_scripts /scripts/init-top

maybe_break modules
[ "$quiet" != "y" ] && log_begin_msg "Loading essential drivers"
load_modules
[ "$quiet" != "y" ] && log_end_msg

[ -n "${netconsole}" ] && modprobe netconsole netconsole="${netconsole}"

maybe_break premount
[ "$quiet" != "y" ] && log_begin_msg "Running /scripts/init-premount"
run_scripts /scripts/init-premount
[ "$quiet" != "y" ] && log_end_msg

maybe_break mount
log_begin_msg "Mounting root file system"
. /scripts/${BOOT}
parse_numeric ${ROOT}
maybe_break mountroot
mountroot
log_end_msg

maybe_break bottom
[ "$quiet" != "y" ] && log_begin_msg "Running /scripts/init-bottom"
run_scripts /scripts/init-bottom
[ "$quiet" != "y" ] && log_end_msg

# Preserve information on old systems without /run on the rootfs
if [ -d ${rootmnt}/run ]; then
	mount -n -o move /run ${rootmnt}/run
else
	# The initramfs udev database must be migrated:
	if [ -d /run/udev ] && [ ! -d /dev/.udev ]; then
		mv /run/udev /dev/.udev
	fi
	# The initramfs debug info must be migrated:
	if [ -d /run/initramfs ] && [ ! -d /dev/.initramfs ]; then
		mv /run/initramfs /dev/.initramfs
	fi
	umount /run
fi

# Move virtual filesystems over to the real filesystem
mount -n -o move /sys ${rootmnt}/sys
mount -n -o move /proc ${rootmnt}/proc

validate_init() {
	checktarget="${1}"

	# Work around absolute symlinks
	if [ -d "${rootmnt}" ] && [ -h "${rootmnt}${checktarget}" ]; then
		case $(readlink "${rootmnt}${checktarget}") in /*)
			checktarget="$(chroot ${rootmnt} readlink ${checktarget})"
			;;
		esac
	fi

	# Make sure the specified init can be executed
	if [ ! -x "${rootmnt}${checktarget}" ]; then
		return 1
	fi

	# Upstart uses /etc/init as configuration directory :-/
	if [ -d "${rootmnt}${checktarget}" ]; then
		return 1
	fi
}

# Check init bootarg
if [ -n "${init}" ]; then
	if ! validate_init "$init"; then
		echo "Target filesystem doesn't have requested ${init}."
		init=
	fi
fi

# Common case: /sbin/init is present
if [ ! -x "${rootmnt}/sbin/init" ]; then
	# ... if it's not available search for valid init
	if [ -z "${init}" ] ; then
		for inittest in /sbin/init /etc/init /bin/init /bin/sh; do
			if validate_init "${inittest}"; then
				init="$inittest"
				break
			fi
		done
	fi

	# No init on rootmount
	if ! validate_init "${init}" ; then
		panic "No init found. Try passing init= bootarg."
	fi
fi

maybe_break init

# don't leak too much of env - some init(8) don't clear it
# (keep init, rootmnt)
unset debug
unset MODPROBE_OPTIONS
unset DPKG_ARCH
unset ROOTFLAGS
unset ROOTFSTYPE
unset ROOTDELAY
unset ROOT
unset IP
unset BOOT
unset BOOTIF
unset UBIMTD
unset blacklist
unset break
unset noresume
unset panic
unset quiet
unset readonly
unset resume
unset resume_offset

# Chain to real filesystem
exec run-init ${rootmnt} ${init} "$@" ${recovery:+--startup-event=recovery} <${rootmnt}/dev/console >${rootmnt}/dev/console 2>&1
panic "Could not execute run-init."


Wrong:
    gunzip initrd.gz
    cpio -iv < initrd


From http://reboot.pro/topic/14547-linux-load-your-root-partition-to-ram-and-boot-it/

his tutorial will guide you through the steps to modify your initramfs to load all files from / to a tmpfs. This will only work with Debian 5 or newer and Ubuntu 9 ? or any unix thats supports booting from a initramfs. Since this is a virtual filesystem in RAM, not a virtual harddisk, this has many advantages.

What you need:
* lots of RAM
* Debian based distribution or any that supports booting from initramfs
* mkinitramfs or a tool to build a new initramfs
* some linux knowledge
* no need to create an image
* no need for Grub4Dos
* no need for a "special driver"

Step 1:
Choose a distribution thats supports booting from initramfs. (like ubuntu)

Step 2:
Install to harddisk. Make sure you split it into multiple partitions (/, /boot, /home, swap, ...).

Step 3:
Boot your new system, install updates, drivers if neccessary (this will improve performance), strip it down to the minimum. Every file will be loaded to RAM ! A fresh install uses about 2 GB auf harddisk-space.

Step 4:
modify /etc/fstab :
* make a backup
cp /etc/fstab /etc/fstab.bak* find the line specifing the root partition and change it in:
none / tmpfs defaults 0 0* save

Step 5:
edit the local script in your initramfs:
cd /usr/share/initramfs-tools/scripts/* make a backup of /usr/share/initramfs-tools/scripts/local
cp local local.bak* modify local, find this line:
# FIXME This has no error checking

# Mount root

mount ${roflag} -t ${FSTYPE} ${ROOTFLAGS} ${ROOT} ${rootmnt}* change it to:
# FIXME This has no error checking

# Mount root

#mount ${roflag} -t ${FSTYPE} ${ROOTFLAGS} ${ROOT} ${rootmnt}

mkdir /ramboottmp

mount ${roflag} -t ${FSTYPE} ${ROOTFLAGS} ${ROOT} /ramboottmp

mount -t tmpfs -o size=100% none ${rootmnt}

cd ${rootmnt}

cp -rfa /ramboottmp/* ${rootmnt}

umount /ramboottmp
* save
* execute, or rebuild initramfs
mkinitramfs -o /boot/initrd.img-ramboot* replace modified local with original file
cp -f local.bak localStep 6:
* modify this file (needs a better solution)
/boot/grub/grub.cfg* copy the first boot entry and replace the /initrd line with this:
/initrd /initrd.img-ramdisk* label the new entrie as RAMBOOT
This will boot our generated initramfs instead the original one.
Step 7:
* reboot
* choose standart boot (no ramdisk)
* choose RAMBOOT and all your files on the root partition will be loaded to a tmpfs

Results:
Test setup:
*Kernel : Linux 2.6.38-8-generic (i686)
*Compiled : #42-Ubuntu SMP Mon Apr 11 03:31:50 UTC 2011
*Distribution : Ubuntu 11.04
*no graphics driver
*Desktop HP 8100E
*Core i7 860
*4GB Memory 2 Modules (DDR3)
*WDVeliciraptor 10k rpm 160GB 

Tiotest results for 4 concurrent io threads:

,----------------------------------------------------------------------.

| Item                  | Time     | Rate         | Usr CPU  | Sys CPU |

+-----------------------+----------+--------------+----------+---------+

| Write         800 MBs | 0.1489 s | 5372.806 MB/s |  2.80 %  | 32.40 % |

| Random Write   16 MBs | 0.0025 s | 6320.793 MB/s |   0.0 %  |   0.0 % |

| Read          800 MBs | 0.0928 s | 8616.790 MB/s |  11.7 %  |  11.7 % |

| Random Read    16 MBs | 0.0021 s | 7454.676 MB/s |   0.0 %  |   0.0 % |

`----------------------------------------------------------------------&#39;

Tiotest latency results:

,-------------------------------------------------------------------------.

| Item         | Average latency | Maximum latency | % >2 sec | % >10 sec |

+--------------+-----------------+-----------------+----------+-----------+

| Write        |        0.003 ms |        0.048 ms |  0.00000 |   0.00000 |

| Random Write |        0.002 ms |        0.011 ms |  0.00000 |   0.00000 |

| Read         |        0.002 ms |        0.025 ms |  0.00000 |   0.00000 |

| Random Read  |        0.002 ms |        0.023 ms |  0.00000 |   0.00000 |

|--------------+-----------------+-----------------+----------+-----------|

| Total        |        0.002 ms |        0.048 ms |  0.00000 |   0.00000 |

`--------------+-----------------+-----------------+----------+-----------&#39
