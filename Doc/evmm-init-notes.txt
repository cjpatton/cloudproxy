Tboot of evmm and Linux single guest stack
===========================================


Introduction
------------

In order to provide authenticated boot, required by cloudProxy, we boot evmm 
using tboot.  This document describes that process, which we refer to as 
"TBooting evmm with a single Linux Guest".

TBooting evmm with a single Linux Guest is accomplished using multiboot.  Tboot 
is the initial booted program but it loads four modules as specified below.
[JLM:  The figure below says "bootstrap.bin" but this will change to evmm.gz, 
 just like linux.]


   submenu "Evmm bootstrap.bin" "Tboot 1.7.0"{
    menuentry 'Ubuntu GNU/Linux, with evmm bootstrap.bin, Tboot 1.7.0 and Linux 3.5.7.20' --class ubuntu --class gnu-linux --class gnu --class os {
            insmod part_msdos
            insmod ext2
            set root='(hd0,msdos1)'
            search --no-floppy --fs-uuid --set=root a1edf4f7-94e1-4c47-8573-0e3f54821ed3
            echo    'Loading Tboot 1.7.0 ...'
            multiboot       /boot/tboot.gz /boot/tboot.gz logging=serial,vga,memory
            echo    'Loading Evmm bootstrap.bin ...'
            module  /boot/bootstrap.bin /boot/bootstrap.bin placeholder   iommu=force
            echo    'Loading Linux 3.5.7.20 ...'
            module  /boot/vmlinuz-3.5.7.20 /boot/vmlinuz-3.5.7.20 placeholder root=UUID=a1edf4f7-94e1-4c47-8573-0e3f54821ed3 ro  quiet splash
            echo    'Loading initial ramdisk ...'
            module  /boot/initrd.img-3.5.7.20 /boot/initrd.img-3.5.7.20
            echo    'Loading sinit SINIT_67.BIN ...'
            module  /boot/SINIT_67.BIN /boot/SINIT_67.BIN
    }

As is evident, tboot loads 4 modules:
    SINIT_67.BIN, which authenticates SMM handlers, checks configuration information 
        and prepares the machine for SMX(ENTER).
    evmm.gz, which is the evmm image.  The evmm image consists of three parts: a 
        32-bit protected mode loader called bootstrap.bin, a header and the 64-bit 
        evmm image.
    linux.gz, which is the linux image.  The linux image consists of three parts: 
        a 32-bit protected mode loader, a header and linux image.
    initrd.gz, which is a small linux file system.  This file system is measured 
        as part of the linux.


Tboot
-----

Tboot calls the evmm loader, called bootstrap.bin, contained in evmm.gz,
in 32 bit protected mode.  To the bootstrap program, this appears as a 
call into main.  Note that the entry point is main and NOT other 
initialization code as is customary in a linux application.

Upon entry, tboot provided bootstrap with:
    1. A protected mode 32 bit environment.
    2. In the recommended layout, tboot allocates 4K for stack+heap.
        Stack+heap at 0x8000-0x8fff
        Cmd arg at 0x9000
        Real mode kernel 0x0000-0x7fff
        real mode size is in real_mode_size
        protected mode size (linux_size-real_mode_size) is in protected_mode _size.
        stack base is in bsp_stack
        idt descriptor is in idt_descr.
        heap size is in heap_size.
    3. An initialized GDT and IDT for 32 bit protected mode.
    4. Information obtained from BIOS including memory size, base address of tboot, 
        size of tboot.
    5. e820 memory and apic information.
    6. the multiboot headers.
    
tboot typically moves the linux protected mode base to 0x100000 when booting a linux.
Tboot passes mbi address on stack (from %ebx) for begin_launch.  Memory layout to
linux is 4GB limit, 4K page size.


Bootstrap.bin
-------------

The bootstrap program uses information from tboot to call vmm_main 
after decompressing the 64-bit evmm image and relocating it to TTTT.

vmm_main is called in 64-bit protected mode with all the information 
vmm_main needs to complete 64-bit initialization.

Upon entry, vmm_main has
    1. A protected mode 64 bit environment with a 64K stack,
          64-bit gdt and idt, have been initialized, and 64 bit 
	  identity mapped page tables are present.
          The 64K stack is based at WWWWW.  Boostrap calls
          vmm-main with a proper 64-bit call frame with
          with arguments properly set.  These arguments provide
          the information cited below.
          Bootstrap's 64 bit memory layout will include the address space of 
          tboot and bootstrap since vmm_main must interact with that data.  
          However, evmm must ensure that it never corrupts that area and it never 
          maps that area into a guest VM.
          The 64-bit heap is prepared by evmm in 64 bit mode. [REHKA: right?]
          The initialized 64-bit GDT and IDT should have the following 
          properties: ZZZZ.  [REHKA TO CONFIRM AND CHECK THIS OUT.]
    2. Information obtained from BIOS (e820 map) and additional information
           from tboot including memory size, base address of tboot, 
           the combined size of tboot itself along with header information
           describing the size and location of the bootstrap program so vmm_main 
           can determine what memory is available to it.  Apic information?
    4. The multiboot header for linux module and information required to
           obtain the 32 bit linux stub as well as 64 bit linux code.
    5. PCR values in the TPM have been properly extended for evmm by bootstrap.
           [JLM to check this out.]
    6. [LATER: SIPI initialization and call of AP's.]

[JLM note:  The current evmm_main.c will be replaced by entry.c and should not
be part of the evmm.bim inage.  I have no idea why the memory/stack/heap 
provided by tboot is not adequate for 32 bit mode.  Why isn't 64 bit evmm 
heap initialization done in the 64 bit code?  REHKA TO CHECK THIS OUT.]

The NMI interrupt trap is handled by evmm [REHKA TO CHECK THIS OUT.].  All other
traps are assigned to the Linux guest . (say how) evmm does not require the fpu 
to be initialized prior to entry.  [REHKA TO CHECK THIS OUT.]
Evmm does not access BIOS [REHKA TO CHECK THIS OUT.]
Upon exit, evmm clears all sensitive data [JLM: unsure, low priority for now.]

If there is ANYTHING else bootstrap should do before calling vmm_main, 
REKHA should note it HERE.

[REKHA: Below is the set of calls from the original evmm loader.  If you can 
say what these functions do in detail, you'll be a long way towards completing 
this section.  Resolving what these functions do should help you ask the specific 
you need to.]

The original loader does the following
    (1) Init loader heap, run-time space, and idt.
    (2) Build E820 table. (replace by copy and modify e820 table from tboot)
        [JLM: I think we just have to copy and modify the table we got from
         tboot.  REKHA to check.]
    (3) Read evmm and thunk header. [[REKHA: What does the "thunk header" do?]
    (4) Load evmm, thunk, and tee.  (replace 3 and 4 with read 64-bit read 
            elf header)
    (5) Setup init32. [REKHA: What does this do?  Is this already done by tboot?]
    (6) Setup init64. [I plan to do in main of entry.c]
    (7) Call thunk.  [REKHA: What does this do? How does it need to be set up?]


vmm_main
--------

vmm_main completes evmm's initialization by allocating its heap 
and setting up the Linux guest.  The details on how it sets up 
the Linux guest is below.  It ensures the guest cannot access system 
memory including bios, tboot, bootstrap ore evmm code or data. 
evmm assigns all interrupts, except for NMI, to the linux guest. 
[REKHA: Explain how.]


Details of bootstrap initialization
-----------------------------------

The remainder of this document describes in detail the environment provided 
to evmm by bootstrap.


vmm_main call
-------------

The call to vmm_main is:

void vmm_main(UINT32 local_apic_id, UINT64 startup_struct_u, UINT64 application_params_struct_u, 
              UINT64 reserved UNUSED)
[REKHA should describe the arguments whose values must be prepared by bootstrap.bin]



Setup of e820 tables by bootstrap
---------------------------------

e820 is the facility by which the BIOS reports the memory map to the operating 
system and boot loader.  The E820 table has range of address and types. The 
table is part of vmm_memory_layout struct passed to vmm_main by bootstrap. 
bootstrap should copy and modify the e820 table to protect it's 
memory region.  [REHKA TO CHECK THIS OUT.]


Memory Initialization
---------------------

We need to block access to the memory that evmm uses from the guest(s).
[JLM: Does bootstrap do this or does 64-bit evmm.  Personally, I don't 
see why this isn't
vmm_main's job requiring no further mention here.  It would amaze me if 
the 64-bit evmm portion did not do this later as part of setting up 
Linux guests as it would be a gigantic security hole
undermining the entire value of the VMM.  So I think this should go in
he Linux guest setup below and be clarified.  REKHA SHOULD CONFIRM. ]


Stack setup
-----------

Bootstrap.bin prepares a 64K stack for 64-bit evmm.
[JLM: You say 16 pages, What page size?
[REKHA: Please make it clear that this is 64 bit stack, verify 16
pages is enough and say where the stack should be in the memory map.]


Heap setup
----------

Same as stack except I think 64 bit heap setup should be done in the
64 bit evmm code.  REKHA should check.]


64-bit address translation
--------------------------

Bootstrap creates initial page tables to enter vmm_main in 64 
bit protected mode.  This initial map is the identity map page table 
structure.  [REKHA SHOULD CONFIRM.]


Multiprocessor rendezvous for evmm
----------------------------------

Describe how BSP/AP rendezvous happens.  It looks like bootstrap needs
to do it but it's unclear what address the AP's are supposed to wake up 
at an what they expect to have happened.  Clarify the purpose, and what
code the BSP and AP's should wake up at after.


Call thunk
----------

REKHA: Explain what this mechanism does. and how it needs to be set up


Linux Guest initialization
--------------------------

Evmm sets up its Linux guest so that at startup, the Linux wakes up 
in the call to main n 32 bit protected mode just as it would after 
TBOOT.  [JLM:  I actually don't know.  Anyway, REKHA SHOULD find out.]  
Can evmm host Windows "Out of the box?"

[REKHA to write this section.]

Linux never accesses BIOS, right?
[REKHA: What should be in the vmcs areas for the guest?  ]


Notes 
-----

This document should be specific and not vague.  You shouldn't say 
things like "maybe an identity mapping is OK."  You should say exactly 
what it should be even if you're not sure and note either what you 
don't know or what you're unsure of so we can find out.  A clear incorrect
statement can be fixed, a vague statement isn't true or false and can never
be fixed.  We should write the document as authoritative and complete as 
quickly as possible and work on updating it as we get better information.
Having the specific questions evident from the doc will help you get 
the info out of Ravi and others.

TODO: Get interrupt code and vt-d code the evmm team offered.
