Tboot of evmm and Linux single guest stack
===========================================


Introduction
------------

In order to provide authenticated boot, required by cloudProxy, we boot evmm 
using tboot.  This document describes that process, which we refer to as 
"TBooting evmm with a single Linux Guest".

TBooting evmm with a single Linux Guest is accomplished using multiboot.  Tboot 
is the initial booted program but it loads four modules as specified below.
[JLM:  The figure below says "bootstrap.bin" but this will change to evmm.gz, 
 just like linux.]


   submenu "Evmm bootstrap.bin" "Tboot 1.7.0"{
    menuentry 'Ubuntu GNU/Linux, with evmm bootstrap.bin, Tboot 1.7.0 and 
               Linux 3.5.7.20' --class ubuntu --class gnu-linux --class gnu 
               --class os {
            insmod part_msdos
            insmod ext2
            set root='(hd0,msdos1)'
            search --no-floppy --fs-uuid --set=root 
                a1edf4f7-94e1-4c47-8573-0e3f54821ed3
            echo    'Loading Tboot 1.7.0 ...'
            multiboot       /boot/tboot.gz /boot/tboot.gz 
                logging=serial,vga,memory
            echo    'Loading Evmm bootstrap.bin ...'
            module  /boot/bootstrap.bin /boot/bootstrap.bin placeholder   
                iommu=force
            echo    'Loading Linux 3.5.7.20 ...'
            module  /boot/vmlinuz-3.5.7.20 /boot/vmlinuz-3.5.7.20 placeholder 
              root=UUID=a1edf4f7-94e1-4c47-8573-0e3f54821ed3 ro  quiet splash
            echo    'Loading initial ramdisk ...'
            module  /boot/initrd.img-3.5.7.20 /boot/initrd.img-3.5.7.20
            echo    'Loading sinit SINIT_67.BIN ...'
            module  /boot/SINIT_67.BIN /boot/SINIT_67.BIN
    }

As is evident, tboot loads 4 modules:
    SINIT_67.BIN, which authenticates SMM handlers, checks configuration 
        information and prepares the machine for SMX(ENTER).
    evmm.gz, which is the evmm image.  The evmm image consists of three 
        parts: a 32-bit protected mode loader called bootstrap.bin, a 
        header and the 64-bit evmm image.
    linux.gz, which is the linux image.  The linux image consists of 
        three parts: a 32-bit protected mode loader, a header and linux 
        image.
    initrd.gz, which is a small linux file system.  This file system 
        is measured as part of the linux.


Tboot
-----

Tboot calls the evmm loader, called bootstrap.bin, contained in evmm.gz,
in 32 bit protected mode.  To the bootstrap program, this appears as a 
call into main.  Note that the entry point is main and NOT other 
initialization code as is customary in a linux application.

Upon entry, tboot provided bootstrap with:
    1. A protected mode 32 bit environment.
    2. In the recommended layout, tboot allocates 4K for stack+heap.
        Stack+heap at 0x8000-0x8fff
        Cmd arg at 0x9000
        Real mode kernel 0x0000-0x7fff
        real mode size is in real_mode_size
        protected mode size (linux_size-real_mode_size) is in 
           protected_mode _size.
        stack base is in bsp_stack
        idt descriptor is in idt_descr.
        heap size is in heap_size.
    3. An initialized GDT and IDT for 32 bit protected mode.
    4. Information obtained from BIOS including memory size, base address of 
        tboot, size of tboot.
    5. e820 memory and apic information.
    6. the multiboot headers.
    
tboot typically moves the linux protected mode base to 0x100000 when booting 
a linux.  Tboot passes mbi address on stack (from %ebx) for begin_launch.  
Memory layout to linux is 4GB limit, 4K page size.

    // address tboot will load and execute at
    #define TBOOT_START              0x0804000
    // start address of tboot MLE page table, beginning of tboot memory
    #define TBOOT_BASE_ADDR          0x0800000
Tboot stack
    #define BSP_STACK_SIZE              4096
    #define AP_STACK_SIZE               1024



Bootstrap.bin
-------------

The bootstrap program uses information from tboot to call vmm_main 
after decompressing the 64-bit evmm image and relocating it to TTTT.

vmm_main is called in 64-bit protected mode with all the information 
vmm_main needs to complete 64-bit initialization.

Upon entry, vmm_main has

1. A protected mode 64 bit environment with a 64K stack, 64-bit gdt and
idt, have been initialized, and 64 bit identity mapped page tables are present.
Boostrap calls vmm_main with a proper 64-bit call frame with with arguments 
properly set.  These arguments provide the information cited below.  
Bootstrap's 64 bit memory layout will include the address space of tboot and 
bootstrap since vmm_main must interact with that data.  However, evmm must 
ensure that it never corrupts that area and it never maps that area into a 
guest VM.  The 64-bit heap is prepared by evmm in 64 bit mode.  Bootstrap code 
should translate the 32-bit GDT and IDT before jumping into vmm_main.  
While tboot/bootstrap memory is visible to vmm_main, but it should
modify the e820 tables to make the tboot/bootstrap memory, and its memory not
accessbile from the guest.

The initialized 64-bit GDT and IDT should have the following properties:
REKHA2: I am not sure, I believe it depends on the e820 table slot that is
chosen for evmm.  Does Linux have a specific location?  
JLM: I'll find out.  
REKHA3: Meanwhile, just say what we do here.

2. Information obtained from BIOS (e820 map) and additional information
from tboot including memory size, base address of tboot, the combined size of
tboot itself along with header information describing the size and location of
the bootstrap program so vmm_main can determine what memory is available to it.

3. Gets apic information, guest and memory map information in it's calling
parameters.

4. Gets the multiboot header for linux module and information
required to obtain the 32 bit linux stub as well as 64 bit linux code.  

5. Enters with correct PCR values in the TPM have been properly extended for 
evmm by bootstrap.  [JLM to check this out.] 

6. [LATER: SIPI initialization and call of AP's.]

The NMI interrupt trap and the timer trap is handled by evmm.  For single guest
Linux, the timer trap is injected back into the Linux guest and
all other interrupts are handled by the Linux guest.

evmm does not require the fpu to be initialized prior to entry.  

Upon exit, evmm clears all sensitive data [JLM: unsure, low priority for now.]

If there is ANYTHING else bootstrap should do before calling vmm_main, 

The original loader does the following
    (1) Init loader heap, run-time space, and idt.
    (2) Build E820 table.
    (3) Read evmm and thunk header.   The Thunk header is image meta-data: 
        image type and image size.
    (4) Load evmm, thunk, and tee.  (replace 3 and 4 with read 64-bit read 
            elf header)
    (5) Setup init32. 
        This is the 32-bit code that runs just before switching to
        64-bit.  It is responsible for translating the machine state (for
        e.g., copying registers from 32-bit to 64-bit) to 64-bit before the
        switch.
    (6) Setup init64. [I plan to do in main of entry.c]
    (7) Call thunk.


vmm_main
--------

vmm_main completes evmm's initialization by allocating its heap 
and setting up the Linux guest.  The details on how it sets up 
the Linux guest is below.  It ensures the guest cannot access system 
memory including bios, tboot, bootstrap ore evmm code or data. 
evmm assigns all interrupts, except for NMI, to the linux guest. 
As explained above, evmm should update the e820 map to prevent
the guest from accessing the tboot/bootstrap and evmm memory regions
and populate the IDT with the appropriate handlers (in evmm or guest).
The input arguments which must be prepared by bootstrap are set
forth below.


Details of bootstrap initialization
-----------------------------------

The remainder of this document describes in detail the environment provided 
to evmm by bootstrap.


Memory layout when bootstrap main is called for single Linux guest
-------------------------------------------

    #define TBOOT_START              0x0804000
    // start address of tboot MLE page table, beginning of tboot memory
    #define TBOOT_BASE_ADDR          0x0800000
Tboot stack
    #define BSP_STACK_SIZE              4096
    #define AP_STACK_SIZE               1024
Tboot calls main of bootstrap in 32 bit protected mode.  The memory layout
at the time of this call is:

IVT                                                     <-- 0x00000000
RDBA (Bios data memory)                                 <-- 0x00000400
Partition table                                         <-- 0x000007be -->7ff
Command line buffer                                     <-- 0x00002000 -->7ff
GRUB Stage 0                                            <-- 0x00007c00 -->7dff
GRUB Stage 1                                            <-- 0x00008000
32 bit scratch space
EMPTY
Extended BIOS, vram, video ROM and ROM BIOS             <-- 0x000a0000
Tboot header                                            <-- 0x00800000
Tboot start (boot.S)                                    <-- 0x00804000
  Tboot ends at ~                                           0x00972e88
Evmm package
   bootstrap code                                       <-- 0x0804a317
   64bit evmm image (uncompressed)                      <-- get_evmm_image(base, size)
Linux image package 
  linux file (uncompressed real mode execution header)
  compressed linux file
Compressed initramfs

For my linux 3.5.7.20, the linux image (what you get when you gunzip the linux
kernel file --- meaning the protected mode portion is still compressed, is
layed out by grub from 0x0973000 to 0x12d5d20 and the uncompressed initram
lies between 0x01390000 and 0x01835200.  The compressed initram here is
2120688 bytes.  Tboot relocates these in the normal Linux boot to
    TBOOT: Initrd from 0x1fb5a000 to 0x1ffff200
    TBOOT: Kernel (protected mode) from 0x1000000 to 0x195eb20
    TBOOT: Kernel (real mode) from 0x90000 to 0x94200 is 2120688 bytes.
    TBOOT: transfering control to kernel @0x1000000...


Required memory setup when vmm_main is called
---------------------------------------------

IVT                                                     <-- 0x00000000
RDBA (Bios data memory)                                 <-- 0x00000400
Partition table                                         <-- 0x000007be -->7ff
Command line buffer                                     <-- 0x00002000 -->7ff
GRUB Stage 0                                            <-- 0x00007c00 -->7dff
GRUB Stage 1                                            <-- 0x00008000
tboot code (real and PE)                                <-- 0x00800000
bootstrap code                                          <-- 0x0804a317
32 bit scratch space
EMPTY
Extended BIOS, vram, video ROM and ROM BIOS             <-- 0x000a0000
64bit evmm image (uncompressed)                         <-- 0x40000000 (?)
Linux (uncompressed)                                    <-- ?
    kernel_image = remove_module(g_mbi, NULL);
    module_t *m = (module_t *)g_mbi->mods_addr;
    void *kernel_image = (void *)m->mod_start;
    size_t kernel_size = m->mod_end - m->mod_start;
  real mode: LEGACY_REAL_START; (0x90000)
  linux_image+KERNEL_HEADER_OFFSET (0x1f1);
  Protected mode base:  BZIMAGE_PROTECTED_START
  initrd_base= max_ram_base+max_ram_size-initrd_size;
      m = (module_t *)g_mbi->mods_addr;
      void *initrd_image = (void *)m->mod_start;
      size_t initrd_size = m->mod_end - m->mod_start;
initramfs (decompressed)                                <--

evmm was based byt the original loader at 0xa0000000.


vmm_main call
-------------

The call to vmm_main is:

void vmm_main(UINT32 local_apic_id, UINT64 startup_struct_u, 
              UINT64 application_params_struct_u, 
              UINT64 reserved UNUSED)
On entry, startup_struct_u is cast to VMM_STARTUP_STRUCT* type and
application_params_struct_u is (eventually) interpreted as a pointer
to a structure of type VMM_INPUT_PARAMS_S.  [REHKA3: what is the 
local_apic_id and what do we get from the shared page to fill it in.]

    typedef struct VMM_INPUT_PARAMS_S {
        UINT64 local_apic_id;
        UINT64 startup_struct;
        UINT64 application_params_struct; // change name
    } VMM_INPUT_PARAMS;

These structures are used both in 32-bit and 64-bit modes, therefore:
- Structure sizes are 64-bit aligned
- All pointers are defined as 64-bit, and must be set so their higher 32 bits
  are 0 (< 4GB).  This ensures their usability in both 32-bit and 64-bit
  modes.
- All pointers are in a loader virtual memory space (if applicable).

The Primary guest is the guest that owns the platform and platform was
booted originally to run this guest. The secondary guest is a guest that 
is used to perform some dedicated tasks on behalf of the primary guest.

Here is the structure hierarchy (---> denotes a pointer) of these
input structures to vmm_main.

VMM_STARTUP_STRUCT
    +---- VMM_MEMORY_LAYOUT     vmm_memory_layout[]
    +---> INT15_E820_MEMORY_MAP physical_memory_layout_E820
    +---> VMM_GUEST_STARTUP     primary_guest_startup_state
    |     +---> VMM_GUEST_CPU_STARTUP_STATE cpu_states_array[]
    |     |     +---- VMM_GP_REGISTERS             gp
    |     |     +---- VMM_XMM_REGISTERS            xmm
    |     |     +---- VMM_SEGMENTS                 seg
    |     |     +---- VMM_CONTROL_REGISTERS        control
    |     |     +---- VMM_MODEL_SPECIFIC_REGISTERS msr
    |     +---> VMM_GUEST_DEVICE            devices_array[]
    +---> VMM_GUEST_STARTUP     secondary_guests_startup_state_array[]
    |     +... as above
    +---- VMM_DEBUG_PARAMS      debug_params
        +---- VMM_DEBUG_PORT_PARAMS       port
VMM_APPLICATION_PARAMS_STRUCT

The structure definitions are:

typedef struct _VMM_STARTUP_STRUCT {
    UINT16   size_of_this_struct;
    UINT16   version_of_this_struct;

    // number of processors/cores at install time.
    // used to verify correctness of the bootstrap process
    UINT16   number_of_processors_at_install_time;

RNB3: number of cores in the system.

    // number of processors/cores as was discovered by vmm loader
    // used to verify correctness of the bootstrap process
    UINT16   number_of_processors_at_boot_time;

RNB3: number of cores on which evmm will be run.

    /* 64-bit aligned */
    // number of secondary Guests
    UINT16   number_of_secondary_guests;

    // size of stack for VMM per processor. In 4K pages.
    UINT16   size_of_vmm_stack;

    // values to be used by VMM to hide devices if VT-d is not accessable
    // **** THIS FEATURE IS CURRENTLY NOT SUPPORTED ****
    UINT16   unsupported_vendor_id;
    UINT16   unsupported_device_id;

    /* 64-bit aligned */
    // set of flags, that define policies for the VMM as a whole
    UINT32   flags;

    // magic number of the guest, that owns all platform devices
    // that were not assigned to any guest
    UINT32   default_device_owner;

RNB3: magic number of the evmm, since we for now evmm is the default owner.

    /* 64-bit aligned */
    // magic number of the guest, that serves as OSPM.
    // SMM code is executed in the context of this guest
    UINT32   acpi_owner;

RNB3: magic number of the evmm, since we decided that evmm will be the acpi
owner (for now).

    // magic number of the guest, that process platform NMIs.
    UINT32   nmi_owner;

RNB3: magic number of the evmm, since we decided that evmm will handle nmi.

    /* 64-bit aligned */
    // vmm memory layout
    VMM_MEMORY_LAYOUT           vmm_memory_layout[uvmm_images_count];

RNB3: This struct contains the VMM size, base address where it should be
loaded, and the address of the entry_point.

    // pointer to the int 15 E820 BIOS table
    //  INT15_E820_MEMORY_MAP*
    // Loader must convert the table into the E820 extended format
    // (each entry 24 bytes long). If BIOS-returned entry was 20 bytes long
    // the extended attributes should be set to 0x1.
    UINT64   physical_memory_layout_E820;

RNB3: e820 memory layout (received from BIOS), and converted to extended format.
loaded, and the address of the entry_point.

    /* 64-bit aligned */
    // pointer to the primary guest state
    //   VMM_GUEST_STARTUP*
    UINT64   primary_guest_startup_state;

RNB3:  Guest startup state. For our case (pre_os), the guest state would be the
same as if tboot was starting the guest.

    /* 64-bit aligned */
    // pointer to the array of secondary guest states
    // size of array is number_of_secondary_guests
    //   VMM_GUEST_STARTUP*
    UINT64   secondary_guests_startup_state_array;

RNB3: Not applicable for now.

    /* 64-bit aligned */
    // Debug parameters
    VMM_DEBUG_PARAMS            debug_params;
        
    /* 64-bit aligned */
    // Active cpu local apic ids
    UINT8    cpu_local_apic_ids[ALIGN_FORWARD(VMM_MAX_CPU_SUPPORTED, 8)];

RNB3: Local apic (processor) ids of all cpus.

}PACKED VMM_STARTUP_STRUCT;


typedef struct _VMM_APPLICATION_PARAMS_STRUCT {
        UINT32   size_of_this_struct; // overall, including all params
        UINT32   number_of_params;    // number of params that will follow

        // random generated id to avoid vmm shutdown by others
        UINT64   session_id;
        // page entry list for the additional heap
    UINT64       address_entry_list;
    UINT64       entry_number;
#ifdef USE_ACPI
    UINT64       fadt_gpa;
#ifdef ENABLE_VTD
    UINT64       dmar_gpa;
#endif
#endif //ifdef USE_ACPI
} VMM_APPLICATION_PARAMS_STRUCT;


typedef struct _VMM_GUEST_CPU_STARTUP_STATE
{
    UINT16       size_of_this_struct;
    UINT16       version_of_this_struct;
    UINT32       reserved_1;

    /* 64-bit aligned */

    // there are additional registers in the CPU that are not passed here.
    // it is assumed that for the new guest the state of such registers is
    // the same, as it was at the VMM entry point.

    VMM_GP_REGISTERS                gp;
    VMM_XMM_REGISTERS               xmm;
    VMM_SEGMENTS                    seg;
    VMM_CONTROL_REGISTERS           control;
    VMM_MODEL_SPECIFIC_REGISTERS    msr;
}PACKED VMM_GUEST_CPU_STARTUP_STATE;

RNB3: the guest state for pre os has to be the state that we had at evmm entry
point, or however, we choose to start the guest (either linux/windows).

REKHA3:  Now what remains is mapping the information from tboot to these data 
values.  Thats what you have to describe since that's what we have to set up.
I believe we need to understand this (and document the understanding) before
checking in code purporting to carry this out.  You should do this if you can.


Setup of e820 tables by bootstrap
---------------------------------

e820 is the facility by which the BIOS reports the memory map to the operating 
system and boot loader.  The E820 table has range of address and types. The 
table is part of vmm_memory_layout struct passed to vmm_main by bootstrap. 
bootstrap should copy and modify the e820 table to protect it's 
memory region.
REKHA3: I think the only thing remaining is a decription of what you change in
the e820 table passed by tboot to accomplish this.

RNB3: we update the size of the e820 slot which evmm uses to not be available
to the guest.


Stack setup
-----------

Bootstrap.bin prepares a 64K stack for 64-bit evmm.  The 64K stack is 
based at WWWWW.
[REKHA3: Fill in WWWW (or whatever we need to do to pick WWWW ourselves.
Should we up a larger than 64H stack?]


Heap setup
----------

The 64-bit heap initialization is done in 64 bit evmm.  The heap prepared
by tboot for 32-bit protected mode needs no further modication.
[REKHA3: Update this when you have the info.]


64-bit address translation
--------------------------

Bootstrap creates initial page tables to enter vmm_main in 64 
bit protected mode.  This initial map is the identity map page table 
structure.  64 bit evmm redoes them mostly.


Multiprocessor rendezvous for evmm
----------------------------------

Describe how BSP/AP rendezvous happens.  It looks like bootstrap needs
to do it but it's unclear what address the AP's are supposed to wake up 
at an what they expect to have happened.  Clarify the purpose, and what
code the BSP and AP's should wake up at after.


Call thunk
----------

The thunk mechanism allows bootstrap to "switch back" into evmm, which 
is applicable only in the post launch case, because a)evmm has to work 
with whatever memory it has available; b) handle the case of restoring 
the native OS if something goes wrong and it can't recover.  In the pre 
os case, we crash and reboot to start over again.  The thunk arranges the 
jump (in 64-bit mode to vmm_main, whose address is calculated for the 
64-bit header information.


Linux Guest initialization
--------------------------

Evmm sets up its Linux guest so that at startup, the Linux wakes up 
in the call to main in 32 bit protected mode just as it would after 
TBOOT.  All information used to configure the Linux guest is
passed in the parameters to vmm_main documented above.

Linux never accesses BIOS.  evmm can host Windows "out of the box."
[REKHA3: can you confirm these last two statements and, if true,
can you get (low prioity) the information we need to start windows,
i.e.- the setup of the parameters to vmm_main that accomplish it.]

RNB3: Yes, the first statements is true, and the second is potentially true.  I
have never ran the evmm we have.

Notes 
-----

TODO: Get interrupt code and vt-d code the evmm team offered.
