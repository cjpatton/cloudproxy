BidProxy

To build, in ROOT (jlmcrypt),
    mkdir bidServerobjects
    mkdir bidClientobjects
    mkdir sellerClientobjects
    mkdir bidNegoobjects
    mkdir bidClient
    mkdir sellerClient
    mkdir sellerClient/bids
    mkdir bidServer
    mkdir bidServer/bids
    mkdir bidNegoServer

In Code/bidProxy
    make -f bidClient.mak
    make -f bidServer.mak
    make -f sellerClient.mak
In Code bidNegoServer
    make -f bidNegoServer.mak

Make up an activity policy key pair and embed the public key certificate in bidClient, sellerClient
and bidServer as with fileClient and fileServer.

Start  bidNegoServer.exe

bidNegoServer.exe 

Start sellerClient.exe 
    sellerClient.exe initProg &

sellerClient.exe will contact bidNegoServer and get a program cert just as fileClient does.

Stop bidNegoServer.exe 

Provision sellerClient's cert to bidNegoServer 
    cp ROOT/sellerClient/cert ROOT/bidNegoServer/auctionCert.xml
restart bidNegoServer

    bidNegoServer.exe -auctionCert auctionCert.xml

Generate a bidder key pair and sign a certificate naming the public key.
Provision bidder cert and private key to the bidClient as you would a principal cert 
for fileClient.

Start  bidServer.exe

    bidServer.exe -initProg &

bidServer.exe will contact bidNegoServer and get a program cert just as fileServer does, however,
bidNegoServer.exe will also transmit auctionCert.xml.

Start bidClient.exe
    bidClient.exe initProg &

bidClient.exe will contact bidNegoServer and get a program cert just as fileClient does.

bidServer.exe opens a port just like fileServer.
bidClient and bidServer negotiate a secure channel just as fileClient and fileServer except that
the bidder cert in place of the user cert for file access.

bidServer accepts a single request: submitBid from bidClient containing a auction identifier and
a bid.

bidServer validates the activityProvider-bidder cert chain. If this chan is valid,
bidServer generates a symmetric encryption/integrity key, and encrypts the bidders bid, 
certificate and the time of the bid.  It seals these keys with the sellerClient public key and
appends this to the sealed blob.   It hashes the composite blob and signs the hash with its
private key.  It then saves the encrypted blob, sealed key, signed hash and its program 
certificate in a single file in ROOT/bidServer/bids with a unique name.

Periodically, and at the end of the auction, some process copies ROOT/bidServer/bids from
all of the bidServers to sellerClient/bids.

Start sellerClient:

    sellerClient -initProg

sellerClient will examine the bid and select the highest one (in the event of a tie, the highest
bid with earliest time).  It then signs a certificate naming the auction identifier, the public key 
of the winning bid, the bid, and the time the bid was submitted.

That's it.


